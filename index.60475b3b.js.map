{"mappings":"IsUGI,EEDA,E4CEA,ErF0CDq1F,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,E,O,G,E,U,C,E,O,C,C,C,I2G5CS,EScP,EaKC,EA6gBA,EASA,EAinDA,EA4KA,EAMA,EAiEA,EAaA,EA6BA,EAsBA,EA0N4B,EA4ZC,EA4BC,EAoC9B,E,E,E,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C7I/kGC,SAAS,EAAW,CAAU,CAAE,CAAM,CAAE,CAAG,CAAE,CAAI,EACpD,IAA2H,EAAvH,EAAI,UAAU,MAAM,CAAE,EAAI,EAAI,EAAI,EAAS,AAAS,OAAT,EAAgB,EAAO,OAAO,wBAAwB,CAAC,EAAQ,GAAO,EACrH,GAAI,AAAmB,UAAnB,OAAO,SAAwB,AAA4B,YAA5B,OAAO,QAAQ,QAAQ,CAAiB,EAAI,QAAQ,QAAQ,CAAC,EAAY,EAAQ,EAAK,QACpH,IAAK,IAAI,EAAI,EAAW,MAAM,CAAG,EAAG,GAAK,EAAG,IAAS,CAAA,EAAI,CAAU,CAAC,EAAE,AAAF,GAAI,CAAA,EAAI,AAAC,CAAA,EAAI,EAAI,EAAE,GAAK,EAAI,EAAI,EAAE,EAAQ,EAAK,GAAK,EAAE,EAAQ,EAAA,GAAS,CAAA,EAChJ,OAAO,EAAI,GAAK,GAAK,OAAO,cAAc,CAAC,EAAQ,EAAK,GAAI,CAChE,C,E,Q,S,C,C,C,E,E,E,O,C,Q,I,EjR1CO,OAAM,EAYT,YAAY,EAAI,CAAG,CAAA,EAAI,CACvB,CAAA,CAVA,IAAA,CAAO,CAAI,CAAA,EAEX,IAAA,CAAO,CAAI,CAAA,EASP,IAAA,CAAK,CAAI,CAAA,EACT,IAAA,CAAK,CAAI,CAAA,CAAA,CAON,OACP,CACI,OAAO,IAAI,EAAM,IAAK,CAAA,CAAA,CAAG,IAAA,CAAK,CAAC,C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","sources":["<anon>","node_modules/pixi.js/lib/maths/point/Point.mjs","node_modules/pixi.js/src/maths/point/Point.ts","node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs","node_modules/pixi.js/src/maths/shapes/Rectangle.ts","node_modules/pixi.js/lib/extensions/Extensions.mjs","node_modules/pixi.js/src/extensions/Extensions.ts","node_modules/@parcel/runtime-js/lib/runtime-7b0cfcc64656e424.js","node_modules/@parcel/runtime-js/lib/helpers/browser/esm-js-loader.js","node_modules/@parcel/runtime-js/lib/runtime-9d48711ea3a09bc4.js","node_modules/pixi.js/lib/rendering/init.mjs","node_modules/pixi.js/src/rendering/init.ts","node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs","node_modules/pixi.js/src/rendering/mask/alpha/AlphaMask.ts","node_modules/pixi.js/lib/scene/sprite/Sprite.mjs","node_modules/pixi.js/src/scene/sprite/Sprite.ts","node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs","node_modules/pixi.js/src/maths/point/ObservablePoint.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/Texture.ts","node_modules/eventemitter3/index.js","node_modules/pixi.js/lib/maths/matrix/groupD8.mjs","node_modules/pixi.js/src/maths/matrix/groupD8.ts","node_modules/pixi.js/lib/maths/matrix/Matrix.mjs","node_modules/pixi.js/src/maths/matrix/Matrix.ts","node_modules/pixi.js/lib/maths/misc/const.mjs","node_modules/pixi.js/src/maths/misc/const.ts","node_modules/pixi.js/lib/utils/data/uid.mjs","node_modules/pixi.js/src/utils/data/uid.ts","node_modules/pixi.js/lib/utils/logging/deprecation.mjs","node_modules/pixi.js/src/utils/logging/deprecation.ts","node_modules/pixi.js/lib/utils/misc/NOOP.mjs","node_modules/pixi.js/src/utils/misc/NOOP.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/BufferSource.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/TextureSource.ts","node_modules/pixi.js/lib/maths/misc/pow2.mjs","node_modules/pixi.js/src/maths/misc/pow2.ts","node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs","node_modules/pixi.js/src/scene/container/utils/definedProps.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureStyle.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureMatrix.ts","node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs","node_modules/pixi.js/src/utils/data/updateQuadBounds.ts","node_modules/pixi.js/lib/scene/container/Container.mjs","node_modules/pixi.js/src/scene/container/Container.ts","node_modules/pixi.js/lib/color/Color.mjs","node_modules/pixi.js/src/color/Color.ts","node_modules/@pixi/colord/index.mjs","node_modules/@pixi/colord/plugins/names.mjs","node_modules/pixi.js/lib/culling/cullingMixin.mjs","node_modules/pixi.js/src/culling/cullingMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/childrenHelperMixin.ts","node_modules/pixi.js/lib/utils/data/removeItems.mjs","node_modules/pixi.js/src/utils/data/removeItems.ts","node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/effectsMixin.ts","node_modules/pixi.js/lib/filters/FilterEffect.mjs","node_modules/pixi.js/src/filters/FilterEffect.ts","node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs","node_modules/pixi.js/src/rendering/mask/MaskEffectManager.ts","node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs","node_modules/pixi.js/src/utils/pool/PoolGroup.ts","node_modules/pixi.js/lib/utils/pool/Pool.mjs","node_modules/pixi.js/src/utils/pool/Pool.ts","node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/findMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/measureMixin.ts","node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs","node_modules/pixi.js/src/scene/container/bounds/Bounds.ts","node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs","node_modules/pixi.js/src/scene/container/bounds/getGlobalBounds.ts","node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs","node_modules/pixi.js/src/scene/container/bounds/utils/matrixAndBoundsPool.ts","node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs","node_modules/pixi.js/src/scene/container/bounds/getLocalBounds.ts","node_modules/pixi.js/lib/utils/logging/warn.mjs","node_modules/pixi.js/src/utils/logging/warn.ts","node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs","node_modules/pixi.js/src/scene/container/utils/checkChildrenDidChange.ts","node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/onRenderMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/sortMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/toLocalGlobalMixin.ts","node_modules/pixi.js/lib/scene/container/RenderGroup.mjs","node_modules/pixi.js/src/scene/container/RenderGroup.ts","node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs","node_modules/pixi.js/src/rendering/renderers/shared/instructions/InstructionSet.ts","node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs","node_modules/pixi.js/src/scene/container/utils/assignWithIgnore.ts","node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs","node_modules/pixi.js/src/rendering/mask/utils/addMaskBounds.ts","node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs","node_modules/pixi.js/src/rendering/mask/utils/addMaskLocalBounds.ts","node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs","node_modules/pixi.js/src/rendering/mask/color/ColorMask.ts","node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs","node_modules/pixi.js/src/rendering/mask/stencil/StencilMask.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/CanvasSource.ts","node_modules/pixi.js/lib/environment/adapter.mjs","node_modules/pixi.js/src/environment/adapter.ts","node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs","node_modules/pixi.js/src/environment-browser/BrowserAdapter.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/ImageSource.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/VideoSource.ts","node_modules/pixi.js/lib/ticker/Ticker.mjs","node_modules/pixi.js/src/ticker/Ticker.ts","node_modules/pixi.js/lib/ticker/const.mjs","node_modules/pixi.js/src/ticker/const.ts","node_modules/pixi.js/lib/ticker/TickerListener.mjs","node_modules/pixi.js/src/ticker/TickerListener.ts","node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs","node_modules/pixi.js/src/utils/browser/detectVideoAlphaMode.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts","node_modules/pixi.js/lib/assets/cache/Cache.mjs","node_modules/pixi.js/src/assets/cache/Cache.ts","node_modules/pixi.js/lib/assets/utils/convertToList.mjs","node_modules/pixi.js/src/assets/utils/convertToList.ts","node_modules/pixi.js/lib/spritesheet/init.mjs","node_modules/pixi.js/src/spritesheet/init.ts","node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs","node_modules/pixi.js/src/spritesheet/spritesheetAsset.ts","node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs","node_modules/pixi.js/src/assets/loader/parsers/LoaderParser.ts","node_modules/pixi.js/lib/assets/resolver/Resolver.mjs","node_modules/pixi.js/src/assets/resolver/Resolver.ts","node_modules/pixi.js/lib/utils/path.mjs","node_modules/pixi.js/src/utils/path.ts","node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs","node_modules/pixi.js/src/assets/utils/createStringVariations.ts","node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs","node_modules/pixi.js/src/assets/utils/isSingleItem.ts","node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs","node_modules/pixi.js/src/assets/utils/copySearchParams.ts","node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs","node_modules/pixi.js/src/spritesheet/Spritesheet.ts","node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs","node_modules/pixi.js/src/rendering/renderers/shared/system/AbstractRenderer.ts","node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs","node_modules/pixi.js/src/utils/browser/unsafeEvalSupported.ts","node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs","node_modules/pixi.js/src/rendering/renderers/gl/const.ts","node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs","node_modules/pixi.js/src/rendering/renderers/shared/system/SystemRunner.ts","node_modules/@parcel/runtime-js/lib/runtime-3fcf120eb33639cf.js","node_modules/@parcel/runtime-js/lib/runtime-8598bb63c4c62ca3.js","node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs","node_modules/pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts","node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs","node_modules/pixi.js/src/rendering/batcher/gpu/BatchGeometry.ts","node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs","node_modules/pixi.js/src/rendering/renderers/shared/buffer/Buffer.ts","node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs","node_modules/pixi.js/src/rendering/renderers/shared/buffer/const.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/Geometry.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/ensureIsBuffer.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts","node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs","node_modules/pixi.js/src/rendering/batcher/gpu/getTextureBatchBindGroup.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts","node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs","node_modules/pixi.js/src/rendering/batcher/shared/const.ts","node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs","node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts","node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs","node_modules/pixi.js/src/utils/data/ViewableBuffer.ts","node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs","node_modules/pixi.js/src/rendering/renderers/shared/buffer/utils/fastCopy.ts","node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs","node_modules/pixi.js/src/rendering/renderers/shared/state/getAdjustedBlendModeBlend.ts","node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs","node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts","node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs","node_modules/pixi.js/src/rendering/batcher/shared/BatchTextureArray.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts","node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs","node_modules/pixi.js/src/scene/graphics/shared/BatchableGraphics.ts","node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs","node_modules/pixi.js/src/scene/container/utils/mixColors.ts","node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs","node_modules/pixi.js/src/scene/container/utils/mixHexColors.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts","node_modules/pixi.js/lib/scene/graphics/shared/const.mjs","node_modules/pixi.js/src/scene/graphics/shared/const.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/getOrientationOfPoints.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPolygon.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/triangulateWithHoles.ts","node_modules/earcut/src/earcut.js","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildRectangle.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildTriangle.ts","node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs","node_modules/pixi.js/src/scene/graphics/shared/fill/FillGradient.ts","node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs","node_modules/pixi.js/src/scene/graphics/shared/fill/FillPattern.ts","node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs","node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts","node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs","node_modules/pixi.js/src/scene/graphics/shared/GraphicsContext.ts","node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs","node_modules/pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts","node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs","node_modules/pixi.js/src/scene/graphics/shared/svg/SVGToGraphicsPath.ts","node_modules/parse-svg-path/index.js","node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs","node_modules/pixi.js/src/scene/graphics/shared/path/ShapePath.ts","node_modules/pixi.js/lib/maths/shapes/Circle.mjs","node_modules/pixi.js/src/maths/shapes/Circle.ts","node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs","node_modules/pixi.js/src/maths/shapes/Ellipse.ts","node_modules/pixi.js/lib/maths/shapes/Polygon.mjs","node_modules/pixi.js/src/maths/shapes/Polygon.ts","node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs","node_modules/pixi.js/src/maths/misc/squaredDistanceToLineSegment.ts","node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs","node_modules/pixi.js/src/maths/shapes/RoundedRectangle.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcTo.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts","node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs","node_modules/pixi.js/src/scene/graphics/shared/path/roundShape.ts","node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs","node_modules/pixi.js/src/scene/graphics/shared/svg/SVGParser.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts","node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs","node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts","node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs","node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs","node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs","node_modules/pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts","node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs","node_modules/pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts","node_modules/pixi.js/lib/scene/text/TextStyle.mjs","node_modules/pixi.js/src/scene/text/TextStyle.ts","node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs","node_modules/pixi.js/src/scene/text/utils/generateTextStyleKey.ts","src/index.ts","src/main-menu.ts","node_modules/tslib/tslib.es6.js","node_modules/@lit/reactive-element/reactive-element.js","node_modules/@lit/reactive-element/src/reactive-element.ts","node_modules/@lit/reactive-element/css-tag.js","node_modules/@lit/reactive-element/src/css-tag.ts","node_modules/lit-html/lit-html.js","node_modules/lit-html/src/lit-html.ts","node_modules/lit-element/lit-element.js","node_modules/lit-element/src/lit-element.ts","node_modules/lit-html/is-server.js","node_modules/lit-html/src/is-server.ts","node_modules/@lit/reactive-element/decorators/custom-element.js","node_modules/@lit/reactive-element/src/decorators/custom-element.ts","node_modules/@lit/reactive-element/decorators/property.js","node_modules/@lit/reactive-element/src/decorators/property.ts","node_modules/@lit/reactive-element/decorators/state.js","node_modules/@lit/reactive-element/src/decorators/state.ts","node_modules/@lit/reactive-element/decorators/event-options.js","node_modules/@lit/reactive-element/src/decorators/event-options.ts","node_modules/@lit/reactive-element/decorators/query.js","node_modules/@lit/reactive-element/src/decorators/query.ts","node_modules/@lit/reactive-element/decorators/base.js","node_modules/@lit/reactive-element/src/decorators/base.ts","node_modules/@lit/reactive-element/decorators/query-all.js","node_modules/@lit/reactive-element/src/decorators/query-all.ts","node_modules/@lit/reactive-element/decorators/query-async.js","node_modules/@lit/reactive-element/src/decorators/query-async.ts","node_modules/@lit/reactive-element/decorators/query-assigned-elements.js","node_modules/@lit/reactive-element/src/decorators/query-assigned-elements.ts","node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js","node_modules/@lit/reactive-element/src/decorators/query-assigned-nodes.ts","src/game.ts","node_modules/pixi.js/lib/math-extras/init.mjs","node_modules/pixi.js/src/math-extras/init.ts","node_modules/pixi.js/lib/math-extras/pointExtras.mjs","node_modules/pixi.js/src/math-extras/pointExtras.ts","node_modules/pixi.js/lib/math-extras/rectangleExtras.mjs","node_modules/pixi.js/src/math-extras/rectangleExtras.ts","node_modules/pixi.js/lib/index.mjs","node_modules/pixi.js/src/index.ts","node_modules/pixi.js/lib/environment-browser/browserExt.mjs","node_modules/pixi.js/src/environment-browser/browserExt.ts","node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs","node_modules/pixi.js/src/environment-webworker/webworkerExt.ts","node_modules/pixi.js/lib/app/Application.mjs","node_modules/pixi.js/src/app/Application.ts","node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs","node_modules/pixi.js/src/rendering/renderers/autoDetectRenderer.ts","node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs","node_modules/pixi.js/src/environment/autoDetectEnvironment.ts","node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs","node_modules/pixi.js/src/utils/browser/isWebGLSupported.ts","node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs","node_modules/pixi.js/src/utils/browser/isWebGPUSupported.ts","node_modules/pixi.js/lib/assets/Assets.mjs","node_modules/pixi.js/src/assets/Assets.ts","node_modules/pixi.js/lib/assets/BackgroundLoader.mjs","node_modules/pixi.js/src/assets/BackgroundLoader.ts","node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs","node_modules/pixi.js/src/assets/cache/parsers/cacheTextureArray.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectAvif.ts","node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs","node_modules/pixi.js/src/assets/detections/utils/testImageFormat.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectDefaults.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectMp4.ts","node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs","node_modules/pixi.js/src/assets/detections/utils/testVideoFormat.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectOgv.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectWebm.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectWebp.ts","node_modules/pixi.js/lib/assets/loader/Loader.mjs","node_modules/pixi.js/src/assets/loader/Loader.ts","node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs","node_modules/pixi.js/src/assets/loader/parsers/loadJson.ts","node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs","node_modules/pixi.js/src/assets/utils/checkDataUrl.ts","node_modules/pixi.js/lib/assets/utils/checkExtension.mjs","node_modules/pixi.js/src/assets/utils/checkExtension.ts","node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs","node_modules/pixi.js/src/assets/loader/parsers/loadTxt.ts","node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs","node_modules/pixi.js/src/assets/loader/parsers/loadWebFont.ts","node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs","node_modules/pixi.js/src/assets/loader/parsers/textures/loadSVG.ts","node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs","node_modules/pixi.js/src/utils/network/getResolutionOfUrl.ts","node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs","node_modules/pixi.js/src/assets/loader/parsers/textures/utils/createTexture.ts","node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs","node_modules/pixi.js/src/assets/loader/parsers/textures/loadTextures.ts","node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs","node_modules/pixi.js/src/assets/loader/workers/WorkerManager.ts","node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs","node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs","node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs","node_modules/pixi.js/src/assets/loader/parsers/textures/loadVideoTextures.ts","node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs","node_modules/pixi.js/src/assets/resolver/parsers/resolveJsonUrl.ts","node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs","node_modules/pixi.js/src/assets/resolver/parsers/resolveTextureUrl.ts","node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.mjs","node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSprite.ts","node_modules/pixi.js/lib/scene/text/Text.mjs","node_modules/pixi.js/src/scene/text/Text.ts","node_modules/pixi.js/lib/scene/text/AbstractText.mjs","node_modules/pixi.js/src/scene/text/AbstractText.ts","src/controller.ts","src/minigames/minigame.ts","src/minigames/final/flingMinigame.ts","node_modules/@pixi/ui/lib/ProgressBar.mjs","node_modules/@pixi/ui/src/ProgressBar.ts","node_modules/@pixi/ui/lib/utils/helpers/view.mjs","node_modules/@pixi/ui/src/utils/helpers/view.ts","src/minigames/assets.ts","src/minigames/typingMinigame.ts","node_modules/@datastructures-js/trie/index.js","node_modules/@datastructures-js/trie/src/trie.js","node_modules/@datastructures-js/trie/src/trieNode.js","src/minigames/keyboardMinigame.ts","src/minigames/rhythmMinigame.ts","src/minigames/final/scrubMinigame.ts","src/minigames/shakingMinigame.ts","src/minigames/final/shoppingMinigame.ts","src/util/devHelpers.ts","src/minigames/balancingMinigame.ts","src/interlude/interlude.ts","src/interlude/frames/introFrames.ts","src/interlude/frames/helpers.ts","src/interlude/frames/weekThreeFrames.ts","src/interlude/frames/outroFrames.ts","src/minigames/final/checkpointOneMinigame.ts","src/minigames/checkpointMinigame.ts","src/minigames/final/checkpointTwoMinigame.ts","src/minigames/final/checkpointThreeMinigame.ts","src/audio/audio_controller.ts","node_modules/howler/dist/howler.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire718f\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire718f\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"1HooC\", function(module, exports) {\n\n$parcel$export(module.exports, \"Point\", () => $fdaff9f788d94485$export$baf26146a414f24a);\n\"use strict\";\nclass $fdaff9f788d94485$export$baf26146a414f24a {\n    /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */ constructor(x = 0, y = 0){\n        /** Position of the point on the x axis */ this.x = 0;\n        /** Position of the point on the y axis */ this.y = 0;\n        this.x = x;\n        this.y = y;\n    }\n    /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */ clone() {\n        return new $fdaff9f788d94485$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */ copyFrom(p) {\n        this.set(p.x, p.y);\n        return this;\n    }\n    /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */ copyTo(p) {\n        p.set(this.x, this.y);\n        return p;\n    }\n    /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */ equals(p) {\n        return p.x === this.x && p.y === this.y;\n    }\n    /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */ set(x = 0, y = x) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    toString() {\n        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n    }\n    /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */ static get shared() {\n        $fdaff9f788d94485$var$tempPoint.x = 0;\n        $fdaff9f788d94485$var$tempPoint.y = 0;\n        return $fdaff9f788d94485$var$tempPoint;\n    }\n}\nconst $fdaff9f788d94485$var$tempPoint = new $fdaff9f788d94485$export$baf26146a414f24a();\n\n});\n\nparcelRegister(\"fM4Mk\", function(module, exports) {\n\n$parcel$export(module.exports, \"Rectangle\", () => $55a82579353c67d9$export$4617fb02663045ef);\n\nvar $1HooC = parcelRequire(\"1HooC\");\n\"use strict\";\nconst $55a82579353c67d9$var$tempPoints = [\n    new (0, $1HooC.Point)(),\n    new (0, $1HooC.Point)(),\n    new (0, $1HooC.Point)(),\n    new (0, $1HooC.Point)()\n];\nclass $55a82579353c67d9$export$4617fb02663045ef {\n    /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */ constructor(x = 0, y = 0, width = 0, height = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */ this.type = \"rectangle\";\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n    /** Returns the left edge of the rectangle. */ get left() {\n        return this.x;\n    }\n    /** Returns the right edge of the rectangle. */ get right() {\n        return this.x + this.width;\n    }\n    /** Returns the top edge of the rectangle. */ get top() {\n        return this.y;\n    }\n    /** Returns the bottom edge of the rectangle. */ get bottom() {\n        return this.y + this.height;\n    }\n    /** Determines whether the Rectangle is empty. */ isEmpty() {\n        return this.left === this.right || this.top === this.bottom;\n    }\n    /** A constant empty rectangle. This is a new object every time the property is accessed */ static get EMPTY() {\n        return new $55a82579353c67d9$export$4617fb02663045ef(0, 0, 0, 0);\n    }\n    /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */ clone() {\n        return new $55a82579353c67d9$export$4617fb02663045ef(this.x, this.y, this.width, this.height);\n    }\n    /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */ copyFromBounds(bounds) {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n        return this;\n    }\n    /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(rectangle) {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n        return this;\n    }\n    /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(rectangle) {\n        rectangle.copyFrom(this);\n        return rectangle;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */ contains(x, y) {\n        if (this.width <= 0 || this.height <= 0) return false;\n        if (x >= this.x && x < this.x + this.width) {\n            if (y >= this.y && y < this.y + this.height) return true;\n        }\n        return false;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */ strokeContains(x, y, strokeWidth) {\n        const { width: width, height: height } = this;\n        if (width <= 0 || height <= 0) return false;\n        const _x = this.x;\n        const _y = this.y;\n        const outerLeft = _x - strokeWidth / 2;\n        const outerRight = _x + width + strokeWidth / 2;\n        const outerTop = _y - strokeWidth / 2;\n        const outerBottom = _y + height + strokeWidth / 2;\n        const innerLeft = _x + strokeWidth / 2;\n        const innerRight = _x + width - strokeWidth / 2;\n        const innerTop = _y + strokeWidth / 2;\n        const innerBottom = _y + height - strokeWidth / 2;\n        return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */ intersects(other, transform) {\n        if (!transform) {\n            const x02 = this.x < other.x ? other.x : this.x;\n            const x12 = this.right > other.right ? other.right : this.right;\n            if (x12 <= x02) return false;\n            const y02 = this.y < other.y ? other.y : this.y;\n            const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n            return y12 > y02;\n        }\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n        if (x1 <= x0 || y1 <= y0) return false;\n        const lt = $55a82579353c67d9$var$tempPoints[0].set(other.left, other.top);\n        const lb = $55a82579353c67d9$var$tempPoints[1].set(other.left, other.bottom);\n        const rt = $55a82579353c67d9$var$tempPoints[2].set(other.right, other.top);\n        const rb = $55a82579353c67d9$var$tempPoints[3].set(other.right, other.bottom);\n        if (rt.x <= lt.x || lb.y <= lt.y) return false;\n        const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n        if (s === 0) return false;\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) return false;\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = nx * x0 + ny * y0;\n        const n10 = nx * x1 + ny * y0;\n        const n01 = nx * x0 + ny * y1;\n        const n11 = nx * x1 + ny * y1;\n        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) return false;\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = mx * x0 + my * y0;\n        const m10 = mx * x1 + my * y0;\n        const m01 = mx * x0 + my * y1;\n        const m11 = mx * x1 + my * y1;\n        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) return false;\n        return true;\n    }\n    /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */ pad(paddingX = 0, paddingY = paddingX) {\n        this.x -= paddingX;\n        this.y -= paddingY;\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n        return this;\n    }\n    /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */ fit(rectangle) {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n        return this;\n    }\n    /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */ ceil(resolution = 1, eps = 1e-3) {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n        return this;\n    }\n    /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */ enlarge(rectangle) {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n        return this;\n    }\n    /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new $55a82579353c67d9$export$4617fb02663045ef();\n        out.copyFrom(this);\n        return out;\n    }\n    toString() {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n}\n\n});\n\nparcelRegister(\"i9BKe\", function(module, exports) {\n\n$parcel$export(module.exports, \"ExtensionType\", () => $2726d886f4171354$export$4f037c6ec2da4eeb);\n$parcel$export(module.exports, \"extensions\", () => $2726d886f4171354$export$cc3e2d3244e01b7f);\n\"use strict\";\nvar $2726d886f4171354$export$4f037c6ec2da4eeb = /* @__PURE__ */ ((ExtensionType2)=>{\n    ExtensionType2[\"Application\"] = \"application\";\n    ExtensionType2[\"WebGLPipes\"] = \"webgl-pipes\";\n    ExtensionType2[\"WebGLPipesAdaptor\"] = \"webgl-pipes-adaptor\";\n    ExtensionType2[\"WebGLSystem\"] = \"webgl-system\";\n    ExtensionType2[\"WebGPUPipes\"] = \"webgpu-pipes\";\n    ExtensionType2[\"WebGPUPipesAdaptor\"] = \"webgpu-pipes-adaptor\";\n    ExtensionType2[\"WebGPUSystem\"] = \"webgpu-system\";\n    ExtensionType2[\"CanvasSystem\"] = \"canvas-system\";\n    ExtensionType2[\"CanvasPipesAdaptor\"] = \"canvas-pipes-adaptor\";\n    ExtensionType2[\"CanvasPipes\"] = \"canvas-pipes\";\n    ExtensionType2[\"Asset\"] = \"asset\";\n    ExtensionType2[\"LoadParser\"] = \"load-parser\";\n    ExtensionType2[\"ResolveParser\"] = \"resolve-parser\";\n    ExtensionType2[\"CacheParser\"] = \"cache-parser\";\n    ExtensionType2[\"DetectionParser\"] = \"detection-parser\";\n    ExtensionType2[\"MaskEffect\"] = \"mask-effect\";\n    ExtensionType2[\"BlendMode\"] = \"blend-mode\";\n    ExtensionType2[\"TextureSource\"] = \"texture-source\";\n    ExtensionType2[\"Environment\"] = \"environment\";\n    return ExtensionType2;\n})($2726d886f4171354$export$4f037c6ec2da4eeb || {});\nconst $2726d886f4171354$var$normalizeExtension = (ext)=>{\n    if (typeof ext === \"function\" || typeof ext === \"object\" && ext.extension) {\n        if (!ext.extension) throw new Error(\"Extension class must have an extension object\");\n        const metadata = typeof ext.extension !== \"object\" ? {\n            type: ext.extension\n        } : ext.extension;\n        ext = {\n            ...metadata,\n            ref: ext\n        };\n    }\n    if (typeof ext === \"object\") ext = {\n        ...ext\n    };\n    else throw new Error(\"Invalid extension type\");\n    if (typeof ext.type === \"string\") ext.type = [\n        ext.type\n    ];\n    return ext;\n};\nconst $2726d886f4171354$export$ba4241979983e013 = (ext, defaultPriority)=>$2726d886f4171354$var$normalizeExtension(ext).priority ?? defaultPriority;\nconst $2726d886f4171354$export$cc3e2d3244e01b7f = {\n    /** @ignore */ _addHandlers: {},\n    /** @ignore */ _removeHandlers: {},\n    /** @ignore */ _queue: {},\n    /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */ remove (...extensions2) {\n        extensions2.map($2726d886f4171354$var$normalizeExtension).forEach((ext)=>{\n            ext.type.forEach((type)=>this._removeHandlers[type]?.(ext));\n        });\n        return this;\n    },\n    /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */ add (...extensions2) {\n        extensions2.map($2726d886f4171354$var$normalizeExtension).forEach((ext)=>{\n            ext.type.forEach((type)=>{\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n                if (!handlers[type]) {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                } else handlers[type]?.(ext);\n            });\n        });\n        return this;\n    },\n    /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */ handle (type, onAdd, onRemove) {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n        if (addHandlers[type] || removeHandlers[type]) throw new Error(`Extension type ${type} already has a handler`);\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n        const queue = this._queue;\n        if (queue[type]) {\n            queue[type]?.forEach((ext)=>onAdd(ext));\n            delete queue[type];\n        }\n        return this;\n    },\n    /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */ handleByMap (type, map) {\n        return this.handle(type, (extension)=>{\n            if (extension.name) map[extension.name] = extension.ref;\n        }, (extension)=>{\n            if (extension.name) delete map[extension.name];\n        });\n    },\n    /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */ handleByNamedList (type, map, defaultPriority = -1) {\n        return this.handle(type, (extension)=>{\n            const index = map.findIndex((item)=>item.name === extension.name);\n            if (index >= 0) return;\n            map.push({\n                name: extension.name,\n                value: extension.ref\n            });\n            map.sort((a, b)=>$2726d886f4171354$export$ba4241979983e013(b.value, defaultPriority) - $2726d886f4171354$export$ba4241979983e013(a.value, defaultPriority));\n        }, (extension)=>{\n            const index = map.findIndex((item)=>item.name === extension.name);\n            if (index !== -1) map.splice(index, 1);\n        });\n    },\n    /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */ handleByList (type, list, defaultPriority = -1) {\n        return this.handle(type, (extension)=>{\n            if (list.includes(extension.ref)) return;\n            list.push(extension.ref);\n            list.sort((a, b)=>$2726d886f4171354$export$ba4241979983e013(b, defaultPriority) - $2726d886f4171354$export$ba4241979983e013(a, defaultPriority));\n        }, (extension)=>{\n            const index = list.indexOf(extension.ref);\n            if (index !== -1) list.splice(index, 1);\n        });\n    }\n};\n\n});\n\nparcelRegister(\"dLk2N\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = Promise.all([\n    $Gr8vk(\"7OvPL\"),\n    $Gr8vk(\"78TkE\"),\n    $Gr8vk(\"dCEEN\")\n]).then(()=>parcelRequire(\"gFyHJ\"));\n\n});\nparcelRegister(\"Gr8vk\", function(module, exports) {\n\"use strict\";\n\nfunction $07f8f9093a769793$var$load(id) {\n    // eslint-disable-next-line no-undef\n    return import((parcelRequire(\"27Lyk\")).resolve(id));\n}\nmodule.exports = $07f8f9093a769793$var$load;\n\n});\n\n\nparcelRegister(\"dwO65\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = Promise.all([\n    $Gr8vk(\"7OvPL\"),\n    $Gr8vk(\"78TkE\"),\n    $Gr8vk(\"5zD7l\")\n]).then(()=>parcelRequire(\"danRq\"));\n\n});\n\nparcelRegister(\"7dx1H\", function(module, exports) {\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $7h8HJ = parcelRequire(\"7h8HJ\");\n\nvar $lLQso = parcelRequire(\"lLQso\");\n\nvar $jXXId = parcelRequire(\"jXXId\");\n\nvar $fwGvo = parcelRequire(\"fwGvo\");\n\nvar $8xl7d = parcelRequire(\"8xl7d\");\n\nvar $aQPld = parcelRequire(\"aQPld\");\n\nvar $hNatJ = parcelRequire(\"hNatJ\");\nparcelRequire(\"8QN7n\");\n\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $7h8HJ.AlphaMask), (0, $lLQso.ColorMask), (0, $jXXId.StencilMask), (0, $hNatJ.VideoSource), (0, $aQPld.ImageSource), (0, $8xl7d.CanvasSource), (0, $fwGvo.BufferImageSource));\n\n});\nparcelRegister(\"7h8HJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"AlphaMask\", () => $90469dbfa4a0e350$export$3c32667be409917c);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $4rhnu = parcelRequire(\"4rhnu\");\n\nvar $jzlb7 = parcelRequire(\"jzlb7\");\n\nvar $4vXk0 = parcelRequire(\"4vXk0\");\n\"use strict\";\nclass $90469dbfa4a0e350$export$3c32667be409917c {\n    constructor(options){\n        this.priority = 0;\n        this.pipe = \"alphaMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n        this.renderMaskToTexture = !(mask instanceof (0, $4rhnu.Sprite));\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n        this.mask.measurable = false;\n    }\n    reset() {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n    addBounds(bounds, skipUpdateTransform) {\n        (0, $jzlb7.addMaskBounds)(this.mask, bounds, skipUpdateTransform);\n    }\n    addLocalBounds(bounds, localRoot) {\n        (0, $4vXk0.addMaskLocalBounds)(this.mask, bounds, localRoot);\n    }\n    containsPoint(point, hitTestFn) {\n        const mask = this.mask;\n        return hitTestFn(mask, point);\n    }\n    destroy() {\n        this.reset();\n    }\n    static test(mask) {\n        return mask instanceof (0, $4rhnu.Sprite);\n    }\n}\n$90469dbfa4a0e350$export$3c32667be409917c.extension = (0, $i9BKe.ExtensionType).MaskEffect;\n\n});\nparcelRegister(\"4rhnu\", function(module, exports) {\n\n$parcel$export(module.exports, \"Sprite\", () => $2ddac34a8a6af484$export$3075603db8e6204c);\n\nvar $a32F4 = parcelRequire(\"a32F4\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $f8J9J = parcelRequire(\"f8J9J\");\n\nvar $eicwU = parcelRequire(\"eicwU\");\n\"use strict\";\nclass $2ddac34a8a6af484$export$3075603db8e6204c extends (0, $eicwU.Container) {\n    /**\n   * @param options - The options for creating the sprite.\n   */ constructor(options = (0, $bLlTJ.Texture).EMPTY){\n        if (options instanceof (0, $bLlTJ.Texture)) options = {\n            texture: options\n        };\n        const { texture: texture, anchor: anchor, roundPixels: roundPixels, width: width, height: height, ...rest } = options;\n        super({\n            label: \"Sprite\",\n            ...rest\n        });\n        this.renderPipeId = \"sprite\";\n        this.batched = true;\n        this._didSpriteUpdate = false;\n        this._bounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        this._sourceBounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        this._boundsDirty = true;\n        this._sourceBoundsDirty = true;\n        this._roundPixels = 0;\n        this._anchor = new (0, $a32F4.ObservablePoint)({\n            _onUpdate: ()=>{\n                this.onViewUpdate();\n            }\n        });\n        if (anchor) this.anchor = anchor;\n        else if (texture.defaultAnchor) this.anchor = texture.defaultAnchor;\n        this.texture = texture;\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n        if (width) this.width = width;\n        if (height) this.height = height;\n    }\n    /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */ static from(source, skipCache = false) {\n        if (source instanceof (0, $bLlTJ.Texture)) return new $2ddac34a8a6af484$export$3075603db8e6204c(source);\n        return new $2ddac34a8a6af484$export$3075603db8e6204c((0, $bLlTJ.Texture).from(source, skipCache));\n    }\n    set texture(value) {\n        value || (value = (0, $bLlTJ.Texture).EMPTY);\n        const currentTexture = this._texture;\n        if (currentTexture === value) return;\n        if (currentTexture && currentTexture.dynamic) currentTexture.off(\"update\", this.onViewUpdate, this);\n        if (value.dynamic) value.on(\"update\", this.onViewUpdate, this);\n        this._texture = value;\n        this.onViewUpdate();\n    }\n    /** The texture that the sprite is using. */ get texture() {\n        return this._texture;\n    }\n    /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */ get bounds() {\n        if (this._boundsDirty) {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n        return this._bounds;\n    }\n    /**\n   * The bounds of the sprite, taking the texture's trim into account.\n   * @type {rendering.Bounds}\n   */ get sourceBounds() {\n        if (this._sourceBoundsDirty) {\n            this._updateSourceBounds();\n            this._sourceBoundsDirty = false;\n        }\n        return this._sourceBounds;\n    }\n    /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        const bounds = this.sourceBounds;\n        if (point.x >= bounds.maxX && point.x <= bounds.minX) {\n            if (point.y >= bounds.maxY && point.y <= bounds.minY) return true;\n        }\n        return false;\n    }\n    /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */ addBounds(bounds) {\n        const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n    onViewUpdate() {\n        this._didChangeId += 4096;\n        this._didSpriteUpdate = true;\n        this._sourceBoundsDirty = this._boundsDirty = true;\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n        if (this.renderGroup) this.renderGroup.onChildViewUpdate(this);\n    }\n    _updateBounds() {\n        (0, $f8J9J.updateQuadBounds)(this._bounds, this._anchor, this._texture, 0);\n    }\n    _updateSourceBounds() {\n        const anchor = this._anchor;\n        const texture = this._texture;\n        const sourceBounds = this._sourceBounds;\n        const { width: width, height: height } = texture.orig;\n        sourceBounds.maxX = -anchor._x * width;\n        sourceBounds.minX = sourceBounds.maxX + width;\n        sourceBounds.maxY = -anchor._y * height;\n        sourceBounds.minY = sourceBounds.maxY + height;\n    }\n    /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */ destroy(options = false) {\n        super.destroy(options);\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            this._texture.destroy(destroyTextureSource);\n        }\n        this._texture = null;\n        this._bounds = null;\n        this._sourceBounds = null;\n        this._anchor = null;\n    }\n    /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from 'pixi.js';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */ get anchor() {\n        return this._anchor;\n    }\n    set anchor(value) {\n        typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n    /**\n   *  Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */ get roundPixels() {\n        return !!this._roundPixels;\n    }\n    set roundPixels(value) {\n        this._roundPixels = value ? 1 : 0;\n    }\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */ get width() {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n    set width(value) {\n        this._setWidth(value, this._texture.orig.width);\n    }\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */ get height() {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n    set height(value) {\n        this._setHeight(value, this._texture.orig.height);\n    }\n    /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */ getSize(out) {\n        if (!out) out = {};\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n        return out;\n    }\n    /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */ setSize(value, height) {\n        let convertedWidth;\n        let convertedHeight;\n        if (typeof value !== \"object\") {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        } else {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n        if (convertedWidth !== void 0) this._setWidth(convertedWidth, this._texture.orig.width);\n        if (convertedHeight !== void 0) this._setHeight(convertedHeight, this._texture.orig.height);\n    }\n}\n\n});\nparcelRegister(\"a32F4\", function(module, exports) {\n\n$parcel$export(module.exports, \"ObservablePoint\", () => $702ea64f2b15c76d$export$3755aaad3fd42e52);\n\"use strict\";\nclass $702ea64f2b15c76d$export$3755aaad3fd42e52 {\n    /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */ constructor(observer, x, y){\n        this._x = x || 0;\n        this._y = y || 0;\n        this._observer = observer;\n    }\n    /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */ clone(observer) {\n        return new $702ea64f2b15c76d$export$3755aaad3fd42e52(observer ?? this._observer, this._x, this._y);\n    }\n    /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */ set(x = 0, y = x) {\n        if (this._x !== x || this._y !== y) {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n        return this;\n    }\n    /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */ copyFrom(p) {\n        if (this._x !== p.x || this._y !== p.y) {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n        return this;\n    }\n    /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */ copyTo(p) {\n        p.set(this._x, this._y);\n        return p;\n    }\n    /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */ equals(p) {\n        return p.x === this._x && p.y === this._y;\n    }\n    toString() {\n        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n    }\n    /** Position of the observable point on the x axis. */ get x() {\n        return this._x;\n    }\n    set x(value) {\n        if (this._x !== value) {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n    /** Position of the observable point on the y axis. */ get y() {\n        return this._y;\n    }\n    set y(value) {\n        if (this._y !== value) {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n\n});\n\nparcelRegister(\"bLlTJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"Texture\", () => $dd4e44a750d6d26c$export$5431306cf43de24a);\n\nvar $3vRz3 = parcelRequire(\"3vRz3\");\n\nvar $2RwkA = parcelRequire(\"2RwkA\");\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\nvar $2coCi = parcelRequire(\"2coCi\");\n\nvar $fwGvo = parcelRequire(\"fwGvo\");\n\nvar $iA5fe = parcelRequire(\"iA5fe\");\n\nvar $jNN6Y = parcelRequire(\"jNN6Y\");\n\"use strict\";\nclass $dd4e44a750d6d26c$export$5431306cf43de24a extends (0, (/*@__PURE__*/$parcel$interopDefault($3vRz3))) {\n    /**\n   * @param {TextureOptions} param0 - Options for the texture\n   */ constructor({ source: source, label: label, frame: frame, orig: orig, trim: trim, defaultAnchor: defaultAnchor, defaultBorders: defaultBorders, rotate: rotate, dynamic: dynamic } = {}){\n        super();\n        /** unique id for this texture */ this.uid = (0, $aGJhg.uid)(\"texture\");\n        /** A uvs object based on the given frame and the texture source */ this.uvs = {\n            x0: 0,\n            y0: 0,\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            x3: 0,\n            y3: 0\n        };\n        /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */ this.frame = new (0, $fM4Mk.Rectangle)();\n        /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */ this.noFrame = false;\n        /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */ this.dynamic = false;\n        /** is it a texture? yes! used for type checking */ this.isTexture = true;\n        this.label = label;\n        this.source = source?.source ?? new (0, $iA5fe.TextureSource)();\n        this.noFrame = !frame;\n        if (frame) this.frame.copyFrom(frame);\n        else {\n            const { width: width, height: height } = this._source;\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n        this.orig = orig || this.frame;\n        this.trim = trim;\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n        this.updateUvs();\n    }\n    set source(value) {\n        if (this._source) this._source.off(\"resize\", this.update, this);\n        this._source = value;\n        value.on(\"resize\", this.update, this);\n        this.emit(\"update\", this);\n    }\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */ get source() {\n        return this._source;\n    }\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */ get textureMatrix() {\n        if (!this._textureMatrix) this._textureMatrix = new (0, $jNN6Y.TextureMatrix)(this);\n        return this._textureMatrix;\n    }\n    /** The width of the Texture in pixels. */ get width() {\n        return this.orig.width;\n    }\n    /** The height of the Texture in pixels. */ get height() {\n        return this.orig.height;\n    }\n    /** Call this function when you have modified the frame of this texture. */ updateUvs() {\n        const { uvs: uvs, frame: frame } = this;\n        const { width: width, height: height } = this._source;\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n        let rotate = this.rotate;\n        if (rotate) {\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n            const cX = nX + w2;\n            const cY = nY + h2;\n            rotate = (0, $2RwkA.groupD8).add(rotate, (0, $2RwkA.groupD8).NW);\n            uvs.x0 = cX + w2 * (0, $2RwkA.groupD8).uX(rotate);\n            uvs.y0 = cY + h2 * (0, $2RwkA.groupD8).uY(rotate);\n            rotate = (0, $2RwkA.groupD8).add(rotate, 2);\n            uvs.x1 = cX + w2 * (0, $2RwkA.groupD8).uX(rotate);\n            uvs.y1 = cY + h2 * (0, $2RwkA.groupD8).uY(rotate);\n            rotate = (0, $2RwkA.groupD8).add(rotate, 2);\n            uvs.x2 = cX + w2 * (0, $2RwkA.groupD8).uX(rotate);\n            uvs.y2 = cY + h2 * (0, $2RwkA.groupD8).uY(rotate);\n            rotate = (0, $2RwkA.groupD8).add(rotate, 2);\n            uvs.x3 = cX + w2 * (0, $2RwkA.groupD8).uX(rotate);\n            uvs.y3 = cY + h2 * (0, $2RwkA.groupD8).uY(rotate);\n        } else {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n    /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */ destroy(destroySource = false) {\n        if (this._source) {\n            if (destroySource) {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n    }\n    /** call this if you have modified the `texture outside` of the constructor */ update() {\n        if (this.noFrame) {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n        this.updateUvs();\n        this.emit(\"update\", this);\n    }\n    /** @deprecated since 8.0.0 */ get baseTexture() {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Texture.baseTexture is now Texture.source\");\n        return this._source;\n    }\n}\n$dd4e44a750d6d26c$export$5431306cf43de24a.EMPTY = new $dd4e44a750d6d26c$export$5431306cf43de24a({\n    label: \"EMPTY\",\n    source: new (0, $iA5fe.TextureSource)({\n        label: \"EMPTY\"\n    })\n});\n$dd4e44a750d6d26c$export$5431306cf43de24a.EMPTY.destroy = (0, $2coCi.NOOP);\n$dd4e44a750d6d26c$export$5431306cf43de24a.WHITE = new $dd4e44a750d6d26c$export$5431306cf43de24a({\n    source: new (0, $fwGvo.BufferImageSource)({\n        resource: new Uint8Array([\n            255,\n            255,\n            255,\n            255\n        ]),\n        width: 1,\n        height: 1,\n        alphaMode: \"premultiply-alpha-on-upload\",\n        label: \"WHITE\"\n    }),\n    label: \"WHITE\"\n});\n$dd4e44a750d6d26c$export$5431306cf43de24a.WHITE.destroy = (0, $2coCi.NOOP);\n\n});\nparcelRegister(\"3vRz3\", function(module, exports) {\n\"use strict\";\nvar $28edd11f6c7e9f5f$var$has = Object.prototype.hasOwnProperty, $28edd11f6c7e9f5f$var$prefix = \"~\";\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function $28edd11f6c7e9f5f$var$Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    $28edd11f6c7e9f5f$var$Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new $28edd11f6c7e9f5f$var$Events().__proto__) $28edd11f6c7e9f5f$var$prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function $28edd11f6c7e9f5f$var$EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function $28edd11f6c7e9f5f$var$addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") throw new TypeError(\"The listener must be a function\");\n    var listener = new $28edd11f6c7e9f5f$var$EE(fn, context || emitter, once), evt = $28edd11f6c7e9f5f$var$prefix ? $28edd11f6c7e9f5f$var$prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function $28edd11f6c7e9f5f$var$clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new $28edd11f6c7e9f5f$var$Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function $28edd11f6c7e9f5f$var$EventEmitter() {\n    this._events = new $28edd11f6c7e9f5f$var$Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ $28edd11f6c7e9f5f$var$EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events)if ($28edd11f6c7e9f5f$var$has.call(events, name)) names.push($28edd11f6c7e9f5f$var$prefix ? name.slice(1) : name);\n    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ $28edd11f6c7e9f5f$var$EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = $28edd11f6c7e9f5f$var$prefix ? $28edd11f6c7e9f5f$var$prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ $28edd11f6c7e9f5f$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = $28edd11f6c7e9f5f$var$prefix ? $28edd11f6c7e9f5f$var$prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ $28edd11f6c7e9f5f$var$EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = $28edd11f6c7e9f5f$var$prefix ? $28edd11f6c7e9f5f$var$prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $28edd11f6c7e9f5f$var$EventEmitter.prototype.on = function on(event, fn, context) {\n    return $28edd11f6c7e9f5f$var$addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $28edd11f6c7e9f5f$var$EventEmitter.prototype.once = function once(event, fn, context) {\n    return $28edd11f6c7e9f5f$var$addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ $28edd11f6c7e9f5f$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = $28edd11f6c7e9f5f$var$prefix ? $28edd11f6c7e9f5f$var$prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        $28edd11f6c7e9f5f$var$clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) $28edd11f6c7e9f5f$var$clearEvent(this, evt);\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else $28edd11f6c7e9f5f$var$clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ $28edd11f6c7e9f5f$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = $28edd11f6c7e9f5f$var$prefix ? $28edd11f6c7e9f5f$var$prefix + event : event;\n        if (this._events[evt]) $28edd11f6c7e9f5f$var$clearEvent(this, evt);\n    } else {\n        this._events = new $28edd11f6c7e9f5f$var$Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\n$28edd11f6c7e9f5f$var$EventEmitter.prototype.off = $28edd11f6c7e9f5f$var$EventEmitter.prototype.removeListener;\n$28edd11f6c7e9f5f$var$EventEmitter.prototype.addListener = $28edd11f6c7e9f5f$var$EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\n$28edd11f6c7e9f5f$var$EventEmitter.prefixed = $28edd11f6c7e9f5f$var$prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\n$28edd11f6c7e9f5f$var$EventEmitter.EventEmitter = $28edd11f6c7e9f5f$var$EventEmitter;\nmodule.exports = $28edd11f6c7e9f5f$var$EventEmitter;\n\n});\n\nparcelRegister(\"2RwkA\", function(module, exports) {\n\n$parcel$export(module.exports, \"groupD8\", () => $99d48e5a2f9844ff$export$b7bb6a2a8d203102);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\"use strict\";\nconst $99d48e5a2f9844ff$var$ux = [\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1\n];\nconst $99d48e5a2f9844ff$var$uy = [\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1\n];\nconst $99d48e5a2f9844ff$var$vx = [\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1\n];\nconst $99d48e5a2f9844ff$var$vy = [\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1\n];\nconst $99d48e5a2f9844ff$var$rotationCayley = [];\nconst $99d48e5a2f9844ff$var$rotationMatrices = [];\nconst $99d48e5a2f9844ff$var$signum = Math.sign;\nfunction $99d48e5a2f9844ff$var$init() {\n    for(let i = 0; i < 16; i++){\n        const row = [];\n        $99d48e5a2f9844ff$var$rotationCayley.push(row);\n        for(let j = 0; j < 16; j++){\n            const _ux = $99d48e5a2f9844ff$var$signum($99d48e5a2f9844ff$var$ux[i] * $99d48e5a2f9844ff$var$ux[j] + $99d48e5a2f9844ff$var$vx[i] * $99d48e5a2f9844ff$var$uy[j]);\n            const _uy = $99d48e5a2f9844ff$var$signum($99d48e5a2f9844ff$var$uy[i] * $99d48e5a2f9844ff$var$ux[j] + $99d48e5a2f9844ff$var$vy[i] * $99d48e5a2f9844ff$var$uy[j]);\n            const _vx = $99d48e5a2f9844ff$var$signum($99d48e5a2f9844ff$var$ux[i] * $99d48e5a2f9844ff$var$vx[j] + $99d48e5a2f9844ff$var$vx[i] * $99d48e5a2f9844ff$var$vy[j]);\n            const _vy = $99d48e5a2f9844ff$var$signum($99d48e5a2f9844ff$var$uy[i] * $99d48e5a2f9844ff$var$vx[j] + $99d48e5a2f9844ff$var$vy[i] * $99d48e5a2f9844ff$var$vy[j]);\n            for(let k = 0; k < 16; k++)if ($99d48e5a2f9844ff$var$ux[k] === _ux && $99d48e5a2f9844ff$var$uy[k] === _uy && $99d48e5a2f9844ff$var$vx[k] === _vx && $99d48e5a2f9844ff$var$vy[k] === _vy) {\n                row.push(k);\n                break;\n            }\n        }\n    }\n    for(let i = 0; i < 16; i++){\n        const mat = new (0, $eY4rt.Matrix)();\n        mat.set($99d48e5a2f9844ff$var$ux[i], $99d48e5a2f9844ff$var$uy[i], $99d48e5a2f9844ff$var$vx[i], $99d48e5a2f9844ff$var$vy[i], 0, 0);\n        $99d48e5a2f9844ff$var$rotationMatrices.push(mat);\n    }\n}\n$99d48e5a2f9844ff$var$init();\nconst $99d48e5a2f9844ff$export$b7bb6a2a8d203102 = {\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ E: 0,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ SE: 1,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ S: 2,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ SW: 3,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ W: 4,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ NW: 5,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ N: 6,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ NE: 7,\n    /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MIRROR_VERTICAL: 8,\n    /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MAIN_DIAGONAL: 10,\n    /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MIRROR_HORIZONTAL: 12,\n    /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ REVERSE_DIAGONAL: 14,\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */ uX: (ind)=>$99d48e5a2f9844ff$var$ux[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */ uY: (ind)=>$99d48e5a2f9844ff$var$uy[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */ vX: (ind)=>$99d48e5a2f9844ff$var$vx[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */ vY: (ind)=>$99d48e5a2f9844ff$var$vy[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */ inv: (rotation)=>{\n        if (rotation & 8) return rotation & 15;\n        return -rotation & 7;\n    },\n    /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */ add: (rotationSecond, rotationFirst)=>$99d48e5a2f9844ff$var$rotationCayley[rotationSecond][rotationFirst],\n    /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */ sub: (rotationSecond, rotationFirst)=>$99d48e5a2f9844ff$var$rotationCayley[rotationSecond][$99d48e5a2f9844ff$export$b7bb6a2a8d203102.inv(rotationFirst)],\n    /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */ rotate180: (rotation)=>rotation ^ 4,\n    /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */ isVertical: (rotation)=>(rotation & 3) === 2,\n    // rotation % 4 === 2\n    /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */ byDirection: (dx, dy)=>{\n        if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n            if (dy >= 0) return $99d48e5a2f9844ff$export$b7bb6a2a8d203102.S;\n            return $99d48e5a2f9844ff$export$b7bb6a2a8d203102.N;\n        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n            if (dx > 0) return $99d48e5a2f9844ff$export$b7bb6a2a8d203102.E;\n            return $99d48e5a2f9844ff$export$b7bb6a2a8d203102.W;\n        } else if (dy > 0) {\n            if (dx > 0) return $99d48e5a2f9844ff$export$b7bb6a2a8d203102.SE;\n            return $99d48e5a2f9844ff$export$b7bb6a2a8d203102.SW;\n        } else if (dx > 0) return $99d48e5a2f9844ff$export$b7bb6a2a8d203102.NE;\n        return $99d48e5a2f9844ff$export$b7bb6a2a8d203102.NW;\n    },\n    /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */ matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0)=>{\n        const mat = $99d48e5a2f9844ff$var$rotationMatrices[$99d48e5a2f9844ff$export$b7bb6a2a8d203102.inv(rotation)];\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    }\n};\n\n});\nparcelRegister(\"eY4rt\", function(module, exports) {\n\n$parcel$export(module.exports, \"Matrix\", () => $fd3f7bfaf4af3d85$export$5b12bf1653c0dd85);\n\nvar $aWW4e = parcelRequire(\"aWW4e\");\n\nvar $1HooC = parcelRequire(\"1HooC\");\n\"use strict\";\nclass $fd3f7bfaf4af3d85$export$5b12bf1653c0dd85 {\n    /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */ constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0){\n        /** An array of the current matrix. Only populated when `toArray` is called */ this.array = null;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n    /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */ fromArray(array) {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n    /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */ set(a, b, c, d, tx, ty) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n        return this;\n    }\n    /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */ toArray(transpose, out) {\n        if (!this.array) this.array = new Float32Array(9);\n        const array = out || this.array;\n        if (transpose) {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        } else {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n        return array;\n    }\n    /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */ apply(pos, newPos) {\n        newPos = newPos || new (0, $1HooC.Point)();\n        const x = pos.x;\n        const y = pos.y;\n        newPos.x = this.a * x + this.c * y + this.tx;\n        newPos.y = this.b * x + this.d * y + this.ty;\n        return newPos;\n    }\n    /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */ applyInverse(pos, newPos) {\n        newPos = newPos || new (0, $1HooC.Point)();\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n        const id = 1 / (a * d + c * -b);\n        const x = pos.x;\n        const y = pos.y;\n        newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n        newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n        return newPos;\n    }\n    /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */ translate(x, y) {\n        this.tx += x;\n        this.ty += y;\n        return this;\n    }\n    /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */ scale(x, y) {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n        return this;\n    }\n    /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */ rotate(angle) {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n        this.a = a1 * cos - this.b * sin;\n        this.b = a1 * sin + this.b * cos;\n        this.c = c1 * cos - this.d * sin;\n        this.d = c1 * sin + this.d * cos;\n        this.tx = tx1 * cos - this.ty * sin;\n        this.ty = tx1 * sin + this.ty * cos;\n        return this;\n    }\n    /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */ append(matrix) {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        this.a = matrix.a * a1 + matrix.b * c1;\n        this.b = matrix.a * b1 + matrix.b * d1;\n        this.c = matrix.c * a1 + matrix.d * c1;\n        this.d = matrix.c * b1 + matrix.d * d1;\n        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n        return this;\n    }\n    /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */ appendFrom(a, b) {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n        this.a = a1 * a2 + b1 * c2;\n        this.b = a1 * b2 + b1 * d2;\n        this.c = c1 * a2 + d1 * c2;\n        this.d = c1 * b2 + d1 * d2;\n        this.tx = tx * a2 + ty * c2 + b.tx;\n        this.ty = tx * b2 + ty * d2 + b.ty;\n        return this;\n    }\n    /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */ setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n        this.tx = x - (pivotX * this.a + pivotY * this.c);\n        this.ty = y - (pivotX * this.b + pivotY * this.d);\n        return this;\n    }\n    /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */ prepend(matrix) {\n        const tx1 = this.tx;\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n            const a1 = this.a;\n            const c1 = this.c;\n            this.a = a1 * matrix.a + this.b * matrix.c;\n            this.b = a1 * matrix.b + this.b * matrix.d;\n            this.c = c1 * matrix.a + this.d * matrix.c;\n            this.d = c1 * matrix.b + this.d * matrix.d;\n        }\n        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n        return this;\n    }\n    /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */ decompose(transform) {\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n        const delta = Math.abs(skewX + skewY);\n        if (delta < 1e-5 || Math.abs((0, $aWW4e.PI_2) - delta) < 1e-5) {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        } else {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n        transform.scale.x = Math.sqrt(a * a + b * b);\n        transform.scale.y = Math.sqrt(c * c + d * d);\n        transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n        transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n        return transform;\n    }\n    /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */ invert() {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = a1 * d1 - b1 * c1;\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = (c1 * this.ty - d1 * tx1) / n;\n        this.ty = -(a1 * this.ty - b1 * tx1) / n;\n        return this;\n    }\n    /** Checks if this matrix is an identity matrix */ isIdentity() {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n    /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */ identity() {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n        return this;\n    }\n    /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */ clone() {\n        const matrix = new $fd3f7bfaf4af3d85$export$5b12bf1653c0dd85();\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n        return matrix;\n    }\n    /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */ copyTo(matrix) {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n        return matrix;\n    }\n    /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */ copyFrom(matrix) {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n        return this;\n    }\n    /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */ equals(matrix) {\n        return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n    toString() {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */ static get IDENTITY() {\n        return $fd3f7bfaf4af3d85$var$identityMatrix.identity();\n    }\n    /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */ static get shared() {\n        return $fd3f7bfaf4af3d85$var$tempMatrix.identity();\n    }\n}\nconst $fd3f7bfaf4af3d85$var$tempMatrix = new $fd3f7bfaf4af3d85$export$5b12bf1653c0dd85();\nconst $fd3f7bfaf4af3d85$var$identityMatrix = new $fd3f7bfaf4af3d85$export$5b12bf1653c0dd85();\n\n});\nparcelRegister(\"aWW4e\", function(module, exports) {\n\n$parcel$export(module.exports, \"PI_2\", () => $635707f32e142ac4$export$59ed0a0a5de1084b);\n$parcel$export(module.exports, \"RAD_TO_DEG\", () => $635707f32e142ac4$export$3f91627dc85c5d57);\n$parcel$export(module.exports, \"DEG_TO_RAD\", () => $635707f32e142ac4$export$870617f62e3187f1);\n\"use strict\";\nconst $635707f32e142ac4$export$59ed0a0a5de1084b = Math.PI * 2;\nconst $635707f32e142ac4$export$3f91627dc85c5d57 = 180 / Math.PI;\nconst $635707f32e142ac4$export$870617f62e3187f1 = Math.PI / 180;\n\n});\n\n\n\nparcelRegister(\"aGJhg\", function(module, exports) {\n\n$parcel$export(module.exports, \"uid\", () => $aa9685d46d70e8a7$export$e2a22331486dcca0);\n\"use strict\";\nconst $aa9685d46d70e8a7$var$uidCache = {\n    default: -1\n};\nfunction $aa9685d46d70e8a7$export$e2a22331486dcca0(name = \"default\") {\n    if ($aa9685d46d70e8a7$var$uidCache[name] === void 0) $aa9685d46d70e8a7$var$uidCache[name] = -1;\n    return ++$aa9685d46d70e8a7$var$uidCache[name];\n}\nfunction $aa9685d46d70e8a7$export$220409b686c277d0() {\n    for(const key in $aa9685d46d70e8a7$var$uidCache)delete $aa9685d46d70e8a7$var$uidCache[key];\n}\n\n});\n\nparcelRegister(\"kXq8E\", function(module, exports) {\n\n$parcel$export(module.exports, \"v8_0_0\", () => $86481ab6f435a4d7$export$dc79da96439604f0);\n$parcel$export(module.exports, \"deprecation\", () => $86481ab6f435a4d7$export$afd31d834b512e89);\n\"use strict\";\nconst $86481ab6f435a4d7$var$warnings = {};\nconst $86481ab6f435a4d7$export$dc79da96439604f0 = \"8.0.0\";\nfunction $86481ab6f435a4d7$export$afd31d834b512e89(version, message, ignoreDepth = 3) {\n    if ($86481ab6f435a4d7$var$warnings[message]) return;\n    let stack = new Error().stack;\n    if (typeof stack === \"undefined\") console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n    else {\n        stack = stack.split(\"\\n\").splice(ignoreDepth).join(\"\\n\");\n        if (console.groupCollapsed) {\n            console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", `${message}\nDeprecated since v${version}`);\n            console.warn(stack);\n            console.groupEnd();\n        } else {\n            console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n            console.warn(stack);\n        }\n    }\n    $86481ab6f435a4d7$var$warnings[message] = true;\n}\n\n});\n\nparcelRegister(\"2coCi\", function(module, exports) {\n\n$parcel$export(module.exports, \"NOOP\", () => $342f4d0330a1a110$export$5702a91a6f42969f);\n\"use strict\";\nconst $342f4d0330a1a110$export$5702a91a6f42969f = ()=>{};\n\n});\n\nparcelRegister(\"fwGvo\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferImageSource\", () => $288e2f2cc997a595$export$1872462350fcb7cd);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $iA5fe = parcelRequire(\"iA5fe\");\n\"use strict\";\nclass $288e2f2cc997a595$export$1872462350fcb7cd extends (0, $iA5fe.TextureSource) {\n    constructor(options){\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n        if (!format) {\n            if (buffer instanceof Float32Array) format = \"rgba32float\";\n            else if (buffer instanceof Int32Array) format = \"rgba32uint\";\n            else if (buffer instanceof Uint32Array) format = \"rgba32uint\";\n            else if (buffer instanceof Int16Array) format = \"rgba16uint\";\n            else if (buffer instanceof Uint16Array) format = \"rgba16uint\";\n            else if (buffer instanceof Int8Array) format = \"bgra8unorm\";\n            else format = \"bgra8unorm\";\n        }\n        super({\n            ...options,\n            resource: buffer,\n            format: format\n        });\n        this.uploadMethodId = \"buffer\";\n    }\n    static test(resource) {\n        return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n    }\n}\n$288e2f2cc997a595$export$1872462350fcb7cd.extension = (0, $i9BKe.ExtensionType).TextureSource;\n\n});\nparcelRegister(\"iA5fe\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureSource\", () => $50e6ce3cf0e8b717$export$8498e6a2e655d3d8);\n\nvar $3vRz3 = parcelRequire(\"3vRz3\");\n\nvar $NbSCN = parcelRequire(\"NbSCN\");\n\nvar $dr868 = parcelRequire(\"dr868\");\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\nvar $aFPUT = parcelRequire(\"aFPUT\");\n\"use strict\";\nconst $50e6ce3cf0e8b717$var$_TextureSource = class _TextureSource extends (0, (/*@__PURE__*/$parcel$interopDefault($3vRz3))) {\n    /**\n   * @param options - options for creating a new TextureSource\n   */ constructor(options = {}){\n        super();\n        this.options = options;\n        /** unique id for this Texture source */ this.uid = (0, $aGJhg.uid)(\"textureSource\");\n        /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */ this._resourceType = \"textureSource\";\n        /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */ this._resourceId = (0, $aGJhg.uid)(\"resource\");\n        /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */ this.uploadMethodId = \"unknown\";\n        // dimensions\n        this._resolution = 1;\n        /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */ this.pixelWidth = 1;\n        /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */ this.pixelHeight = 1;\n        /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */ this.width = 1;\n        /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */ this.height = 1;\n        /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */ this.sampleCount = 1;\n        /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */ this.mipLevelCount = 1;\n        /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */ this.autoGenerateMipmaps = false;\n        /** the format that the texture data has */ this.format = \"rgba8unorm\";\n        /** how many dimensions does this texture have? currently v8 only supports 2d */ this.dimension = \"2d\";\n        /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */ this.antialias = false;\n        /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */ this._touched = 0;\n        /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */ this._batchTick = -1;\n        /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */ this._textureBindLocation = -1;\n        options = {\n            ..._TextureSource.defaultOptions,\n            ...options\n        };\n        this.label = options.label ?? \"\";\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n        if (options.width) this.pixelWidth = options.width * this._resolution;\n        else this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n        if (options.height) this.pixelHeight = options.height * this._resolution;\n        else this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n        this.style = new (0, $aFPUT.TextureStyle)((0, $dr868.definedProps)(options));\n        this.destroyed = false;\n        this._refreshPOT();\n    }\n    /** returns itself */ get source() {\n        return this;\n    }\n    /** the style of the texture */ get style() {\n        return this._style;\n    }\n    set style(value) {\n        if (this.style === value) return;\n        this._style?.off(\"change\", this._onStyleChange, this);\n        this._style = value;\n        this._style?.on(\"change\", this._onStyleChange, this);\n        this._onStyleChange();\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get addressMode() {\n        return this._style.addressMode;\n    }\n    set addressMode(value) {\n        this._style.addressMode = value;\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get repeatMode() {\n        return this._style.addressMode;\n    }\n    set repeatMode(value) {\n        this._style.addressMode = value;\n    }\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */ get magFilter() {\n        return this._style.magFilter;\n    }\n    set magFilter(value) {\n        this._style.magFilter = value;\n    }\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */ get minFilter() {\n        return this._style.minFilter;\n    }\n    set minFilter(value) {\n        this._style.minFilter = value;\n    }\n    /** Specifies behavior for sampling between mipmap levels. */ get mipmapFilter() {\n        return this._style.mipmapFilter;\n    }\n    set mipmapFilter(value) {\n        this._style.mipmapFilter = value;\n    }\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */ get lodMinClamp() {\n        return this._style.lodMinClamp;\n    }\n    set lodMinClamp(value) {\n        this._style.lodMinClamp = value;\n    }\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */ get lodMaxClamp() {\n        return this._style.lodMaxClamp;\n    }\n    set lodMaxClamp(value) {\n        this._style.lodMaxClamp = value;\n    }\n    _onStyleChange() {\n        this.emit(\"styleChange\", this);\n    }\n    /** call this if you have modified the texture outside of the constructor */ update() {\n        if (this.resource) {\n            const resolution = this._resolution;\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n            if (didResize) return;\n        }\n        this.emit(\"update\", this);\n    }\n    /** Destroys this texture source */ destroy() {\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.emit(\"change\", this);\n        if (this._style) {\n            this._style.destroy();\n            this._style = null;\n        }\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n    /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */ unload() {\n        this._resourceId = (0, $aGJhg.uid)(\"resource\");\n        this.emit(\"change\", this);\n        this.emit(\"unload\", this);\n    }\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */ get resourceWidth() {\n        const { resource: resource } = this;\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */ get resourceHeight() {\n        const { resource: resource } = this;\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n    /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */ get resolution() {\n        return this._resolution;\n    }\n    set resolution(resolution) {\n        if (this._resolution === resolution) return;\n        this._resolution = resolution;\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n    /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */ resize(width, height, resolution) {\n        resolution = resolution || this._resolution;\n        width = width || this.width;\n        height = height || this.height;\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n        this._resolution = resolution;\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) return false;\n        this._refreshPOT();\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n        this.emit(\"resize\", this);\n        this._resourceId = (0, $aGJhg.uid)(\"resource\");\n        this.emit(\"change\", this);\n        return true;\n    }\n    /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n   */ updateMipmaps() {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1) this.emit(\"updateMipmaps\", this);\n    }\n    set wrapMode(value) {\n        this._style.wrapMode = value;\n    }\n    get wrapMode() {\n        return this._style.wrapMode;\n    }\n    set scaleMode(value) {\n        this._style.scaleMode = value;\n    }\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */ get scaleMode() {\n        return this._style.scaleMode;\n    }\n    /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */ _refreshPOT() {\n        this.isPowerOfTwo = (0, $NbSCN.isPow2)(this.pixelWidth) && (0, $NbSCN.isPow2)(this.pixelHeight);\n    }\n    static test(_resource) {\n        throw new Error(\"Unimplemented\");\n    }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */ $50e6ce3cf0e8b717$var$_TextureSource.defaultOptions = {\n    resolution: 1,\n    format: \"bgra8unorm\",\n    alphaMode: \"premultiply-alpha-on-upload\",\n    dimensions: \"2d\",\n    mipLevelCount: 1,\n    autoGenerateMipmaps: false,\n    sampleCount: 1,\n    antialias: false,\n    autoGarbageCollect: false\n};\nlet $50e6ce3cf0e8b717$export$8498e6a2e655d3d8 = $50e6ce3cf0e8b717$var$_TextureSource;\n\n});\nparcelRegister(\"NbSCN\", function(module, exports) {\n\n$parcel$export(module.exports, \"nextPow2\", () => $445bbf816b14b66c$export$f0d90cf68bd426eb);\n$parcel$export(module.exports, \"isPow2\", () => $445bbf816b14b66c$export$eb50b9c078eb6ae7);\n\"use strict\";\nfunction $445bbf816b14b66c$export$f0d90cf68bd426eb(v) {\n    v += v === 0 ? 1 : 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n    return v + 1;\n}\nfunction $445bbf816b14b66c$export$eb50b9c078eb6ae7(v) {\n    return !(v & v - 1) && !!v;\n}\nfunction $445bbf816b14b66c$export$b9fae0bba9d9094d(v) {\n    let r = (v > 65535 ? 1 : 0) << 4;\n    v >>>= r;\n    let shift = (v > 255 ? 1 : 0) << 3;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 15 ? 1 : 0) << 2;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 3 ? 1 : 0) << 1;\n    v >>>= shift;\n    r |= shift;\n    return r | v >> 1;\n}\n\n});\n\nparcelRegister(\"dr868\", function(module, exports) {\n\n$parcel$export(module.exports, \"definedProps\", () => $c5dcc841d9b9a11e$export$801feaffb936a09d);\n\"use strict\";\nfunction $c5dcc841d9b9a11e$export$801feaffb936a09d(obj) {\n    const result = {};\n    for(const key in obj)if (obj[key] !== void 0) result[key] = obj[key];\n    return result;\n}\n\n});\n\nparcelRegister(\"aFPUT\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureStyle\", () => $46d9af7c4b00e80a$export$1ce1d0c10d3de5d5);\n\nvar $3vRz3 = parcelRequire(\"3vRz3\");\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\"use strict\";\nconst $46d9af7c4b00e80a$var$idHash = /* @__PURE__ */ Object.create(null);\nfunction $46d9af7c4b00e80a$var$createResourceIdFromString(value) {\n    const id = $46d9af7c4b00e80a$var$idHash[value];\n    if (id === void 0) $46d9af7c4b00e80a$var$idHash[value] = (0, $aGJhg.uid)(\"resource\");\n    return id;\n}\nconst $46d9af7c4b00e80a$var$_TextureStyle = class _TextureStyle extends (0, (/*@__PURE__*/$parcel$interopDefault($3vRz3))) {\n    /**\n   * @param options - options for the style\n   */ constructor(options = {}){\n        super();\n        this._resourceType = \"textureSampler\";\n        this._touched = 0;\n        /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */ this._maxAnisotropy = 1;\n        /**\n     * Has the style been destroyed?\n     * @readonly\n     */ this.destroyed = false;\n        options = {\n            ..._TextureStyle.defaultOptions,\n            ...options\n        };\n        this.addressMode = options.addressMode;\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n        this.scaleMode = options.scaleMode;\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n        this.compare = options.compare;\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n    set addressMode(value) {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get addressMode() {\n        return this.addressModeU;\n    }\n    set wrapMode(value) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"TextureStyle.wrapMode is now TextureStyle.addressMode\");\n        this.addressMode = value;\n    }\n    get wrapMode() {\n        return this.addressMode;\n    }\n    set scaleMode(value) {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */ get scaleMode() {\n        return this.magFilter;\n    }\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */ set maxAnisotropy(value) {\n        this._maxAnisotropy = Math.min(value, 16);\n        if (this._maxAnisotropy > 1) this.scaleMode = \"linear\";\n    }\n    get maxAnisotropy() {\n        return this._maxAnisotropy;\n    }\n    // TODO - move this to WebGL?\n    get _resourceId() {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n    update() {\n        this.emit(\"change\", this);\n        this._sharedResourceId = null;\n    }\n    _generateResourceId() {\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n        this._sharedResourceId = $46d9af7c4b00e80a$var$createResourceIdFromString(bigKey);\n        return this._resourceId;\n    }\n    /** Destroys the style */ destroy() {\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.emit(\"change\", this);\n        this.removeAllListeners();\n    }\n};\n/** default options for the style */ $46d9af7c4b00e80a$var$_TextureStyle.defaultOptions = {\n    addressMode: \"clamp-to-edge\",\n    scaleMode: \"linear\"\n};\nlet $46d9af7c4b00e80a$export$1ce1d0c10d3de5d5 = $46d9af7c4b00e80a$var$_TextureStyle;\n\n});\n\n\n\nparcelRegister(\"jNN6Y\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureMatrix\", () => $707e20d60f27daa2$export$dbea3135e9da48cb);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\"use strict\";\nconst $707e20d60f27daa2$var$tempMat = new (0, $eY4rt.Matrix)();\nclass $707e20d60f27daa2$export$dbea3135e9da48cb {\n    /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */ constructor(texture, clampMargin){\n        this.mapCoord = new (0, $eY4rt.Matrix)();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n        this.clampOffset = 0;\n        if (typeof clampMargin === \"undefined\") this.clampMargin = texture.width < 10 ? 0 : 0.5;\n        else this.clampMargin = clampMargin;\n        this.isSimple = false;\n        this.texture = texture;\n    }\n    /** Texture property. */ get texture() {\n        return this._texture;\n    }\n    set texture(value) {\n        if (this.texture === value) return;\n        this._texture?.removeListener(\"update\", this.update, this);\n        this._texture = value;\n        this._texture.addListener(\"update\", this.update, this);\n        this.update();\n    }\n    /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */ multiplyUvs(uvs, out) {\n        if (out === void 0) out = uvs;\n        const mat = this.mapCoord;\n        for(let i = 0; i < uvs.length; i += 2){\n            const x = uvs[i];\n            const y = uvs[i + 1];\n            out[i] = x * mat.a + y * mat.c + mat.tx;\n            out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n        }\n        return out;\n    }\n    /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */ update() {\n        const tex = this._texture;\n        this._updateID++;\n        const uvs = tex.uvs;\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n        const orig = tex.orig;\n        const trim = tex.trim;\n        if (trim) {\n            $707e20d60f27daa2$var$tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);\n            this.mapCoord.append($707e20d60f27daa2$var$tempMat);\n        }\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset;\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n        this.uClampOffset[0] = offset / texBase.pixelWidth;\n        this.uClampOffset[1] = offset / texBase.pixelHeight;\n        this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n        return true;\n    }\n}\n\n});\n\n\nparcelRegister(\"f8J9J\", function(module, exports) {\n\n$parcel$export(module.exports, \"updateQuadBounds\", () => $67aa708353891905$export$558ce66aa5723f1d);\n\"use strict\";\nfunction $67aa708353891905$export$558ce66aa5723f1d(bounds, anchor, texture, padding) {\n    const { width: width, height: height } = texture.orig;\n    const trim = texture.trim;\n    if (trim) {\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n        bounds.minX = trim.x - anchor._x * width - padding;\n        bounds.maxX = bounds.minX + sourceWidth;\n        bounds.minY = trim.y - anchor._y * height - padding;\n        bounds.maxY = bounds.minY + sourceHeight;\n    } else {\n        bounds.minX = -anchor._x * width - padding;\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = -anchor._y * height - padding;\n        bounds.maxY = bounds.minY + height;\n    }\n    return;\n}\n\n});\n\nparcelRegister(\"eicwU\", function(module, exports) {\n\n$parcel$export(module.exports, \"UPDATE_COLOR\", () => $8a2b4ed6f59ce4dc$export$f8ede8d8bf091ab5);\n$parcel$export(module.exports, \"UPDATE_BLEND\", () => $8a2b4ed6f59ce4dc$export$e4801e7edc7582f);\n$parcel$export(module.exports, \"UPDATE_VISIBLE\", () => $8a2b4ed6f59ce4dc$export$83db162b74637ea);\n$parcel$export(module.exports, \"Container\", () => $8a2b4ed6f59ce4dc$export$42a852a2b6b56249);\n\nvar $3vRz3 = parcelRequire(\"3vRz3\");\n\nvar $a2eTA = parcelRequire(\"a2eTA\");\n\nvar $j1i7q = parcelRequire(\"j1i7q\");\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $aWW4e = parcelRequire(\"aWW4e\");\n\nvar $a32F4 = parcelRequire(\"a32F4\");\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\nvar $236jP = parcelRequire(\"236jP\");\n\nvar $apXS2 = parcelRequire(\"apXS2\");\n\nvar $kkVML = parcelRequire(\"kkVML\");\n\nvar $kEqoj = parcelRequire(\"kEqoj\");\n\nvar $ggvKl = parcelRequire(\"ggvKl\");\n\nvar $82jXu = parcelRequire(\"82jXu\");\n\nvar $g5iYs = parcelRequire(\"g5iYs\");\n\nvar $1pFbO = parcelRequire(\"1pFbO\");\n\nvar $gIPW8 = parcelRequire(\"gIPW8\");\n\"use strict\";\nconst $8a2b4ed6f59ce4dc$var$defaultSkew = new (0, $a32F4.ObservablePoint)(null);\nconst $8a2b4ed6f59ce4dc$var$defaultPivot = new (0, $a32F4.ObservablePoint)(null);\nconst $8a2b4ed6f59ce4dc$var$defaultScale = new (0, $a32F4.ObservablePoint)(null, 1, 1);\nconst $8a2b4ed6f59ce4dc$export$f8ede8d8bf091ab5 = 1;\nconst $8a2b4ed6f59ce4dc$export$e4801e7edc7582f = 2;\nconst $8a2b4ed6f59ce4dc$export$83db162b74637ea = 4;\nconst $8a2b4ed6f59ce4dc$export$8363b5079568fbee = 8;\nclass $8a2b4ed6f59ce4dc$export$42a852a2b6b56249 extends (0, (/*@__PURE__*/$parcel$interopDefault($3vRz3))) {\n    constructor(options = {}){\n        super();\n        /** @private */ this.uid = (0, $aGJhg.uid)(\"renderable\");\n        /** @private */ this._updateFlags = 15;\n        // is this container the root of a renderGroup?\n        // TODO implement this in a few more places\n        /** @private */ this.isRenderGroupRoot = false;\n        // the render group this container belongs to OR owns\n        /** @private */ this.renderGroup = null;\n        // set to true if the container has changed. It is reset once the changes have been applied\n        // by the transform system\n        // its here to stop ensure that when things change, only one update gets registers with the transform system\n        /** @private */ this.didChange = false;\n        // same as above, but for the renderable\n        /** @private */ this.didViewUpdate = false;\n        // how deep is the container relative to its render group..\n        // unless the element is the root render group - it will be relative to its parent\n        /** @private */ this.relativeRenderGroupDepth = 0;\n        /**\n     * The array of children of this container.\n     * @readonly\n     */ this.children = [];\n        /** The display object container that contains this display object. */ this.parent = null;\n        // used internally for changing up the render order.. mainly for masks and filters\n        // TODO setting this should cause a rebuild??\n        /** @private */ this.includeInBuild = true;\n        /** @private */ this.measurable = true;\n        /** @private */ this.isSimple = true;\n        // / /////////////Transform related props//////////////\n        // used by the transform system to check if a container needs to be updated that frame\n        // if the tick matches the current transform system tick, it is not updated again\n        /**\n     * @internal\n     * @ignore\n     */ this.updateTick = -1;\n        /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */ this.localTransform = new (0, $eY4rt.Matrix)();\n        /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */ this.relativeGroupTransform = new (0, $eY4rt.Matrix)();\n        /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */ this.groupTransform = this.relativeGroupTransform;\n        /** If the object has been destroyed via destroy(). If true, it should not be used. */ this.destroyed = false;\n        // transform data..\n        /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */ this._position = new (0, $a32F4.ObservablePoint)(this, 0, 0);\n        /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */ this._scale = $8a2b4ed6f59ce4dc$var$defaultScale;\n        /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */ this._pivot = $8a2b4ed6f59ce4dc$var$defaultPivot;\n        /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */ this._skew = $8a2b4ed6f59ce4dc$var$defaultSkew;\n        /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._cx = 1;\n        /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._sx = 0;\n        /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._cy = 0;\n        /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._sy = 1;\n        /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */ this._rotation = 0;\n        // / COLOR related props //////////////\n        // color stored as ABGR\n        this.localColor = 16777215;\n        this.localAlpha = 1;\n        this.groupAlpha = 1;\n        // A\n        this.groupColor = 16777215;\n        // BGR\n        this.groupColorAlpha = 4294967295;\n        // ABGR\n        // / BLEND related props //////////////\n        /**\n     * @internal\n     * @ignore\n     */ this.localBlendMode = \"inherit\";\n        /**\n     * @internal\n     * @ignore\n     */ this.groupBlendMode = \"normal\";\n        // / VISIBILITY related props //////////////\n        // visibility\n        // 0b11\n        // first bit is visible, second bit is renderable\n        /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = renderable, 1 = not renderable) 0b001\n     * @internal\n     * @ignore\n     */ this.localDisplayStatus = 7;\n        // 0b11 | 0b10 | 0b01 | 0b00\n        /**\n     * @internal\n     * @ignore\n     */ this.globalDisplayStatus = 7;\n        /**\n     * A value that increments each time the container is modified\n     * the first 12 bits represent the container changes (eg transform, alpha, visible etc)\n     * the second 12 bits represent the view changes (eg texture swap, geometry change etc)\n     *\n     *  view          container\n     * [000000000000][00000000000]\n     * @ignore\n     */ this._didChangeId = 0;\n        /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */ this._didLocalTransformChangeId = -1;\n        (0, $gIPW8.assignWithIgnore)(this, options, {\n            children: true,\n            parent: true,\n            effects: true\n        });\n        options.children?.forEach((child)=>this.addChild(child));\n        this.effects = [];\n        options.parent?.addChild(this);\n    }\n    /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */ static mixin(source) {\n        Object.defineProperties($8a2b4ed6f59ce4dc$export$42a852a2b6b56249.prototype, Object.getOwnPropertyDescriptors(source));\n    }\n    /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */ addChild(...children) {\n        if (!this.allowChildren) (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"addChild: Only Containers will be allowed to add children in v8.0.0\");\n        if (children.length > 1) {\n            for(let i = 0; i < children.length; i++)this.addChild(children[i]);\n            return children[0];\n        }\n        const child = children[0];\n        if (child.parent === this) {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n            if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n            return child;\n        }\n        if (child.parent) child.parent.removeChild(child);\n        this.children.push(child);\n        if (this.sortableChildren) this.sortDirty = true;\n        child.parent = this;\n        child.didChange = true;\n        child.didViewUpdate = false;\n        child._updateFlags = 15;\n        if (this.renderGroup) this.renderGroup.addChild(child);\n        this.emit(\"childAdded\", child, this, this.children.length - 1);\n        child.emit(\"added\", this);\n        if (child._zIndex !== 0) child.depthOfChildModified();\n        return child;\n    }\n    /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */ removeChild(...children) {\n        if (children.length > 1) {\n            for(let i = 0; i < children.length; i++)this.removeChild(children[i]);\n            return children[0];\n        }\n        const child = children[0];\n        const index = this.children.indexOf(child);\n        if (index > -1) {\n            this.children.splice(index, 1);\n            if (this.renderGroup) this.renderGroup.removeChild(child);\n            child.parent = null;\n            this.emit(\"childRemoved\", child, this, index);\n            child.emit(\"removed\", this);\n        }\n        return child;\n    }\n    /** @ignore */ _onUpdate(point) {\n        if (point) {\n            if (point === this._skew) this._updateSkew();\n        }\n        this._didChangeId++;\n        if (this.didChange) return;\n        this.didChange = true;\n        if (this.isRenderGroupRoot) {\n            const renderGroupParent = this.renderGroup.renderGroupParent;\n            if (renderGroupParent) renderGroupParent.onChildUpdate(this);\n        } else if (this.renderGroup) this.renderGroup.onChildUpdate(this);\n    }\n    set isRenderGroup(value) {\n        if (this.isRenderGroupRoot && value === false) throw new Error(\"[Pixi] cannot undo a render group just yet\");\n        if (value) this.enableRenderGroup();\n    }\n    /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */ get isRenderGroup() {\n        return this.isRenderGroupRoot;\n    }\n    /** This enables the container to be rendered as a render group. */ enableRenderGroup() {\n        if (this.renderGroup && this.renderGroup.root === this) return;\n        this.isRenderGroupRoot = true;\n        const parentRenderGroup = this.renderGroup;\n        if (parentRenderGroup) parentRenderGroup.removeChild(this);\n        this.renderGroup = new (0, $1pFbO.RenderGroup)(this);\n        if (parentRenderGroup) {\n            for(let i = 0; i < parentRenderGroup.renderGroupChildren.length; i++){\n                const childRenderGroup = parentRenderGroup.renderGroupChildren[i];\n                let parent = childRenderGroup.root;\n                while(parent){\n                    if (parent === this) {\n                        this.renderGroup.addRenderGroupChild(childRenderGroup);\n                        break;\n                    }\n                    parent = parent.parent;\n                }\n            }\n            parentRenderGroup.addRenderGroupChild(this.renderGroup);\n        }\n        this._updateIsSimple();\n        this.groupTransform = (0, $eY4rt.Matrix).IDENTITY;\n    }\n    /** @ignore */ _updateIsSimple() {\n        this.isSimple = !this.isRenderGroupRoot && this.effects.length === 0;\n    }\n    /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */ get worldTransform() {\n        this._worldTransform || (this._worldTransform = new (0, $eY4rt.Matrix)());\n        if (this.renderGroup) {\n            if (this.isRenderGroupRoot) this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n            else this._worldTransform.appendFrom(this.relativeGroupTransform, this.renderGroup.worldTransform);\n        }\n        return this._worldTransform;\n    }\n    // / ////// transform related stuff\n    /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */ get x() {\n        return this._position.x;\n    }\n    set x(value) {\n        this._position.x = value;\n    }\n    /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */ get y() {\n        return this._position.y;\n    }\n    set y(value) {\n        this._position.y = value;\n    }\n    /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */ get position() {\n        return this._position;\n    }\n    set position(value) {\n        this._position.copyFrom(value);\n    }\n    /**\n   * The rotation of the object in radians.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */ get rotation() {\n        return this._rotation;\n    }\n    set rotation(value) {\n        if (this._rotation !== value) {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n    /**\n   * The angle of the object in degrees.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */ get angle() {\n        return this.rotation * (0, $aWW4e.RAD_TO_DEG);\n    }\n    set angle(value) {\n        this.rotation = value * (0, $aWW4e.DEG_TO_RAD);\n    }\n    /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent's local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */ get pivot() {\n        if (this._pivot === $8a2b4ed6f59ce4dc$var$defaultPivot) this._pivot = new (0, $a32F4.ObservablePoint)(this, 0, 0);\n        return this._pivot;\n    }\n    set pivot(value) {\n        if (this._pivot === $8a2b4ed6f59ce4dc$var$defaultPivot) this._pivot = new (0, $a32F4.ObservablePoint)(this, 0, 0);\n        typeof value === \"number\" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n    /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */ get skew() {\n        if (this._skew === $8a2b4ed6f59ce4dc$var$defaultSkew) this._skew = new (0, $a32F4.ObservablePoint)(this, 0, 0);\n        return this._skew;\n    }\n    set skew(value) {\n        if (this._skew === $8a2b4ed6f59ce4dc$var$defaultSkew) this._skew = new (0, $a32F4.ObservablePoint)(this, 0, 0);\n        this._skew.copyFrom(value);\n    }\n    /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */ get scale() {\n        if (this._scale === $8a2b4ed6f59ce4dc$var$defaultScale) this._scale = new (0, $a32F4.ObservablePoint)(this, 1, 1);\n        return this._scale;\n    }\n    set scale(value) {\n        if (this._scale === $8a2b4ed6f59ce4dc$var$defaultScale) this._scale = new (0, $a32F4.ObservablePoint)(this, 0, 0);\n        typeof value === \"number\" ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n    /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */ get width() {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n    set width(value) {\n        const localWidth = this.getLocalBounds().width;\n        this._setWidth(value, localWidth);\n    }\n    /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */ get height() {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n    set height(value) {\n        const localHeight = this.getLocalBounds().height;\n        this._setHeight(value, localHeight);\n    }\n    /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */ getSize(out) {\n        if (!out) out = {};\n        const bounds = this.getLocalBounds();\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n        return out;\n    }\n    /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */ setSize(value, height) {\n        const size = this.getLocalBounds();\n        let convertedWidth;\n        let convertedHeight;\n        if (typeof value !== \"object\") {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        } else {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n        if (convertedWidth !== void 0) this._setWidth(convertedWidth, size.width);\n        if (convertedHeight !== void 0) this._setHeight(convertedHeight, size.height);\n    }\n    /** Called when the skew or the rotation changes. */ _updateSkew() {\n        const rotation = this._rotation;\n        const skew = this._skew;\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x);\n        this._sy = Math.cos(rotation - skew._x);\n    }\n    /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */ updateTransform(opts) {\n        this.position.set(typeof opts.x === \"number\" ? opts.x : this.position.x, typeof opts.y === \"number\" ? opts.y : this.position.y);\n        this.scale.set(typeof opts.scaleX === \"number\" ? opts.scaleX || 1 : this.scale.x, typeof opts.scaleY === \"number\" ? opts.scaleY || 1 : this.scale.y);\n        this.rotation = typeof opts.rotation === \"number\" ? opts.rotation : this.rotation;\n        this.skew.set(typeof opts.skewX === \"number\" ? opts.skewX : this.skew.x, typeof opts.skewY === \"number\" ? opts.skewY : this.skew.y);\n        this.pivot.set(typeof opts.pivotX === \"number\" ? opts.pivotX : this.pivot.x, typeof opts.pivotY === \"number\" ? opts.pivotY : this.pivot.y);\n        return this;\n    }\n    /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */ setFromMatrix(matrix) {\n        matrix.decompose(this);\n    }\n    /** Updates the local transform. */ updateLocalTransform() {\n        if ((this._didLocalTransformChangeId & 15) === this._didChangeId) return;\n        this._didLocalTransformChangeId = this._didChangeId;\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const position = this._position;\n        const sx = scale._x;\n        const sy = scale._y;\n        const px = pivot._x;\n        const py = pivot._y;\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n        lt.tx = position._x - (px * lt.a + py * lt.c);\n        lt.ty = position._y - (px * lt.b + py * lt.d);\n    }\n    // / ///// color related stuff\n    set alpha(value) {\n        if (value === this.localAlpha) return;\n        this.localAlpha = value;\n        this._updateFlags |= $8a2b4ed6f59ce4dc$export$f8ede8d8bf091ab5;\n        this._onUpdate();\n    }\n    /** The opacity of the object. */ get alpha() {\n        return this.localAlpha;\n    }\n    set tint(value) {\n        const tempColor = (0, $a2eTA.Color).shared.setValue(value ?? 16777215);\n        const bgr = tempColor.toBgrNumber();\n        if (bgr === this.localColor) return;\n        this.localColor = bgr;\n        this._updateFlags |= $8a2b4ed6f59ce4dc$export$f8ede8d8bf091ab5;\n        this._onUpdate();\n    }\n    /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */ get tint() {\n        const bgr = this.localColor;\n        return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);\n    }\n    // / //////////////// blend related stuff\n    set blendMode(value) {\n        if (this.localBlendMode === value) return;\n        if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n        this._updateFlags |= $8a2b4ed6f59ce4dc$export$e4801e7edc7582f;\n        this.localBlendMode = value;\n        this._onUpdate();\n    }\n    /**\n   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n   * @default 'normal'\n   */ get blendMode() {\n        return this.localBlendMode;\n    }\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n    /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */ get visible() {\n        return !!(this.localDisplayStatus & 2);\n    }\n    set visible(value) {\n        const valueNumber = value ? 1 : 0;\n        if ((this.localDisplayStatus & 2) >> 1 === valueNumber) return;\n        if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n        this._updateFlags |= $8a2b4ed6f59ce4dc$export$83db162b74637ea;\n        this.localDisplayStatus ^= 2;\n        this._onUpdate();\n    }\n    /** @ignore */ get culled() {\n        return !(this.localDisplayStatus & 4);\n    }\n    /** @ignore */ set culled(value) {\n        const valueNumber = value ? 1 : 0;\n        if ((this.localDisplayStatus & 4) >> 2 === valueNumber) return;\n        if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n        this._updateFlags |= $8a2b4ed6f59ce4dc$export$83db162b74637ea;\n        this.localDisplayStatus ^= 4;\n        this._onUpdate();\n    }\n    /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */ get renderable() {\n        return !!(this.localDisplayStatus & 1);\n    }\n    set renderable(value) {\n        const valueNumber = value ? 1 : 0;\n        if ((this.localDisplayStatus & 1) === valueNumber) return;\n        this._updateFlags |= $8a2b4ed6f59ce4dc$export$83db162b74637ea;\n        this.localDisplayStatus ^= 1;\n        if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n        this._onUpdate();\n    }\n    /** Whether or not the object should be rendered. */ get isRenderable() {\n        return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n    }\n    /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */ destroy(options = false) {\n        if (this.destroyed) return;\n        this.destroyed = true;\n        this.removeFromParent();\n        this.parent = null;\n        this._mask = null;\n        this._filters = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._skew = null;\n        this.emit(\"destroyed\", this);\n        this.removeAllListeners();\n        const destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n        const oldChildren = this.removeChildren(0, this.children.length);\n        if (destroyChildren) for(let i = 0; i < oldChildren.length; ++i)oldChildren[i].destroy(options);\n    }\n}\n$8a2b4ed6f59ce4dc$export$42a852a2b6b56249.mixin((0, $236jP.childrenHelperMixin));\n$8a2b4ed6f59ce4dc$export$42a852a2b6b56249.mixin((0, $g5iYs.toLocalGlobalMixin));\n$8a2b4ed6f59ce4dc$export$42a852a2b6b56249.mixin((0, $ggvKl.onRenderMixin));\n$8a2b4ed6f59ce4dc$export$42a852a2b6b56249.mixin((0, $kEqoj.measureMixin));\n$8a2b4ed6f59ce4dc$export$42a852a2b6b56249.mixin((0, $apXS2.effectsMixin));\n$8a2b4ed6f59ce4dc$export$42a852a2b6b56249.mixin((0, $kkVML.findMixin));\n$8a2b4ed6f59ce4dc$export$42a852a2b6b56249.mixin((0, $82jXu.sortMixin));\n$8a2b4ed6f59ce4dc$export$42a852a2b6b56249.mixin((0, $j1i7q.cullingMixin));\n\n});\nparcelRegister(\"a2eTA\", function(module, exports) {\n\n$parcel$export(module.exports, \"Color\", () => $f6a94f8017837c10$export$892596cec99bc70e);\n\nvar $erZA3 = parcelRequire(\"erZA3\");\n\nvar $lCM3s = parcelRequire(\"lCM3s\");\n\"use strict\";\n(0, $erZA3.extend)([\n    (0, $lCM3s.default)\n]);\nconst $f6a94f8017837c10$var$_Color = class _Color {\n    /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */ constructor(value = 16777215){\n        this._value = null;\n        this._components = new Float32Array(4);\n        this._components.fill(1);\n        this._int = 16777215;\n        this.value = value;\n    }\n    /** Get red component (0 - 1) */ get red() {\n        return this._components[0];\n    }\n    /** Get green component (0 - 1) */ get green() {\n        return this._components[1];\n    }\n    /** Get blue component (0 - 1) */ get blue() {\n        return this._components[2];\n    }\n    /** Get alpha component (0 - 1) */ get alpha() {\n        return this._components[3];\n    }\n    /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */ setValue(value) {\n        this.value = value;\n        return this;\n    }\n    /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */ set value(value) {\n        if (value instanceof _Color) {\n            this._value = this._cloneSource(value._value);\n            this._int = value._int;\n            this._components.set(value._components);\n        } else if (value === null) throw new Error(\"Cannot set Color#value to null\");\n        else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n            this._normalize(value);\n            this._value = this._cloneSource(value);\n        }\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */ _cloneSource(value) {\n        if (typeof value === \"string\" || typeof value === \"number\" || value instanceof Number || value === null) return value;\n        else if (Array.isArray(value) || ArrayBuffer.isView(value)) return value.slice(0);\n        else if (typeof value === \"object\" && value !== null) return {\n            ...value\n        };\n        return value;\n    }\n    /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */ _isSourceEqual(value1, value2) {\n        const type1 = typeof value1;\n        const type2 = typeof value2;\n        if (type1 !== type2) return false;\n        else if (type1 === \"number\" || type1 === \"string\" || value1 instanceof Number) return value1 === value2;\n        else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n            if (value1.length !== value2.length) return false;\n            return value1.every((v, i)=>v === value2[i]);\n        } else if (value1 !== null && value2 !== null) {\n            const keys1 = Object.keys(value1);\n            const keys2 = Object.keys(value2);\n            if (keys1.length !== keys2.length) return false;\n            return keys1.every((key)=>value1[key] === value2[key]);\n        }\n        return value1 === value2;\n    }\n    /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */ toRgba() {\n        const [r, g, b, a] = this._components;\n        return {\n            r: r,\n            g: g,\n            b: b,\n            a: a\n        };\n    }\n    /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */ toRgb() {\n        const [r, g, b] = this._components;\n        return {\n            r: r,\n            g: g,\n            b: b\n        };\n    }\n    /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */ toRgbaString() {\n        const [r, g, b] = this.toUint8RgbArray();\n        return `rgba(${r},${g},${b},${this.alpha})`;\n    }\n    toUint8RgbArray(out) {\n        const [r, g, b] = this._components;\n        if (!this._arrayRgb) this._arrayRgb = [];\n        out = out || this._arrayRgb;\n        out[0] = Math.round(r * 255);\n        out[1] = Math.round(g * 255);\n        out[2] = Math.round(b * 255);\n        return out;\n    }\n    toArray(out) {\n        if (!this._arrayRgba) this._arrayRgba = [];\n        out = out || this._arrayRgba;\n        const [r, g, b, a] = this._components;\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n        return out;\n    }\n    toRgbArray(out) {\n        if (!this._arrayRgb) this._arrayRgb = [];\n        out = out || this._arrayRgb;\n        const [r, g, b] = this._components;\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        return out;\n    }\n    /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toNumber(); // returns 16777215\n   */ toNumber() {\n        return this._int;\n    }\n    /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */ toBgrNumber() {\n        const [r, g, b] = this.toUint8RgbArray();\n        return (b << 16) + (g << 8) + r;\n    }\n    /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */ toLittleEndianNumber() {\n        const value = this._int;\n        return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n    }\n    /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */ multiply(value) {\n        const [r, g, b, a] = _Color._temp.setValue(value)._components;\n        this._components[0] *= r;\n        this._components[1] *= g;\n        this._components[2] *= b;\n        this._components[3] *= a;\n        this._refreshInt();\n        this._value = null;\n        return this;\n    }\n    /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */ premultiply(alpha, applyToRGB = true) {\n        if (applyToRGB) {\n            this._components[0] *= alpha;\n            this._components[1] *= alpha;\n            this._components[2] *= alpha;\n        }\n        this._components[3] = alpha;\n        this._refreshInt();\n        this._value = null;\n        return this;\n    }\n    /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */ toPremultiplied(alpha, applyToRGB = true) {\n        if (alpha === 1) return -16777216 + this._int;\n        if (alpha === 0) return applyToRGB ? 0 : this._int;\n        let r = this._int >> 16 & 255;\n        let g = this._int >> 8 & 255;\n        let b = this._int & 255;\n        if (applyToRGB) {\n            r = r * alpha + 0.5 | 0;\n            g = g * alpha + 0.5 | 0;\n            b = b * alpha + 0.5 | 0;\n        }\n        return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n    }\n    /**\n   * Convert to a hexidecimal string.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHex(); // returns \"#ffffff\"\n   */ toHex() {\n        const hexString = this._int.toString(16);\n        return `#${\"000000\".substring(0, 6 - hexString.length) + hexString}`;\n    }\n    /**\n   * Convert to a hexidecimal string with alpha.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHexa(); // returns \"#ffffffff\"\n   */ toHexa() {\n        const alphaValue = Math.round(this._components[3] * 255);\n        const alphaString = alphaValue.toString(16);\n        return this.toHex() + \"00\".substring(0, 2 - alphaString.length) + alphaString;\n    }\n    /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */ setAlpha(alpha) {\n        this._components[3] = this._clamp(alpha);\n        return this;\n    }\n    /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */ _normalize(value) {\n        let r;\n        let g;\n        let b;\n        let a;\n        if ((typeof value === \"number\" || value instanceof Number) && value >= 0 && value <= 16777215) {\n            const int = value;\n            r = (int >> 16 & 255) / 255;\n            g = (int >> 8 & 255) / 255;\n            b = (int & 255) / 255;\n            a = 1;\n        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n            value = this._clamp(value);\n            [r, g, b, a = 1] = value;\n        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n            value = this._clamp(value, 0, 255);\n            [r, g, b, a = 255] = value;\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            a /= 255;\n        } else if (typeof value === \"string\" || typeof value === \"object\") {\n            if (typeof value === \"string\") {\n                const match = _Color.HEX_PATTERN.exec(value);\n                if (match) value = `#${match[2]}`;\n            }\n            const color = (0, $erZA3.colord)(value);\n            if (color.isValid()) {\n                ({ r: r, g: g, b: b, a: a } = color.rgba);\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n        }\n        if (r !== void 0) {\n            this._components[0] = r;\n            this._components[1] = g;\n            this._components[2] = b;\n            this._components[3] = a;\n            this._refreshInt();\n        } else throw new Error(`Unable to convert color ${value}`);\n    }\n    /** Refresh the internal color rgb number */ _refreshInt() {\n        this._clamp(this._components);\n        const [r, g, b] = this._components;\n        this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n    }\n    /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */ _clamp(value, min = 0, max = 1) {\n        if (typeof value === \"number\") return Math.min(Math.max(value, min), max);\n        value.forEach((v, i)=>{\n            value[i] = Math.min(Math.max(v, min), max);\n        });\n        return value;\n    }\n    /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from 'pixi.js';\n   * Color.isColorLike('white'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */ static isColorLike(value) {\n        return typeof value === \"number\" || typeof value === \"string\" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n    }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from 'pixi.js';\n * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n */ $f6a94f8017837c10$var$_Color.shared = new $f6a94f8017837c10$var$_Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */ $f6a94f8017837c10$var$_Color._temp = new $f6a94f8017837c10$var$_Color();\n/** Pattern for hex strings */ // eslint-disable-next-line @typescript-eslint/naming-convention\n$f6a94f8017837c10$var$_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet $f6a94f8017837c10$export$892596cec99bc70e = $f6a94f8017837c10$var$_Color;\n\n});\nparcelRegister(\"erZA3\", function(module, exports) {\n\n$parcel$export(module.exports, \"colord\", () => $482ad42e73ee00b6$export$c8efe09109f9cb9e);\n$parcel$export(module.exports, \"extend\", () => $482ad42e73ee00b6$export$8b58be045bf06082);\nvar $482ad42e73ee00b6$var$r = {\n    grad: .9,\n    turn: 360,\n    rad: 360 / (2 * Math.PI)\n}, $482ad42e73ee00b6$var$t = function(r) {\n    return \"string\" == typeof r ? r.length > 0 : \"number\" == typeof r;\n}, $482ad42e73ee00b6$var$n = function(r, t, n) {\n    return void 0 === t && (t = 0), void 0 === n && (n = Math.pow(10, t)), Math.round(n * r) / n + 0;\n}, $482ad42e73ee00b6$var$e = function(r, t, n) {\n    return void 0 === t && (t = 0), void 0 === n && (n = 1), r > n ? n : r > t ? r : t;\n}, $482ad42e73ee00b6$var$u = function(r) {\n    return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360;\n}, $482ad42e73ee00b6$var$a = function(r) {\n    return {\n        r: $482ad42e73ee00b6$var$e(r.r, 0, 255),\n        g: $482ad42e73ee00b6$var$e(r.g, 0, 255),\n        b: $482ad42e73ee00b6$var$e(r.b, 0, 255),\n        a: $482ad42e73ee00b6$var$e(r.a)\n    };\n}, $482ad42e73ee00b6$var$o = function(r) {\n    return {\n        r: $482ad42e73ee00b6$var$n(r.r),\n        g: $482ad42e73ee00b6$var$n(r.g),\n        b: $482ad42e73ee00b6$var$n(r.b),\n        a: $482ad42e73ee00b6$var$n(r.a, 3)\n    };\n}, $482ad42e73ee00b6$var$i = /^#([0-9a-f]{3,8})$/i, $482ad42e73ee00b6$var$s = function(r) {\n    var t = r.toString(16);\n    return t.length < 2 ? \"0\" + t : t;\n}, $482ad42e73ee00b6$var$h = function(r) {\n    var t = r.r, n = r.g, e = r.b, u = r.a, a = Math.max(t, n, e), o = a - Math.min(t, n, e), i = o ? a === t ? (n - e) / o : a === n ? 2 + (e - t) / o : 4 + (t - n) / o : 0;\n    return {\n        h: 60 * (i < 0 ? i + 6 : i),\n        s: a ? o / a * 100 : 0,\n        v: a / 255 * 100,\n        a: u\n    };\n}, $482ad42e73ee00b6$var$b = function(r) {\n    var t = r.h, n = r.s, e = r.v, u = r.a;\n    t = t / 360 * 6, n /= 100, e /= 100;\n    var a = Math.floor(t), o = e * (1 - n), i = e * (1 - (t - a) * n), s = e * (1 - (1 - t + a) * n), h = a % 6;\n    return {\n        r: 255 * [\n            e,\n            i,\n            o,\n            o,\n            s,\n            e\n        ][h],\n        g: 255 * [\n            s,\n            e,\n            e,\n            i,\n            o,\n            o\n        ][h],\n        b: 255 * [\n            o,\n            o,\n            s,\n            e,\n            e,\n            i\n        ][h],\n        a: u\n    };\n}, $482ad42e73ee00b6$var$g = function(r) {\n    return {\n        h: $482ad42e73ee00b6$var$u(r.h),\n        s: $482ad42e73ee00b6$var$e(r.s, 0, 100),\n        l: $482ad42e73ee00b6$var$e(r.l, 0, 100),\n        a: $482ad42e73ee00b6$var$e(r.a)\n    };\n}, $482ad42e73ee00b6$var$d = function(r) {\n    return {\n        h: $482ad42e73ee00b6$var$n(r.h),\n        s: $482ad42e73ee00b6$var$n(r.s),\n        l: $482ad42e73ee00b6$var$n(r.l),\n        a: $482ad42e73ee00b6$var$n(r.a, 3)\n    };\n}, $482ad42e73ee00b6$var$f = function(r) {\n    var t, n, e;\n    return $482ad42e73ee00b6$var$b((n = (t = r).s, {\n        h: t.h,\n        s: (n *= ((e = t.l) < 50 ? e : 100 - e) / 100) > 0 ? 2 * n / (e + n) * 100 : 0,\n        v: e + n,\n        a: t.a\n    }));\n}, $482ad42e73ee00b6$var$c = function(r) {\n    var t, n, e, u;\n    return {\n        h: (t = $482ad42e73ee00b6$var$h(r)).h,\n        s: (u = (200 - (n = t.s)) * (e = t.v) / 100) > 0 && u < 200 ? n * e / 100 / (u <= 100 ? u : 200 - u) * 100 : 0,\n        l: u / 2,\n        a: t.a\n    };\n}, $482ad42e73ee00b6$var$l = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $482ad42e73ee00b6$var$p = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $482ad42e73ee00b6$var$v = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $482ad42e73ee00b6$var$m = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $482ad42e73ee00b6$var$y = {\n    string: [\n        [\n            function(r) {\n                var t = $482ad42e73ee00b6$var$i.exec(r);\n                return t ? (r = t[1]).length <= 4 ? {\n                    r: parseInt(r[0] + r[0], 16),\n                    g: parseInt(r[1] + r[1], 16),\n                    b: parseInt(r[2] + r[2], 16),\n                    a: 4 === r.length ? $482ad42e73ee00b6$var$n(parseInt(r[3] + r[3], 16) / 255, 2) : 1\n                } : 6 === r.length || 8 === r.length ? {\n                    r: parseInt(r.substr(0, 2), 16),\n                    g: parseInt(r.substr(2, 2), 16),\n                    b: parseInt(r.substr(4, 2), 16),\n                    a: 8 === r.length ? $482ad42e73ee00b6$var$n(parseInt(r.substr(6, 2), 16) / 255, 2) : 1\n                } : null : null;\n            },\n            \"hex\"\n        ],\n        [\n            function(r) {\n                var t = $482ad42e73ee00b6$var$v.exec(r) || $482ad42e73ee00b6$var$m.exec(r);\n                return t ? t[2] !== t[4] || t[4] !== t[6] ? null : $482ad42e73ee00b6$var$a({\n                    r: Number(t[1]) / (t[2] ? 100 / 255 : 1),\n                    g: Number(t[3]) / (t[4] ? 100 / 255 : 1),\n                    b: Number(t[5]) / (t[6] ? 100 / 255 : 1),\n                    a: void 0 === t[7] ? 1 : Number(t[7]) / (t[8] ? 100 : 1)\n                }) : null;\n            },\n            \"rgb\"\n        ],\n        [\n            function(t) {\n                var n = $482ad42e73ee00b6$var$l.exec(t) || $482ad42e73ee00b6$var$p.exec(t);\n                if (!n) return null;\n                var e, u, a = $482ad42e73ee00b6$var$g({\n                    h: (e = n[1], u = n[2], void 0 === u && (u = \"deg\"), Number(e) * ($482ad42e73ee00b6$var$r[u] || 1)),\n                    s: Number(n[3]),\n                    l: Number(n[4]),\n                    a: void 0 === n[5] ? 1 : Number(n[5]) / (n[6] ? 100 : 1)\n                });\n                return $482ad42e73ee00b6$var$f(a);\n            },\n            \"hsl\"\n        ]\n    ],\n    object: [\n        [\n            function(r) {\n                var n = r.r, e = r.g, u = r.b, o = r.a, i = void 0 === o ? 1 : o;\n                return $482ad42e73ee00b6$var$t(n) && $482ad42e73ee00b6$var$t(e) && $482ad42e73ee00b6$var$t(u) ? $482ad42e73ee00b6$var$a({\n                    r: Number(n),\n                    g: Number(e),\n                    b: Number(u),\n                    a: Number(i)\n                }) : null;\n            },\n            \"rgb\"\n        ],\n        [\n            function(r) {\n                var n = r.h, e = r.s, u = r.l, a = r.a, o = void 0 === a ? 1 : a;\n                if (!$482ad42e73ee00b6$var$t(n) || !$482ad42e73ee00b6$var$t(e) || !$482ad42e73ee00b6$var$t(u)) return null;\n                var i = $482ad42e73ee00b6$var$g({\n                    h: Number(n),\n                    s: Number(e),\n                    l: Number(u),\n                    a: Number(o)\n                });\n                return $482ad42e73ee00b6$var$f(i);\n            },\n            \"hsl\"\n        ],\n        [\n            function(r) {\n                var n = r.h, a = r.s, o = r.v, i = r.a, s = void 0 === i ? 1 : i;\n                if (!$482ad42e73ee00b6$var$t(n) || !$482ad42e73ee00b6$var$t(a) || !$482ad42e73ee00b6$var$t(o)) return null;\n                var h = function(r) {\n                    return {\n                        h: $482ad42e73ee00b6$var$u(r.h),\n                        s: $482ad42e73ee00b6$var$e(r.s, 0, 100),\n                        v: $482ad42e73ee00b6$var$e(r.v, 0, 100),\n                        a: $482ad42e73ee00b6$var$e(r.a)\n                    };\n                }({\n                    h: Number(n),\n                    s: Number(a),\n                    v: Number(o),\n                    a: Number(s)\n                });\n                return $482ad42e73ee00b6$var$b(h);\n            },\n            \"hsv\"\n        ]\n    ]\n}, $482ad42e73ee00b6$var$N = function(r, t) {\n    for(var n = 0; n < t.length; n++){\n        var e = t[n][0](r);\n        if (e) return [\n            e,\n            t[n][1]\n        ];\n    }\n    return [\n        null,\n        void 0\n    ];\n}, $482ad42e73ee00b6$var$x = function(r) {\n    return \"string\" == typeof r ? $482ad42e73ee00b6$var$N(r.trim(), $482ad42e73ee00b6$var$y.string) : \"object\" == typeof r && null !== r ? $482ad42e73ee00b6$var$N(r, $482ad42e73ee00b6$var$y.object) : [\n        null,\n        void 0\n    ];\n}, $482ad42e73ee00b6$export$f61ac8b6f1f46202 = function(r) {\n    return $482ad42e73ee00b6$var$x(r)[1];\n}, $482ad42e73ee00b6$var$M = function(r, t) {\n    var n = $482ad42e73ee00b6$var$c(r);\n    return {\n        h: n.h,\n        s: $482ad42e73ee00b6$var$e(n.s + 100 * t, 0, 100),\n        l: n.l,\n        a: n.a\n    };\n}, $482ad42e73ee00b6$var$H = function(r) {\n    return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255;\n}, $482ad42e73ee00b6$var$$ = function(r, t) {\n    var n = $482ad42e73ee00b6$var$c(r);\n    return {\n        h: n.h,\n        s: n.s,\n        l: $482ad42e73ee00b6$var$e(n.l + 100 * t, 0, 100),\n        a: n.a\n    };\n}, $482ad42e73ee00b6$export$4d30ed660ff08d0 = function() {\n    function r(r) {\n        this.parsed = $482ad42e73ee00b6$var$x(r)[0], this.rgba = this.parsed || {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        };\n    }\n    return r.prototype.isValid = function() {\n        return null !== this.parsed;\n    }, r.prototype.brightness = function() {\n        return $482ad42e73ee00b6$var$n($482ad42e73ee00b6$var$H(this.rgba), 2);\n    }, r.prototype.isDark = function() {\n        return $482ad42e73ee00b6$var$H(this.rgba) < .5;\n    }, r.prototype.isLight = function() {\n        return $482ad42e73ee00b6$var$H(this.rgba) >= .5;\n    }, r.prototype.toHex = function() {\n        var r, t, e, u, a, i;\n        return r = $482ad42e73ee00b6$var$o(this.rgba), t = r.r, e = r.g, u = r.b, i = (a = r.a) < 1 ? $482ad42e73ee00b6$var$s($482ad42e73ee00b6$var$n(255 * a)) : \"\", \"#\" + $482ad42e73ee00b6$var$s(t) + $482ad42e73ee00b6$var$s(e) + $482ad42e73ee00b6$var$s(u) + i;\n    }, r.prototype.toRgb = function() {\n        return $482ad42e73ee00b6$var$o(this.rgba);\n    }, r.prototype.toRgbString = function() {\n        var r, t, n, e, u;\n        return r = $482ad42e73ee00b6$var$o(this.rgba), t = r.r, n = r.g, e = r.b, (u = r.a) < 1 ? \"rgba(\" + t + \", \" + n + \", \" + e + \", \" + u + \")\" : \"rgb(\" + t + \", \" + n + \", \" + e + \")\";\n    }, r.prototype.toHsl = function() {\n        return $482ad42e73ee00b6$var$d($482ad42e73ee00b6$var$c(this.rgba));\n    }, r.prototype.toHslString = function() {\n        var r, t, n, e, u;\n        return r = $482ad42e73ee00b6$var$d($482ad42e73ee00b6$var$c(this.rgba)), t = r.h, n = r.s, e = r.l, (u = r.a) < 1 ? \"hsla(\" + t + \", \" + n + \"%, \" + e + \"%, \" + u + \")\" : \"hsl(\" + t + \", \" + n + \"%, \" + e + \"%)\";\n    }, r.prototype.toHsv = function() {\n        var r;\n        return r = $482ad42e73ee00b6$var$h(this.rgba), {\n            h: $482ad42e73ee00b6$var$n(r.h),\n            s: $482ad42e73ee00b6$var$n(r.s),\n            v: $482ad42e73ee00b6$var$n(r.v),\n            a: $482ad42e73ee00b6$var$n(r.a, 3)\n        };\n    }, r.prototype.invert = function() {\n        var r;\n        return $482ad42e73ee00b6$export$c8efe09109f9cb9e({\n            r: 255 - (r = this.rgba).r,\n            g: 255 - r.g,\n            b: 255 - r.b,\n            a: r.a\n        });\n    }, r.prototype.saturate = function(r) {\n        return void 0 === r && (r = .1), $482ad42e73ee00b6$export$c8efe09109f9cb9e($482ad42e73ee00b6$var$M(this.rgba, r));\n    }, r.prototype.desaturate = function(r) {\n        return void 0 === r && (r = .1), $482ad42e73ee00b6$export$c8efe09109f9cb9e($482ad42e73ee00b6$var$M(this.rgba, -r));\n    }, r.prototype.grayscale = function() {\n        return $482ad42e73ee00b6$export$c8efe09109f9cb9e($482ad42e73ee00b6$var$M(this.rgba, -1));\n    }, r.prototype.lighten = function(r) {\n        return void 0 === r && (r = .1), $482ad42e73ee00b6$export$c8efe09109f9cb9e($482ad42e73ee00b6$var$$(this.rgba, r));\n    }, r.prototype.darken = function(r) {\n        return void 0 === r && (r = .1), $482ad42e73ee00b6$export$c8efe09109f9cb9e($482ad42e73ee00b6$var$$(this.rgba, -r));\n    }, r.prototype.rotate = function(r) {\n        return void 0 === r && (r = 15), this.hue(this.hue() + r);\n    }, r.prototype.alpha = function(r) {\n        var t;\n        return \"number\" == typeof r ? $482ad42e73ee00b6$export$c8efe09109f9cb9e({\n            r: (t = this.rgba).r,\n            g: t.g,\n            b: t.b,\n            a: r\n        }) : $482ad42e73ee00b6$var$n(this.rgba.a, 3);\n    }, r.prototype.hue = function(r) {\n        var t = $482ad42e73ee00b6$var$c(this.rgba);\n        return \"number\" == typeof r ? $482ad42e73ee00b6$export$c8efe09109f9cb9e({\n            h: r,\n            s: t.s,\n            l: t.l,\n            a: t.a\n        }) : $482ad42e73ee00b6$var$n(t.h);\n    }, r.prototype.isEqual = function(r) {\n        return this.toHex() === $482ad42e73ee00b6$export$c8efe09109f9cb9e(r).toHex();\n    }, r;\n}(), $482ad42e73ee00b6$export$c8efe09109f9cb9e = function(r) {\n    return r instanceof $482ad42e73ee00b6$export$4d30ed660ff08d0 ? r : new $482ad42e73ee00b6$export$4d30ed660ff08d0(r);\n}, $482ad42e73ee00b6$var$S = [], $482ad42e73ee00b6$export$8b58be045bf06082 = function(r) {\n    r.forEach(function(r) {\n        $482ad42e73ee00b6$var$S.indexOf(r) < 0 && (r($482ad42e73ee00b6$export$4d30ed660ff08d0, $482ad42e73ee00b6$var$y), $482ad42e73ee00b6$var$S.push(r));\n    });\n}, $482ad42e73ee00b6$export$4385e60b38654f68 = function() {\n    return new $482ad42e73ee00b6$export$4d30ed660ff08d0({\n        r: 255 * Math.random(),\n        g: 255 * Math.random(),\n        b: 255 * Math.random()\n    });\n};\n\n});\n\nparcelRegister(\"lCM3s\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $4bf1f6e6e10c0717$export$2e2bcd8739ae039);\nfunction $4bf1f6e6e10c0717$export$2e2bcd8739ae039(e, f) {\n    var a = {\n        white: \"#ffffff\",\n        bisque: \"#ffe4c4\",\n        blue: \"#0000ff\",\n        cadetblue: \"#5f9ea0\",\n        chartreuse: \"#7fff00\",\n        chocolate: \"#d2691e\",\n        coral: \"#ff7f50\",\n        antiquewhite: \"#faebd7\",\n        aqua: \"#00ffff\",\n        azure: \"#f0ffff\",\n        whitesmoke: \"#f5f5f5\",\n        papayawhip: \"#ffefd5\",\n        plum: \"#dda0dd\",\n        blanchedalmond: \"#ffebcd\",\n        black: \"#000000\",\n        gold: \"#ffd700\",\n        goldenrod: \"#daa520\",\n        gainsboro: \"#dcdcdc\",\n        cornsilk: \"#fff8dc\",\n        cornflowerblue: \"#6495ed\",\n        burlywood: \"#deb887\",\n        aquamarine: \"#7fffd4\",\n        beige: \"#f5f5dc\",\n        crimson: \"#dc143c\",\n        cyan: \"#00ffff\",\n        darkblue: \"#00008b\",\n        darkcyan: \"#008b8b\",\n        darkgoldenrod: \"#b8860b\",\n        darkkhaki: \"#bdb76b\",\n        darkgray: \"#a9a9a9\",\n        darkgreen: \"#006400\",\n        darkgrey: \"#a9a9a9\",\n        peachpuff: \"#ffdab9\",\n        darkmagenta: \"#8b008b\",\n        darkred: \"#8b0000\",\n        darkorchid: \"#9932cc\",\n        darkorange: \"#ff8c00\",\n        darkslateblue: \"#483d8b\",\n        gray: \"#808080\",\n        darkslategray: \"#2f4f4f\",\n        darkslategrey: \"#2f4f4f\",\n        deeppink: \"#ff1493\",\n        deepskyblue: \"#00bfff\",\n        wheat: \"#f5deb3\",\n        firebrick: \"#b22222\",\n        floralwhite: \"#fffaf0\",\n        ghostwhite: \"#f8f8ff\",\n        darkviolet: \"#9400d3\",\n        magenta: \"#ff00ff\",\n        green: \"#008000\",\n        dodgerblue: \"#1e90ff\",\n        grey: \"#808080\",\n        honeydew: \"#f0fff0\",\n        hotpink: \"#ff69b4\",\n        blueviolet: \"#8a2be2\",\n        forestgreen: \"#228b22\",\n        lawngreen: \"#7cfc00\",\n        indianred: \"#cd5c5c\",\n        indigo: \"#4b0082\",\n        fuchsia: \"#ff00ff\",\n        brown: \"#a52a2a\",\n        maroon: \"#800000\",\n        mediumblue: \"#0000cd\",\n        lightcoral: \"#f08080\",\n        darkturquoise: \"#00ced1\",\n        lightcyan: \"#e0ffff\",\n        ivory: \"#fffff0\",\n        lightyellow: \"#ffffe0\",\n        lightsalmon: \"#ffa07a\",\n        lightseagreen: \"#20b2aa\",\n        linen: \"#faf0e6\",\n        mediumaquamarine: \"#66cdaa\",\n        lemonchiffon: \"#fffacd\",\n        lime: \"#00ff00\",\n        khaki: \"#f0e68c\",\n        mediumseagreen: \"#3cb371\",\n        limegreen: \"#32cd32\",\n        mediumspringgreen: \"#00fa9a\",\n        lightskyblue: \"#87cefa\",\n        lightblue: \"#add8e6\",\n        midnightblue: \"#191970\",\n        lightpink: \"#ffb6c1\",\n        mistyrose: \"#ffe4e1\",\n        moccasin: \"#ffe4b5\",\n        mintcream: \"#f5fffa\",\n        lightslategray: \"#778899\",\n        lightslategrey: \"#778899\",\n        navajowhite: \"#ffdead\",\n        navy: \"#000080\",\n        mediumvioletred: \"#c71585\",\n        powderblue: \"#b0e0e6\",\n        palegoldenrod: \"#eee8aa\",\n        oldlace: \"#fdf5e6\",\n        paleturquoise: \"#afeeee\",\n        mediumturquoise: \"#48d1cc\",\n        mediumorchid: \"#ba55d3\",\n        rebeccapurple: \"#663399\",\n        lightsteelblue: \"#b0c4de\",\n        mediumslateblue: \"#7b68ee\",\n        thistle: \"#d8bfd8\",\n        tan: \"#d2b48c\",\n        orchid: \"#da70d6\",\n        mediumpurple: \"#9370db\",\n        purple: \"#800080\",\n        pink: \"#ffc0cb\",\n        skyblue: \"#87ceeb\",\n        springgreen: \"#00ff7f\",\n        palegreen: \"#98fb98\",\n        red: \"#ff0000\",\n        yellow: \"#ffff00\",\n        slateblue: \"#6a5acd\",\n        lavenderblush: \"#fff0f5\",\n        peru: \"#cd853f\",\n        palevioletred: \"#db7093\",\n        violet: \"#ee82ee\",\n        teal: \"#008080\",\n        slategray: \"#708090\",\n        slategrey: \"#708090\",\n        aliceblue: \"#f0f8ff\",\n        darkseagreen: \"#8fbc8f\",\n        darkolivegreen: \"#556b2f\",\n        greenyellow: \"#adff2f\",\n        seagreen: \"#2e8b57\",\n        seashell: \"#fff5ee\",\n        tomato: \"#ff6347\",\n        silver: \"#c0c0c0\",\n        sienna: \"#a0522d\",\n        lavender: \"#e6e6fa\",\n        lightgreen: \"#90ee90\",\n        orange: \"#ffa500\",\n        orangered: \"#ff4500\",\n        steelblue: \"#4682b4\",\n        royalblue: \"#4169e1\",\n        turquoise: \"#40e0d0\",\n        yellowgreen: \"#9acd32\",\n        salmon: \"#fa8072\",\n        saddlebrown: \"#8b4513\",\n        sandybrown: \"#f4a460\",\n        rosybrown: \"#bc8f8f\",\n        darksalmon: \"#e9967a\",\n        lightgoldenrodyellow: \"#fafad2\",\n        snow: \"#fffafa\",\n        lightgrey: \"#d3d3d3\",\n        lightgray: \"#d3d3d3\",\n        dimgray: \"#696969\",\n        dimgrey: \"#696969\",\n        olivedrab: \"#6b8e23\",\n        olive: \"#808000\"\n    }, r = {};\n    for(var d in a)r[a[d]] = d;\n    var l = {};\n    e.prototype.toName = function(f) {\n        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return \"transparent\";\n        var d, i, n = r[this.toHex()];\n        if (n) return n;\n        if (null == f ? void 0 : f.closest) {\n            var o = this.toRgb(), t = 1 / 0, b = \"black\";\n            if (!l.length) for(var c in a)l[c] = new e(a[c]).toRgb();\n            for(var g in a){\n                var u = (d = o, i = l[g], Math.pow(d.r - i.r, 2) + Math.pow(d.g - i.g, 2) + Math.pow(d.b - i.b, 2));\n                u < t && (t = u, b = g);\n            }\n            return b;\n        }\n    };\n    f.string.push([\n        function(f) {\n            var r = f.toLowerCase(), d = \"transparent\" === r ? \"#0000\" : a[r];\n            return d ? new e(d).toRgb() : null;\n        },\n        \"name\"\n    ]);\n}\n\n});\n\n\nparcelRegister(\"j1i7q\", function(module, exports) {\n\n$parcel$export(module.exports, \"cullingMixin\", () => $b5b40e006e048a91$export$dce76d4f0fd249ed);\n\"use strict\";\nconst $b5b40e006e048a91$export$dce76d4f0fd249ed = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true\n};\n\n});\n\nparcelRegister(\"236jP\", function(module, exports) {\n\n$parcel$export(module.exports, \"childrenHelperMixin\", () => $0d8e0eeab3189cd3$export$64cca9f0c2df174a);\n\nvar $33PVi = parcelRequire(\"33PVi\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\"use strict\";\nconst $0d8e0eeab3189cd3$export$64cca9f0c2df174a = {\n    allowChildren: true,\n    /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */ removeChildren (beginIndex = 0, endIndex) {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed = [];\n        if (range > 0 && range <= end) {\n            for(let i = end - 1; i >= beginIndex; i--){\n                const child = this.children[i];\n                if (!child) continue;\n                if (this.renderGroup) this.renderGroup.removeChild(child);\n                removed.push(child);\n                child.parent = null;\n            }\n            (0, $33PVi.removeItems)(this.children, beginIndex, end);\n            for(let i = 0; i < removed.length; ++i){\n                this.emit(\"childRemoved\", removed[i], this, i);\n                removed[i].emit(\"removed\", this);\n            }\n            return removed;\n        } else if (range === 0 && this.children.length === 0) return removed;\n        throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n    },\n    /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */ removeChildAt (index) {\n        const child = this.getChildAt(index);\n        return this.removeChild(child);\n    },\n    /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */ getChildAt (index) {\n        if (index < 0 || index >= this.children.length) throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        return this.children[index];\n    },\n    /**\n   * Changes the position of an existing child in the container container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */ setChildIndex (child, index) {\n        if (index < 0 || index >= this.children.length) throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        this.getChildIndex(child);\n        this.addChildAt(child, index);\n    },\n    /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */ getChildIndex (child) {\n        const index = this.children.indexOf(child);\n        if (index === -1) throw new Error(\"The supplied Container must be a child of the caller\");\n        return index;\n    },\n    /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */ addChildAt (child, index) {\n        if (!this.allowChildren) (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"addChildAt: Only Containers will be allowed to add children in v8.0.0\");\n        const { children: children } = this;\n        if (index < 0 || index > children.length) throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        if (child.parent) {\n            const currentIndex = child.parent.children.indexOf(child);\n            if (child.parent === this && currentIndex === index) return child;\n            if (currentIndex !== -1) child.parent.children.splice(currentIndex, 1);\n        }\n        if (index === children.length) children.push(child);\n        else children.splice(index, 0, child);\n        child.parent = this;\n        child.didChange = true;\n        child.didViewUpdate = false;\n        child._updateFlags = 15;\n        if (this.renderGroup) this.renderGroup.addChild(child);\n        if (this.sortableChildren) this.sortDirty = true;\n        this.emit(\"childAdded\", child, this, index);\n        child.emit(\"added\", this);\n        return child;\n    },\n    /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   */ swapChildren (child, child2) {\n        if (child === child2) return;\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n        this.children[index1] = child2;\n        this.children[index2] = child;\n    },\n    /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */ removeFromParent () {\n        this.parent?.removeChild(this);\n    }\n};\n\n});\nparcelRegister(\"33PVi\", function(module, exports) {\n\n$parcel$export(module.exports, \"removeItems\", () => $cefc366e7023560b$export$8d47c0e1ce445404);\n\"use strict\";\nfunction $cefc366e7023560b$export$8d47c0e1ce445404(arr, startIdx, removeCount) {\n    const length = arr.length;\n    let i;\n    if (startIdx >= length || removeCount === 0) return;\n    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n    const len = length - removeCount;\n    for(i = startIdx; i < len; ++i)arr[i] = arr[i + removeCount];\n    arr.length = len;\n}\n\n});\n\n\nparcelRegister(\"apXS2\", function(module, exports) {\n\n$parcel$export(module.exports, \"effectsMixin\", () => $1d59e812d2000ae8$export$eec5e288a9d02a7c);\n\nvar $aWIPo = parcelRequire(\"aWIPo\");\n\nvar $dZmDL = parcelRequire(\"dZmDL\");\n\nvar $61KiY = parcelRequire(\"61KiY\");\n\"use strict\";\nconst $1d59e812d2000ae8$export$eec5e288a9d02a7c = {\n    _mask: null,\n    _filters: null,\n    /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */ effects: [],\n    /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */ addEffect (effect) {\n        const index = this.effects.indexOf(effect);\n        if (index !== -1) return;\n        this.effects.push(effect);\n        this.effects.sort((a, b)=>a.priority - b.priority);\n        if (this.renderGroup) this.renderGroup.structureDidChange = true;\n        this._updateIsSimple();\n    },\n    /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */ removeEffect (effect) {\n        const index = this.effects.indexOf(effect);\n        if (index === -1) return;\n        this.effects.splice(index, 1);\n        if (!this.isRenderGroupRoot && this.renderGroup) this.renderGroup.structureDidChange = true;\n        this._updateIsSimple();\n    },\n    set mask (value){\n        this._mask || (this._mask = {\n            mask: null,\n            effect: null\n        });\n        if (this._mask.mask === value) return;\n        if (this._mask.effect) {\n            this.removeEffect(this._mask.effect);\n            (0, $dZmDL.MaskEffectManager).returnMaskEffect(this._mask.effect);\n            this._mask.effect = null;\n        }\n        this._mask.mask = value;\n        if (value === null || value === void 0) return;\n        const effect = (0, $dZmDL.MaskEffectManager).getMaskEffect(value);\n        this._mask.effect = effect;\n        this.addEffect(effect);\n    },\n    /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */ get mask () {\n        return this._mask?.mask;\n    },\n    set filters (value){\n        if (!Array.isArray(value) && value) value = [\n            value\n        ];\n        value;\n        this._filters || (this._filters = {\n            filters: null,\n            effect: null,\n            filterArea: null\n        });\n        const hasFilters = value?.length > 0;\n        const didChange = this._filters.effect && !hasFilters || !this._filters.effect && hasFilters;\n        value = Array.isArray(value) ? value.slice(0) : value;\n        this._filters.filters = Object.freeze(value);\n        if (didChange) {\n            if (hasFilters) {\n                const effect = (0, $61KiY.BigPool).get((0, $aWIPo.FilterEffect));\n                this._filters.effect = effect;\n                this.addEffect(effect);\n            } else {\n                const effect = this._filters.effect;\n                this.removeEffect(effect);\n                effect.filterArea = null;\n                effect.filters = null;\n                this._filters.effect = null;\n                (0, $61KiY.BigPool).return(effect);\n            }\n        }\n        if (hasFilters) {\n            this._filters.effect.filters = value;\n            this._filters.effect.filterArea = this.filterArea;\n        }\n    },\n    /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */ get filters () {\n        return this._filters?.filters;\n    },\n    set filterArea (value){\n        this._filters || (this._filters = {\n            filters: null,\n            effect: null,\n            filterArea: null\n        });\n        this._filters.filterArea = value;\n    },\n    /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */ get filterArea () {\n        return this._filters?.filterArea;\n    }\n};\n\n});\nparcelRegister(\"aWIPo\", function(module, exports) {\n\n$parcel$export(module.exports, \"FilterEffect\", () => $573d66e12a5f4185$export$d66c06ffe23037ab);\n\"use strict\";\nclass $573d66e12a5f4185$export$d66c06ffe23037ab {\n    constructor(options){\n        this.pipe = \"filter\";\n        this.priority = 1;\n        this.filters = options?.filters;\n        this.filterArea = options?.filterArea;\n    }\n    destroy() {\n        for(let i = 0; i < this.filters.length; i++)this.filters[i].destroy();\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n\n});\n\nparcelRegister(\"dZmDL\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaskEffectManager\", () => $f40a37c299623cb8$export$1eb319167fe02d04);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $61KiY = parcelRequire(\"61KiY\");\n\"use strict\";\nclass $f40a37c299623cb8$export$3b0749bf144d4b29 {\n    constructor(){\n        /**\n     * @private\n     */ this._effectClasses = [];\n        this._tests = [];\n        this._initialized = false;\n    }\n    init() {\n        if (this._initialized) return;\n        this._initialized = true;\n        this._effectClasses.forEach((test)=>{\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n    add(test) {\n        this._tests.push(test);\n    }\n    getMaskEffect(item) {\n        if (!this._initialized) this.init();\n        for(let i = 0; i < this._tests.length; i++){\n            const test = this._tests[i];\n            if (test.test(item)) return (0, $61KiY.BigPool).get(test.maskClass, item);\n        }\n        return item;\n    }\n    returnMaskEffect(effect) {\n        (0, $61KiY.BigPool).return(effect);\n    }\n}\nconst $f40a37c299623cb8$export$1eb319167fe02d04 = new $f40a37c299623cb8$export$3b0749bf144d4b29();\n(0, $i9BKe.extensions).handleByList((0, $i9BKe.ExtensionType).MaskEffect, $f40a37c299623cb8$export$1eb319167fe02d04._effectClasses);\n\n});\nparcelRegister(\"61KiY\", function(module, exports) {\n\n$parcel$export(module.exports, \"BigPool\", () => $9483424e2013bba4$export$8249372279066210);\n\nvar $5Xsoh = parcelRequire(\"5Xsoh\");\n\"use strict\";\nclass $9483424e2013bba4$export$866836a21808b71c {\n    constructor(){\n        /**\n     * A map to store the pools by their class type.\n     * @private\n     */ this._poolsByClass = /* @__PURE__ */ new Map();\n    }\n    /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */ prepopulate(Class, total) {\n        const classPool = this.getPool(Class);\n        classPool.prepopulate(total);\n    }\n    /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */ get(Class, data) {\n        const pool = this.getPool(Class);\n        return pool.get(data);\n    }\n    /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */ return(item) {\n        const pool = this.getPool(item.constructor);\n        pool.return(item);\n    }\n    /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */ getPool(ClassType) {\n        if (!this._poolsByClass.has(ClassType)) this._poolsByClass.set(ClassType, new (0, $5Xsoh.Pool)(ClassType));\n        return this._poolsByClass.get(ClassType);\n    }\n    /** gets the usage stats of each pool in the system */ stats() {\n        const stats = {};\n        this._poolsByClass.forEach((pool)=>{\n            const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n            stats[name] = {\n                free: pool.totalFree,\n                used: pool.totalUsed,\n                size: pool.totalSize\n            };\n        });\n        return stats;\n    }\n}\nconst $9483424e2013bba4$export$8249372279066210 = new $9483424e2013bba4$export$866836a21808b71c();\n\n});\nparcelRegister(\"5Xsoh\", function(module, exports) {\n\n$parcel$export(module.exports, \"Pool\", () => $ce33839780b5f2f3$export$14963ee5c8637e11);\n\"use strict\";\nclass $ce33839780b5f2f3$export$14963ee5c8637e11 {\n    /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */ constructor(ClassType, initialSize){\n        this._pool = [];\n        this._count = 0;\n        this._index = 0;\n        this._classType = ClassType;\n        if (initialSize) this.prepopulate(initialSize);\n    }\n    /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */ prepopulate(total) {\n        for(let i = 0; i < total; i++)this._pool[this._index++] = new this._classType();\n        this._count += total;\n    }\n    /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */ get(data) {\n        let item;\n        if (this._index > 0) item = this._pool[--this._index];\n        else item = new this._classType();\n        item.init?.(data);\n        return item;\n    }\n    /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */ return(item) {\n        item.reset?.();\n        this._pool[this._index++] = item;\n    }\n    /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */ get totalSize() {\n        return this._count;\n    }\n    /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */ get totalFree() {\n        return this._index;\n    }\n    /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */ get totalUsed() {\n        return this._count - this._index;\n    }\n}\n\n});\n\n\n\n\nparcelRegister(\"kkVML\", function(module, exports) {\n\n$parcel$export(module.exports, \"findMixin\", () => $1ce16328dd0c7b09$export$468b0762e1bfbd64);\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\"use strict\";\nconst $1ce16328dd0c7b09$export$468b0762e1bfbd64 = {\n    /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */ label: null,\n    /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */ get name () {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Container.name property has been removed, use Container.label instead\");\n        return this.label;\n    },\n    set name (value){\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Container.name property has been removed, use Container.label instead\");\n        this.label = value;\n    },\n    /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */ getChildByName (name, deep = false) {\n        return this.getChildByLabel(name, deep);\n    },\n    /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */ getChildByLabel (label, deep = false) {\n        const children = this.children;\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child.label === label || label instanceof RegExp && label.test(child.label)) return child;\n        }\n        if (deep) for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            const found = child.getChildByLabel(label, true);\n            if (found) return found;\n        }\n        return null;\n    },\n    /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */ getChildrenByLabel (label, deep = false, out = []) {\n        const children = this.children;\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child.label === label || label instanceof RegExp && label.test(child.label)) out.push(child);\n        }\n        if (deep) for(let i = 0; i < children.length; i++)children[i].getChildrenByLabel(label, true, out);\n        return out;\n    }\n};\n\n});\n\nparcelRegister(\"kEqoj\", function(module, exports) {\n\n$parcel$export(module.exports, \"measureMixin\", () => $4a6a8e8422db6a2e$export$285e6e72e8e62f0);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $7wtv9 = parcelRequire(\"7wtv9\");\n\nvar $iskjc = parcelRequire(\"iskjc\");\n\nvar $j68wk = parcelRequire(\"j68wk\");\n\nvar $lK289 = parcelRequire(\"lK289\");\n\"use strict\";\nconst $4a6a8e8422db6a2e$var$tempMatrix = new (0, $eY4rt.Matrix)();\nconst $4a6a8e8422db6a2e$export$285e6e72e8e62f0 = {\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n    _setWidth (value, localWidth) {\n        const sign = Math.sign(this.scale.x) || 1;\n        if (localWidth !== 0) this.scale.x = value / localWidth * sign;\n        else this.scale.x = sign;\n    },\n    _setHeight (value, localHeight) {\n        const sign = Math.sign(this.scale.y) || 1;\n        if (localHeight !== 0) this.scale.y = value / localHeight * sign;\n        else this.scale.y = sign;\n    },\n    /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */ getLocalBounds () {\n        if (!this._localBoundsCacheData) this._localBoundsCacheData = {\n            data: [],\n            index: 1,\n            didChange: false,\n            localBounds: new (0, $7wtv9.Bounds)()\n        };\n        const localBoundsCacheData = this._localBoundsCacheData;\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n        if (localBoundsCacheData.data[0] !== this._didChangeId >> 12) {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didChangeId >> 12;\n        }\n        (0, $lK289.checkChildrenDidChange)(this, localBoundsCacheData);\n        if (localBoundsCacheData.didChange) (0, $j68wk.getLocalBounds)(this, localBoundsCacheData.localBounds, $4a6a8e8422db6a2e$var$tempMatrix);\n        return localBoundsCacheData.localBounds;\n    },\n    /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */ getBounds (skipUpdate, bounds) {\n        return (0, $iskjc.getGlobalBounds)(this, skipUpdate, bounds || new (0, $7wtv9.Bounds)());\n    }\n};\n\n});\nparcelRegister(\"7wtv9\", function(module, exports) {\n\n$parcel$export(module.exports, \"Bounds\", () => $0b15abb3a529f09f$export$c4e9d269599ab4b4);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\"use strict\";\nconst $0b15abb3a529f09f$var$defaultMatrix = new (0, $eY4rt.Matrix)();\nclass $0b15abb3a529f09f$export$c4e9d269599ab4b4 {\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity){\n        /** @default Infinity */ this.minX = Infinity;\n        /** @default Infinity */ this.minY = Infinity;\n        /** @default -Infinity */ this.maxX = -Infinity;\n        /** @default -Infinity */ this.maxY = -Infinity;\n        this.matrix = $0b15abb3a529f09f$var$defaultMatrix;\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */ isEmpty() {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n    /** The bounding rectangle of the bounds. */ get rectangle() {\n        if (!this._rectangle) this._rectangle = new (0, $fM4Mk.Rectangle)();\n        const rectangle = this._rectangle;\n        if (this.minX > this.maxX || this.minY > this.maxY) {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        } else rectangle.copyFromBounds(this);\n        return rectangle;\n    }\n    /** Clears the bounds and resets. */ clear() {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n        this.matrix = $0b15abb3a529f09f$var$defaultMatrix;\n        return this;\n    }\n    /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */ set(x0, y0, x1, y1) {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n    /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */ addFrame(x0, y0, x1, y1, matrix) {\n        matrix || (matrix = this.matrix);\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n        let x = a * x0 + c * y0 + tx;\n        let y = b * x0 + d * y0 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x1 + c * y0 + tx;\n        y = b * x1 + d * y0 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x0 + c * y1 + tx;\n        y = b * x0 + d * y1 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x1 + c * y1 + tx;\n        y = b * x1 + d * y1 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */ addRect(rect, matrix) {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n    /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */ addBounds(bounds, matrix) {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n    /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */ addBoundsMask(mask) {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n    /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */ applyMatrix(matrix) {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n        const { a: a, b: b, c: c, d: d, tx: tx, ty: ty } = matrix;\n        let x = a * minX + c * minY + tx;\n        let y = b * minX + d * minY + ty;\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n        x = a * maxX + c * minY + tx;\n        y = b * maxX + d * minY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n        x = a * minX + c * maxY + tx;\n        y = b * minX + d * maxY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n        x = a * maxX + c * maxY + tx;\n        y = b * maxX + d * maxY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n    /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */ fit(rect) {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n        return this;\n    }\n    /**\n   * Resizes the bounds object to include the given bounds.\n   * @param left - The left value of the bounds.\n   * @param right - The right value of the bounds.\n   * @param top - The top value of the bounds.\n   * @param bottom - The bottom value of the bounds.\n   */ fitBounds(left, right, top, bottom) {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n        return this;\n    }\n    /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */ pad(paddingX, paddingY = paddingX) {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n        return this;\n    }\n    /** Ceils the bounds. */ ceil() {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n        return this;\n    }\n    /** Clones the bounds. */ clone() {\n        return new $0b15abb3a529f09f$export$c4e9d269599ab4b4(this.minX, this.minY, this.maxX, this.maxY);\n    }\n    /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */ scale(x, y = x) {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n        return this;\n    }\n    /** the x value of the bounds. */ get x() {\n        return this.minX;\n    }\n    set x(value) {\n        const width = this.maxX - this.minX;\n        this.minX = value;\n        this.maxX = value + width;\n    }\n    /** the y value of the bounds. */ get y() {\n        return this.minY;\n    }\n    set y(value) {\n        const height = this.maxY - this.minY;\n        this.minY = value;\n        this.maxY = value + height;\n    }\n    /** the width value of the bounds. */ get width() {\n        return this.maxX - this.minX;\n    }\n    set width(value) {\n        this.maxX = this.minX + value;\n    }\n    /** the height value of the bounds. */ get height() {\n        return this.maxY - this.minY;\n    }\n    set height(value) {\n        this.maxY = this.minY + value;\n    }\n    /** the left value of the bounds. */ get left() {\n        return this.minX;\n    }\n    /** the right value of the bounds. */ get right() {\n        return this.maxX;\n    }\n    /** the top value of the bounds. */ get top() {\n        return this.minY;\n    }\n    /** the bottom value of the bounds. */ get bottom() {\n        return this.maxY;\n    }\n    /** Is the bounds positive. */ get isPositive() {\n        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n    }\n    get isValid() {\n        return this.minX + this.minY !== Infinity;\n    }\n    /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */ addVertexData(vertexData, beginOffset, endOffset, matrix) {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n        matrix || (matrix = this.matrix);\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        for(let i = beginOffset; i < endOffset; i += 2){\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n            const x = a * localX + c * localY + tx;\n            const y = b * localX + d * localY + ty;\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */ containsPoint(x, y) {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) return true;\n        return false;\n    }\n    toString() {\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n}\n\n});\n\nparcelRegister(\"iskjc\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGlobalBounds\", () => $b2563854990e287d$export$f4412a6981d97baa);\n$parcel$export(module.exports, \"updateTransformBackwards\", () => $b2563854990e287d$export$2022bc48a49dd6d2);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $5tmC8 = parcelRequire(\"5tmC8\");\n\"use strict\";\nfunction $b2563854990e287d$export$f4412a6981d97baa(target, skipUpdateTransform, bounds) {\n    bounds.clear();\n    let parentTransform;\n    let pooledMatrix;\n    if (target.parent) {\n        if (!skipUpdateTransform) {\n            pooledMatrix = (0, $5tmC8.matrixPool).get().identity();\n            parentTransform = $b2563854990e287d$export$2022bc48a49dd6d2(target, pooledMatrix);\n        } else parentTransform = target.parent.worldTransform;\n    } else parentTransform = (0, $eY4rt.Matrix).IDENTITY;\n    $b2563854990e287d$export$ca70956e64971628(target, bounds, parentTransform, skipUpdateTransform);\n    if (pooledMatrix) (0, $5tmC8.matrixPool).return(pooledMatrix);\n    if (!bounds.isValid) bounds.set(0, 0, 0, 0);\n    return bounds;\n}\nfunction $b2563854990e287d$export$ca70956e64971628(target, bounds, parentTransform, skipUpdateTransform) {\n    if (!target.visible || !target.measurable) return;\n    let worldTransform;\n    if (!skipUpdateTransform) {\n        target.updateLocalTransform();\n        worldTransform = (0, $5tmC8.matrixPool).get();\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    } else worldTransform = target.worldTransform;\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n    if (preserveBounds) bounds = (0, $5tmC8.boundsPool).get().clear();\n    if (target.boundsArea) bounds.addRect(target.boundsArea, worldTransform);\n    else {\n        if (target.addBounds) {\n            bounds.matrix = worldTransform;\n            target.addBounds(bounds);\n        }\n        for(let i = 0; i < target.children.length; i++)$b2563854990e287d$export$ca70956e64971628(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n    if (preserveBounds) {\n        for(let i = 0; i < target.effects.length; i++)target.effects[i].addBounds?.(bounds);\n        parentBounds.addBounds(bounds, (0, $eY4rt.Matrix).IDENTITY);\n        (0, $5tmC8.boundsPool).return(bounds);\n    }\n    if (!skipUpdateTransform) (0, $5tmC8.matrixPool).return(worldTransform);\n}\nfunction $b2563854990e287d$export$2022bc48a49dd6d2(target, parentTransform) {\n    const parent = target.parent;\n    if (parent) {\n        $b2563854990e287d$export$2022bc48a49dd6d2(parent, parentTransform);\n        parent.updateLocalTransform();\n        parentTransform.append(parent.localTransform);\n    }\n    return parentTransform;\n}\n\n});\nparcelRegister(\"5tmC8\", function(module, exports) {\n\n$parcel$export(module.exports, \"matrixPool\", () => $aaa7ee585a7b6ebc$export$3849005ba4dacf72);\n$parcel$export(module.exports, \"boundsPool\", () => $aaa7ee585a7b6ebc$export$9194656040c1dc42);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $5Xsoh = parcelRequire(\"5Xsoh\");\n\nvar $7wtv9 = parcelRequire(\"7wtv9\");\n\"use strict\";\nconst $aaa7ee585a7b6ebc$export$3849005ba4dacf72 = new (0, $5Xsoh.Pool)((0, $eY4rt.Matrix));\nconst $aaa7ee585a7b6ebc$export$9194656040c1dc42 = new (0, $5Xsoh.Pool)((0, $7wtv9.Bounds));\n\n});\n\n\nparcelRegister(\"j68wk\", function(module, exports) {\n\n$parcel$export(module.exports, \"getLocalBounds\", () => $653ce529dcaa332d$export$ffaf4f504c4c5c9c);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $5tmC8 = parcelRequire(\"5tmC8\");\n\"use strict\";\nfunction $653ce529dcaa332d$export$ffaf4f504c4c5c9c(target, bounds, relativeMatrix) {\n    bounds.clear();\n    relativeMatrix || (relativeMatrix = (0, $eY4rt.Matrix).IDENTITY);\n    $653ce529dcaa332d$var$_getLocalBounds(target, bounds, relativeMatrix, target, true);\n    if (!bounds.isValid) bounds.set(0, 0, 0, 0);\n    return bounds;\n}\nfunction $653ce529dcaa332d$var$_getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n    let relativeTransform;\n    if (!isRoot) {\n        if (!target.visible || !target.measurable) return;\n        target.updateLocalTransform();\n        const localTransform = target.localTransform;\n        relativeTransform = (0, $5tmC8.matrixPool).get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    } else {\n        relativeTransform = (0, $5tmC8.matrixPool).get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n    if (preserveBounds) bounds = (0, $5tmC8.boundsPool).get().clear();\n    if (target.boundsArea) bounds.addRect(target.boundsArea, relativeTransform);\n    else {\n        if (target.renderPipeId) {\n            bounds.matrix = relativeTransform;\n            target.addBounds(bounds);\n        }\n        const children = target.children;\n        for(let i = 0; i < children.length; i++)$653ce529dcaa332d$var$_getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n    if (preserveBounds) {\n        for(let i = 0; i < target.effects.length; i++)target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        parentBounds.addBounds(bounds, (0, $eY4rt.Matrix).IDENTITY);\n        (0, $5tmC8.boundsPool).return(bounds);\n    }\n    (0, $5tmC8.matrixPool).return(relativeTransform);\n}\nfunction $653ce529dcaa332d$export$58081aedf094d85b(target, root, matrix) {\n    const parent = target.parent;\n    if (!parent) {\n        (0, $hUCK4.warn)(\"Item is not inside the root container\");\n        return;\n    }\n    if (parent !== root) {\n        $653ce529dcaa332d$export$58081aedf094d85b(parent, root, matrix);\n        parent.updateLocalTransform();\n        matrix.append(parent.localTransform);\n    }\n}\n\n});\nparcelRegister(\"hUCK4\", function(module, exports) {\n\n$parcel$export(module.exports, \"warn\", () => $ffdcd240d931c2ea$export$c106dd0671a0fc2d);\n\"use strict\";\nlet $ffdcd240d931c2ea$var$warnCount = 0;\nconst $ffdcd240d931c2ea$var$maxWarnings = 500;\nfunction $ffdcd240d931c2ea$export$c106dd0671a0fc2d(...args) {\n    if ($ffdcd240d931c2ea$var$warnCount === $ffdcd240d931c2ea$var$maxWarnings) return;\n    $ffdcd240d931c2ea$var$warnCount++;\n    if ($ffdcd240d931c2ea$var$warnCount === $ffdcd240d931c2ea$var$maxWarnings) console.warn(\"PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.\");\n    else console.warn(\"PixiJS Warning: \", ...args);\n}\n\n});\n\n\nparcelRegister(\"lK289\", function(module, exports) {\n\n$parcel$export(module.exports, \"checkChildrenDidChange\", () => $6ac8d139665df8ac$export$fd5aadbd3827bcf1);\n\"use strict\";\nfunction $6ac8d139665df8ac$export$fd5aadbd3827bcf1(container, previousData) {\n    const children = container.children;\n    for(let i = 0; i < children.length; i++){\n        const child = children[i];\n        const changeId = (child.uid & 255) << 24 | child._didChangeId & 16777215;\n        if (previousData.data[previousData.index] !== changeId) {\n            previousData.data[previousData.index] = changeId;\n            previousData.didChange = true;\n        }\n        previousData.index++;\n        if (child.children.length) $6ac8d139665df8ac$export$fd5aadbd3827bcf1(child, previousData);\n    }\n    return previousData.didChange;\n}\n\n});\n\n\nparcelRegister(\"ggvKl\", function(module, exports) {\n\n$parcel$export(module.exports, \"onRenderMixin\", () => $63981d12ee78567e$export$2a5246d1114cb81d);\n\"use strict\";\nconst $63981d12ee78567e$export$2a5246d1114cb81d = {\n    _onRender: null,\n    set onRender (func){\n        const renderGroup = this.renderGroup;\n        if (!func) {\n            if (this._onRender) renderGroup?.removeOnRender(this);\n            this._onRender = null;\n            return;\n        }\n        if (!this._onRender) renderGroup?.addOnRender(this);\n        this._onRender = func;\n    },\n    /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and \"updateTransform\" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */ get onRender () {\n        return this._onRender;\n    }\n};\n\n});\n\nparcelRegister(\"82jXu\", function(module, exports) {\n\n$parcel$export(module.exports, \"sortMixin\", () => $8864252dd84a6b69$export$eb4acdd9f4781aed);\n\"use strict\";\nconst $8864252dd84a6b69$export$eb4acdd9f4781aed = {\n    _zIndex: 0,\n    /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */ sortDirty: false,\n    /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */ sortableChildren: false,\n    /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */ get zIndex () {\n        return this._zIndex;\n    },\n    set zIndex (value){\n        if (this._zIndex === value) return;\n        this._zIndex = value;\n        this.depthOfChildModified();\n    },\n    depthOfChildModified () {\n        if (this.parent) {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n        if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n    },\n    /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */ sortChildren () {\n        if (!this.sortDirty) return;\n        this.sortDirty = false;\n        this.children.sort($8864252dd84a6b69$var$sortChildren);\n    }\n};\nfunction $8864252dd84a6b69$var$sortChildren(a, b) {\n    return a._zIndex - b._zIndex;\n}\n\n});\n\nparcelRegister(\"g5iYs\", function(module, exports) {\n\n$parcel$export(module.exports, \"toLocalGlobalMixin\", () => $6a95391942e887de$export$38fa7a987602e8dd);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $1HooC = parcelRequire(\"1HooC\");\n\nvar $iskjc = parcelRequire(\"iskjc\");\n\"use strict\";\nconst $6a95391942e887de$export$38fa7a987602e8dd = {\n    /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */ getGlobalPosition (point = new (0, $1HooC.Point)(), skipUpdate = false) {\n        if (this.parent) this.parent.toGlobal(this._position, point, skipUpdate);\n        else {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n        return point;\n    },\n    /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */ toGlobal (position, point, skipUpdate = false) {\n        if (!skipUpdate) {\n            this.updateLocalTransform();\n            const globalMatrix = (0, $iskjc.updateTransformBackwards)(this, new (0, $eY4rt.Matrix)());\n            globalMatrix.append(this.localTransform);\n            return globalMatrix.apply(position, point);\n        }\n        return this.worldTransform.apply(position, point);\n    },\n    /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */ toLocal (position, from, point, skipUpdate) {\n        if (from) position = from.toGlobal(position, point, skipUpdate);\n        if (!skipUpdate) {\n            this.updateLocalTransform();\n            const globalMatrix = (0, $iskjc.updateTransformBackwards)(this, new (0, $eY4rt.Matrix)());\n            globalMatrix.append(this.localTransform);\n            return globalMatrix.applyInverse(position, point);\n        }\n        return this.worldTransform.applyInverse(position, point);\n    }\n};\n\n});\n\nparcelRegister(\"1pFbO\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderGroup\", () => $5a621eb8e375b2c4$export$94d273f8d74f2a5);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $dK5Jn = parcelRequire(\"dK5Jn\");\n\"use strict\";\nclass $5a621eb8e375b2c4$export$94d273f8d74f2a5 {\n    constructor(root){\n        this.renderPipeId = \"renderGroup\";\n        this.root = null;\n        this.canBundle = false;\n        this.renderGroupParent = null;\n        this.renderGroupChildren = [];\n        this._children = [];\n        this.worldTransform = new (0, $eY4rt.Matrix)();\n        this.worldColorAlpha = 4294967295;\n        this.worldColor = 16777215;\n        this.worldAlpha = 1;\n        // these updates are transform changes..\n        this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n        this.updateTick = 0;\n        // these update are renderable changes..\n        this.childrenRenderablesToUpdate = {\n            list: [],\n            index: 0\n        };\n        // other\n        this.structureDidChange = true;\n        this.instructionSet = new (0, $dK5Jn.InstructionSet)();\n        this._onRenderContainers = [];\n        this.root = root;\n        this.addChild(root);\n    }\n    get localTransform() {\n        return this.root.localTransform;\n    }\n    addRenderGroupChild(renderGroupChild) {\n        if (renderGroupChild.renderGroupParent) renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        renderGroupChild.renderGroupParent = this;\n        this.onChildUpdate(renderGroupChild.root);\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n    _removeRenderGroupChild(renderGroupChild) {\n        if (renderGroupChild.root.didChange) this._removeChildFromUpdate(renderGroupChild.root);\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n        if (index > -1) this.renderGroupChildren.splice(index, 1);\n        renderGroupChild.renderGroupParent = null;\n    }\n    addChild(child) {\n        this.structureDidChange = true;\n        if (child !== this.root) {\n            this._children.push(child);\n            child.updateTick = -1;\n            if (child.parent === this.root) child.relativeRenderGroupDepth = 1;\n            else child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n            if (child._onRender) this.addOnRender(child);\n        }\n        if (child.renderGroup) {\n            if (child.renderGroup.root === child) {\n                this.addRenderGroupChild(child.renderGroup);\n                return;\n            }\n        } else {\n            child.renderGroup = this;\n            child.didChange = true;\n        }\n        const children = child.children;\n        if (!child.isRenderGroupRoot) this.onChildUpdate(child);\n        for(let i = 0; i < children.length; i++)this.addChild(children[i]);\n    }\n    removeChild(child) {\n        this.structureDidChange = true;\n        if (child._onRender) this.removeOnRender(child);\n        if (child.renderGroup.root !== child) {\n            const children = child.children;\n            for(let i = 0; i < children.length; i++)this.removeChild(children[i]);\n            if (child.didChange) child.renderGroup._removeChildFromUpdate(child);\n            child.renderGroup = null;\n        } else this._removeRenderGroupChild(child.renderGroup);\n        const index = this._children.indexOf(child);\n        if (index > -1) this._children.splice(index, 1);\n    }\n    onChildUpdate(child) {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n        if (!childrenToUpdate) childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n            index: 0,\n            list: []\n        };\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n    // SHOULD THIS BE HERE?\n    updateRenderable(container) {\n        if (container.globalDisplayStatus < 7) return;\n        container.didViewUpdate = false;\n        this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n    }\n    onChildViewUpdate(child) {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n    _removeChildFromUpdate(child) {\n        const childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n        if (!childrenToUpdate) return;\n        const index = childrenToUpdate.list.indexOf(child);\n        if (index > -1) childrenToUpdate.list.splice(index, 1);\n        childrenToUpdate.index--;\n    }\n    get isRenderable() {\n        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n    }\n    /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */ addOnRender(container) {\n        this._onRenderContainers.push(container);\n    }\n    removeOnRender(container) {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n    runOnRender() {\n        for(let i = 0; i < this._onRenderContainers.length; i++)this._onRenderContainers[i]._onRender();\n    }\n}\n\n});\nparcelRegister(\"dK5Jn\", function(module, exports) {\n\n$parcel$export(module.exports, \"InstructionSet\", () => $a69ff318b1fa7c86$export$2946bd01f10dd922);\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\"use strict\";\nclass $a69ff318b1fa7c86$export$2946bd01f10dd922 {\n    constructor(){\n        /** a unique id for this instruction set used through the renderer */ this.uid = (0, $aGJhg.uid)(\"instructionSet\");\n        /** the array of instructions */ this.instructions = [];\n        /** the actual size of the array (any instructions passed this should be ignored) */ this.instructionSize = 0;\n    }\n    /** reset the instruction set so it can be reused set size back to 0 */ reset() {\n        this.instructionSize = 0;\n    }\n    /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */ add(instruction) {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n    /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */ log() {\n        this.instructions.length = this.instructionSize;\n        console.table(this.instructions, [\n            \"type\",\n            \"action\"\n        ]);\n    }\n}\n\n});\n\n\nparcelRegister(\"gIPW8\", function(module, exports) {\n\n$parcel$export(module.exports, \"assignWithIgnore\", () => $83c57e61d47d996f$export$59d0441a278e5935);\n\"use strict\";\nfunction $83c57e61d47d996f$export$59d0441a278e5935(target, options, ignore = {}) {\n    for(const key in options)if (!ignore[key] && options[key] !== void 0) target[key] = options[key];\n}\n\n});\n\n\n\nparcelRegister(\"jzlb7\", function(module, exports) {\n\n$parcel$export(module.exports, \"addMaskBounds\", () => $cd1eadd0f2fb679c$export$12af48852c6ac574);\n\nvar $7wtv9 = parcelRequire(\"7wtv9\");\n\nvar $iskjc = parcelRequire(\"iskjc\");\n\"use strict\";\nconst $cd1eadd0f2fb679c$var$tempBounds = new (0, $7wtv9.Bounds)();\nfunction $cd1eadd0f2fb679c$export$12af48852c6ac574(mask, bounds, skipUpdateTransform) {\n    const boundsToMask = $cd1eadd0f2fb679c$var$tempBounds;\n    mask.measurable = true;\n    (0, $iskjc.getGlobalBounds)(mask, skipUpdateTransform, boundsToMask);\n    bounds.addBoundsMask(boundsToMask);\n    mask.measurable = false;\n}\n\n});\n\nparcelRegister(\"4vXk0\", function(module, exports) {\n\n$parcel$export(module.exports, \"addMaskLocalBounds\", () => $6df4144b7f405909$export$7416ac774b1f1a33);\n\nvar $j68wk = parcelRequire(\"j68wk\");\n\nvar $5tmC8 = parcelRequire(\"5tmC8\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\"use strict\";\nfunction $6df4144b7f405909$export$7416ac774b1f1a33(mask, bounds, localRoot) {\n    const boundsToMask = (0, $5tmC8.boundsPool).get();\n    mask.measurable = true;\n    const tempMatrix = (0, $5tmC8.matrixPool).get().identity();\n    const relativeMask = $6df4144b7f405909$export$1536bde1a0bf3cb9(mask, localRoot, tempMatrix);\n    (0, $j68wk.getLocalBounds)(mask, boundsToMask, relativeMask);\n    mask.measurable = false;\n    bounds.addBoundsMask(boundsToMask);\n    (0, $5tmC8.matrixPool).return(tempMatrix);\n    (0, $5tmC8.boundsPool).return(boundsToMask);\n}\nfunction $6df4144b7f405909$export$1536bde1a0bf3cb9(target, root, matrix) {\n    if (!target) {\n        (0, $hUCK4.warn)(\"Mask bounds, renderable is not inside the root container\");\n        return matrix;\n    }\n    if (target !== root) {\n        $6df4144b7f405909$export$1536bde1a0bf3cb9(target.parent, root, matrix);\n        target.updateLocalTransform();\n        matrix.append(target.localTransform);\n    }\n    return matrix;\n}\n\n});\n\n\nparcelRegister(\"lLQso\", function(module, exports) {\n\n$parcel$export(module.exports, \"ColorMask\", () => $2625cf12b5a3b5e5$export$1e2a2c76374c2542);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\nclass $2625cf12b5a3b5e5$export$1e2a2c76374c2542 {\n    constructor(options){\n        this.priority = 0;\n        this.pipe = \"colorMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n    }\n    destroy() {}\n    static test(mask) {\n        return typeof mask === \"number\";\n    }\n}\n$2625cf12b5a3b5e5$export$1e2a2c76374c2542.extension = (0, $i9BKe.ExtensionType).MaskEffect;\n\n});\n\nparcelRegister(\"jXXId\", function(module, exports) {\n\n$parcel$export(module.exports, \"StencilMask\", () => $e8890ea82735e7dd$export$abd85894695764cb);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $eicwU = parcelRequire(\"eicwU\");\n\nvar $jzlb7 = parcelRequire(\"jzlb7\");\n\nvar $4vXk0 = parcelRequire(\"4vXk0\");\n\"use strict\";\nclass $e8890ea82735e7dd$export$abd85894695764cb {\n    constructor(options){\n        this.priority = 0;\n        this.pipe = \"stencilMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n    reset() {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n    addBounds(bounds, skipUpdateTransform) {\n        (0, $jzlb7.addMaskBounds)(this.mask, bounds, skipUpdateTransform);\n    }\n    addLocalBounds(bounds, localRoot) {\n        (0, $4vXk0.addMaskLocalBounds)(this.mask, bounds, localRoot);\n    }\n    containsPoint(point, hitTestFn) {\n        const mask = this.mask;\n        return hitTestFn(mask, point);\n    }\n    destroy() {\n        this.reset();\n    }\n    static test(mask) {\n        return mask instanceof (0, $eicwU.Container);\n    }\n}\n$e8890ea82735e7dd$export$abd85894695764cb.extension = (0, $i9BKe.ExtensionType).MaskEffect;\n\n});\n\nparcelRegister(\"8xl7d\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasSource\", () => $adfc96265c7ca69d$export$ca65ccf5708c6a0c);\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $iA5fe = parcelRequire(\"iA5fe\");\n\"use strict\";\nclass $adfc96265c7ca69d$export$ca65ccf5708c6a0c extends (0, $iA5fe.TextureSource) {\n    constructor(options){\n        if (!options.resource) options.resource = (0, $iCGeI.DOMAdapter).get().createCanvas();\n        if (!options.width) {\n            options.width = options.resource.width;\n            if (!options.autoDensity) options.width /= options.resolution;\n        }\n        if (!options.height) {\n            options.height = options.resource.height;\n            if (!options.autoDensity) options.height /= options.resolution;\n        }\n        super(options);\n        this.uploadMethodId = \"image\";\n        this.autoDensity = options.autoDensity;\n        const canvas = options.resource;\n        if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) this.resizeCanvas();\n        this.transparent = !!options.transparent;\n    }\n    resizeCanvas() {\n        if (this.autoDensity) {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n    resize(width = this.width, height = this.height, resolution = this._resolution) {\n        const didResize = super.resize(width, height, resolution);\n        if (didResize) this.resizeCanvas();\n        return didResize;\n    }\n    static test(resource) {\n        return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n    }\n}\n$adfc96265c7ca69d$export$ca65ccf5708c6a0c.extension = (0, $i9BKe.ExtensionType).TextureSource;\n\n});\nparcelRegister(\"iCGeI\", function(module, exports) {\n\n$parcel$export(module.exports, \"DOMAdapter\", () => $bfbe44ab70ab7a53$export$d988306fa84f7b44);\n\nvar $9OKiP = parcelRequire(\"9OKiP\");\n\"use strict\";\nlet $bfbe44ab70ab7a53$var$currentAdapter = (0, $9OKiP.BrowserAdapter);\nconst $bfbe44ab70ab7a53$export$d988306fa84f7b44 = {\n    /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */ get () {\n        return $bfbe44ab70ab7a53$var$currentAdapter;\n    },\n    /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */ set (adapter) {\n        $bfbe44ab70ab7a53$var$currentAdapter = adapter;\n    }\n};\n\n});\nparcelRegister(\"9OKiP\", function(module, exports) {\n\n$parcel$export(module.exports, \"BrowserAdapter\", () => $ed1c5172c2eee607$export$e467cc3399500025);\n\"use strict\";\nconst $ed1c5172c2eee607$export$e467cc3399500025 = {\n    createCanvas: (width, height)=>{\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    },\n    getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,\n    getWebGLRenderingContext: ()=>WebGLRenderingContext,\n    getNavigator: ()=>navigator,\n    getBaseUrl: ()=>document.baseURI ?? window.location.href,\n    getFontFaceSet: ()=>document.fonts,\n    fetch: (url, options)=>fetch(url, options),\n    parseXML: (xml)=>{\n        const parser = new DOMParser();\n        return parser.parseFromString(xml, \"text/xml\");\n    }\n};\n\n});\n\n\n\nparcelRegister(\"aQPld\", function(module, exports) {\n\n$parcel$export(module.exports, \"ImageSource\", () => $ac4c5539d7b1f960$export$280e9a68c3ffd919);\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $iA5fe = parcelRequire(\"iA5fe\");\n\"use strict\";\nclass $ac4c5539d7b1f960$export$280e9a68c3ffd919 extends (0, $iA5fe.TextureSource) {\n    constructor(options){\n        if (options.resource && globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement) {\n            const canvas = (0, $iCGeI.DOMAdapter).get().createCanvas(options.resource.width, options.resource.height);\n            const context = canvas.getContext(\"2d\");\n            context.drawImage(options.resource, 0, 0);\n            options.resource = canvas;\n            (0, $hUCK4.warn)(\"ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.\");\n        }\n        super(options);\n        this.uploadMethodId = \"image\";\n        this.autoGarbageCollect = true;\n    }\n    static test(resource) {\n        return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== \"undefined\" && resource instanceof ImageBitmap;\n    }\n}\n$ac4c5539d7b1f960$export$280e9a68c3ffd919.extension = (0, $i9BKe.ExtensionType).TextureSource;\n\n});\n\nparcelRegister(\"hNatJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"VideoSource\", () => $4dc351acd421ceef$export$f3a17123d80000c5);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $4J7WL = parcelRequire(\"4J7WL\");\n\nvar $7blVu = parcelRequire(\"7blVu\");\n\nvar $iA5fe = parcelRequire(\"iA5fe\");\n\"use strict\";\nconst $4dc351acd421ceef$var$_VideoSource = class _VideoSource extends (0, $iA5fe.TextureSource) {\n    constructor(options){\n        super(options);\n        // Public\n        /** Whether or not the video is ready to play. */ this.isReady = false;\n        /** The upload method for this texture. */ this.uploadMethodId = \"video\";\n        options = {\n            ..._VideoSource.defaultOptions,\n            ...options\n        };\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? \"premultiply-alpha-on-upload\";\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n        if (options.autoLoad !== false) this.load();\n    }\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */ updateFrame() {\n        if (this.destroyed) return;\n        if (this._updateFPS) {\n            const elapsedMS = (0, $4J7WL.Ticker).shared.elapsedMS * this.resource.playbackRate;\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n        if (!this._updateFPS || this._msToNextUpdate <= 0) this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n        if (this.isValid) this.update();\n    }\n    /** Callback to update the video frame and potentially request the next frame update. */ _videoFrameRequestCallback() {\n        this.updateFrame();\n        if (this.destroyed) this._videoFrameRequestCallbackHandle = null;\n        else this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);\n    }\n    /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */ get isValid() {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n    /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */ async load() {\n        if (this._load) return this._load;\n        const source = this.resource;\n        const options = this.options;\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) source.complete = true;\n        source.addEventListener(\"play\", this._onPlayStart);\n        source.addEventListener(\"pause\", this._onPlayStop);\n        source.addEventListener(\"seeked\", this._onSeeked);\n        if (!this._isSourceReady()) {\n            if (!options.preload) source.addEventListener(\"canplay\", this._onCanPlay);\n            source.addEventListener(\"canplaythrough\", this._onCanPlayThrough);\n            source.addEventListener(\"error\", this._onError, true);\n        } else this._mediaReady();\n        this.alphaMode = await (0, $7blVu.detectVideoAlphaMode)();\n        this._load = new Promise((resolve, reject)=>{\n            if (this.isValid) resolve(this);\n            else {\n                this._resolve = resolve;\n                this._reject = reject;\n                if (options.preloadTimeoutMs !== void 0) this._preloadTimeout = setTimeout(()=>{\n                    this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                });\n                source.load();\n            }\n        });\n        return this._load;\n    }\n    /**\n   * Handle video error events.\n   * @param event - The error event\n   */ _onError(event) {\n        this.resource.removeEventListener(\"error\", this._onError, true);\n        this.emit(\"error\", event);\n        if (this._reject) {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n    /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */ _isSourcePlaying() {\n        const source = this.resource;\n        return !source.paused && !source.ended;\n    }\n    /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */ _isSourceReady() {\n        const source = this.resource;\n        return source.readyState > 2;\n    }\n    /** Runs the update loop when the video is ready to play. */ _onPlayStart() {\n        if (!this.isValid) this._mediaReady();\n        this._configureAutoUpdate();\n    }\n    /** Stops the update loop when a pause event is triggered. */ _onPlayStop() {\n        this._configureAutoUpdate();\n    }\n    /** Handles behavior when the video completes seeking to the current playback position. */ _onSeeked() {\n        if (this._autoUpdate && !this._isSourcePlaying()) {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n    _onCanPlay() {\n        const source = this.resource;\n        source.removeEventListener(\"canplay\", this._onCanPlay);\n        this._mediaReady();\n    }\n    _onCanPlayThrough() {\n        const source = this.resource;\n        source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n        if (this._preloadTimeout) {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = void 0;\n        }\n        this._mediaReady();\n    }\n    /** Fired when the video is loaded and ready to play. */ _mediaReady() {\n        const source = this.resource;\n        if (this.isValid) {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n        if (this._resolve) {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n        if (this._isSourcePlaying()) this._onPlayStart();\n        else if (this.autoPlay) this.resource.play();\n    }\n    /** Cleans up resources and event listeners associated with this texture. */ destroy() {\n        this._configureAutoUpdate();\n        const source = this.resource;\n        if (source) {\n            source.removeEventListener(\"play\", this._onPlayStart);\n            source.removeEventListener(\"pause\", this._onPlayStop);\n            source.removeEventListener(\"seeked\", this._onSeeked);\n            source.removeEventListener(\"canplay\", this._onCanPlay);\n            source.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n            source.removeEventListener(\"error\", this._onError, true);\n            source.pause();\n            source.src = \"\";\n            source.load();\n        }\n        super.destroy();\n    }\n    /** Should the base texture automatically update itself, set to true by default. */ get autoUpdate() {\n        return this._autoUpdate;\n    }\n    set autoUpdate(value) {\n        if (value !== this._autoUpdate) {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n    /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */ get updateFPS() {\n        return this._updateFPS;\n    }\n    set updateFPS(value) {\n        if (value !== this._updateFPS) {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n    /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser's native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video's state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n   */ _configureAutoUpdate() {\n        if (this._autoUpdate && this._isSourcePlaying()) {\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback) {\n                if (this._isConnectedToTicker) {\n                    (0, $4J7WL.Ticker).shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    this._msToNextUpdate = 0;\n                }\n                if (this._videoFrameRequestCallbackHandle === null) this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);\n            } else {\n                if (this._videoFrameRequestCallbackHandle !== null) {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n                if (!this._isConnectedToTicker) {\n                    (0, $4J7WL.Ticker).shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    this._msToNextUpdate = 0;\n                }\n            }\n        } else {\n            if (this._videoFrameRequestCallbackHandle !== null) {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n            if (this._isConnectedToTicker) {\n                (0, $4J7WL.Ticker).shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n    static test(resource) {\n        return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement || globalThis.VideoFrame && resource instanceof VideoFrame;\n    }\n};\n$4dc351acd421ceef$var$_VideoSource.extension = (0, $i9BKe.ExtensionType).TextureSource;\n/** The default options for video sources. */ $4dc351acd421ceef$var$_VideoSource.defaultOptions = {\n    ...(0, $iA5fe.TextureSource).defaultOptions,\n    /** If true, the video will start loading immediately. */ autoLoad: true,\n    /** If true, the video will start playing as soon as it is loaded. */ autoPlay: true,\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */ updateFPS: 0,\n    /** If true, the video will be loaded with the `crossorigin` attribute. */ crossorigin: true,\n    /** If true, the video will loop when it ends. */ loop: false,\n    /** If true, the video will be muted. */ muted: true,\n    /** If true, the video will play inline. */ playsinline: true,\n    /** If true, the video will be preloaded. */ preload: false\n};\n/**\n * Map of video MIME types that can't be directly derived from file extensions.\n * @readonly\n */ $4dc351acd421ceef$var$_VideoSource.MIME_TYPES = {\n    ogv: \"video/ogg\",\n    mov: \"video/quicktime\",\n    m4v: \"video/mp4\"\n};\nlet $4dc351acd421ceef$export$f3a17123d80000c5 = $4dc351acd421ceef$var$_VideoSource;\n\n});\nparcelRegister(\"4J7WL\", function(module, exports) {\n\n$parcel$export(module.exports, \"Ticker\", () => $2bf8d15685054100$export$39c54bcc89dcee11);\n\nvar $cQMLP = parcelRequire(\"cQMLP\");\n\nvar $bJH8Y = parcelRequire(\"bJH8Y\");\n\"use strict\";\nconst $2bf8d15685054100$var$_Ticker = class _Ticker {\n    constructor(){\n        /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */ this.autoStart = false;\n        /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */ this.deltaTime = 1;\n        /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     */ this.lastTime = -1;\n        /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */ this.speed = 1;\n        /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */ this.started = false;\n        /** Internal current frame request ID */ this._requestId = null;\n        /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */ this._maxElapsedMS = 100;\n        /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */ this._minElapsedMS = 0;\n        /** If enabled, deleting is disabled.*/ this._protected = false;\n        /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */ this._lastFrame = -1;\n        this._head = new (0, $bJH8Y.TickerListener)(null, null, Infinity);\n        this.deltaMS = 1 / _Ticker.targetFPMS;\n        this.elapsedMS = 1 / _Ticker.targetFPMS;\n        this._tick = (time)=>{\n            this._requestId = null;\n            if (this.started) {\n                this.update(time);\n                if (this.started && this._requestId === null && this._head.next) this._requestId = requestAnimationFrame(this._tick);\n            }\n        };\n    }\n    /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */ _requestIfNeeded() {\n        if (this._requestId === null && this._head.next) {\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n    /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */ _cancelIfNeeded() {\n        if (this._requestId !== null) {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n    /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */ _startIfPossible() {\n        if (this.started) this._requestIfNeeded();\n        else if (this.autoStart) this.start();\n    }\n    /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */ add(fn, context, priority = (0, $cQMLP.UPDATE_PRIORITY).NORMAL) {\n        return this._addListener(new (0, $bJH8Y.TickerListener)(fn, context, priority));\n    }\n    /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */ addOnce(fn, context, priority = (0, $cQMLP.UPDATE_PRIORITY).NORMAL) {\n        return this._addListener(new (0, $bJH8Y.TickerListener)(fn, context, priority, true));\n    }\n    /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */ _addListener(listener) {\n        let current = this._head.next;\n        let previous = this._head;\n        if (!current) listener.connect(previous);\n        else {\n            while(current){\n                if (listener.priority > current.priority) {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n            if (!listener.previous) listener.connect(previous);\n        }\n        this._startIfPossible();\n        return this;\n    }\n    /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */ remove(fn, context) {\n        let listener = this._head.next;\n        while(listener)if (listener.match(fn, context)) listener = listener.destroy();\n        else listener = listener.next;\n        if (!this._head.next) this._cancelIfNeeded();\n        return this;\n    }\n    /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */ get count() {\n        if (!this._head) return 0;\n        let count = 0;\n        let current = this._head;\n        while(current = current.next)count++;\n        return count;\n    }\n    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */ start() {\n        if (!this.started) {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */ stop() {\n        if (this.started) {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */ destroy() {\n        if (!this._protected) {\n            this.stop();\n            let listener = this._head.next;\n            while(listener)listener = listener.destroy(true);\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n    /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */ update(currentTime = performance.now()) {\n        let elapsedMS;\n        if (currentTime > this.lastTime) {\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n            if (elapsedMS > this._maxElapsedMS) elapsedMS = this._maxElapsedMS;\n            elapsedMS *= this.speed;\n            if (this._minElapsedMS) {\n                const delta = currentTime - this._lastFrame | 0;\n                if (delta < this._minElapsedMS) return;\n                this._lastFrame = currentTime - delta % this._minElapsedMS;\n            }\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n            const head = this._head;\n            let listener = head.next;\n            while(listener)listener = listener.emit(this);\n            if (!head.next) this._cancelIfNeeded();\n        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        this.lastTime = currentTime;\n    }\n    /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */ get FPS() {\n        return 1e3 / this.elapsedMS;\n    }\n    /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */ get minFPS() {\n        return 1e3 / this._maxElapsedMS;\n    }\n    set minFPS(fps) {\n        const minFPS = Math.min(this.maxFPS, fps);\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n    /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */ get maxFPS() {\n        if (this._minElapsedMS) return Math.round(1e3 / this._minElapsedMS);\n        return 0;\n    }\n    set maxFPS(fps) {\n        if (fps === 0) this._minElapsedMS = 0;\n        else {\n            const maxFPS = Math.max(this.minFPS, fps);\n            this._minElapsedMS = 1 / (maxFPS / 1e3);\n        }\n    }\n    /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */ static get shared() {\n        if (!_Ticker._shared) {\n            const shared = _Ticker._shared = new _Ticker();\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n        return _Ticker._shared;\n    }\n    /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */ static get system() {\n        if (!_Ticker._system) {\n            const system = _Ticker._system = new _Ticker();\n            system.autoStart = true;\n            system._protected = true;\n        }\n        return _Ticker._system;\n    }\n};\n/**\n * Target frames per millisecond.\n * @static\n */ $2bf8d15685054100$var$_Ticker.targetFPMS = 0.06;\nlet $2bf8d15685054100$export$39c54bcc89dcee11 = $2bf8d15685054100$var$_Ticker;\n\n});\nparcelRegister(\"cQMLP\", function(module, exports) {\n\n$parcel$export(module.exports, \"UPDATE_PRIORITY\", () => $d091949369ecd400$export$688aaf132ba9b379);\n\"use strict\";\nvar $d091949369ecd400$export$688aaf132ba9b379 = /* @__PURE__ */ ((UPDATE_PRIORITY2)=>{\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"INTERACTION\"] = 50] = \"INTERACTION\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"HIGH\"] = 25] = \"HIGH\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"NORMAL\"] = 0] = \"NORMAL\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"LOW\"] = -25] = \"LOW\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"UTILITY\"] = -50] = \"UTILITY\";\n    return UPDATE_PRIORITY2;\n})($d091949369ecd400$export$688aaf132ba9b379 || {});\n\n});\n\nparcelRegister(\"bJH8Y\", function(module, exports) {\n\n$parcel$export(module.exports, \"TickerListener\", () => $44ffb68c45a667a2$export$579021a5759a260f);\n\"use strict\";\nclass $44ffb68c45a667a2$export$579021a5759a260f {\n    /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */ constructor(fn, context = null, priority = 0, once = false){\n        /** The next item in chain. */ this.next = null;\n        /** The previous item in chain. */ this.previous = null;\n        /** `true` if this listener has been destroyed already. */ this._destroyed = false;\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n    /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */ match(fn, context = null) {\n        return this._fn === fn && this._context === context;\n    }\n    /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */ emit(ticker) {\n        if (this._fn) {\n            if (this._context) this._fn.call(this._context, ticker);\n            else this._fn(ticker);\n        }\n        const redirect = this.next;\n        if (this._once) this.destroy(true);\n        if (this._destroyed) this.next = null;\n        return redirect;\n    }\n    /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */ connect(previous) {\n        this.previous = previous;\n        if (previous.next) previous.next.previous = this;\n        this.next = previous.next;\n        previous.next = this;\n    }\n    /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */ destroy(hard = false) {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n        if (this.previous) this.previous.next = this.next;\n        if (this.next) this.next.previous = this.previous;\n        const redirect = this.next;\n        this.next = hard ? null : redirect;\n        this.previous = null;\n        return redirect;\n    }\n}\n\n});\n\n\nparcelRegister(\"7blVu\", function(module, exports) {\n\n$parcel$export(module.exports, \"detectVideoAlphaMode\", () => $1603b82fc2121ba0$export$8df68d58aae31877);\n\"use strict\";\nlet $1603b82fc2121ba0$var$promise;\nasync function $1603b82fc2121ba0$export$8df68d58aae31877() {\n    $1603b82fc2121ba0$var$promise ?? ($1603b82fc2121ba0$var$promise = (async ()=>{\n        const canvas = document.createElement(\"canvas\");\n        const gl = canvas.getContext(\"webgl\");\n        if (!gl) return \"premultiply-alpha-on-upload\";\n        const video = await new Promise((resolve)=>{\n            const video2 = document.createElement(\"video\");\n            video2.onloadeddata = ()=>resolve(video2);\n            video2.onerror = ()=>resolve(null);\n            video2.autoplay = false;\n            video2.crossOrigin = \"anonymous\";\n            video2.preload = \"auto\";\n            video2.src = \"data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=\";\n            video2.load();\n        });\n        if (!video) return \"premultiply-alpha-on-upload\";\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        const framebuffer = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n        const pixel = new Uint8Array(4);\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n        return pixel[0] <= pixel[3] ? \"premultiplied-alpha\" : \"premultiply-alpha-on-upload\";\n    })());\n    return $1603b82fc2121ba0$var$promise;\n}\n\n});\n\n\nparcelRegister(\"8QN7n\", function(module, exports) {\n\nvar $2IhKp = parcelRequire(\"2IhKp\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $iA5fe = parcelRequire(\"iA5fe\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\"use strict\";\nconst $da9f248d33f9f2f1$var$sources = [];\n(0, $i9BKe.extensions).handleByList((0, $i9BKe.ExtensionType).TextureSource, $da9f248d33f9f2f1$var$sources);\nfunction $da9f248d33f9f2f1$export$688bcf31fbf7eb15(options = {}) {\n    const hasResource = options && options.resource;\n    const res = hasResource ? options.resource : options;\n    const opts = hasResource ? options : {\n        resource: options\n    };\n    for(let i = 0; i < $da9f248d33f9f2f1$var$sources.length; i++){\n        const Source = $da9f248d33f9f2f1$var$sources[i];\n        if (Source.test(res)) return new Source(opts);\n    }\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction $da9f248d33f9f2f1$export$3b748ed6327ec85b(options = {}, skipCache = false) {\n    const hasResource = options && options.resource;\n    const resource = hasResource ? options.resource : options;\n    const opts = hasResource ? options : {\n        resource: options\n    };\n    if (!skipCache && (0, $2IhKp.Cache).has(resource)) return (0, $2IhKp.Cache).get(resource);\n    const texture = new (0, $bLlTJ.Texture)({\n        source: $da9f248d33f9f2f1$export$688bcf31fbf7eb15(opts)\n    });\n    texture.on(\"destroy\", ()=>{\n        if ((0, $2IhKp.Cache).has(resource)) (0, $2IhKp.Cache).remove(resource);\n    });\n    if (!skipCache) (0, $2IhKp.Cache).set(resource, texture);\n    return texture;\n}\nfunction $da9f248d33f9f2f1$export$4266177d9730bb1(id, skipCache = false) {\n    if (typeof id === \"string\") return (0, $2IhKp.Cache).get(id);\n    else if (id instanceof (0, $iA5fe.TextureSource)) return new (0, $bLlTJ.Texture)({\n        source: id\n    });\n    return $da9f248d33f9f2f1$export$3b748ed6327ec85b(id, skipCache);\n}\n(0, $bLlTJ.Texture).from = $da9f248d33f9f2f1$export$4266177d9730bb1;\n\n});\nparcelRegister(\"2IhKp\", function(module, exports) {\n\n$parcel$export(module.exports, \"Cache\", () => $3d19110becfaeec3$export$94affb487e701bf2);\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $3CHiv = parcelRequire(\"3CHiv\");\n\"use strict\";\nclass $3d19110becfaeec3$var$CacheClass {\n    constructor(){\n        this._parsers = [];\n        this._cache = /* @__PURE__ */ new Map();\n        this._cacheMap = /* @__PURE__ */ new Map();\n    }\n    /** Clear all entries. */ reset() {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n    /**\n   * Check if the key exists\n   * @param key - The key to check\n   */ has(key) {\n        return this._cache.has(key);\n    }\n    /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */ get(key) {\n        const result = this._cache.get(key);\n        if (!result) (0, $hUCK4.warn)(`[Assets] Asset id ${key} was not found in the Cache`);\n        return result;\n    }\n    /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */ set(key, value) {\n        const keys = (0, $3CHiv.convertToList)(key);\n        let cacheableAssets;\n        for(let i = 0; i < this.parsers.length; i++){\n            const parser = this.parsers[i];\n            if (parser.test(value)) {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n                break;\n            }\n        }\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n        if (!cacheableAssets) keys.forEach((key2)=>{\n            cacheableMap.set(key2, value);\n        });\n        const cacheKeys = [\n            ...cacheableMap.keys()\n        ];\n        const cachedAssets = {\n            cacheKeys: cacheKeys,\n            keys: keys\n        };\n        keys.forEach((key2)=>{\n            this._cacheMap.set(key2, cachedAssets);\n        });\n        cacheKeys.forEach((key2)=>{\n            const val = cacheableAssets ? cacheableAssets[key2] : value;\n            if (this._cache.has(key2) && this._cache.get(key2) !== val) (0, $hUCK4.warn)(\"[Cache] already has key:\", key2);\n            this._cache.set(key2, cacheableMap.get(key2));\n        });\n    }\n    /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */ remove(key) {\n        if (!this._cacheMap.has(key)) {\n            (0, $hUCK4.warn)(`[Assets] Asset id ${key} was not found in the Cache`);\n            return;\n        }\n        const cacheMap = this._cacheMap.get(key);\n        const cacheKeys = cacheMap.cacheKeys;\n        cacheKeys.forEach((key2)=>{\n            this._cache.delete(key2);\n        });\n        cacheMap.keys.forEach((key2)=>{\n            this._cacheMap.delete(key2);\n        });\n    }\n    /** All loader parsers registered */ get parsers() {\n        return this._parsers;\n    }\n}\nconst $3d19110becfaeec3$export$94affb487e701bf2 = new $3d19110becfaeec3$var$CacheClass();\n\n});\nparcelRegister(\"3CHiv\", function(module, exports) {\n\n$parcel$export(module.exports, \"convertToList\", () => $93954259b3f62d4e$export$b01be8e180bf3d9b);\n\"use strict\";\nconst $93954259b3f62d4e$export$b01be8e180bf3d9b = (input, transform, forceTransform = false)=>{\n    if (!Array.isArray(input)) input = [\n        input\n    ];\n    if (!transform) return input;\n    return input.map((item)=>{\n        if (typeof item === \"string\" || forceTransform) return transform(item);\n        return item;\n    });\n};\n\n});\n\n\n\n\nparcelRegister(\"4RJM2\", function(module, exports) {\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $8PDkK = parcelRequire(\"8PDkK\");\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $8PDkK.spritesheetAsset));\n\n});\nparcelRegister(\"8PDkK\", function(module, exports) {\n\n$parcel$export(module.exports, \"spritesheetAsset\", () => $a322641177c54ad8$export$46dcda4f1cdd80fe);\n\nvar $iEtN5 = parcelRequire(\"iEtN5\");\n\nvar $8kCsw = parcelRequire(\"8kCsw\");\n\nvar $5Oad7 = parcelRequire(\"5Oad7\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $lzfZe = parcelRequire(\"lzfZe\");\n\nvar $58WFl = parcelRequire(\"58WFl\");\n\"use strict\";\nconst $a322641177c54ad8$var$validImages = [\n    \"jpg\",\n    \"png\",\n    \"jpeg\",\n    \"avif\",\n    \"webp\",\n    \"basis\",\n    \"etc2\",\n    \"bc7\",\n    \"bc6h\",\n    \"bc5\",\n    \"bc4\",\n    \"bc3\",\n    \"bc2\",\n    \"bc1\",\n    \"eac\",\n    \"astc\"\n];\nfunction $a322641177c54ad8$var$getCacheableAssets(keys, asset, ignoreMultiPack) {\n    const out = {};\n    keys.forEach((key)=>{\n        out[key] = asset;\n    });\n    Object.keys(asset.textures).forEach((key)=>{\n        out[key] = asset.textures[key];\n    });\n    if (!ignoreMultiPack) {\n        const basePath = (0, $lzfZe.path).dirname(keys[0]);\n        asset.linkedSheets.forEach((item, i)=>{\n            const out2 = $a322641177c54ad8$var$getCacheableAssets([\n                `${basePath}/${asset.data.meta.related_multi_packs[i]}`\n            ], item, true);\n            Object.assign(out, out2);\n        });\n    }\n    return out;\n}\nconst $a322641177c54ad8$export$46dcda4f1cdd80fe = {\n    extension: (0, $i9BKe.ExtensionType).Asset,\n    /** Handle the caching of the related Spritesheet Textures */ cache: {\n        test: (asset)=>asset instanceof (0, $58WFl.Spritesheet),\n        getCacheableAssets: (keys, asset)=>$a322641177c54ad8$var$getCacheableAssets(keys, asset, false)\n    },\n    /** Resolve the resolution of the asset. */ resolver: {\n        test: (value)=>{\n            const tempURL = value.split(\"?\")[0];\n            const split = tempURL.split(\".\");\n            const extension = split.pop();\n            const format = split.pop();\n            return extension === \"json\" && $a322641177c54ad8$var$validImages.includes(format);\n        },\n        parse: (value)=>{\n            const split = value.split(\".\");\n            return {\n                resolution: parseFloat((0, $8kCsw.Resolver).RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n                format: split[split.length - 2],\n                src: value\n            };\n        }\n    },\n    /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */ loader: {\n        name: \"spritesheetLoader\",\n        extension: {\n            type: (0, $i9BKe.ExtensionType).LoadParser,\n            priority: (0, $iEtN5.LoaderParserPriority).Normal\n        },\n        async testParse (asset, options) {\n            return (0, $lzfZe.path).extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n        },\n        async parse (asset, options, loader) {\n            const { texture: imageTexture, imageFilename: // if user need to use preloaded texture\n            imageFilename } = options?.data ?? {};\n            let basePath = (0, $lzfZe.path).dirname(options.src);\n            if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) basePath += \"/\";\n            let texture;\n            if (imageTexture instanceof (0, $bLlTJ.Texture)) texture = imageTexture;\n            else {\n                const imagePath = (0, $5Oad7.copySearchParams)(basePath + (imageFilename ?? asset.meta.image), options.src);\n                const assets = await loader.load([\n                    imagePath\n                ]);\n                texture = assets[imagePath];\n            }\n            const spritesheet = new (0, $58WFl.Spritesheet)(texture.source, asset);\n            await spritesheet.parse();\n            const multiPacks = asset?.meta?.related_multi_packs;\n            if (Array.isArray(multiPacks)) {\n                const promises = [];\n                for (const item of multiPacks){\n                    if (typeof item !== \"string\") continue;\n                    let itemUrl = basePath + item;\n                    if (options.data?.ignoreMultiPack) continue;\n                    itemUrl = (0, $5Oad7.copySearchParams)(itemUrl, options.src);\n                    promises.push(loader.load({\n                        src: itemUrl,\n                        data: {\n                            ignoreMultiPack: true\n                        }\n                    }));\n                }\n                const res = await Promise.all(promises);\n                spritesheet.linkedSheets = res;\n                res.forEach((item)=>{\n                    item.linkedSheets = [\n                        spritesheet\n                    ].concat(spritesheet.linkedSheets.filter((sp)=>sp !== item));\n                });\n            }\n            return spritesheet;\n        },\n        async unload (spritesheet, _resolvedAsset, loader) {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n            spritesheet.destroy(false);\n        }\n    }\n};\n\n});\nparcelRegister(\"iEtN5\", function(module, exports) {\n\n$parcel$export(module.exports, \"LoaderParserPriority\", () => $29ed14ceb032dea6$export$820ed6348c4f2750);\n\"use strict\";\nvar $29ed14ceb032dea6$export$820ed6348c4f2750 = /* @__PURE__ */ ((LoaderParserPriority2)=>{\n    LoaderParserPriority2[LoaderParserPriority2[\"Low\"] = 0] = \"Low\";\n    LoaderParserPriority2[LoaderParserPriority2[\"Normal\"] = 1] = \"Normal\";\n    LoaderParserPriority2[LoaderParserPriority2[\"High\"] = 2] = \"High\";\n    return LoaderParserPriority2;\n})($29ed14ceb032dea6$export$820ed6348c4f2750 || {});\n\n});\n\nparcelRegister(\"8kCsw\", function(module, exports) {\n\n$parcel$export(module.exports, \"Resolver\", () => $23cc1cafdfe05125$export$8b4c839865b08288);\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $lzfZe = parcelRequire(\"lzfZe\");\n\nvar $3CHiv = parcelRequire(\"3CHiv\");\n\nvar $8F3vm = parcelRequire(\"8F3vm\");\n\nvar $4DmkB = parcelRequire(\"4DmkB\");\n\"use strict\";\nclass $23cc1cafdfe05125$export$8b4c839865b08288 {\n    constructor(){\n        this._defaultBundleIdentifierOptions = {\n            connector: \"-\",\n            createBundleAssetId: (bundleId, assetId)=>`${bundleId}${this._bundleIdConnector}${assetId}`,\n            extractAssetIdFromBundle: (bundleId, assetBundleId)=>assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n        };\n        /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */ this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n        /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */ this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n        /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */ this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n        this._assetMap = {};\n        this._preferredOrder = [];\n        this._parsers = [];\n        this._resolverHash = {};\n        this._bundles = {};\n    }\n    /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */ setBundleIdentifier(bundleIdentifier) {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n        if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n    /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */ prefer(...preferOrders) {\n        preferOrders.forEach((prefer)=>{\n            this._preferredOrder.push(prefer);\n            if (!prefer.priority) prefer.priority = Object.keys(prefer.params);\n        });\n        this._resolverHash = {};\n    }\n    /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */ set basePath(basePath) {\n        this._basePath = basePath;\n    }\n    get basePath() {\n        return this._basePath;\n    }\n    /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */ set rootPath(rootPath) {\n        this._rootPath = rootPath;\n    }\n    get rootPath() {\n        return this._rootPath;\n    }\n    /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */ get parsers() {\n        return this._parsers;\n    }\n    /** Used for testing, this resets the resolver to its initial state */ reset() {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n        this._assetMap = {};\n        this._preferredOrder = [];\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n    /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */ setDefaultSearchParams(searchParams) {\n        if (typeof searchParams === \"string\") this._defaultSearchParams = searchParams;\n        else {\n            const queryValues = searchParams;\n            this._defaultSearchParams = Object.keys(queryValues).map((key)=>`${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n        }\n    }\n    /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */ getAlias(asset) {\n        const { alias: alias, src: src } = asset;\n        const aliasesToUse = (0, $3CHiv.convertToList)(alias || src, (value)=>{\n            if (typeof value === \"string\") return value;\n            if (Array.isArray(value)) return value.map((v)=>v?.src ?? v);\n            if (value?.src) return value.src;\n            return value;\n        }, true);\n        return aliasesToUse;\n    }\n    /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */ addManifest(manifest) {\n        if (this._manifest) (0, $hUCK4.warn)(\"[Resolver] Manifest already exists, this will be overwritten\");\n        this._manifest = manifest;\n        manifest.bundles.forEach((bundle)=>{\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n    /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */ addBundle(bundleId, assets) {\n        const assetNames = [];\n        let convertedAssets = assets;\n        if (!Array.isArray(assets)) convertedAssets = Object.entries(assets).map(([alias, src])=>{\n            if (typeof src === \"string\" || Array.isArray(src)) return {\n                alias: alias,\n                src: src\n            };\n            return {\n                alias: alias,\n                ...src\n            };\n        });\n        convertedAssets.forEach((asset)=>{\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids;\n            if (typeof aliases === \"string\") {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n                assetNames.push(bundleAssetId);\n                ids = [\n                    aliases,\n                    bundleAssetId\n                ];\n            } else {\n                const bundleIds = aliases.map((name)=>this._createBundleAssetId(bundleId, name));\n                assetNames.push(...bundleIds);\n                ids = [\n                    ...aliases,\n                    ...bundleIds\n                ];\n            }\n            this.add({\n                ...asset,\n                alias: ids,\n                src: srcs\n            });\n        });\n        this._bundles[bundleId] = assetNames;\n    }\n    /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */ add(aliases) {\n        const assets = [];\n        if (Array.isArray(aliases)) assets.push(...aliases);\n        else assets.push(aliases);\n        let keyCheck;\n        keyCheck = (key)=>{\n            if (this.hasKey(key)) (0, $hUCK4.warn)(`[Resolver] already has key: ${key} overwriting`);\n        };\n        const assetArray = (0, $3CHiv.convertToList)(assets);\n        assetArray.forEach((asset)=>{\n            const { src: src } = asset;\n            let { data: data, format: format, loadParser: loadParser } = asset;\n            const srcsToUse = (0, $3CHiv.convertToList)(src).map((src2)=>{\n                if (typeof src2 === \"string\") return (0, $8F3vm.createStringVariations)(src2);\n                return Array.isArray(src2) ? src2 : [\n                    src2\n                ];\n            });\n            const aliasesToUse = this.getAlias(asset);\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            const resolvedAssets = [];\n            srcsToUse.forEach((srcs)=>{\n                srcs.forEach((src2)=>{\n                    let formattedAsset = {};\n                    if (typeof src2 !== \"object\") {\n                        formattedAsset.src = src2;\n                        for(let i = 0; i < this._parsers.length; i++){\n                            const parser = this._parsers[i];\n                            if (parser.test(src2)) {\n                                formattedAsset = parser.parse(src2);\n                                break;\n                            }\n                        }\n                    } else {\n                        data = src2.data ?? data;\n                        format = src2.format ?? format;\n                        loadParser = src2.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src2\n                        };\n                    }\n                    if (!aliasesToUse) throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data: data,\n                        format: format,\n                        loadParser: loadParser\n                    });\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n            aliasesToUse.forEach((alias)=>{\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n    // TODO: this needs an overload like load did in Assets\n    /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */ resolveBundle(bundleIds) {\n        const singleAsset = (0, $4DmkB.isSingleItem)(bundleIds);\n        bundleIds = (0, $3CHiv.convertToList)(bundleIds);\n        const out = {};\n        bundleIds.forEach((bundleId)=>{\n            const assetNames = this._bundles[bundleId];\n            if (assetNames) {\n                const results = this.resolve(assetNames);\n                const assets = {};\n                for(const key in results){\n                    const asset = results[key];\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n                out[bundleId] = assets;\n            }\n        });\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n    /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */ resolveUrl(key) {\n        const result = this.resolve(key);\n        if (typeof key !== \"string\") {\n            const out = {};\n            for(const i in result)out[i] = result[i].src;\n            return out;\n        }\n        return result.src;\n    }\n    resolve(keys) {\n        const singleAsset = (0, $4DmkB.isSingleItem)(keys);\n        keys = (0, $3CHiv.convertToList)(keys);\n        const result = {};\n        keys.forEach((key)=>{\n            if (!this._resolverHash[key]) {\n                if (this._assetMap[key]) {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n                    preferredOrder?.priority.forEach((priorityKey)=>{\n                        preferredOrder.params[priorityKey].forEach((value)=>{\n                            const filteredAssets = assets.filter((asset)=>{\n                                if (asset[priorityKey]) return asset[priorityKey] === value;\n                                return false;\n                            });\n                            if (filteredAssets.length) assets = filteredAssets;\n                        });\n                    });\n                    this._resolverHash[key] = assets[0];\n                } else this._resolverHash[key] = this._buildResolvedAsset({\n                    alias: [\n                        key\n                    ],\n                    src: key\n                }, {});\n            }\n            result[key] = this._resolverHash[key];\n        });\n        return singleAsset ? result[keys[0]] : result;\n    }\n    /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */ hasKey(key) {\n        return !!this._assetMap[key];\n    }\n    /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */ hasBundle(key) {\n        return !!this._bundles[key];\n    }\n    /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */ _getPreferredOrder(assets) {\n        for(let i = 0; i < assets.length; i++){\n            const asset = assets[0];\n            const preferred = this._preferredOrder.find((preference)=>preference.params.format.includes(asset.format));\n            if (preferred) return preferred;\n        }\n        return this._preferredOrder[0];\n    }\n    /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */ _appendDefaultSearchParams(url) {\n        if (!this._defaultSearchParams) return url;\n        const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n    _buildResolvedAsset(formattedAsset, data) {\n        const { aliases: aliases, data: assetData, loadParser: loadParser, format: format } = data;\n        if (this._basePath || this._rootPath) formattedAsset.src = (0, $lzfZe.path).toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [\n            formattedAsset.src\n        ];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = {\n            ...assetData || {},\n            ...formattedAsset.data\n        };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? $23cc1cafdfe05125$export$4bb0ea38086a2ed5(formattedAsset.src);\n        return formattedAsset;\n    }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */ $23cc1cafdfe05125$export$8b4c839865b08288.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction $23cc1cafdfe05125$export$4bb0ea38086a2ed5(url) {\n    return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\n});\nparcelRegister(\"lzfZe\", function(module, exports) {\n\n$parcel$export(module.exports, \"path\", () => $3c67d20d89e3898c$export$bb654e07daaf8c3a);\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\"use strict\";\nfunction $3c67d20d89e3898c$var$assertPath(path2) {\n    if (typeof path2 !== \"string\") throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n}\nfunction $3c67d20d89e3898c$var$removeUrlParams(url) {\n    const re = url.split(\"?\")[0];\n    return re.split(\"#\")[0];\n}\nfunction $3c67d20d89e3898c$var$escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction $3c67d20d89e3898c$var$replaceAll(str, find, replace) {\n    return str.replace(new RegExp($3c67d20d89e3898c$var$escapeRegExp(find), \"g\"), replace);\n}\nfunction $3c67d20d89e3898c$var$normalizeStringPosix(path2, allowAboveRoot) {\n    let res = \"\";\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n    for(let i = 0; i <= path2.length; ++i){\n        if (i < path2.length) code = path2.charCodeAt(i);\n        else if (code === 47) break;\n        else code = 47;\n        if (code === 47) {\n            if (lastSlash === i - 1 || dots === 1) ;\n            else if (lastSlash !== i - 1 && dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(\"/\");\n                        if (lastSlashIndex !== res.length - 1) {\n                            if (lastSlashIndex === -1) {\n                                res = \"\";\n                                lastSegmentLength = 0;\n                            } else {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    } else if (res.length === 2 || res.length === 1) {\n                        res = \"\";\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    if (res.length > 0) res += \"/..\";\n                    else res = \"..\";\n                    lastSegmentLength = 2;\n                }\n            } else {\n                if (res.length > 0) res += `/${path2.slice(lastSlash + 1, i)}`;\n                else res = path2.slice(lastSlash + 1, i);\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        } else if (code === 46 && dots !== -1) ++dots;\n        else dots = -1;\n    }\n    return res;\n}\nconst $3c67d20d89e3898c$export$bb654e07daaf8c3a = {\n    /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */ toPosix (path2) {\n        return $3c67d20d89e3898c$var$replaceAll(path2, \"\\\\\", \"/\");\n    },\n    /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */ isUrl (path2) {\n        return /^https?:/.test(this.toPosix(path2));\n    },\n    /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */ isDataUrl (path2) {\n        return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n    },\n    /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */ isBlobUrl (path2) {\n        return path2.startsWith(\"blob:\");\n    },\n    /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */ hasProtocol (path2) {\n        return /^[^/:]+:/.test(this.toPosix(path2));\n    },\n    /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */ getProtocol (path2) {\n        $3c67d20d89e3898c$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        const matchFile = /^file:\\/\\/\\//.exec(path2);\n        if (matchFile) return matchFile[0];\n        const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n        if (matchProtocol) return matchProtocol[0];\n        return \"\";\n    },\n    /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */ toAbsolute (url, customBaseUrl, customRootUrl) {\n        $3c67d20d89e3898c$var$assertPath(url);\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n        const baseUrl = $3c67d20d89e3898c$var$removeUrlParams(this.toPosix(customBaseUrl ?? (0, $iCGeI.DOMAdapter).get().getBaseUrl()));\n        const rootUrl = $3c67d20d89e3898c$var$removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n        url = this.toPosix(url);\n        if (url.startsWith(\"/\")) return $3c67d20d89e3898c$export$bb654e07daaf8c3a.join(rootUrl, url.slice(1));\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n        return absolutePath;\n    },\n    /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */ normalize (path2) {\n        $3c67d20d89e3898c$var$assertPath(path2);\n        if (path2.length === 0) return \".\";\n        if (this.isDataUrl(path2) || this.isBlobUrl(path2)) return path2;\n        path2 = this.toPosix(path2);\n        let protocol = \"\";\n        const isAbsolute = path2.startsWith(\"/\");\n        if (this.hasProtocol(path2)) {\n            protocol = this.rootname(path2);\n            path2 = path2.slice(protocol.length);\n        }\n        const trailingSeparator = path2.endsWith(\"/\");\n        path2 = $3c67d20d89e3898c$var$normalizeStringPosix(path2, false);\n        if (path2.length > 0 && trailingSeparator) path2 += \"/\";\n        if (isAbsolute) return `/${path2}`;\n        return protocol + path2;\n    },\n    /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */ isAbsolute (path2) {\n        $3c67d20d89e3898c$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        if (this.hasProtocol(path2)) return true;\n        return path2.startsWith(\"/\");\n    },\n    /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */ join (...segments) {\n        if (segments.length === 0) return \".\";\n        let joined;\n        for(let i = 0; i < segments.length; ++i){\n            const arg = segments[i];\n            $3c67d20d89e3898c$var$assertPath(arg);\n            if (arg.length > 0) {\n                if (joined === void 0) joined = arg;\n                else {\n                    const prevArg = segments[i - 1] ?? \"\";\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) joined += `/../${arg}`;\n                    else joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === void 0) return \".\";\n        return this.normalize(joined);\n    },\n    /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */ dirname (path2) {\n        $3c67d20d89e3898c$var$assertPath(path2);\n        if (path2.length === 0) return \".\";\n        path2 = this.toPosix(path2);\n        let code = path2.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n        const proto = this.getProtocol(path2);\n        const origpath = path2;\n        path2 = path2.slice(proto.length);\n        for(let i = path2.length - 1; i >= 1; --i){\n            code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            } else matchedSlash = false;\n        }\n        if (end === -1) return hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto;\n        if (hasRoot && end === 1) return \"//\";\n        return proto + path2.slice(0, end);\n    },\n    /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */ rootname (path2) {\n        $3c67d20d89e3898c$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        let root = \"\";\n        if (path2.startsWith(\"/\")) root = \"/\";\n        else root = this.getProtocol(path2);\n        if (this.isUrl(path2)) {\n            const index = path2.indexOf(\"/\", root.length);\n            if (index !== -1) root = path2.slice(0, index);\n            else root = path2;\n            if (!root.endsWith(\"/\")) root += \"/\";\n        }\n        return root;\n    },\n    /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */ basename (path2, ext) {\n        $3c67d20d89e3898c$var$assertPath(path2);\n        if (ext) $3c67d20d89e3898c$var$assertPath(ext);\n        path2 = $3c67d20d89e3898c$var$removeUrlParams(this.toPosix(path2));\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n            if (ext.length === path2.length && ext === path2) return \"\";\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for(i = path2.length - 1; i >= 0; --i){\n                const code = path2.charCodeAt(i);\n                if (code === 47) {\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                } else {\n                    if (firstNonSlashEnd === -1) {\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) end = i;\n                        } else {\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) end = firstNonSlashEnd;\n            else if (end === -1) end = path2.length;\n            return path2.slice(start, end);\n        }\n        for(i = path2.length - 1; i >= 0; --i){\n            if (path2.charCodeAt(i) === 47) {\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            } else if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) return \"\";\n        return path2.slice(start, end);\n    },\n    /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */ extname (path2) {\n        $3c67d20d89e3898c$var$assertPath(path2);\n        path2 = $3c67d20d89e3898c$var$removeUrlParams(this.toPosix(path2));\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let preDotState = 0;\n        for(let i = path2.length - 1; i >= 0; --i){\n            const code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46) {\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            } else if (startDot !== -1) preDotState = -1;\n        }\n        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return \"\";\n        return path2.slice(startDot, end);\n    },\n    /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */ parse (path2) {\n        $3c67d20d89e3898c$var$assertPath(path2);\n        const ret = {\n            root: \"\",\n            dir: \"\",\n            base: \"\",\n            ext: \"\",\n            name: \"\"\n        };\n        if (path2.length === 0) return ret;\n        path2 = $3c67d20d89e3898c$var$removeUrlParams(this.toPosix(path2));\n        let code = path2.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path2);\n        let start;\n        const protocol = \"\";\n        ret.root = this.rootname(path2);\n        if (isAbsolute || this.hasProtocol(path2)) start = 1;\n        else start = 0;\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path2.length - 1;\n        let preDotState = 0;\n        for(; i >= start; --i){\n            code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46) {\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            } else if (startDot !== -1) preDotState = -1;\n        }\n        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n            if (end !== -1) {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end);\n                else ret.base = ret.name = path2.slice(startPart, end);\n            }\n        } else {\n            if (startPart === 0 && isAbsolute) {\n                ret.name = path2.slice(1, startDot);\n                ret.base = path2.slice(1, end);\n            } else {\n                ret.name = path2.slice(startPart, startDot);\n                ret.base = path2.slice(startPart, end);\n            }\n            ret.ext = path2.slice(startDot, end);\n        }\n        ret.dir = this.dirname(path2);\n        if (protocol) ret.dir = protocol + ret.dir;\n        return ret;\n    },\n    sep: \"/\",\n    delimiter: \":\",\n    joinExtensions: [\n        \".html\"\n    ]\n};\n\n});\n\nparcelRegister(\"8F3vm\", function(module, exports) {\n\n$parcel$export(module.exports, \"createStringVariations\", () => $fde1bf5bcf60c2d9$export$738117acc6638004);\n\"use strict\";\nfunction $fde1bf5bcf60c2d9$var$processX(base, ids, depth, result, tags) {\n    const id = ids[depth];\n    for(let i = 0; i < id.length; i++){\n        const value = id[i];\n        if (depth < ids.length - 1) $fde1bf5bcf60c2d9$var$processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        else tags.push(base.replace(result[depth], value));\n    }\n}\nfunction $fde1bf5bcf60c2d9$export$738117acc6638004(string) {\n    const regex = /\\{(.*?)\\}/g;\n    const result = string.match(regex);\n    const tags = [];\n    if (result) {\n        const ids = [];\n        result.forEach((vars)=>{\n            const split = vars.substring(1, vars.length - 1).split(\",\");\n            ids.push(split);\n        });\n        $fde1bf5bcf60c2d9$var$processX(string, ids, 0, result, tags);\n    } else tags.push(string);\n    return tags;\n}\n\n});\n\nparcelRegister(\"4DmkB\", function(module, exports) {\n\n$parcel$export(module.exports, \"isSingleItem\", () => $f373b2ad881b3255$export$16a80d27953452d4);\n\"use strict\";\nconst $f373b2ad881b3255$export$16a80d27953452d4 = (item)=>!Array.isArray(item);\n\n});\n\n\nparcelRegister(\"5Oad7\", function(module, exports) {\n\n$parcel$export(module.exports, \"copySearchParams\", () => $273b4a26d8a43536$export$f57b97ef8be10dda);\n\"use strict\";\nconst $273b4a26d8a43536$export$f57b97ef8be10dda = (targetUrl, sourceUrl)=>{\n    const searchParams = sourceUrl.split(\"?\")[1];\n    if (searchParams) targetUrl += `?${searchParams}`;\n    return targetUrl;\n};\n\n});\n\nparcelRegister(\"58WFl\", function(module, exports) {\n\n$parcel$export(module.exports, \"Spritesheet\", () => $9c38ec259f91df14$export$674d2eb4debbef0c);\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\"use strict\";\nconst $9c38ec259f91df14$var$_Spritesheet = class _Spritesheet {\n    /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */ constructor(texture, data){\n        /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */ this.linkedSheets = [];\n        this._texture = texture instanceof (0, $bLlTJ.Texture) ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {};\n        this.animations = {};\n        this.data = data;\n        const metaResolution = parseFloat(data.meta.scale);\n        if (metaResolution) {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        } else this.resolution = texture.source._resolution;\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n    /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */ parse() {\n        return new Promise((resolve)=>{\n            this._callback = resolve;\n            this._batchIndex = 0;\n            if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            } else this._nextBatch();\n        });\n    }\n    /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */ _processFrames(initialFrameIndex) {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = _Spritesheet.BATCH_SIZE;\n        while(frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length){\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n            if (rect) {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n                const orig = new (0, $fM4Mk.Rectangle)(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n                if (data.rotated) frame = new (0, $fM4Mk.Rectangle)(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n                else frame = new (0, $fM4Mk.Rectangle)(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n                if (data.trimmed !== false && data.spriteSourceSize) trim = new (0, $fM4Mk.Rectangle)(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n                this.textures[i] = new (0, $bLlTJ.Texture)({\n                    source: this.textureSource,\n                    frame: frame,\n                    orig: orig,\n                    trim: trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n                    label: i.toString()\n                });\n            }\n            frameIndex++;\n        }\n    }\n    /** Parse animations config. */ _processAnimations() {\n        const animations = this.data.animations || {};\n        for(const animName in animations){\n            this.animations[animName] = [];\n            for(let i = 0; i < animations[animName].length; i++){\n                const frameName = animations[animName][i];\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n    /** The parse has completed. */ _parseComplete() {\n        const callback = this._callback;\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n    /** Begin the next batch of textures. */ _nextBatch() {\n        this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(()=>{\n            if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) this._nextBatch();\n            else {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n    /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */ destroy(destroyBase = false) {\n        for(const i in this.textures)this.textures[i].destroy();\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase) {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n};\n/** The maximum number of Textures to build per process. */ $9c38ec259f91df14$var$_Spritesheet.BATCH_SIZE = 1e3;\nlet $9c38ec259f91df14$export$674d2eb4debbef0c = $9c38ec259f91df14$var$_Spritesheet;\n\n});\n\n\n\nparcelRegister(\"3UUq4\", function(module, exports) {\n\n$parcel$export(module.exports, \"AbstractRenderer\", () => $453fded98f054a94$export$58ab3ed211eed562);\n\nvar $a2eTA = parcelRequire(\"a2eTA\");\n\nvar $eicwU = parcelRequire(\"eicwU\");\n\nvar $cJHPn = parcelRequire(\"cJHPn\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\n\nvar $hFYOq = parcelRequire(\"hFYOq\");\n\nvar $gtbjr = parcelRequire(\"gtbjr\");\n\nvar $3vRz3 = parcelRequire(\"3vRz3\");\n\"use strict\";\nconst $453fded98f054a94$var$defaultRunners = [\n    \"init\",\n    \"destroy\",\n    \"contextChange\",\n    \"resolutionChange\",\n    \"reset\",\n    \"renderEnd\",\n    \"renderStart\",\n    \"render\",\n    \"update\",\n    \"postrender\",\n    \"prerender\"\n];\nconst $453fded98f054a94$var$_AbstractRenderer = class _AbstractRenderer extends (0, (/*@__PURE__*/$parcel$interopDefault($3vRz3))) {\n    /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */ constructor(config){\n        super();\n        this.runners = /* @__PURE__ */ Object.create(null);\n        this.renderPipes = /* @__PURE__ */ Object.create(null);\n        this._initOptions = {};\n        this._systemsHash = /* @__PURE__ */ Object.create(null);\n        this.type = config.type;\n        this.name = config.name;\n        const combinedRunners = [\n            ...$453fded98f054a94$var$defaultRunners,\n            ...config.runners ?? []\n        ];\n        this._addRunners(...combinedRunners);\n        this._addSystems(config.systems);\n        this._addPipes(config.renderPipes, config.renderPipeAdaptors);\n        this._unsafeEvalCheck();\n    }\n    /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */ async init(options = {}) {\n        for(const systemName in this._systemsHash){\n            const system = this._systemsHash[systemName];\n            const defaultSystemOptions = system.constructor.defaultOptions;\n            options = {\n                ...defaultSystemOptions,\n                ...options\n            };\n        }\n        options = {\n            ..._AbstractRenderer.defaultOptions,\n            ...options\n        };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n        for(let i = 0; i < this.runners.init.items.length; i++)await this.runners.init.items[i].init(options);\n        this._initOptions = options;\n    }\n    render(args, deprecated) {\n        let options = args;\n        if (options instanceof (0, $eicwU.Container)) {\n            options = {\n                container: options\n            };\n            if (deprecated) {\n                (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"passing a second argument is deprecated, please use render options instead\");\n                options.target = deprecated.renderTexture;\n            }\n        }\n        options.target || (options.target = this.view.renderTarget);\n        if (options.target === this.view.renderTarget) {\n            this._lastObjectRendered = options.container;\n            options.clearColor = this.background.colorRgba;\n        }\n        if (options.clearColor) {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n            options.clearColor = isRGBAArray ? options.clearColor : (0, $a2eTA.Color).shared.setValue(options.clearColor).toArray();\n        }\n        if (!options.transform) {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n    /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */ resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit(\"resize\", this.view.screen.width, this.view.screen.height);\n    }\n    clear(options = {}) {\n        const renderer = this;\n        options.target || (options.target = renderer.renderTarget.renderTarget);\n        options.clearColor || (options.clearColor = this.background.colorRgba);\n        options.clear ?? (options.clear = (0, $hFYOq.CLEAR).ALL);\n        const { clear: clear, clearColor: clearColor, target: target } = options;\n        (0, $a2eTA.Color).shared.setValue(clearColor ?? this.background.colorRgba);\n        renderer.renderTarget.clear(target, clear, (0, $a2eTA.Color).shared.toArray());\n    }\n    /** The resolution / device pixel ratio of the renderer. */ get resolution() {\n        return this.view.resolution;\n    }\n    set resolution(value) {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n    /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */ get width() {\n        return this.view.texture.frame.width;\n    }\n    /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */ get height() {\n        return this.view.texture.frame.height;\n    }\n    // NOTE: this was `view` in v7\n    /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */ get canvas() {\n        return this.view.canvas;\n    }\n    /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */ get lastObjectRendered() {\n        return this._lastObjectRendered;\n    }\n    /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */ get renderingToScreen() {\n        const renderer = this;\n        return renderer.renderTarget.renderingToScreen;\n    }\n    /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */ get screen() {\n        return this.view.screen;\n    }\n    /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */ _addRunners(...runnerIds) {\n        runnerIds.forEach((runnerId)=>{\n            this.runners[runnerId] = new (0, $gtbjr.SystemRunner)(runnerId);\n        });\n    }\n    _addSystems(systems) {\n        let i;\n        for(i in systems){\n            const val = systems[i];\n            this._addSystem(val.value, val.name);\n        }\n    }\n    /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn't collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */ _addSystem(ClassRef, name) {\n        const system = new ClassRef(this);\n        if (this[name]) throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        this[name] = system;\n        this._systemsHash[name] = system;\n        for(const i in this.runners)this.runners[i].add(system);\n        return this;\n    }\n    _addPipes(pipes, pipeAdaptors) {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor)=>{\n            acc[adaptor.name] = adaptor.value;\n            return acc;\n        }, {});\n        pipes.forEach((pipe)=>{\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n            const Adaptor = adaptors[name];\n            this.renderPipes[name] = new PipeClass(this, Adaptor ? new Adaptor() : null);\n        });\n    }\n    destroy(options = false) {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n        Object.values(this.runners).forEach((runner)=>{\n            runner.destroy();\n        });\n        this._systemsHash = null;\n        this.renderPipes = null;\n    }\n    /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */ generateTexture(options) {\n        return this.textureGenerator.generateTexture(options);\n    }\n    /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */ get roundPixels() {\n        return !!this._roundPixels;\n    }\n    /**\n   * Overrideable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   * @ignore\n   */ _unsafeEvalCheck() {\n        if (!(0, $cJHPn.unsafeEvalSupported)()) throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n};\n/** The default options for the renderer. */ $453fded98f054a94$var$_AbstractRenderer.defaultOptions = {\n    /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */ resolution: 1,\n    /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */ failIfMajorPerformanceCaveat: false,\n    /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */ roundPixels: false\n};\nlet $453fded98f054a94$export$58ab3ed211eed562 = $453fded98f054a94$var$_AbstractRenderer;\n\n});\nparcelRegister(\"cJHPn\", function(module, exports) {\n\n$parcel$export(module.exports, \"unsafeEvalSupported\", () => $d88536e9c61409d6$export$70c0711f29adc5cf);\n\"use strict\";\nlet $d88536e9c61409d6$var$unsafeEval;\nfunction $d88536e9c61409d6$export$70c0711f29adc5cf() {\n    if (typeof $d88536e9c61409d6$var$unsafeEval === \"boolean\") return $d88536e9c61409d6$var$unsafeEval;\n    try {\n        const func = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n        $d88536e9c61409d6$var$unsafeEval = func({\n            a: \"b\"\n        }, \"a\", \"b\") === true;\n    } catch (e) {\n        $d88536e9c61409d6$var$unsafeEval = false;\n    }\n    return $d88536e9c61409d6$var$unsafeEval;\n}\n\n});\n\nparcelRegister(\"hFYOq\", function(module, exports) {\n\n$parcel$export(module.exports, \"CLEAR\", () => $bdcaad22b468ed1b$export$6c4d37c7f376a1de);\n\"use strict\";\nvar $bdcaad22b468ed1b$export$6c4d37c7f376a1de = /* @__PURE__ */ ((CLEAR2)=>{\n    CLEAR2[CLEAR2[\"NONE\"] = 0] = \"NONE\";\n    CLEAR2[CLEAR2[\"COLOR\"] = 16384] = \"COLOR\";\n    CLEAR2[CLEAR2[\"STENCIL\"] = 1024] = \"STENCIL\";\n    CLEAR2[CLEAR2[\"DEPTH\"] = 256] = \"DEPTH\";\n    CLEAR2[CLEAR2[\"COLOR_DEPTH\"] = 16640] = \"COLOR_DEPTH\";\n    CLEAR2[CLEAR2[\"COLOR_STENCIL\"] = 17408] = \"COLOR_STENCIL\";\n    CLEAR2[CLEAR2[\"DEPTH_STENCIL\"] = 1280] = \"DEPTH_STENCIL\";\n    CLEAR2[CLEAR2[\"ALL\"] = 17664] = \"ALL\";\n    return CLEAR2;\n})($bdcaad22b468ed1b$export$6c4d37c7f376a1de || {});\n\n});\n\nparcelRegister(\"gtbjr\", function(module, exports) {\n\n$parcel$export(module.exports, \"SystemRunner\", () => $299af1a7d2dd4105$export$ff5f2fe687fe3979);\n\"use strict\";\nclass $299af1a7d2dd4105$export$ff5f2fe687fe3979 {\n    /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */ constructor(name){\n        this.items = [];\n        this._name = name;\n    }\n    /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */ /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */ /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */ emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n        const { name: name, items: items } = this;\n        for(let i = 0, len = items.length; i < len; i++)items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        return this;\n    }\n    /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */ add(item) {\n        if (item[this._name]) {\n            this.remove(item);\n            this.items.push(item);\n        }\n        return this;\n    }\n    /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */ remove(item) {\n        const index = this.items.indexOf(item);\n        if (index !== -1) this.items.splice(index, 1);\n        return this;\n    }\n    /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */ contains(item) {\n        return this.items.indexOf(item) !== -1;\n    }\n    /** Remove all listeners from the Runner */ removeAll() {\n        this.items.length = 0;\n        return this;\n    }\n    /** Remove all references, don't use after this. */ destroy() {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n    /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */ get empty() {\n        return this.items.length === 0;\n    }\n    /**\n   * The name of the runner.\n   * @readonly\n   */ get name() {\n        return this._name;\n    }\n}\n\n});\n\n\nparcelRegister(\"2OFKu\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = Promise.all([\n    $Gr8vk(\"eNXth\"),\n    $Gr8vk(\"7OvPL\"),\n    $Gr8vk(\"aNM0B\")\n]).then(()=>parcelRequire(\"aIpib\"));\n\n});\n\nparcelRegister(\"dcZu1\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = Promise.all([\n    $Gr8vk(\"eNXth\"),\n    $Gr8vk(\"7OvPL\"),\n    $Gr8vk(\"7EYKF\")\n]).then(()=>parcelRequire(\"kpxDv\"));\n\n});\n\nparcelRegister(\"hFzkv\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsContextSystem\", () => $119fb8487ef4f791$export$f2f3ca33e4c65172);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $ixM8g = parcelRequire(\"ixM8g\");\n\nvar $beJMG = parcelRequire(\"beJMG\");\n\nvar $4rmMq = parcelRequire(\"4rmMq\");\n\nvar $dK5Jn = parcelRequire(\"dK5Jn\");\n\nvar $61KiY = parcelRequire(\"61KiY\");\n\nvar $1mKkK = parcelRequire(\"1mKkK\");\n\"use strict\";\nclass $119fb8487ef4f791$export$e3e348c254036d55 {\n    constructor(){\n        this.batches = [];\n        this.geometryData = {\n            vertices: [],\n            uvs: [],\n            indices: []\n        };\n    }\n}\nclass $119fb8487ef4f791$export$9b6a6c5b37fc8f49 {\n    constructor(){\n        this.geometry = new (0, $ixM8g.BatchGeometry)();\n        this.instructions = new (0, $dK5Jn.InstructionSet)();\n    }\n    init() {\n        this.instructions.reset();\n    }\n}\nconst $119fb8487ef4f791$var$_GraphicsContextSystem = class _GraphicsContextSystem {\n    constructor(){\n        // the root context batches, used to either make a batch or geometry\n        // all graphics use this as a base\n        this._activeBatchers = [];\n        this._gpuContextHash = {};\n        // used for non-batchable graphics\n        this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n        this._needsContextNeedsRebuild = [];\n    }\n    /**\n   * Runner init called, update the default options\n   * @ignore\n   */ init(options) {\n        _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n    prerender() {\n        this._returnActiveBatchers();\n    }\n    getContextRenderData(context) {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n    // Context management functions\n    updateGpuContext(context) {\n        let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n        if (context.dirty) {\n            if (gpuContext) this._cleanGraphicsContextData(context);\n            else gpuContext = this._initContext(context);\n            (0, $1mKkK.buildContextBatches)(context, gpuContext);\n            const batchMode = context.batchMode;\n            if (context.customShader || batchMode === \"no-batch\") gpuContext.isBatchable = false;\n            else if (batchMode === \"auto\") gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n            context.dirty = false;\n        }\n        return gpuContext;\n    }\n    getGpuContext(context) {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n    _returnActiveBatchers() {\n        for(let i = 0; i < this._activeBatchers.length; i++)(0, $61KiY.BigPool).return(this._activeBatchers[i]);\n        this._activeBatchers.length = 0;\n    }\n    _initContextRenderData(context) {\n        const graphicsData = (0, $61KiY.BigPool).get($119fb8487ef4f791$export$9b6a6c5b37fc8f49);\n        const { batches: batches, geometryData: geometryData } = this._gpuContextHash[context.uid];\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n        for(let i = 0; i < batches.length; i++)batches[i].applyTransform = false;\n        const batcher = (0, $61KiY.BigPool).get((0, $4rmMq.Batcher));\n        this._activeBatchers.push(batcher);\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n        batcher.begin();\n        for(let i = 0; i < batches.length; i++){\n            const batch = batches[i];\n            batcher.add(batch);\n        }\n        batcher.finish(graphicsData.instructions);\n        const geometry = graphicsData.geometry;\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n        const drawBatches = batcher.batches;\n        for(let i = 0; i < drawBatches.length; i++){\n            const batch = drawBatches[i];\n            batch.bindGroup = (0, $beJMG.getTextureBatchBindGroup)(batch.textures.textures, batch.textures.count);\n        }\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n        return graphicsData;\n    }\n    _initContext(context) {\n        const gpuContext = new $119fb8487ef4f791$export$e3e348c254036d55();\n        this._gpuContextHash[context.uid] = gpuContext;\n        context.on(\"update\", this.onGraphicsContextUpdate, this);\n        context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n        return this._gpuContextHash[context.uid];\n    }\n    onGraphicsContextUpdate(context) {\n        this._needsContextNeedsRebuild.push(context);\n    }\n    onGraphicsContextDestroy(context) {\n        this._cleanGraphicsContextData(context);\n        context.off(\"update\", this.onGraphicsContextUpdate, this);\n        context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n        this._gpuContextHash[context.uid] = null;\n    }\n    _cleanGraphicsContextData(context) {\n        const gpuContext = this._gpuContextHash[context.uid];\n        if (!gpuContext.isBatchable) {\n            if (this._graphicsDataContextHash[context.uid]) {\n                (0, $61KiY.BigPool).return(this.getContextRenderData(context));\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n        if (gpuContext.batches) gpuContext.batches.forEach((batch)=>{\n            (0, $61KiY.BigPool).return(batch);\n        });\n    }\n    destroy() {\n        for (const context of this._needsContextNeedsRebuild)if (this._gpuContextHash[context.uid]) this.onGraphicsContextDestroy(context);\n        this._needsContextNeedsRebuild.length = 0;\n    }\n};\n/** @ignore */ $119fb8487ef4f791$var$_GraphicsContextSystem.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem,\n        (0, $i9BKe.ExtensionType).WebGPUSystem,\n        (0, $i9BKe.ExtensionType).CanvasSystem\n    ],\n    name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */ $119fb8487ef4f791$var$_GraphicsContextSystem.defaultOptions = {\n    /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */ bezierSmoothness: 0.5\n};\nlet $119fb8487ef4f791$export$f2f3ca33e4c65172 = $119fb8487ef4f791$var$_GraphicsContextSystem;\n\n});\nparcelRegister(\"ixM8g\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchGeometry\", () => $21794e3cca2986f9$export$449e8d355fd68e43);\n\nvar $lvEAL = parcelRequire(\"lvEAL\");\n\nvar $1UZ6r = parcelRequire(\"1UZ6r\");\n\nvar $cOnev = parcelRequire(\"cOnev\");\n\"use strict\";\nconst $21794e3cca2986f9$var$placeHolderBufferData = new Float32Array(1);\nconst $21794e3cca2986f9$var$placeHolderIndexData = new Uint32Array(1);\nclass $21794e3cca2986f9$export$449e8d355fd68e43 extends (0, $cOnev.Geometry) {\n    constructor(){\n        const vertexSize = 6;\n        const attributeBuffer = new (0, $lvEAL.Buffer)({\n            data: $21794e3cca2986f9$var$placeHolderBufferData,\n            label: \"attribute-batch-buffer\",\n            usage: (0, $1UZ6r.BufferUsage).VERTEX | (0, $1UZ6r.BufferUsage).COPY_DST,\n            shrinkToFit: false\n        });\n        const indexBuffer = new (0, $lvEAL.Buffer)({\n            data: $21794e3cca2986f9$var$placeHolderIndexData,\n            label: \"index-batch-buffer\",\n            usage: (0, $1UZ6r.BufferUsage).INDEX | (0, $1UZ6r.BufferUsage).COPY_DST,\n            // | BufferUsage.STATIC,\n            shrinkToFit: false\n        });\n        const stride = vertexSize * 4;\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: \"float32x2\",\n                    stride: stride,\n                    offset: 0,\n                    location: 1\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: \"float32x2\",\n                    stride: stride,\n                    offset: 8,\n                    location: 3\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: \"unorm8x4\",\n                    stride: stride,\n                    offset: 16,\n                    location: 0\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: \"uint16x2\",\n                    stride: stride,\n                    offset: 20,\n                    location: 2\n                }\n            },\n            indexBuffer: indexBuffer\n        });\n    }\n}\n\n});\nparcelRegister(\"lvEAL\", function(module, exports) {\n\n$parcel$export(module.exports, \"Buffer\", () => $9841377a483d1ce7$export$a143d493d941bafc);\n\nvar $3vRz3 = parcelRequire(\"3vRz3\");\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\nvar $1UZ6r = parcelRequire(\"1UZ6r\");\n\"use strict\";\nclass $9841377a483d1ce7$export$a143d493d941bafc extends (0, (/*@__PURE__*/$parcel$interopDefault($3vRz3))) {\n    /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */ constructor(options){\n        let { data: data, size: size } = options;\n        const { usage: usage, label: label, shrinkToFit: shrinkToFit } = options;\n        super();\n        /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */ /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */ /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */ /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */ this.uid = (0, $aGJhg.uid)(\"buffer\");\n        /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */ this._resourceType = \"buffer\";\n        /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */ this._resourceId = (0, $aGJhg.uid)(\"resource\");\n        /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */ this._touched = 0;\n        /**\n     * @internal\n     * @ignore\n     */ this._updateID = 1;\n        /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */ this.shrinkToFit = true;\n        /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */ this.destroyed = false;\n        if (data instanceof Array) data = new Float32Array(data);\n        this._data = data;\n        size = size ?? data?.byteLength;\n        const mappedAtCreation = !!data;\n        this.descriptor = {\n            size: size,\n            usage: usage,\n            mappedAtCreation: mappedAtCreation,\n            label: label\n        };\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n    /** the data in the buffer */ get data() {\n        return this._data;\n    }\n    set data(value) {\n        this.setDataWithSize(value, value.length, true);\n    }\n    /** whether the buffer is static or not */ get static() {\n        return !!(this.descriptor.usage & (0, $1UZ6r.BufferUsage).STATIC);\n    }\n    set static(value) {\n        if (value) this.descriptor.usage |= (0, $1UZ6r.BufferUsage).STATIC;\n        else this.descriptor.usage &= ~(0, $1UZ6r.BufferUsage).STATIC;\n    }\n    /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */ setDataWithSize(value, size, syncGPU) {\n        this._updateID++;\n        this._updateSize = size * value.BYTES_PER_ELEMENT;\n        if (this._data === value) {\n            if (syncGPU) this.emit(\"update\", this);\n            return;\n        }\n        const oldData = this._data;\n        this._data = value;\n        if (oldData.length !== value.length) {\n            if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n                if (syncGPU) this.emit(\"update\", this);\n            } else {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = (0, $aGJhg.uid)(\"resource\");\n                this.emit(\"change\", this);\n            }\n            return;\n        }\n        if (syncGPU) this.emit(\"update\", this);\n    }\n    /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */ update(sizeInBytes) {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n        this._updateID++;\n        this.emit(\"update\", this);\n    }\n    /** Destroys the buffer */ destroy() {\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.emit(\"change\", this);\n        this._data = null;\n        this.descriptor = null;\n        this.removeAllListeners();\n    }\n}\n\n});\nparcelRegister(\"1UZ6r\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferUsage\", () => $f4c8f2641f61e66f$export$f8deb2be8632fd10);\n\"use strict\";\nvar $f4c8f2641f61e66f$export$f8deb2be8632fd10 = /* @__PURE__ */ ((BufferUsage2)=>{\n    BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n    BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n    BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n    BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n    BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n    BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n    BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n    BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n    BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n    BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n    BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n    return BufferUsage2;\n})($f4c8f2641f61e66f$export$f8deb2be8632fd10 || {});\n\n});\n\n\nparcelRegister(\"cOnev\", function(module, exports) {\n\n$parcel$export(module.exports, \"Geometry\", () => $f72e7cebaee4d192$export$2db6c17465f94a2);\n\nvar $3vRz3 = parcelRequire(\"3vRz3\");\n\nvar $7wtv9 = parcelRequire(\"7wtv9\");\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\nvar $lvEAL = parcelRequire(\"lvEAL\");\n\nvar $zwuDY = parcelRequire(\"zwuDY\");\n\nvar $dYcXX = parcelRequire(\"dYcXX\");\n\"use strict\";\nfunction $f72e7cebaee4d192$var$ensureIsAttribute(attribute) {\n    if (attribute instanceof (0, $lvEAL.Buffer) || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) attribute = {\n        buffer: attribute\n    };\n    attribute.buffer = (0, $zwuDY.ensureIsBuffer)(attribute.buffer, false);\n    return attribute;\n}\nclass $f72e7cebaee4d192$export$2db6c17465f94a2 extends (0, (/*@__PURE__*/$parcel$interopDefault($3vRz3))) {\n    /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */ constructor(options){\n        const { attributes: attributes, indexBuffer: indexBuffer, topology: topology } = options;\n        super();\n        /** The unique id of the geometry. */ this.uid = (0, $aGJhg.uid)(\"geometry\");\n        /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */ this._layoutKey = 0;\n        /** the instance count of the geometry to draw */ this.instanceCount = 1;\n        this._bounds = new (0, $7wtv9.Bounds)();\n        this._boundsDirty = true;\n        this.attributes = attributes;\n        this.buffers = [];\n        this.instanceCount = options.instanceCount || 1;\n        for(const i in attributes){\n            const attribute = attributes[i] = $f72e7cebaee4d192$var$ensureIsAttribute(attributes[i]);\n            const bufferIndex = this.buffers.indexOf(attribute.buffer);\n            if (bufferIndex === -1) {\n                this.buffers.push(attribute.buffer);\n                attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n                attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n            }\n        }\n        if (indexBuffer) {\n            this.indexBuffer = (0, $zwuDY.ensureIsBuffer)(indexBuffer, true);\n            this.buffers.push(this.indexBuffer);\n        }\n        this.topology = topology || \"triangle-list\";\n    }\n    onBufferUpdate() {\n        this._boundsDirty = true;\n        this.emit(\"update\", this);\n    }\n    /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */ getAttribute(id) {\n        return this.attributes[id];\n    }\n    /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */ getIndex() {\n        return this.indexBuffer;\n    }\n    /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */ getBuffer(id) {\n        return this.getAttribute(id).buffer;\n    }\n    /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */ getSize() {\n        for(const i in this.attributes){\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n            return buffer.data.length / (attribute.stride / 4 || attribute.size);\n        }\n        return 0;\n    }\n    /** Returns the bounds of the geometry. */ get bounds() {\n        if (!this._boundsDirty) return this._bounds;\n        this._boundsDirty = false;\n        return (0, $dYcXX.getGeometryBounds)(this, \"aPosition\", this._bounds);\n    }\n    /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */ destroy(destroyBuffers = false) {\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n        if (destroyBuffers) this.buffers.forEach((buffer)=>buffer.destroy());\n        this.attributes = null;\n        this.buffers = null;\n        this.indexBuffer = null;\n        this._bounds = null;\n    }\n}\n\n});\nparcelRegister(\"zwuDY\", function(module, exports) {\n\n$parcel$export(module.exports, \"ensureIsBuffer\", () => $c27f8a68b3d31b3f$export$e02adcb3cf335e03);\n\nvar $lvEAL = parcelRequire(\"lvEAL\");\n\nvar $1UZ6r = parcelRequire(\"1UZ6r\");\n\"use strict\";\nfunction $c27f8a68b3d31b3f$export$e02adcb3cf335e03(buffer, index) {\n    if (!(buffer instanceof (0, $lvEAL.Buffer))) {\n        let usage = index ? (0, $1UZ6r.BufferUsage).INDEX : (0, $1UZ6r.BufferUsage).VERTEX;\n        if (buffer instanceof Array) {\n            if (index) {\n                buffer = new Uint32Array(buffer);\n                usage = (0, $1UZ6r.BufferUsage).INDEX | (0, $1UZ6r.BufferUsage).COPY_DST;\n            } else {\n                buffer = new Float32Array(buffer);\n                usage = (0, $1UZ6r.BufferUsage).VERTEX | (0, $1UZ6r.BufferUsage).COPY_DST;\n            }\n        }\n        buffer = new (0, $lvEAL.Buffer)({\n            data: buffer,\n            label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n            usage: usage\n        });\n    }\n    return buffer;\n}\n\n});\n\nparcelRegister(\"dYcXX\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGeometryBounds\", () => $547d4a1f0305efcb$export$ca8be28ec6402f29);\n\"use strict\";\nfunction $547d4a1f0305efcb$export$ca8be28ec6402f29(geometry, attributeId, bounds) {\n    const attribute = geometry.getAttribute(attributeId);\n    if (!attribute) {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n        return bounds;\n    }\n    const data = attribute.buffer.data;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    const byteSize = data.BYTES_PER_ELEMENT;\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || 8) / byteSize;\n    for(let i = offset; i < data.length; i += stride){\n        const x = data[i];\n        const y = data[i + 1];\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n    }\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n    return bounds;\n}\n\n});\n\n\n\nparcelRegister(\"beJMG\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTextureBatchBindGroup\", () => $24797d7b1c25d5bc$export$84c26df82650dc9b);\n\nvar $awcfo = parcelRequire(\"awcfo\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $67Wkd = parcelRequire(\"67Wkd\");\n\"use strict\";\nconst $24797d7b1c25d5bc$var$cachedGroups = {};\nfunction $24797d7b1c25d5bc$export$84c26df82650dc9b(textures, size) {\n    let uid = 0;\n    for(let i = 0; i < size; i++)uid = uid * 31 + textures[i].uid >>> 0;\n    return $24797d7b1c25d5bc$var$cachedGroups[uid] || $24797d7b1c25d5bc$var$generateTextureBatchBindGroup(textures, uid);\n}\nfunction $24797d7b1c25d5bc$var$generateTextureBatchBindGroup(textures, key) {\n    const bindGroupResources = {};\n    let bindIndex = 0;\n    for(let i = 0; i < (0, $67Wkd.MAX_TEXTURES); i++){\n        const texture = i < textures.length ? textures[i] : (0, $bLlTJ.Texture).EMPTY.source;\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n    const bindGroup = new (0, $awcfo.BindGroup)(bindGroupResources);\n    $24797d7b1c25d5bc$var$cachedGroups[key] = bindGroup;\n    return bindGroup;\n}\n\n});\nparcelRegister(\"awcfo\", function(module, exports) {\n\n$parcel$export(module.exports, \"BindGroup\", () => $6cadf620a92ebba7$export$6f452ee382def63c);\n\"use strict\";\nclass $6cadf620a92ebba7$export$6f452ee382def63c {\n    /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */ constructor(resources){\n        /** The resources that are bound together for use by a shader. */ this.resources = /* @__PURE__ */ Object.create(null);\n        this._dirty = true;\n        let index = 0;\n        for(const i in resources){\n            const resource = resources[i];\n            this.setResource(resource, index++);\n        }\n        this._updateKey();\n    }\n    /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */ _updateKey() {\n        if (!this._dirty) return;\n        this._dirty = false;\n        const keyParts = [];\n        let index = 0;\n        for(const i in this.resources)keyParts[index++] = this.resources[i]._resourceId;\n        this._key = keyParts.join(\"|\");\n    }\n    /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */ setResource(resource, index) {\n        const currentResource = this.resources[index];\n        if (resource === currentResource) return;\n        if (currentResource) resource.off?.(\"change\", this.onResourceChange, this);\n        resource.on?.(\"change\", this.onResourceChange, this);\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n    /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */ getResource(index) {\n        return this.resources[index];\n    }\n    /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */ _touch(tick) {\n        const resources = this.resources;\n        for(const i in resources)resources[i]._touched = tick;\n    }\n    /** Destroys this bind group and removes all listeners. */ destroy() {\n        const resources = this.resources;\n        for(const i in resources){\n            const resource = resources[i];\n            resource.off?.(\"change\", this.onResourceChange, this);\n        }\n        this.resources = null;\n    }\n    onResourceChange(resource) {\n        this._dirty = true;\n        if (resource.destroyed) {\n            const resources = this.resources;\n            for(const i in resources)if (resources[i] === resource) resources[i] = null;\n        } else this._updateKey();\n    }\n}\n\n});\n\nparcelRegister(\"67Wkd\", function(module, exports) {\n\n$parcel$export(module.exports, \"MAX_TEXTURES\", () => $7769f35d458fe19d$export$e09e7788b3f0275e);\n\"use strict\";\nconst $7769f35d458fe19d$export$e09e7788b3f0275e = 16;\n\n});\n\n\nparcelRegister(\"4rmMq\", function(module, exports) {\n\n$parcel$export(module.exports, \"Batcher\", () => $71f140885a3d3890$export$704b12ddc1dacdd2);\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\nvar $aaUE3 = parcelRequire(\"aaUE3\");\n\nvar $1tfR4 = parcelRequire(\"1tfR4\");\n\nvar $eN26f = parcelRequire(\"eN26f\");\n\nvar $bRzRK = parcelRequire(\"bRzRK\");\n\nvar $67Wkd = parcelRequire(\"67Wkd\");\n\"use strict\";\nclass $71f140885a3d3890$export$33b107562567fc47 {\n    constructor(){\n        this.renderPipeId = \"batch\";\n        this.action = \"startBatch\";\n        // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n        // public elementStart = 0;\n        // public elementSize = 0;\n        // for drawing..\n        this.start = 0;\n        this.size = 0;\n        this.blendMode = \"normal\";\n        this.canBundle = true;\n    }\n    destroy() {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\nlet $71f140885a3d3890$var$BATCH_TICK = 0;\nconst $71f140885a3d3890$var$_Batcher = class _Batcher {\n    constructor(options = {}){\n        this.uid = (0, $aGJhg.uid)(\"batcher\");\n        this.dirty = true;\n        this.batchIndex = 0;\n        this.batches = [];\n        // specifics.\n        this._vertexSize = 6;\n        this._elements = [];\n        this._batchPool = [];\n        this._batchPoolIndex = 0;\n        this._textureBatchPool = [];\n        this._textureBatchPoolIndex = 0;\n        options = {\n            ..._Batcher.defaultOptions,\n            ...options\n        };\n        const { vertexSize: vertexSize, indexSize: indexSize } = options;\n        this.attributeBuffer = new (0, $aaUE3.ViewableBuffer)(vertexSize * this._vertexSize * 4);\n        this.indexBuffer = new Uint16Array(indexSize);\n    }\n    begin() {\n        this.batchIndex = 0;\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n        this._batchPoolIndex = 0;\n        this._textureBatchPoolIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n        this.dirty = true;\n    }\n    add(batchableObject) {\n        this._elements[this.elementSize++] = batchableObject;\n        batchableObject.indexStart = this.indexSize;\n        batchableObject.location = this.attributeSize;\n        batchableObject.batcher = this;\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n    }\n    checkAndUpdateTexture(batchableObject, texture) {\n        const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n        if (!textureId && textureId !== 0) return false;\n        batchableObject.textureId = textureId;\n        batchableObject.texture = texture;\n        return true;\n    }\n    updateElement(batchableObject) {\n        this.dirty = true;\n        batchableObject.packAttributes(this.attributeBuffer.float32View, this.attributeBuffer.uint32View, batchableObject.location, batchableObject.textureId);\n    }\n    /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */ break(instructionSet) {\n        const elements = this._elements;\n        let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new (0, $bRzRK.BatchTextureArray)();\n        textureBatch.clear();\n        if (!elements[this.elementStart]) return;\n        const firstElement = elements[this.elementStart];\n        let blendMode = (0, $eN26f.getAdjustedBlendModeBlend)(firstElement.blendMode, firstElement.texture._source);\n        if (this.attributeSize * 4 > this.attributeBuffer.size) this._resizeAttributeBuffer(this.attributeSize * 4);\n        if (this.indexSize > this.indexBuffer.length) this._resizeIndexBuffer(this.indexSize);\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const iBuffer = this.indexBuffer;\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n        let action = \"startBatch\";\n        let batch = this._batchPool[this._batchPoolIndex++] || new $71f140885a3d3890$export$33b107562567fc47();\n        for(let i = this.elementStart; i < this.elementSize; ++i){\n            const element = elements[i];\n            elements[i] = null;\n            const texture = element.texture;\n            const source = texture._source;\n            const adjustedBlendMode = (0, $eN26f.getAdjustedBlendModeBlend)(element.blendMode, source);\n            const blendModeChange = blendMode !== adjustedBlendMode;\n            if (source._batchTick === $71f140885a3d3890$var$BATCH_TICK && !blendModeChange) {\n                element.textureId = source._textureBindLocation;\n                size += element.indexSize;\n                element.packAttributes(f32, u32, element.location, element.textureId);\n                element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n                element.batch = batch;\n                continue;\n            }\n            source._batchTick = $71f140885a3d3890$var$BATCH_TICK;\n            if (textureBatch.count >= (0, $67Wkd.MAX_TEXTURES) || blendModeChange) {\n                this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n                action = \"renderBatch\";\n                start = size;\n                blendMode = adjustedBlendMode;\n                textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new (0, $bRzRK.BatchTextureArray)();\n                textureBatch.clear();\n                batch = this._batchPool[this._batchPoolIndex++] || new $71f140885a3d3890$export$33b107562567fc47();\n                ++$71f140885a3d3890$var$BATCH_TICK;\n            }\n            element.textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element.batch = batch;\n            size += element.indexSize;\n            element.packAttributes(f32, u32, element.location, element.textureId);\n            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        }\n        if (textureBatch.count > 0) {\n            this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n            start = size;\n            ++$71f140885a3d3890$var$BATCH_TICK;\n        }\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n    _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n        batch.gpuBindGroup = null;\n        batch.action = action;\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n        batch.start = indexStart;\n        batch.size = indexSize;\n        ++$71f140885a3d3890$var$BATCH_TICK;\n        instructionSet.add(batch);\n    }\n    finish(instructionSet) {\n        this.break(instructionSet);\n    }\n    /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */ ensureAttributeBuffer(size) {\n        if (size * 4 <= this.attributeBuffer.size) return;\n        this._resizeAttributeBuffer(size * 4);\n    }\n    /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */ ensureIndexBuffer(size) {\n        if (size <= this.indexBuffer.length) return;\n        this._resizeIndexBuffer(size);\n    }\n    _resizeAttributeBuffer(size) {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n        const newArrayBuffer = new (0, $aaUE3.ViewableBuffer)(newSize);\n        (0, $1tfR4.fastCopy)(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n        this.attributeBuffer = newArrayBuffer;\n    }\n    _resizeIndexBuffer(size) {\n        const indexBuffer = this.indexBuffer;\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n        newSize += newSize % 2;\n        const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) for(let i = 0; i < indexBuffer.length; i++)newIndexBuffer[i] = indexBuffer[i];\n        else (0, $1tfR4.fastCopy)(indexBuffer.buffer, newIndexBuffer.buffer);\n        this.indexBuffer = newIndexBuffer;\n    }\n    destroy() {\n        for(let i = 0; i < this.batches.length; i++)this.batches[i].destroy();\n        this.batches = null;\n        for(let i = 0; i < this._elements.length; i++)this._elements[i].batch = null;\n        this._elements = null;\n        this.indexBuffer = null;\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n};\n$71f140885a3d3890$var$_Batcher.defaultOptions = {\n    vertexSize: 4,\n    indexSize: 6\n};\nlet $71f140885a3d3890$export$704b12ddc1dacdd2 = $71f140885a3d3890$var$_Batcher;\n\n});\nparcelRegister(\"aaUE3\", function(module, exports) {\n\n$parcel$export(module.exports, \"ViewableBuffer\", () => $d6aafa25b0389ff9$export$4fdbf0662aa3047a);\n\"use strict\";\nclass $d6aafa25b0389ff9$export$4fdbf0662aa3047a {\n    constructor(sizeOrBuffer){\n        if (typeof sizeOrBuffer === \"number\") this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        else if (sizeOrBuffer instanceof Uint8Array) this.rawBinaryData = sizeOrBuffer.buffer;\n        else this.rawBinaryData = sizeOrBuffer;\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n        this.size = this.rawBinaryData.byteLength;\n    }\n    /** View on the raw binary data as a `Int8Array`. */ get int8View() {\n        if (!this._int8View) this._int8View = new Int8Array(this.rawBinaryData);\n        return this._int8View;\n    }\n    /** View on the raw binary data as a `Uint8Array`. */ get uint8View() {\n        if (!this._uint8View) this._uint8View = new Uint8Array(this.rawBinaryData);\n        return this._uint8View;\n    }\n    /**  View on the raw binary data as a `Int16Array`. */ get int16View() {\n        if (!this._int16View) this._int16View = new Int16Array(this.rawBinaryData);\n        return this._int16View;\n    }\n    /** View on the raw binary data as a `Int32Array`. */ get int32View() {\n        if (!this._int32View) this._int32View = new Int32Array(this.rawBinaryData);\n        return this._int32View;\n    }\n    /** View on the raw binary data as a `Float64Array`. */ get float64View() {\n        if (!this._float64Array) this._float64Array = new Float64Array(this.rawBinaryData);\n        return this._float64Array;\n    }\n    /** View on the raw binary data as a `BigUint64Array`. */ get bigUint64View() {\n        if (!this._bigUint64Array) this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        return this._bigUint64Array;\n    }\n    /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */ view(type) {\n        return this[`${type}View`];\n    }\n    /** Destroys all buffer references. Do not use after calling this. */ destroy() {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n    /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */ static sizeOf(type) {\n        switch(type){\n            case \"int8\":\n            case \"uint8\":\n                return 1;\n            case \"int16\":\n            case \"uint16\":\n                return 2;\n            case \"int32\":\n            case \"uint32\":\n            case \"float32\":\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n\n});\n\nparcelRegister(\"1tfR4\", function(module, exports) {\n\n$parcel$export(module.exports, \"fastCopy\", () => $3976cf47510ef1a5$export$c691b0c42debe682);\n\"use strict\";\nfunction $3976cf47510ef1a5$export$c691b0c42debe682(sourceBuffer, destinationBuffer) {\n    const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n    destinationFloat64View.set(sourceFloat64View);\n    const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n    if (remainingBytes > 0) {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n\n});\n\nparcelRegister(\"eN26f\", function(module, exports) {\n\n$parcel$export(module.exports, \"getAdjustedBlendModeBlend\", () => $3b017cb7131d92fc$export$ab2fc5cf3fe899fe);\n\nvar $eE5Ke = parcelRequire(\"eE5Ke\");\n\"use strict\";\nfunction $3b017cb7131d92fc$export$ab2fc5cf3fe899fe(blendMode, textureSource) {\n    if (textureSource.alphaMode === \"no-premultiply-alpha\") return (0, $eE5Ke.BLEND_TO_NPM)[blendMode] || blendMode;\n    return blendMode;\n}\n\n});\nparcelRegister(\"eE5Ke\", function(module, exports) {\n\n$parcel$export(module.exports, \"BLEND_TO_NPM\", () => $16526f00f7b0e2b9$export$8c0bd2ccaa4a8d5e);\n$parcel$export(module.exports, \"STENCIL_MODES\", () => $16526f00f7b0e2b9$export$c250b85d73a91bdf);\n\"use strict\";\nconst $16526f00f7b0e2b9$export$8c0bd2ccaa4a8d5e = {\n    normal: \"normal-npm\",\n    add: \"add-npm\",\n    screen: \"screen-npm\"\n};\nvar $16526f00f7b0e2b9$export$c250b85d73a91bdf = /* @__PURE__ */ ((STENCIL_MODES2)=>{\n    STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n    STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n    STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n    STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 3] = \"RENDERING_MASK_REMOVE\";\n    STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 4] = \"NONE\";\n    return STENCIL_MODES2;\n})($16526f00f7b0e2b9$export$c250b85d73a91bdf || {});\n\n});\n\n\nparcelRegister(\"bRzRK\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchTextureArray\", () => $a96c3003620e8697$export$aa760e0febf1a758);\n\"use strict\";\nclass $a96c3003620e8697$export$aa760e0febf1a758 {\n    constructor(){\n        /** Respective locations for textures. */ this.ids = /* @__PURE__ */ Object.create(null);\n        this.textures = [];\n        this.count = 0;\n    }\n    /** Clear the textures and their locations. */ clear() {\n        for(let i = 0; i < this.count; i++){\n            const t = this.textures[i];\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n        this.count = 0;\n    }\n}\n\n});\n\n\nparcelRegister(\"1mKkK\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildContextBatches\", () => $2ba674c6e42be2fb$export$e3c00f31a053d231);\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\nvar $kVCUp = parcelRequire(\"kVCUp\");\n\nvar $9Co9Q = parcelRequire(\"9Co9Q\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $61KiY = parcelRequire(\"61KiY\");\n\nvar $xZ5a3 = parcelRequire(\"xZ5a3\");\n\nvar $dY2iR = parcelRequire(\"dY2iR\");\n\nvar $46SPq = parcelRequire(\"46SPq\");\n\nvar $ei7YJ = parcelRequire(\"ei7YJ\");\n\nvar $7DIxn = parcelRequire(\"7DIxn\");\n\nvar $iAUCq = parcelRequire(\"iAUCq\");\n\nvar $2E1jb = parcelRequire(\"2E1jb\");\n\"use strict\";\nconst $2ba674c6e42be2fb$var$buildMap = {\n    rectangle: (0, $7DIxn.buildRectangle),\n    polygon: (0, $ei7YJ.buildPolygon),\n    triangle: (0, $iAUCq.buildTriangle),\n    circle: (0, $dY2iR.buildCircle),\n    ellipse: (0, $dY2iR.buildCircle),\n    roundedRectangle: (0, $dY2iR.buildCircle)\n};\nconst $2ba674c6e42be2fb$var$tempRect = new (0, $fM4Mk.Rectangle)();\nfunction $2ba674c6e42be2fb$export$e3c00f31a053d231(context, gpuContext) {\n    const { geometryData: geometryData, batches: batches } = gpuContext;\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n    for(let i = 0; i < context.instructions.length; i++){\n        const instruction = context.instructions[i];\n        if (instruction.action === \"texture\") $2ba674c6e42be2fb$var$addTextureToGeometryData(instruction.data, batches, geometryData);\n        else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n            const isStroke = instruction.action === \"stroke\";\n            const shapePath = instruction.data.path.shapePath;\n            const style = instruction.data.style;\n            const hole = instruction.data.hole;\n            if (isStroke && hole) $2ba674c6e42be2fb$var$addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            $2ba674c6e42be2fb$var$addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\nfunction $2ba674c6e42be2fb$var$addTextureToGeometryData(data, batches, geometryData) {\n    const { vertices: vertices, uvs: uvs, indices: indices } = geometryData;\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = $2ba674c6e42be2fb$var$buildMap.rectangle;\n    const rect = $2ba674c6e42be2fb$var$tempRect;\n    const texture = data.image;\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n    const matrix = data.transform;\n    build.build(rect, points);\n    if (matrix) (0, $9Co9Q.transformVertices)(points, matrix);\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n    const textureUvs = texture.uvs;\n    uvs.push(textureUvs.x0, textureUvs.y0, textureUvs.x1, textureUvs.y1, textureUvs.x3, textureUvs.y3, textureUvs.x2, textureUvs.y2);\n    const graphicsBatch = (0, $61KiY.BigPool).get((0, $xZ5a3.BatchableGraphics));\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.color = data.style;\n    graphicsBatch.alpha = data.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n}\nfunction $2ba674c6e42be2fb$var$addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n    const { vertices: vertices, uvs: uvs, indices: indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n    shapePath.shapePrimitives.forEach(({ shape: shape, transform: matrix }, i)=>{\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n        const points = [];\n        const build = $2ba674c6e42be2fb$var$buildMap[shape.type];\n        build.build(shape, points);\n        if (matrix) (0, $9Co9Q.transformVertices)(points, matrix);\n        if (!isStroke) {\n            if (hole && lastIndex === i) {\n                if (lastIndex !== 0) console.warn(\"[Pixi Graphics] only the last shape have be cut out\");\n                const holeIndices = [];\n                const otherPoints = points.slice();\n                const holeArrays = $2ba674c6e42be2fb$var$getHoleArrays(hole.shapePath);\n                holeArrays.forEach((holePoints)=>{\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n                (0, $2E1jb.triangulateWithHoles)(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            } else build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n        } else {\n            const close = shape.closePath ?? true;\n            const lineStyle = style;\n            (0, $46SPq.buildLine)(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n        }\n        const uvsOffset = uvs.length / 2;\n        const texture = style.texture;\n        if (texture !== (0, $bLlTJ.Texture).WHITE) {\n            const textureMatrix = style.matrix;\n            if (matrix) textureMatrix.append(matrix.clone().invert());\n            (0, $kVCUp.buildUvs)(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n        } else (0, $kVCUp.buildSimpleUvs)(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n        const graphicsBatch = (0, $61KiY.BigPool).get((0, $xZ5a3.BatchableGraphics));\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n        graphicsBatch.vertexOffset = vertOffset;\n        graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n        graphicsBatch.color = style.color;\n        graphicsBatch.alpha = style.alpha;\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        batches.push(graphicsBatch);\n    });\n}\nfunction $2ba674c6e42be2fb$var$getHoleArrays(shape) {\n    if (!shape) return [];\n    const holePrimitives = shape.shapePrimitives;\n    const holeArrays = [];\n    for(let k = 0; k < holePrimitives.length; k++){\n        const holePrimitive = holePrimitives[k].shape;\n        const holePoints = [];\n        const holeBuilder = $2ba674c6e42be2fb$var$buildMap[holePrimitive.type];\n        holeBuilder.build(holePrimitive, holePoints);\n        holeArrays.push(holePoints);\n    }\n    return holeArrays;\n}\n\n});\nparcelRegister(\"kVCUp\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildUvs\", () => $1606ccc0770732ec$export$2027711a0ff70dc2);\n$parcel$export(module.exports, \"buildSimpleUvs\", () => $1606ccc0770732ec$export$580e3d8462b9fe52);\n\"use strict\";\nfunction $1606ccc0770732ec$export$2027711a0ff70dc2(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n    let index = 0;\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    while(index < size){\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n        uvs[uvsOffset] = a * x + c * y + tx;\n        uvs[uvsOffset + 1] = b * x + d * y + ty;\n        uvsOffset += uvsStride;\n        verticesOffset += verticesStride;\n        index++;\n    }\n}\nfunction $1606ccc0770732ec$export$580e3d8462b9fe52(uvs, uvsOffset, uvsStride, size) {\n    let index = 0;\n    uvsOffset *= uvsStride;\n    while(index < size){\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n        uvsOffset += uvsStride;\n        index++;\n    }\n}\n\n});\n\nparcelRegister(\"9Co9Q\", function(module, exports) {\n\n$parcel$export(module.exports, \"transformVertices\", () => $74e682a1604b3625$export$cbe36b8a8d6e3d3);\n\"use strict\";\nfunction $74e682a1604b3625$export$cbe36b8a8d6e3d3(vertices, m, offset, stride, size) {\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n    offset = offset || 0;\n    stride = stride || 2;\n    size = size || vertices.length / stride - offset;\n    let index = offset * stride;\n    for(let i = 0; i < size; i++){\n        const x = vertices[index];\n        const y = vertices[index + 1];\n        vertices[index] = a * x + c * y + tx;\n        vertices[index + 1] = b * x + d * y + ty;\n        index += stride;\n    }\n}\n\n});\n\nparcelRegister(\"xZ5a3\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableGraphics\", () => $3f80d08e0b9378c5$export$91d2a08bbf21546b);\n\nvar $1btgi = parcelRequire(\"1btgi\");\n\"use strict\";\nclass $3f80d08e0b9378c5$export$91d2a08bbf21546b {\n    constructor(){\n        this.batcher = null;\n        this.batch = null;\n        this.applyTransform = true;\n        this.roundPixels = 0;\n    }\n    get blendMode() {\n        if (this.applyTransform) return this.renderable.groupBlendMode;\n        return \"normal\";\n    }\n    packIndex(indexBuffer, index, indicesOffset) {\n        const indices = this.geometryData.indices;\n        for(let i = 0; i < this.indexSize; i++)indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n    }\n    packAttributes(float32View, uint32View, index, textureId) {\n        const geometry = this.geometryData;\n        const graphics = this.renderable;\n        const positions = geometry.vertices;\n        const uvs = geometry.uvs;\n        const offset = this.vertexOffset * 2;\n        const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n        const rgb = this.color;\n        const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n        if (this.applyTransform) {\n            const argb = (0, $1btgi.mixColors)(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);\n            const wt = graphics.groupTransform;\n            const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n            const a = wt.a;\n            const b = wt.b;\n            const c = wt.c;\n            const d = wt.d;\n            const tx = wt.tx;\n            const ty = wt.ty;\n            for(let i = offset; i < vertSize; i += 2){\n                const x = positions[i];\n                const y = positions[i + 1];\n                float32View[index] = a * x + c * y + tx;\n                float32View[index + 1] = b * x + d * y + ty;\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureIdAndRound;\n                index += 6;\n            }\n        } else {\n            const argb = bgr + (this.alpha * 255 << 24);\n            for(let i = offset; i < vertSize; i += 2){\n                float32View[index] = positions[i];\n                float32View[index + 1] = positions[i + 1];\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureId << 16;\n                index += 6;\n            }\n        }\n    }\n    // TODO rename to vertexSize\n    get vertSize() {\n        return this.vertexSize;\n    }\n    copyTo(gpuBuffer) {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n        gpuBuffer.vertexOffset = this.vertexOffset;\n        gpuBuffer.vertexSize = this.vertexSize;\n        gpuBuffer.color = this.color;\n        gpuBuffer.alpha = this.alpha;\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n    }\n    reset() {\n        this.applyTransform = true;\n    }\n}\n\n});\nparcelRegister(\"1btgi\", function(module, exports) {\n\n$parcel$export(module.exports, \"mixColors\", () => $fa16342a035ea58b$export$72a85c3a80ccc403);\n\nvar $e39Qs = parcelRequire(\"e39Qs\");\n\"use strict\";\nconst $fa16342a035ea58b$var$WHITE_BGR = 16777215;\nfunction $fa16342a035ea58b$export$72a85c3a80ccc403(localBGRColor, parentBGRColor) {\n    if (localBGRColor === $fa16342a035ea58b$var$WHITE_BGR || parentBGRColor === $fa16342a035ea58b$var$WHITE_BGR) return localBGRColor + parentBGRColor - $fa16342a035ea58b$var$WHITE_BGR;\n    return (0, $e39Qs.mixHexColors)(localBGRColor, parentBGRColor, 0.5);\n}\nfunction $fa16342a035ea58b$export$2c7842eb56139270(localColorRGB, localAlpha, parentColor) {\n    const parentAlpha = (parentColor >> 24 & 255) / 255;\n    const globalAlpha = localAlpha * parentAlpha * 255;\n    const localBGRColor = ((localColorRGB & 255) << 16) + (localColorRGB & 65280) + (localColorRGB >> 16 & 255);\n    const parentBGRColor = parentColor & 16777215;\n    let sharedBGRColor;\n    if (localBGRColor === $fa16342a035ea58b$var$WHITE_BGR || parentBGRColor === $fa16342a035ea58b$var$WHITE_BGR) sharedBGRColor = localBGRColor + parentBGRColor - $fa16342a035ea58b$var$WHITE_BGR;\n    else sharedBGRColor = (0, $e39Qs.mixHexColors)(localBGRColor, parentBGRColor, 0.5);\n    return sharedBGRColor + (globalAlpha << 24);\n}\n\n});\nparcelRegister(\"e39Qs\", function(module, exports) {\n\n$parcel$export(module.exports, \"mixHexColors\", () => $5ef5460938e8160b$export$ff72adc46f6bc63c);\n\"use strict\";\nfunction $5ef5460938e8160b$export$ff72adc46f6bc63c(color1, color2, ratio) {\n    const r1 = color1 >> 16 & 255;\n    const g1 = color1 >> 8 & 255;\n    const b1 = color1 & 255;\n    const r2 = color2 >> 16 & 255;\n    const g2 = color2 >> 8 & 255;\n    const b2 = color2 & 255;\n    const r = r1 + (r2 - r1) * ratio;\n    const g = g1 + (g2 - g1) * ratio;\n    const b = b1 + (b2 - b1) * ratio;\n    return (r << 16) + (g << 8) + b;\n}\n\n});\n\n\n\nparcelRegister(\"dY2iR\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildCircle\", () => $791ed7b81fe09d67$export$a3541b2d8ecbfcf2);\n\"use strict\";\nconst $791ed7b81fe09d67$export$a3541b2d8ecbfcf2 = {\n    build (shape, points) {\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n        if (shape.type === \"circle\") {\n            const circle = shape;\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        } else if (shape.type === \"ellipse\") {\n            const ellipse = shape;\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        } else {\n            const roundedRect = shape;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) return points;\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n        if (m === 0) return points;\n        if (n === 0) {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n            return points;\n        }\n        let j1 = 0;\n        let j2 = n * 4 + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n        if (dy) {\n            const y22 = y - y0;\n            points[j3++] = x2;\n            points[j3++] = y22;\n            points[--j4] = y22;\n            points[--j4] = x1;\n        }\n        for(let i = 1; i < n; i++){\n            const a = Math.PI / 2 * (i / n);\n            const x02 = dx + Math.cos(a) * rx;\n            const y02 = dy + Math.sin(a) * ry;\n            const x12 = x + x02;\n            const x22 = x - x02;\n            const y12 = y + y02;\n            const y22 = y - y02;\n            points[j1++] = x12;\n            points[j1++] = y12;\n            points[--j2] = y12;\n            points[--j2] = x22;\n            points[j3++] = x22;\n            points[j3++] = y22;\n            points[--j4] = y22;\n            points[--j4] = x12;\n        }\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n        if (dx) {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        if (points.length === 0) return;\n        let centerX = 0;\n        let centerY = 0;\n        for(let i = 0; i < points.length; i += 2){\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= points.length / 2;\n        centerY /= points.length / 2;\n        let count = verticesOffset;\n        vertices[count * verticesStride] = centerX;\n        vertices[count * verticesStride + 1] = centerY;\n        const centerIndex = count++;\n        for(let i = 0; i < points.length; i += 2){\n            vertices[count * verticesStride] = points[i];\n            vertices[count * verticesStride + 1] = points[i + 1];\n            if (i > 0) {\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n};\n\n});\n\nparcelRegister(\"46SPq\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildLine\", () => $9fc8551677af3cf1$export$45986ccf08e93b0b);\n\nvar $1HooC = parcelRequire(\"1HooC\");\n\nvar $d1s7O = parcelRequire(\"d1s7O\");\n\nvar $168p3 = parcelRequire(\"168p3\");\n\"use strict\";\nfunction $9fc8551677af3cf1$var$square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n    const ix = x - nx * innerWeight;\n    const iy = y - ny * innerWeight;\n    const ox = x + nx * outerWeight;\n    const oy = y + ny * outerWeight;\n    let exx;\n    let eyy;\n    if (clockwise) {\n        exx = ny;\n        eyy = -nx;\n    } else {\n        exx = -ny;\n        eyy = nx;\n    }\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n    return 2;\n}\nfunction $9fc8551677af3cf1$var$round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n    if (clockwise && angle0 < angle1) angle0 += Math.PI * 2;\n    else if (!clockwise && angle0 > angle1) angle1 += Math.PI * 2;\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n    startAngle += angleInc;\n    if (clockwise) {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n        for(let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc){\n            verts.push(cx, cy);\n            verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n        }\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    } else {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n        for(let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc){\n            verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n            verts.push(cx, cy);\n        }\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n    return segCount * 2;\n}\nfunction $9fc8551677af3cf1$export$45986ccf08e93b0b(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n    const eps = (0, $d1s7O.closePointEps);\n    if (points.length === 0) return;\n    const style = lineStyle;\n    let alignment = style.alignment;\n    if (lineStyle.alignment !== 0.5) {\n        let orientation = (0, $168p3.getOrientationOfPoints)(points);\n        if (flipAlignment) orientation *= -1;\n        alignment = (alignment - 0.5) * orientation + 0.5;\n    }\n    const firstPoint = new (0, $1HooC.Point)(points[0], points[1]);\n    const lastPoint = new (0, $1HooC.Point)(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n    if (closedShape) {\n        points = points.slice();\n        if (closedPath) {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n    const verts = vertices;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n    let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    const ratio = alignment;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n    if (!closedShape) {\n        if (style.cap === \"round\") indexCount += $9fc8551677af3cf1$var$round(x0 - perpX * (innerWeight - outerWeight) * 0.5, y0 - perpY * (innerWeight - outerWeight) * 0.5, x0 - perpX * innerWeight, y0 - perpY * innerWeight, x0 + perpX * outerWeight, y0 + perpY * outerWeight, verts, true) + 2;\n        else if (style.cap === \"square\") indexCount += $9fc8551677af3cf1$var$square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n    verts.push(x0 - perpX * innerWeight, y0 - perpY * innerWeight);\n    verts.push(x0 + perpX * outerWeight, y0 + perpY * outerWeight);\n    for(let i = 1; i < length - 1; ++i){\n        x0 = points[(i - 1) * 2];\n        y0 = points[(i - 1) * 2 + 1];\n        x1 = points[i * 2];\n        y1 = points[i * 2 + 1];\n        x2 = points[(i + 1) * 2];\n        y2 = points[(i + 1) * 2 + 1];\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n        dist = Math.sqrt(perpX * perpX + perpY * perpY);\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n        dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n        const dot = dx0 * dx1 + dy0 * dy1;\n        const cross = dy0 * dx1 - dy1 * dx0;\n        const clockwise = cross < 0;\n        if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n            if (dot >= 0) {\n                if (style.join === \"round\") indexCount += $9fc8551677af3cf1$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n                else indexCount += 2;\n                verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);\n                verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);\n            }\n            continue;\n        }\n        const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n        const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n        const px = (dx0 * c2 - dx1 * c1) / cross;\n        const py = (dy1 * c1 - dy0 * c2) / cross;\n        const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n        const imx = x1 + (px - x1) * innerWeight;\n        const imy = y1 + (py - y1) * innerWeight;\n        const omx = x1 - (px - x1) * outerWeight;\n        const omy = y1 - (py - y1) * outerWeight;\n        const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n        if (insideMiterOk) {\n            if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n                if (clockwise) {\n                    verts.push(imx, imy);\n                    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n                    verts.push(imx, imy);\n                    verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n                } else {\n                    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n                    verts.push(omx, omy);\n                    verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n                    verts.push(omx, omy);\n                }\n                indexCount += 2;\n            } else if (style.join === \"round\") {\n                if (clockwise) {\n                    verts.push(imx, imy);\n                    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n                    indexCount += $9fc8551677af3cf1$var$round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n                    verts.push(imx, imy);\n                    verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n                } else {\n                    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n                    verts.push(omx, omy);\n                    indexCount += $9fc8551677af3cf1$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n                    verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n                    verts.push(omx, omy);\n                }\n            } else {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        } else {\n            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n            if (style.join === \"round\") {\n                if (clockwise) indexCount += $9fc8551677af3cf1$var$round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n                else indexCount += $9fc8551677af3cf1$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n            } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n                if (clockwise) {\n                    verts.push(omx, omy);\n                    verts.push(omx, omy);\n                } else {\n                    verts.push(imx, imy);\n                    verts.push(imx, imy);\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n            indexCount += 2;\n        }\n    }\n    x0 = points[(length - 2) * 2];\n    y0 = points[(length - 2) * 2 + 1];\n    x1 = points[(length - 1) * 2];\n    y1 = points[(length - 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n    if (!closedShape) {\n        if (style.cap === \"round\") indexCount += $9fc8551677af3cf1$var$round(x1 - perpX * (innerWeight - outerWeight) * 0.5, y1 - perpY * (innerWeight - outerWeight) * 0.5, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 + perpX * outerWeight, y1 + perpY * outerWeight, verts, false) + 2;\n        else if (style.cap === \"square\") indexCount += $9fc8551677af3cf1$var$square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n    const eps2 = (0, $d1s7O.curveEps) * (0, $d1s7O.curveEps);\n    for(let i = indexStart; i < indexCount + indexStart - 2; ++i){\n        x0 = verts[i * 2];\n        y0 = verts[i * 2 + 1];\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[(i + 1) * 2 + 1];\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[(i + 2) * 2 + 1];\n        if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) continue;\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n});\nparcelRegister(\"d1s7O\", function(module, exports) {\n\n$parcel$export(module.exports, \"closePointEps\", () => $5f88c52b3933a72f$export$7159a7c43f12984);\n$parcel$export(module.exports, \"curveEps\", () => $5f88c52b3933a72f$export$51a946149243709);\n\"use strict\";\nconst $5f88c52b3933a72f$export$7159a7c43f12984 = 1e-4;\nconst $5f88c52b3933a72f$export$51a946149243709 = 1e-4;\n\n});\n\nparcelRegister(\"168p3\", function(module, exports) {\n\n$parcel$export(module.exports, \"getOrientationOfPoints\", () => $19281094736c08bb$export$38856eae80d480e1);\n\"use strict\";\nfunction $19281094736c08bb$export$38856eae80d480e1(points) {\n    const m = points.length;\n    if (m < 6) return 1;\n    let area = 0;\n    for(let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2){\n        const x2 = points[i];\n        const y2 = points[i + 1];\n        area += (x2 - x1) * (y2 + y1);\n        x1 = x2;\n        y1 = y2;\n    }\n    if (area < 0) return -1;\n    return 1;\n}\n\n});\n\n\nparcelRegister(\"ei7YJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildPolygon\", () => $7f823fd9a95a0bf4$export$4c2d12f7b210f357);\n\nvar $2E1jb = parcelRequire(\"2E1jb\");\n\"use strict\";\nconst $7f823fd9a95a0bf4$var$emptyArray = [];\nconst $7f823fd9a95a0bf4$export$4c2d12f7b210f357 = {\n    build (shape, points) {\n        for(let i = 0; i < shape.points.length; i++)points[i] = shape.points[i];\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        (0, $2E1jb.triangulateWithHoles)(points, $7f823fd9a95a0bf4$var$emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    }\n};\n\n});\nparcelRegister(\"2E1jb\", function(module, exports) {\n\n$parcel$export(module.exports, \"triangulateWithHoles\", () => $0c79f6b53084d415$export$5a241bf9c2c3d94b);\n\nvar $2jYVZ = parcelRequire(\"2jYVZ\");\n\"use strict\";\nfunction $0c79f6b53084d415$export$5a241bf9c2c3d94b(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    const triangles = (0, (/*@__PURE__*/$parcel$interopDefault($2jYVZ)))(points, holes, 2);\n    if (!triangles) return;\n    for(let i = 0; i < triangles.length; i += 3){\n        indices[indicesOffset++] = triangles[i] + verticesOffset;\n        indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n        indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n    }\n    let index = verticesOffset * verticesStride;\n    for(let i = 0; i < points.length; i += 2){\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n        index += verticesStride;\n    }\n}\n\n});\nparcelRegister(\"2jYVZ\", function(module, exports) {\n\"use strict\";\nmodule.exports = $1b0c9f6ca9bef72e$var$earcut;\nmodule.exports.default = $1b0c9f6ca9bef72e$var$earcut;\nfunction $1b0c9f6ca9bef72e$var$earcut(data, holeIndices, dim) {\n    dim = dim || 2;\n    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = $1b0c9f6ca9bef72e$var$linkedList(data, 0, outerLen, dim, true), triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    var minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles) outerNode = $1b0c9f6ca9bef72e$var$eliminateHoles(data, holeIndices, outerNode, dim);\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n        for(var i = dim; i < outerLen; i += dim){\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n    $1b0c9f6ca9bef72e$var$earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n    return triangles;\n}\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction $1b0c9f6ca9bef72e$var$linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n    if (clockwise === $1b0c9f6ca9bef72e$var$signedArea(data, start, end, dim) > 0) for(i = start; i < end; i += dim)last = $1b0c9f6ca9bef72e$var$insertNode(i, data[i], data[i + 1], last);\n    else for(i = end - dim; i >= start; i -= dim)last = $1b0c9f6ca9bef72e$var$insertNode(i, data[i], data[i + 1], last);\n    if (last && $1b0c9f6ca9bef72e$var$equals(last, last.next)) {\n        $1b0c9f6ca9bef72e$var$removeNode(last);\n        last = last.next;\n    }\n    return last;\n}\n// eliminate colinear or duplicate points\nfunction $1b0c9f6ca9bef72e$var$filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n    var p = start, again;\n    do {\n        again = false;\n        if (!p.steiner && ($1b0c9f6ca9bef72e$var$equals(p, p.next) || $1b0c9f6ca9bef72e$var$area(p.prev, p, p.next) === 0)) {\n            $1b0c9f6ca9bef72e$var$removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n        } else p = p.next;\n    }while (again || p !== end);\n    return end;\n}\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction $1b0c9f6ca9bef72e$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) $1b0c9f6ca9bef72e$var$indexCurve(ear, minX, minY, invSize);\n    var stop = ear, prev, next;\n    // iterate through ears, slicing them one by one\n    while(ear.prev !== ear.next){\n        prev = ear.prev;\n        next = ear.next;\n        if (invSize ? $1b0c9f6ca9bef72e$var$isEarHashed(ear, minX, minY, invSize) : $1b0c9f6ca9bef72e$var$isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n            $1b0c9f6ca9bef72e$var$removeNode(ear);\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n            continue;\n        }\n        ear = next;\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) $1b0c9f6ca9bef72e$var$earcutLinked($1b0c9f6ca9bef72e$var$filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n            else if (pass === 1) {\n                ear = $1b0c9f6ca9bef72e$var$cureLocalIntersections($1b0c9f6ca9bef72e$var$filterPoints(ear), triangles, dim);\n                $1b0c9f6ca9bef72e$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) $1b0c9f6ca9bef72e$var$splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            break;\n        }\n    }\n}\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction $1b0c9f6ca9bef72e$var$isEar(ear) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if ($1b0c9f6ca9bef72e$var$area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    var p = c.next;\n    while(p !== a){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && $1b0c9f6ca9bef72e$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $1b0c9f6ca9bef72e$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n    return true;\n}\nfunction $1b0c9f6ca9bef72e$var$isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if ($1b0c9f6ca9bef72e$var$area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    // z-order range for the current triangle bbox;\n    var minZ = $1b0c9f6ca9bef72e$var$zOrder(x0, y0, minX, minY, invSize), maxZ = $1b0c9f6ca9bef72e$var$zOrder(x1, y1, minX, minY, invSize);\n    var p = ear.prevZ, n = ear.nextZ;\n    // look for points inside the triangle in both directions\n    while(p && p.z >= minZ && n && n.z <= maxZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && $1b0c9f6ca9bef72e$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $1b0c9f6ca9bef72e$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && $1b0c9f6ca9bef72e$var$pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && $1b0c9f6ca9bef72e$var$area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    // look for remaining points in decreasing z-order\n    while(p && p.z >= minZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && $1b0c9f6ca9bef72e$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $1b0c9f6ca9bef72e$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n    // look for remaining points in increasing z-order\n    while(n && n.z <= maxZ){\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && $1b0c9f6ca9bef72e$var$pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && $1b0c9f6ca9bef72e$var$area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    return true;\n}\n// go through all polygon nodes and cure small local self-intersections\nfunction $1b0c9f6ca9bef72e$var$cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev, b = p.next.next;\n        if (!$1b0c9f6ca9bef72e$var$equals(a, b) && $1b0c9f6ca9bef72e$var$intersects(a, p, p.next, b) && $1b0c9f6ca9bef72e$var$locallyInside(a, b) && $1b0c9f6ca9bef72e$var$locallyInside(b, a)) {\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n            // remove two nodes involved\n            $1b0c9f6ca9bef72e$var$removeNode(p);\n            $1b0c9f6ca9bef72e$var$removeNode(p.next);\n            p = start = b;\n        }\n        p = p.next;\n    }while (p !== start);\n    return $1b0c9f6ca9bef72e$var$filterPoints(p);\n}\n// try splitting polygon into two and triangulate them independently\nfunction $1b0c9f6ca9bef72e$var$splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while(b !== a.prev){\n            if (a.i !== b.i && $1b0c9f6ca9bef72e$var$isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = $1b0c9f6ca9bef72e$var$splitPolygon(a, b);\n                // filter colinear points around the cuts\n                a = $1b0c9f6ca9bef72e$var$filterPoints(a, a.next);\n                c = $1b0c9f6ca9bef72e$var$filterPoints(c, c.next);\n                // run earcut on each half\n                $1b0c9f6ca9bef72e$var$earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                $1b0c9f6ca9bef72e$var$earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    }while (a !== start);\n}\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction $1b0c9f6ca9bef72e$var$eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [], i, len, start, end, list;\n    for(i = 0, len = holeIndices.length; i < len; i++){\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = $1b0c9f6ca9bef72e$var$linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push($1b0c9f6ca9bef72e$var$getLeftmost(list));\n    }\n    queue.sort($1b0c9f6ca9bef72e$var$compareX);\n    // process holes from left to right\n    for(i = 0; i < queue.length; i++)outerNode = $1b0c9f6ca9bef72e$var$eliminateHole(queue[i], outerNode);\n    return outerNode;\n}\nfunction $1b0c9f6ca9bef72e$var$compareX(a, b) {\n    return a.x - b.x;\n}\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction $1b0c9f6ca9bef72e$var$eliminateHole(hole, outerNode) {\n    var bridge = $1b0c9f6ca9bef72e$var$findHoleBridge(hole, outerNode);\n    if (!bridge) return outerNode;\n    var bridgeReverse = $1b0c9f6ca9bef72e$var$splitPolygon(bridge, hole);\n    // filter collinear points around the cuts\n    $1b0c9f6ca9bef72e$var$filterPoints(bridgeReverse, bridgeReverse.next);\n    return $1b0c9f6ca9bef72e$var$filterPoints(bridge, bridge.next);\n}\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction $1b0c9f6ca9bef72e$var$findHoleBridge(hole, outerNode) {\n    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    }while (p !== outerNode);\n    if (!m) return null;\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;\n    p = m;\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x && $1b0c9f6ca9bef72e$var$pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n            if ($1b0c9f6ca9bef72e$var$locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && $1b0c9f6ca9bef72e$var$sectorContainsSector(m, p)))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n        p = p.next;\n    }while (p !== stop);\n    return m;\n}\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction $1b0c9f6ca9bef72e$var$sectorContainsSector(m, p) {\n    return $1b0c9f6ca9bef72e$var$area(m.prev, m, p.prev) < 0 && $1b0c9f6ca9bef72e$var$area(p.next, m, m.next) < 0;\n}\n// interlink polygon nodes in z-order\nfunction $1b0c9f6ca9bef72e$var$indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = $1b0c9f6ca9bef72e$var$zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    }while (p !== start);\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n    $1b0c9f6ca9bef72e$var$sortLinked(p);\n}\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction $1b0c9f6ca9bef72e$var$sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n        while(p){\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for(i = 0; i < inSize; i++){\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n            while(pSize > 0 || qSize > 0 && q){\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n                if (tail) tail.nextZ = e;\n                else list = e;\n                e.prevZ = tail;\n                tail = e;\n            }\n            p = q;\n        }\n        tail.nextZ = null;\n        inSize *= 2;\n    }while (numMerges > 1);\n    return list;\n}\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction $1b0c9f6ca9bef72e$var$zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n    x = (x | x << 8) & 0x00FF00FF;\n    x = (x | x << 4) & 0x0F0F0F0F;\n    x = (x | x << 2) & 0x33333333;\n    x = (x | x << 1) & 0x55555555;\n    y = (y | y << 8) & 0x00FF00FF;\n    y = (y | y << 4) & 0x0F0F0F0F;\n    y = (y | y << 2) & 0x33333333;\n    y = (y | y << 1) & 0x55555555;\n    return x | y << 1;\n}\n// find the leftmost node of a polygon ring\nfunction $1b0c9f6ca9bef72e$var$getLeftmost(start) {\n    var p = start, leftmost = start;\n    do {\n        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n        p = p.next;\n    }while (p !== start);\n    return leftmost;\n}\n// check if a point lies within a convex triangle\nfunction $1b0c9f6ca9bef72e$var$pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction $1b0c9f6ca9bef72e$var$isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !$1b0c9f6ca9bef72e$var$intersectsPolygon(a, b) && // dones't intersect other edges\n    ($1b0c9f6ca9bef72e$var$locallyInside(a, b) && $1b0c9f6ca9bef72e$var$locallyInside(b, a) && $1b0c9f6ca9bef72e$var$middleInside(a, b) && // locally visible\n    ($1b0c9f6ca9bef72e$var$area(a.prev, a, b.prev) || $1b0c9f6ca9bef72e$var$area(a, b.prev, b)) || // does not create opposite-facing sectors\n    $1b0c9f6ca9bef72e$var$equals(a, b) && $1b0c9f6ca9bef72e$var$area(a.prev, a, a.next) > 0 && $1b0c9f6ca9bef72e$var$area(b.prev, b, b.next) > 0); // special zero-length case\n}\n// signed area of a triangle\nfunction $1b0c9f6ca9bef72e$var$area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n// check if two points are equal\nfunction $1b0c9f6ca9bef72e$var$equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n// check if two segments intersect\nfunction $1b0c9f6ca9bef72e$var$intersects(p1, q1, p2, q2) {\n    var o1 = $1b0c9f6ca9bef72e$var$sign($1b0c9f6ca9bef72e$var$area(p1, q1, p2));\n    var o2 = $1b0c9f6ca9bef72e$var$sign($1b0c9f6ca9bef72e$var$area(p1, q1, q2));\n    var o3 = $1b0c9f6ca9bef72e$var$sign($1b0c9f6ca9bef72e$var$area(p2, q2, p1));\n    var o4 = $1b0c9f6ca9bef72e$var$sign($1b0c9f6ca9bef72e$var$area(p2, q2, q1));\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n    if (o1 === 0 && $1b0c9f6ca9bef72e$var$onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && $1b0c9f6ca9bef72e$var$onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && $1b0c9f6ca9bef72e$var$onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && $1b0c9f6ca9bef72e$var$onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n    return false;\n}\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction $1b0c9f6ca9bef72e$var$onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction $1b0c9f6ca9bef72e$var$sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n// check if a polygon diagonal intersects any polygon segments\nfunction $1b0c9f6ca9bef72e$var$intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && $1b0c9f6ca9bef72e$var$intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    }while (p !== a);\n    return false;\n}\n// check if a polygon diagonal is locally inside the polygon\nfunction $1b0c9f6ca9bef72e$var$locallyInside(a, b) {\n    return $1b0c9f6ca9bef72e$var$area(a.prev, a, a.next) < 0 ? $1b0c9f6ca9bef72e$var$area(a, b, a.next) >= 0 && $1b0c9f6ca9bef72e$var$area(a, a.prev, b) >= 0 : $1b0c9f6ca9bef72e$var$area(a, b, a.prev) < 0 || $1b0c9f6ca9bef72e$var$area(a, a.next, b) < 0;\n}\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction $1b0c9f6ca9bef72e$var$middleInside(a, b) {\n    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;\n    do {\n        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n        p = p.next;\n    }while (p !== a);\n    return inside;\n}\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction $1b0c9f6ca9bef72e$var$splitPolygon(a, b) {\n    var a2 = new $1b0c9f6ca9bef72e$var$Node(a.i, a.x, a.y), b2 = new $1b0c9f6ca9bef72e$var$Node(b.i, b.x, b.y), an = a.next, bp = b.prev;\n    a.next = b;\n    b.prev = a;\n    a2.next = an;\n    an.prev = a2;\n    b2.next = a2;\n    a2.prev = b2;\n    bp.next = b2;\n    b2.prev = bp;\n    return b2;\n}\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction $1b0c9f6ca9bef72e$var$insertNode(i, x, y, last) {\n    var p = new $1b0c9f6ca9bef72e$var$Node(i, x, y);\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\nfunction $1b0c9f6ca9bef72e$var$removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nfunction $1b0c9f6ca9bef72e$var$Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n    // z-order curve value\n    this.z = 0;\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\n$1b0c9f6ca9bef72e$var$earcut.deviation = function(data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    var polygonArea = Math.abs($1b0c9f6ca9bef72e$var$signedArea(data, 0, outerLen, dim));\n    if (hasHoles) for(var i = 0, len = holeIndices.length; i < len; i++){\n        var start = holeIndices[i] * dim;\n        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        polygonArea -= Math.abs($1b0c9f6ca9bef72e$var$signedArea(data, start, end, dim));\n    }\n    var trianglesArea = 0;\n    for(i = 0; i < triangles.length; i += 3){\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\nfunction $1b0c9f6ca9bef72e$var$signedArea(data, start, end, dim) {\n    var sum = 0;\n    for(var i = start, j = end - dim; i < end; i += dim){\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\n$1b0c9f6ca9bef72e$var$earcut.flatten = function(data) {\n    var dim = data[0][0].length, result = {\n        vertices: [],\n        holes: [],\n        dimensions: dim\n    }, holeIndex = 0;\n    for(var i = 0; i < data.length; i++){\n        for(var j = 0; j < data[i].length; j++)for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n});\n\n\n\nparcelRegister(\"7DIxn\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildRectangle\", () => $1d4b4832ec6feb5d$export$cbe813d11f2192b2);\n\"use strict\";\nconst $1d4b4832ec6feb5d$export$cbe813d11f2192b2 = {\n    build (shape, points) {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n        if (!(width >= 0 && height >= 0)) return points;\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        let count = 0;\n        verticesOffset *= verticesStride;\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n        count += verticesStride;\n        const verticesIndex = verticesOffset / verticesStride;\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    }\n};\n\n});\n\nparcelRegister(\"iAUCq\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildTriangle\", () => $14f13b7de979604e$export$8eb75cb9f614d270);\n\"use strict\";\nconst $14f13b7de979604e$export$8eb75cb9f614d270 = {\n    build (shape, points) {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        let count = 0;\n        verticesOffset *= verticesStride;\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n        const verticesIndex = verticesOffset / verticesStride;\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    }\n};\n\n});\n\n\n\nparcelRegister(\"gwwtL\", function(module, exports) {\n\n$parcel$export(module.exports, \"FillGradient\", () => $339e160815705dba$export$722a6ea8c60ca86);\n\nvar $a2eTA = parcelRequire(\"a2eTA\");\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $aQPld = parcelRequire(\"aQPld\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\"use strict\";\nconst $339e160815705dba$var$_FillGradient = class _FillGradient {\n    constructor(x0, y0, x1, y1){\n        this.uid = (0, $aGJhg.uid)(\"fillGradient\");\n        this.type = \"linear\";\n        this.gradientStops = [];\n        this.x0 = x0;\n        this.y0 = y0;\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n    addColorStop(offset, color) {\n        this.gradientStops.push({\n            offset: offset,\n            color: (0, $a2eTA.Color).shared.setValue(color).toHex()\n        });\n        return this;\n    }\n    // TODO move to the system!\n    buildLinearGradient() {\n        const defaultSize = _FillGradient.defaultTextureSize;\n        const { gradientStops: gradientStops } = this;\n        const canvas = (0, $iCGeI.DOMAdapter).get().createCanvas();\n        canvas.width = defaultSize;\n        canvas.height = defaultSize;\n        const ctx = canvas.getContext(\"2d\");\n        const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n        for(let i = 0; i < gradientStops.length; i++){\n            const stop = gradientStops[i];\n            gradient.addColorStop(stop.offset, stop.color);\n        }\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, defaultSize, defaultSize);\n        this.texture = new (0, $bLlTJ.Texture)({\n            source: new (0, $aQPld.ImageSource)({\n                resource: canvas,\n                addressModeU: \"clamp-to-edge\",\n                addressModeV: \"repeat\"\n            })\n        });\n        const { x0: x0, y0: y0, x1: x1, y1: y1 } = this;\n        const m = new (0, $eY4rt.Matrix)();\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const angle = Math.atan2(dy, dx);\n        m.translate(-x0, -y0);\n        m.scale(1 / defaultSize, 1 / defaultSize);\n        m.rotate(-angle);\n        m.scale(256 / dist, 1);\n        this.transform = m;\n    }\n};\n$339e160815705dba$var$_FillGradient.defaultTextureSize = 256;\nlet $339e160815705dba$export$722a6ea8c60ca86 = $339e160815705dba$var$_FillGradient;\n\n});\n\nparcelRegister(\"ktCpi\", function(module, exports) {\n\n$parcel$export(module.exports, \"FillPattern\", () => $e9923e9fec04a606$export$3d1378c7410cd8e);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\"use strict\";\nconst $e9923e9fec04a606$var$repetitionMap = {\n    repeat: {\n        addressModeU: \"repeat\",\n        addressModeV: \"repeat\"\n    },\n    \"repeat-x\": {\n        addressModeU: \"repeat\",\n        addressModeV: \"clamp-to-edge\"\n    },\n    \"repeat-y\": {\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"repeat\"\n    },\n    \"no-repeat\": {\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"clamp-to-edge\"\n    }\n};\nclass $e9923e9fec04a606$export$3d1378c7410cd8e {\n    constructor(texture, repetition){\n        this.uid = (0, $aGJhg.uid)(\"fillPattern\");\n        this.transform = new (0, $eY4rt.Matrix)();\n        this.texture = texture;\n        this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);\n        if (repetition) {\n            texture.source.style.addressModeU = $e9923e9fec04a606$var$repetitionMap[repetition].addressModeU;\n            texture.source.style.addressModeV = $e9923e9fec04a606$var$repetitionMap[repetition].addressModeV;\n        }\n    }\n    setTransform(transform) {\n        const texture = this.texture;\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);\n    }\n}\n\n});\n\nparcelRegister(\"3cebA\", function(module, exports) {\n\n$parcel$export(module.exports, \"Graphics\", () => $1b5e4ef3a1ed4a4a$export$29d3e417456abdad);\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\nvar $eicwU = parcelRequire(\"eicwU\");\n\nvar $8aC7P = parcelRequire(\"8aC7P\");\n\"use strict\";\nclass $1b5e4ef3a1ed4a4a$export$29d3e417456abdad extends (0, $eicwU.Container) {\n    /**\n   * @param options - Options for the Graphics.\n   */ constructor(options){\n        if (options instanceof (0, $8aC7P.GraphicsContext)) options = {\n            context: options\n        };\n        const { context: context, roundPixels: roundPixels, ...rest } = options || {};\n        super({\n            label: \"Graphics\",\n            ...rest\n        });\n        this.canBundle = true;\n        this.renderPipeId = \"graphics\";\n        this._roundPixels = 0;\n        if (!context) this._context = this._ownedContext = new (0, $8aC7P.GraphicsContext)();\n        else this._context = context;\n        this._context.on(\"update\", this.onViewUpdate, this);\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n    set context(context) {\n        if (context === this._context) return;\n        this._context.off(\"update\", this.onViewUpdate, this);\n        this._context = context;\n        this._context.on(\"update\", this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n    get context() {\n        return this._context;\n    }\n    /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */ get bounds() {\n        return this._context.bounds;\n    }\n    /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */ addBounds(bounds) {\n        bounds.addBounds(this._context.bounds);\n    }\n    /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        return this._context.containsPoint(point);\n    }\n    /**\n   *  Whether or not to round the x/y position of the graphic.\n   * @type {boolean}\n   */ get roundPixels() {\n        return !!this._roundPixels;\n    }\n    set roundPixels(value) {\n        this._roundPixels = value ? 1 : 0;\n    }\n    onViewUpdate() {\n        this._didChangeId += 4096;\n        this._didGraphicsUpdate = true;\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n        if (this.renderGroup) this.renderGroup.onChildViewUpdate(this);\n    }\n    /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */ destroy(options) {\n        if (this._ownedContext && !options) this._ownedContext.destroy(options);\n        else if (options === true || options?.context === true) this._context.destroy(options);\n        this._ownedContext = null;\n        this._context = null;\n        super.destroy(options);\n    }\n    _callContextMethod(method, args) {\n        this.context[method](...args);\n        return this;\n    }\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setFillStyle(...args) {\n        return this._callContextMethod(\"setFillStyle\", args);\n    }\n    /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setStrokeStyle(...args) {\n        return this._callContextMethod(\"setStrokeStyle\", args);\n    }\n    fill(...args) {\n        return this._callContextMethod(\"fill\", args);\n    }\n    /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ stroke(...args) {\n        return this._callContextMethod(\"stroke\", args);\n    }\n    texture(...args) {\n        return this._callContextMethod(\"texture\", args);\n    }\n    /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ beginPath() {\n        return this._callContextMethod(\"beginPath\", []);\n    }\n    /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */ cut() {\n        return this._callContextMethod(\"cut\", []);\n    }\n    arc(...args) {\n        return this._callContextMethod(\"arc\", args);\n    }\n    arcTo(...args) {\n        return this._callContextMethod(\"arcTo\", args);\n    }\n    arcToSvg(...args) {\n        return this._callContextMethod(\"arcToSvg\", args);\n    }\n    bezierCurveTo(...args) {\n        return this._callContextMethod(\"bezierCurveTo\", args);\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        return this._callContextMethod(\"closePath\", []);\n    }\n    ellipse(...args) {\n        return this._callContextMethod(\"ellipse\", args);\n    }\n    circle(...args) {\n        return this._callContextMethod(\"circle\", args);\n    }\n    path(...args) {\n        return this._callContextMethod(\"path\", args);\n    }\n    lineTo(...args) {\n        return this._callContextMethod(\"lineTo\", args);\n    }\n    moveTo(...args) {\n        return this._callContextMethod(\"moveTo\", args);\n    }\n    quadraticCurveTo(...args) {\n        return this._callContextMethod(\"quadraticCurveTo\", args);\n    }\n    rect(...args) {\n        return this._callContextMethod(\"rect\", args);\n    }\n    roundRect(...args) {\n        return this._callContextMethod(\"roundRect\", args);\n    }\n    poly(...args) {\n        return this._callContextMethod(\"poly\", args);\n    }\n    regularPoly(...args) {\n        return this._callContextMethod(\"regularPoly\", args);\n    }\n    roundPoly(...args) {\n        return this._callContextMethod(\"roundPoly\", args);\n    }\n    roundShape(...args) {\n        return this._callContextMethod(\"roundShape\", args);\n    }\n    filletRect(...args) {\n        return this._callContextMethod(\"filletRect\", args);\n    }\n    chamferRect(...args) {\n        return this._callContextMethod(\"chamferRect\", args);\n    }\n    star(...args) {\n        return this._callContextMethod(\"star\", args);\n    }\n    svg(...args) {\n        return this._callContextMethod(\"svg\", args);\n    }\n    restore(...args) {\n        return this._callContextMethod(\"restore\", args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */ save() {\n        return this._callContextMethod(\"save\", []);\n    }\n    /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */ getTransform() {\n        return this.context.getTransform();\n    }\n    /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ resetTransform() {\n        return this._callContextMethod(\"resetTransform\", []);\n    }\n    rotateTransform(...args) {\n        return this._callContextMethod(\"rotate\", args);\n    }\n    scaleTransform(...args) {\n        return this._callContextMethod(\"scale\", args);\n    }\n    setTransform(...args) {\n        return this._callContextMethod(\"setTransform\", args);\n    }\n    transform(...args) {\n        return this._callContextMethod(\"transform\", args);\n    }\n    translateTransform(...args) {\n        return this._callContextMethod(\"translate\", args);\n    }\n    /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ clear() {\n        return this._callContextMethod(\"clear\", []);\n    }\n    /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */ get fillStyle() {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value) {\n        this._context.fillStyle = value;\n    }\n    /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */ get strokeStyle() {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value) {\n        this._context.strokeStyle = value;\n    }\n    /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */ clone(deep = false) {\n        if (deep) return new $1b5e4ef3a1ed4a4a$export$29d3e417456abdad(this._context.clone());\n        this._ownedContext = null;\n        const clone = new $1b5e4ef3a1ed4a4a$export$29d3e417456abdad(this._context);\n        return clone;\n    }\n    // -------- v7 deprecations ---------\n    /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */ lineStyle(width, color, alpha) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n        const strokeStyle = {};\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n        this.context.strokeStyle = strokeStyle;\n        return this;\n    }\n    /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */ beginFill(color, alpha) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n        const fillStyle = {};\n        color && (fillStyle.color = color);\n        alpha && (fillStyle.alpha = alpha);\n        this.context.fillStyle = fillStyle;\n        return this;\n    }\n    /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */ endFill() {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n        if (strokeStyle.width !== (0, $8aC7P.GraphicsContext).defaultStrokeStyle.width || strokeStyle.color !== (0, $8aC7P.GraphicsContext).defaultStrokeStyle.color || strokeStyle.alpha !== (0, $8aC7P.GraphicsContext).defaultStrokeStyle.alpha) this.context.stroke();\n        return this;\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */ drawCircle(...args) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Graphics#drawCircle has been renamed to Graphics#circle\");\n        return this._callContextMethod(\"circle\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */ drawEllipse(...args) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n        return this._callContextMethod(\"ellipse\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */ drawPolygon(...args) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n        return this._callContextMethod(\"poly\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */ drawRect(...args) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Graphics#drawRect has been renamed to Graphics#rect\");\n        return this._callContextMethod(\"rect\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */ drawRoundedRect(...args) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n        return this._callContextMethod(\"roundRect\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */ drawStar(...args) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Graphics#drawStar has been renamed to Graphics#star\");\n        return this._callContextMethod(\"star\", args);\n    }\n}\n\n});\nparcelRegister(\"8aC7P\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsContext\", () => $5d1287b36eb70f7f$export$cde35afe8b5f985);\n\nvar $3vRz3 = parcelRequire(\"3vRz3\");\n\nvar $a2eTA = parcelRequire(\"a2eTA\");\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $1HooC = parcelRequire(\"1HooC\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\nvar $7wtv9 = parcelRequire(\"7wtv9\");\n\nvar $c9xxq = parcelRequire(\"c9xxq\");\n\nvar $6ph3G = parcelRequire(\"6ph3G\");\n\nvar $6mQKv = parcelRequire(\"6mQKv\");\n\"use strict\";\nconst $5d1287b36eb70f7f$var$tmpPoint = new (0, $1HooC.Point)();\nconst $5d1287b36eb70f7f$var$tempMatrix = new (0, $eY4rt.Matrix)();\nconst $5d1287b36eb70f7f$var$_GraphicsContext = class _GraphicsContext extends (0, (/*@__PURE__*/$parcel$interopDefault($3vRz3))) {\n    constructor(){\n        super(...arguments);\n        this.uid = (0, $aGJhg.uid)(\"graphicsContext\");\n        this.dirty = true;\n        this.batchMode = \"auto\";\n        this.instructions = [];\n        this._activePath = new (0, $c9xxq.GraphicsPath)();\n        this._transform = new (0, $eY4rt.Matrix)();\n        this._fillStyle = {\n            ..._GraphicsContext.defaultFillStyle\n        };\n        this._strokeStyle = {\n            ..._GraphicsContext.defaultStrokeStyle\n        };\n        this._stateStack = [];\n        this._tick = 0;\n        this._bounds = new (0, $7wtv9.Bounds)();\n        this._boundsDirty = true;\n    }\n    /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */ clone() {\n        const clone = new _GraphicsContext();\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = {\n            ...this._fillStyle\n        };\n        clone._strokeStyle = {\n            ...this._strokeStyle\n        };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n        return clone;\n    }\n    /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */ get fillStyle() {\n        return this._fillStyle;\n    }\n    set fillStyle(value) {\n        this._fillStyle = (0, $6mQKv.convertFillInputToFillStyle)(value, _GraphicsContext.defaultFillStyle);\n    }\n    /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */ get strokeStyle() {\n        return this._strokeStyle;\n    }\n    set strokeStyle(value) {\n        this._strokeStyle = (0, $6mQKv.convertFillInputToFillStyle)(value, _GraphicsContext.defaultStrokeStyle);\n    }\n    /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setFillStyle(style) {\n        this._fillStyle = (0, $6mQKv.convertFillInputToFillStyle)(style, _GraphicsContext.defaultFillStyle);\n        return this;\n    }\n    /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setStrokeStyle(style) {\n        this._strokeStyle = (0, $6mQKv.convertFillInputToFillStyle)(style, _GraphicsContext.defaultStrokeStyle);\n        return this;\n    }\n    texture(texture, tint, dx, dy, dw, dh) {\n        this.instructions.push({\n            action: \"texture\",\n            data: {\n                image: texture,\n                dx: dx || 0,\n                dy: dy || 0,\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? (0, $a2eTA.Color).shared.setValue(tint).toNumber() : 16777215\n            }\n        });\n        this.onUpdate();\n        return this;\n    }\n    /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ beginPath() {\n        this._activePath = new (0, $c9xxq.GraphicsPath)();\n        return this;\n    }\n    fill(style, alpha) {\n        let path;\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") path = lastInstruction.data.path;\n        else path = this._activePath.clone();\n        if (!path) return this;\n        if (style != null) {\n            if (alpha !== void 0 && typeof style === \"number\") {\n                (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n                style = {\n                    color: style,\n                    alpha: alpha\n                };\n            }\n            this._fillStyle = (0, $6mQKv.convertFillInputToFillStyle)(style, _GraphicsContext.defaultFillStyle);\n        }\n        this.instructions.push({\n            action: \"fill\",\n            // TODO copy fill style!\n            data: {\n                style: this.fillStyle,\n                path: path\n            }\n        });\n        this.onUpdate();\n        this._initNextPathLocation();\n        this._tick = 0;\n        return this;\n    }\n    _initNextPathLocation() {\n        const { x: x, y: y } = this._activePath.getLastPoint((0, $1HooC.Point).shared);\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n    /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ stroke(style) {\n        let path;\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") path = lastInstruction.data.path;\n        else path = this._activePath.clone();\n        if (!path) return this;\n        if (style != null) this._strokeStyle = (0, $6mQKv.convertFillInputToFillStyle)(style, _GraphicsContext.defaultStrokeStyle);\n        this.instructions.push({\n            action: \"stroke\",\n            // TODO copy fill style!\n            data: {\n                style: this.strokeStyle,\n                path: path\n            }\n        });\n        this.onUpdate();\n        this._initNextPathLocation();\n        this._tick = 0;\n        return this;\n    }\n    /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ cut() {\n        for(let i = 0; i < 2; i++){\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n            const holePath = this._activePath.clone();\n            if (lastInstruction) {\n                if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n                    if (lastInstruction.data.hole) lastInstruction.data.hole.addPath(holePath);\n                    else {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n        this._initNextPathLocation();\n        return this;\n    }\n    /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arc(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, radius, startAngle, endAngle, counterclockwise);\n        return this;\n    }\n    /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ arcTo(x1, y1, x2, y2, radius) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arcTo(t.a * x1 + t.c * y1 + t.tx, t.b * x1 + t.d * y1 + t.ty, t.a * x2 + t.c * y2 + t.tx, t.b * x2 + t.d * y2 + t.ty, radius);\n        return this;\n    }\n    /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */ arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arcToSvg(rx, ry, xAxisRotation, // should we rotate this with transform??\n        largeArcFlag, sweepFlag, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.bezierCurveTo(t.a * cp1x + t.c * cp1y + t.tx, t.b * cp1x + t.d * cp1y + t.ty, t.a * cp2x + t.c * cp2y + t.tx, t.b * cp2x + t.d * cp2y + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this._tick++;\n        this._activePath?.closePath();\n        return this;\n    }\n    /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */ ellipse(x, y, radiusX, radiusY) {\n        this._tick++;\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius) {\n        this._tick++;\n        this._activePath.circle(x, y, radius, this._transform.clone());\n        return this;\n    }\n    /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */ path(path) {\n        this._tick++;\n        this._activePath.addPath(path, this._transform.clone());\n        return this;\n    }\n    /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */ lineTo(x, y) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.lineTo(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);\n        return this;\n    }\n    /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */ moveTo(x, y) {\n        this._tick++;\n        const t = this._transform;\n        const instructions = this._activePath.instructions;\n        const transformedX = t.a * x + t.c * y + t.tx;\n        const transformedY = t.b * x + t.d * y + t.ty;\n        if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n            return this;\n        }\n        this._activePath.moveTo(transformedX, transformedY);\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.quadraticCurveTo(t.a * cpx + t.c * cpy + t.tx, t.b * cpx + t.d * cpy + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);\n        return this;\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h) {\n        this._tick++;\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */ roundRect(x, y, w, h, radius) {\n        this._tick++;\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */ poly(points, close) {\n        this._tick++;\n        this._activePath.poly(points, close, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ regularPoly(x, y, radius, sides, rotation = 0, transform) {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n        return this;\n    }\n    /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */ roundPoly(x, y, radius, sides, corner, rotation) {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n        return this;\n    }\n    /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */ roundShape(points, radius, useQuadratic, smoothness) {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n        return this;\n    }\n    /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */ filletRect(x, y, width, height, fillet) {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n        return this;\n    }\n    /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */ chamferRect(x, y, width, height, chamfer, transform) {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n        return this;\n    }\n    /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */ star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n        this._tick++;\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n        return this;\n    }\n    /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */ svg(svg) {\n        this._tick++;\n        (0, $6ph3G.SVGParser)(svg, this);\n        return this;\n    }\n    /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */ restore() {\n        const state = this._stateStack.pop();\n        if (state) {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n        return this;\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */ save() {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: {\n                ...this._fillStyle\n            },\n            strokeStyle: {\n                ...this._strokeStyle\n            }\n        });\n        return this;\n    }\n    /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */ getTransform() {\n        return this._transform;\n    }\n    /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ resetTransform() {\n        this._transform.identity();\n        return this;\n    }\n    /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ rotate(angle) {\n        this._transform.rotate(angle);\n        return this;\n    }\n    /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ scale(x, y = x) {\n        this._transform.scale(x, y);\n        return this;\n    }\n    setTransform(a, b, c, d, dx, dy) {\n        if (a instanceof (0, $eY4rt.Matrix)) {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n            return this;\n        }\n        this._transform.set(a, b, c, d, dx, dy);\n        return this;\n    }\n    transform(a, b, c, d, dx, dy) {\n        if (a instanceof (0, $eY4rt.Matrix)) {\n            this._transform.append(a);\n            return this;\n        }\n        $5d1287b36eb70f7f$var$tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append($5d1287b36eb70f7f$var$tempMatrix);\n        return this;\n    }\n    /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ translate(x, y = x) {\n        this._transform.translate(x, y);\n        return this;\n    }\n    /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ clear() {\n        this.instructions.length = 0;\n        this.resetTransform();\n        this.onUpdate();\n        return this;\n    }\n    onUpdate() {\n        if (this.dirty) return;\n        this.emit(\"update\", this, 16);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n    /** The bounds of the graphic shape. */ get bounds() {\n        if (!this._boundsDirty) return this._bounds;\n        const bounds = this._bounds;\n        bounds.clear();\n        for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n            if (action === \"fill\") {\n                const data = instruction.data;\n                bounds.addBounds(data.path.bounds);\n            } else if (action === \"texture\") {\n                const data = instruction.data;\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === \"stroke\") {\n                const data = instruction.data;\n                const padding = data.style.width / 2;\n                const _bounds = data.path.bounds;\n                bounds.addFrame(_bounds.minX - padding, _bounds.minY - padding, _bounds.maxX + padding, _bounds.maxY + padding);\n            }\n        }\n        return bounds;\n    }\n    /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */ containsPoint(point) {\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n        const instructions = this.instructions;\n        let hasHit = false;\n        for(let k = 0; k < instructions.length; k++){\n            const instruction = instructions[k];\n            const data = instruction.data;\n            const path = data.path;\n            if (!instruction.action || !path) continue;\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n            for(let i = 0; i < shapes.length; i++){\n                const shape = shapes[i].shape;\n                if (!style || !shape) continue;\n                const transform = shapes[i].transform;\n                const transformedPoint = transform ? transform.applyInverse(point, $5d1287b36eb70f7f$var$tmpPoint) : point;\n                if (instruction.action === \"fill\") hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                else hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n                const holes = data.hole;\n                if (holes) {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n                    if (holeShapes) {\n                        for(let j = 0; j < holeShapes.length; j++)if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) hasHit = false;\n                    }\n                }\n                if (hasHit) return true;\n            }\n        }\n        return hasHit;\n    }\n    /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */ destroy(options = false) {\n        this._stateStack.length = 0;\n        this._transform = null;\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            if (this._fillStyle.texture) this._fillStyle.texture.destroy(destroyTextureSource);\n            if (this._strokeStyle.texture) this._strokeStyle.texture.destroy(destroyTextureSource);\n        }\n        this._fillStyle = null;\n        this._strokeStyle = null;\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n};\n/** The default fill style to use when none is provided. */ $5d1287b36eb70f7f$var$_GraphicsContext.defaultFillStyle = {\n    /** The color to use for the fill. */ color: 16777215,\n    /** The alpha value to use for the fill. */ alpha: 1,\n    /** The texture to use for the fill. */ texture: (0, $bLlTJ.Texture).WHITE,\n    /** The matrix to apply. */ matrix: null,\n    /** The fill pattern to use. */ fill: null\n};\n/** The default stroke style to use when none is provided. */ $5d1287b36eb70f7f$var$_GraphicsContext.defaultStrokeStyle = {\n    /** The width of the stroke. */ width: 1,\n    /** The color to use for the stroke. */ color: 16777215,\n    /** The alpha value to use for the stroke. */ alpha: 1,\n    /** The alignment of the stroke. */ alignment: 0.5,\n    /** The miter limit to use. */ miterLimit: 10,\n    /** The line cap style to use. */ cap: \"butt\",\n    /** The line join style to use. */ join: \"miter\",\n    /** The texture to use for the fill. */ texture: (0, $bLlTJ.Texture).WHITE,\n    /** The matrix to apply. */ matrix: null,\n    /** The fill pattern to use. */ fill: null\n};\nlet $5d1287b36eb70f7f$export$cde35afe8b5f985 = $5d1287b36eb70f7f$var$_GraphicsContext;\n\n});\nparcelRegister(\"c9xxq\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsPath\", () => $0663b1de1906f348$export$7e54506375634c19);\n\nvar $1HooC = parcelRequire(\"1HooC\");\n\nvar $aGJhg = parcelRequire(\"aGJhg\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $Zb4t5 = parcelRequire(\"Zb4t5\");\n\nvar $ein11 = parcelRequire(\"ein11\");\n\"use strict\";\nclass $0663b1de1906f348$export$7e54506375634c19 {\n    /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */ constructor(instructions){\n        this.instructions = [];\n        this.uid = (0, $aGJhg.uid)(\"graphicsPath\");\n        this._dirty = true;\n        if (typeof instructions === \"string\") (0, $Zb4t5.SVGToGraphicsPath)(instructions, this);\n        else this.instructions = instructions?.slice() ?? [];\n    }\n    /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */ get shapePath() {\n        if (!this._shapePath) this._shapePath = new (0, $ein11.ShapePath)(this);\n        if (this._dirty) {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n        return this._shapePath;\n    }\n    /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */ addPath(path, transform) {\n        path = path.clone();\n        this.instructions.push({\n            action: \"addPath\",\n            data: [\n                path,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    arc(...args) {\n        this.instructions.push({\n            action: \"arc\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    arcTo(...args) {\n        this.instructions.push({\n            action: \"arcTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    arcToSvg(...args) {\n        this.instructions.push({\n            action: \"arcToSvg\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    bezierCurveTo(...args) {\n        this.instructions.push({\n            action: \"bezierCurveTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n        const last = this.instructions[this.instructions.length - 1];\n        const lastPoint = this.getLastPoint((0, $1HooC.Point).shared);\n        let cp1x = 0;\n        let cp1y = 0;\n        if (!last || last.action !== \"bezierCurveTo\") {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        } else {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n        this.instructions.push({\n            action: \"bezierCurveTo\",\n            data: [\n                cp1x,\n                cp1y,\n                cp2x,\n                cp2y,\n                x,\n                y,\n                smoothness\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this.instructions.push({\n            action: \"closePath\",\n            data: []\n        });\n        this._dirty = true;\n        return this;\n    }\n    ellipse(...args) {\n        this.instructions.push({\n            action: \"ellipse\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    lineTo(...args) {\n        this.instructions.push({\n            action: \"lineTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    moveTo(...args) {\n        this.instructions.push({\n            action: \"moveTo\",\n            data: args\n        });\n        return this;\n    }\n    quadraticCurveTo(...args) {\n        this.instructions.push({\n            action: \"quadraticCurveTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveToShort(x, y, smoothness) {\n        const last = this.instructions[this.instructions.length - 1];\n        const lastPoint = this.getLastPoint((0, $1HooC.Point).shared);\n        let cpx1 = 0;\n        let cpy1 = 0;\n        if (!last || last.action !== \"quadraticCurveTo\") {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        } else {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n        this.instructions.push({\n            action: \"quadraticCurveTo\",\n            data: [\n                cpx1,\n                cpy1,\n                x,\n                y,\n                smoothness\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h, transform) {\n        this.instructions.push({\n            action: \"rect\",\n            data: [\n                x,\n                y,\n                w,\n                h,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius, transform) {\n        this.instructions.push({\n            action: \"circle\",\n            data: [\n                x,\n                y,\n                radius,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundRect(...args) {\n        this.instructions.push({\n            action: \"roundRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    poly(...args) {\n        this.instructions.push({\n            action: \"poly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    regularPoly(...args) {\n        this.instructions.push({\n            action: \"regularPoly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundPoly(...args) {\n        this.instructions.push({\n            action: \"roundPoly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundShape(...args) {\n        this.instructions.push({\n            action: \"roundShape\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    filletRect(...args) {\n        this.instructions.push({\n            action: \"filletRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    chamferRect(...args) {\n        this.instructions.push({\n            action: \"chamferRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */ // eslint-disable-next-line max-len\n    star(x, y, points, radius, innerRadius, rotation, transform) {\n        innerRadius = innerRadius || radius / 2;\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const len = points * 2;\n        const delta = Math.PI * 2 / len;\n        const polygon = [];\n        for(let i = 0; i < len; i++){\n            const r = i % 2 ? innerRadius : radius;\n            const angle = i * delta + startAngle;\n            polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));\n        }\n        this.poly(polygon, true, transform);\n        return this;\n    }\n    /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */ clone(deep = false) {\n        const newGraphicsPath2D = new $0663b1de1906f348$export$7e54506375634c19();\n        if (!deep) newGraphicsPath2D.instructions = this.instructions.slice();\n        else for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            newGraphicsPath2D.instructions.push({\n                action: instruction.action,\n                data: instruction.data.slice()\n            });\n        }\n        return newGraphicsPath2D;\n    }\n    clear() {\n        this.instructions.length = 0;\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */ transform(matrix) {\n        if (matrix.isIdentity()) return this;\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        let x = 0;\n        let y = 0;\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n        let rx = 0;\n        let ry = 0;\n        for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            const data = instruction.data;\n            switch(instruction.action){\n                case \"moveTo\":\n                case \"lineTo\":\n                    x = data[0];\n                    y = data[1];\n                    data[0] = a * x + c * y + tx;\n                    data[1] = b * x + d * y + ty;\n                    break;\n                case \"bezierCurveTo\":\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n                    x = data[4];\n                    y = data[5];\n                    data[0] = a * cpx1 + c * cpy1 + tx;\n                    data[1] = b * cpx1 + d * cpy1 + ty;\n                    data[2] = a * cpx2 + c * cpy2 + tx;\n                    data[3] = b * cpx2 + d * cpy2 + ty;\n                    data[4] = a * x + c * y + tx;\n                    data[5] = b * x + d * y + ty;\n                    break;\n                case \"quadraticCurveTo\":\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    x = data[2];\n                    y = data[3];\n                    data[0] = a * cpx1 + c * cpy1 + tx;\n                    data[1] = b * cpx1 + d * cpy1 + ty;\n                    data[2] = a * x + c * y + tx;\n                    data[3] = b * x + d * y + ty;\n                    break;\n                case \"arcToSvg\":\n                    x = data[5];\n                    y = data[6];\n                    rx = data[0];\n                    ry = data[1];\n                    data[0] = a * rx + c * ry;\n                    data[1] = b * rx + d * ry;\n                    data[5] = a * x + c * y + tx;\n                    data[6] = b * x + d * y + ty;\n                    break;\n                case \"circle\":\n                    data[4] = $0663b1de1906f348$var$adjustTransform(data[3], matrix);\n                    break;\n                case \"rect\":\n                    data[4] = $0663b1de1906f348$var$adjustTransform(data[4], matrix);\n                    break;\n                case \"ellipse\":\n                    data[8] = $0663b1de1906f348$var$adjustTransform(data[8], matrix);\n                    break;\n                case \"roundRect\":\n                    data[5] = $0663b1de1906f348$var$adjustTransform(data[5], matrix);\n                    break;\n                case \"addPath\":\n                    data[0].transform(matrix);\n                    break;\n                case \"poly\":\n                    data[2] = $0663b1de1906f348$var$adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    (0, $hUCK4.warn)(\"unknown transform action\", instruction.action);\n                    break;\n            }\n        }\n        this._dirty = true;\n        return this;\n    }\n    get bounds() {\n        return this.shapePath.bounds;\n    }\n    /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */ getLastPoint(out) {\n        let index = this.instructions.length - 1;\n        let lastInstruction = this.instructions[index];\n        if (!lastInstruction) {\n            out.x = 0;\n            out.y = 0;\n            return out;\n        }\n        while(lastInstruction.action === \"closePath\"){\n            index--;\n            if (index < 0) {\n                out.x = 0;\n                out.y = 0;\n                return out;\n            }\n            lastInstruction = this.instructions[index];\n        }\n        switch(lastInstruction.action){\n            case \"moveTo\":\n            case \"lineTo\":\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case \"quadraticCurveTo\":\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case \"bezierCurveTo\":\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case \"arc\":\n            case \"arcToSvg\":\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case \"addPath\":\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n        return out;\n    }\n}\nfunction $0663b1de1906f348$var$adjustTransform(currentMatrix, transform) {\n    if (currentMatrix) return currentMatrix.prepend(transform);\n    return transform.clone();\n}\n\n});\nparcelRegister(\"Zb4t5\", function(module, exports) {\n\n$parcel$export(module.exports, \"SVGToGraphicsPath\", () => $af4e82628a1183ef$export$14a4a8042d02aa8d);\n\nvar $8DJYa = parcelRequire(\"8DJYa\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\"use strict\";\nfunction $af4e82628a1183ef$export$14a4a8042d02aa8d(svgPath, path) {\n    const commands = (0, (/*@__PURE__*/$parcel$interopDefault($8DJYa)))(svgPath);\n    const subpaths = [];\n    let currentSubPath = null;\n    let lastX = 0;\n    let lastY = 0;\n    for(let i = 0; i < commands.length; i++){\n        const command = commands[i];\n        const type = command[0];\n        const data = command;\n        switch(type){\n            case \"M\":\n                lastX = data[1];\n                lastY = data[2];\n                path.moveTo(lastX, lastY);\n                break;\n            case \"m\":\n                lastX += data[1];\n                lastY += data[2];\n                path.moveTo(lastX, lastY);\n                break;\n            case \"H\":\n                lastX = data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"h\":\n                lastX += data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"V\":\n                lastY = data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"v\":\n                lastY += data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"L\":\n                lastX = data[1];\n                lastY = data[2];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"l\":\n                lastX += data[1];\n                lastY += data[2];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"C\":\n                lastX = data[5];\n                lastY = data[6];\n                path.bezierCurveTo(data[1], data[2], data[3], data[4], lastX, lastY);\n                break;\n            case \"c\":\n                path.bezierCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4], lastX + data[5], lastY + data[6]);\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case \"S\":\n                lastX = data[3];\n                lastY = data[4];\n                path.bezierCurveToShort(data[1], data[2], lastX, lastY);\n                break;\n            case \"s\":\n                path.bezierCurveToShort(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case \"Q\":\n                lastX = data[3];\n                lastY = data[4];\n                path.quadraticCurveTo(data[1], data[2], lastX, lastY);\n                break;\n            case \"q\":\n                path.quadraticCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case \"T\":\n                lastX = data[1];\n                lastY = data[2];\n                path.quadraticCurveToShort(lastX, lastY);\n                break;\n            case \"t\":\n                lastX += data[1];\n                lastY += data[2];\n                path.quadraticCurveToShort(lastX, lastY);\n                break;\n            case \"A\":\n                lastX = data[6];\n                lastY = data[7];\n                path.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);\n                break;\n            case \"a\":\n                lastX += data[6];\n                lastY += data[7];\n                path.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);\n                break;\n            case \"Z\":\n            case \"z\":\n                path.closePath();\n                if (subpaths.length > 0) {\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath) {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    } else {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                (0, $hUCK4.warn)(`Unknown SVG path command: ${type}`);\n        }\n        if (type !== \"Z\" && type !== \"z\") {\n            if (currentSubPath === null) {\n                currentSubPath = {\n                    startX: lastX,\n                    startY: lastY\n                };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n    return path;\n}\n\n});\nparcelRegister(\"8DJYa\", function(module, exports) {\nmodule.exports = $64a59fcc91535eb3$var$parse;\n/**\n * expected argument lengths\n * @type {Object}\n */ var $64a59fcc91535eb3$var$length = {\n    a: 7,\n    c: 6,\n    h: 1,\n    l: 2,\n    m: 2,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    z: 0\n};\n/**\n * segment pattern\n * @type {RegExp}\n */ var $64a59fcc91535eb3$var$segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */ function $64a59fcc91535eb3$var$parse(path) {\n    var data = [];\n    path.replace($64a59fcc91535eb3$var$segment, function(_, command, args) {\n        var type = command.toLowerCase();\n        args = $64a59fcc91535eb3$var$parseValues(args);\n        // overloaded moveTo\n        if (type == \"m\" && args.length > 2) {\n            data.push([\n                command\n            ].concat(args.splice(0, 2)));\n            type = \"l\";\n            command = command == \"m\" ? \"l\" : \"L\";\n        }\n        while(true){\n            if (args.length == $64a59fcc91535eb3$var$length[type]) {\n                args.unshift(command);\n                return data.push(args);\n            }\n            if (args.length < $64a59fcc91535eb3$var$length[type]) throw new Error(\"malformed path data\");\n            data.push([\n                command\n            ].concat(args.splice(0, $64a59fcc91535eb3$var$length[type])));\n        }\n    });\n    return data;\n}\nvar $64a59fcc91535eb3$var$number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig;\nfunction $64a59fcc91535eb3$var$parseValues(args) {\n    var numbers = args.match($64a59fcc91535eb3$var$number);\n    return numbers ? numbers.map(Number) : [];\n}\n\n});\n\n\nparcelRegister(\"ein11\", function(module, exports) {\n\n$parcel$export(module.exports, \"ShapePath\", () => $664ff60a6792361f$export$148534a3c727230b);\n\nvar $h7nJT = parcelRequire(\"h7nJT\");\n\nvar $9hswb = parcelRequire(\"9hswb\");\n\nvar $hbpIN = parcelRequire(\"hbpIN\");\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\nvar $7u40a = parcelRequire(\"7u40a\");\n\nvar $7wtv9 = parcelRequire(\"7wtv9\");\n\nvar $lI2iN = parcelRequire(\"lI2iN\");\n\nvar $eRV6E = parcelRequire(\"eRV6E\");\n\nvar $aiLPr = parcelRequire(\"aiLPr\");\n\nvar $boMdH = parcelRequire(\"boMdH\");\n\nvar $jjbCG = parcelRequire(\"jjbCG\");\n\nvar $9ad7k = parcelRequire(\"9ad7k\");\n\"use strict\";\nconst $664ff60a6792361f$var$tempRectangle = new (0, $fM4Mk.Rectangle)();\nclass $664ff60a6792361f$export$148534a3c727230b {\n    constructor(graphicsPath2D){\n        /** The list of shape primitives that make up the path. */ this.shapePrimitives = [];\n        this._currentPoly = null;\n        this._bounds = new (0, $7wtv9.Bounds)();\n        this._graphicsPath2D = graphicsPath2D;\n    }\n    /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */ moveTo(x, y) {\n        this.startPoly(x, y);\n        return this;\n    }\n    /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */ lineTo(x, y) {\n        this._ensurePoly();\n        const points = this._currentPoly.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n        if (fromX !== x || fromY !== y) points.push(x, y);\n        return this;\n    }\n    /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */ arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n        this._ensurePoly(false);\n        const points = this._currentPoly.points;\n        (0, $aiLPr.buildArc)(points, x, y, radius, startAngle, endAngle, counterclockwise);\n        return this;\n    }\n    /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */ arcTo(x1, y1, x2, y2, radius) {\n        this._ensurePoly();\n        const points = this._currentPoly.points;\n        (0, $boMdH.buildArcTo)(points, x1, y1, x2, y2, radius);\n        return this;\n    }\n    /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */ arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        const points = this._currentPoly.points;\n        (0, $jjbCG.buildArcToSvg)(points, this._currentPoly.lastX, this._currentPoly.lastY, x, y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n        this._ensurePoly();\n        const currentPoly = this._currentPoly;\n        (0, $lI2iN.buildAdaptiveBezier)(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, cp2x, cp2y, x, y, smoothness);\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n        this._ensurePoly();\n        const currentPoly = this._currentPoly;\n        (0, $eRV6E.buildAdaptiveQuadratic)(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, x, y, smoothing);\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this.endPoly(true);\n        return this;\n    }\n    /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */ addPath(path, transform) {\n        this.endPoly();\n        if (transform && !transform.isIdentity()) {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n        for(let i = 0; i < path.instructions.length; i++){\n            const instruction = path.instructions[i];\n            this[instruction.action](...instruction.data);\n        }\n        return this;\n    }\n    /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */ finish(closePath = false) {\n        this.endPoly(closePath);\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h, transform) {\n        this.drawShape(new (0, $fM4Mk.Rectangle)(x, y, w, h), transform);\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius, transform) {\n        this.drawShape(new (0, $h7nJT.Circle)(x, y, radius), transform);\n        return this;\n    }\n    /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ poly(points, close, transform) {\n        const polygon = new (0, $hbpIN.Polygon)(points);\n        polygon.closePath = close;\n        this.drawShape(polygon, transform);\n        return this;\n    }\n    /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ regularPoly(x, y, radius, sides, rotation = 0, transform) {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const delta = Math.PI * 2 / sides;\n        const polygon = [];\n        for(let i = 0; i < sides; i++){\n            const angle = i * delta + startAngle;\n            polygon.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));\n        }\n        this.poly(polygon, true, transform);\n        return this;\n    }\n    /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */ roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n        sides = Math.max(sides | 0, 3);\n        if (corner <= 0) return this.regularPoly(x, y, radius, sides, rotation);\n        const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n        corner = Math.min(corner, sideLength);\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const delta = Math.PI * 2 / sides;\n        const internalAngle = (sides - 2) * Math.PI / sides / 2;\n        for(let i = 0; i < sides; i++){\n            const angle = i * delta + startAngle;\n            const x0 = x + radius * Math.cos(angle);\n            const y0 = y + radius * Math.sin(angle);\n            const a1 = angle + Math.PI + internalAngle;\n            const a2 = angle - Math.PI - internalAngle;\n            const x1 = x0 + corner * Math.cos(a1);\n            const y1 = y0 + corner * Math.sin(a1);\n            const x3 = x0 + corner * Math.cos(a2);\n            const y3 = y0 + corner * Math.sin(a2);\n            if (i === 0) this.moveTo(x1, y1);\n            else this.lineTo(x1, y1);\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n        return this.closePath();\n    }\n    /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */ roundShape(points, radius, useQuadratic = false, smoothness) {\n        if (points.length < 3) return this;\n        if (useQuadratic) (0, $9ad7k.roundedShapeQuadraticCurve)(this, points, radius, smoothness);\n        else (0, $9ad7k.roundedShapeArc)(this, points, radius);\n        return this.closePath();\n    }\n    /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */ filletRect(x, y, width, height, fillet) {\n        if (fillet === 0) return this.rect(x, y, width, height);\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n        return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n    }\n    /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */ chamferRect(x, y, width, height, chamfer, transform) {\n        if (chamfer <= 0) return this.rect(x, y, width, height);\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset,\n            y,\n            right - inset,\n            y,\n            right,\n            y + inset,\n            right,\n            bottom - inset,\n            right - inset,\n            bottom,\n            x + inset,\n            bottom,\n            x,\n            bottom - inset,\n            x,\n            y + inset\n        ];\n        for(let i = points.length - 1; i >= 2; i -= 2)if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) points.splice(i - 1, 2);\n        return this.poly(points, true, transform);\n    }\n    /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */ ellipse(x, y, radiusX, radiusY, transform) {\n        this.drawShape(new (0, $9hswb.Ellipse)(x, y, radiusX, radiusY), transform);\n        return this;\n    }\n    /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ roundRect(x, y, w, h, radius, transform) {\n        this.drawShape(new (0, $7u40a.RoundedRectangle)(x, y, w, h, radius), transform);\n        return this;\n    }\n    /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */ drawShape(shape, matrix) {\n        this.endPoly();\n        this.shapePrimitives.push({\n            shape: shape,\n            transform: matrix\n        });\n        return this;\n    }\n    /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */ startPoly(x, y) {\n        let currentPoly = this._currentPoly;\n        if (currentPoly) this.endPoly();\n        currentPoly = new (0, $hbpIN.Polygon)();\n        currentPoly.points.push(x, y);\n        this._currentPoly = currentPoly;\n        return this;\n    }\n    /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */ endPoly(closePath = false) {\n        const shape = this._currentPoly;\n        if (shape && shape.points.length > 2) {\n            shape.closePath = closePath;\n            this.shapePrimitives.push({\n                shape: shape\n            });\n        }\n        this._currentPoly = null;\n        return this;\n    }\n    _ensurePoly(start = true) {\n        if (this._currentPoly) return;\n        this._currentPoly = new (0, $hbpIN.Polygon)();\n        if (start) {\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n            if (lastShape) {\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n                if (!lastShape.transform.isIdentity()) {\n                    const t = lastShape.transform;\n                    const tempX = lx;\n                    lx = t.a * lx + t.c * ly + t.tx;\n                    ly = t.b * tempX + t.d * ly + t.ty;\n                }\n                this._currentPoly.points.push(lx, ly);\n            } else this._currentPoly.points.push(0, 0);\n        }\n    }\n    /** Builds the path. */ buildPath() {\n        const path = this._graphicsPath2D;\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n        for(let i = 0; i < path.instructions.length; i++){\n            const instruction = path.instructions[i];\n            this[instruction.action](...instruction.data);\n        }\n        this.finish();\n    }\n    /** Gets the bounds of the path. */ get bounds() {\n        const bounds = this._bounds;\n        bounds.clear();\n        const shapePrimitives = this.shapePrimitives;\n        for(let i = 0; i < shapePrimitives.length; i++){\n            const shapePrimitive = shapePrimitives[i];\n            const boundsRect = shapePrimitive.shape.getBounds($664ff60a6792361f$var$tempRectangle);\n            if (shapePrimitive.transform) bounds.addRect(boundsRect, shapePrimitive.transform);\n            else bounds.addRect(boundsRect);\n        }\n        return bounds;\n    }\n}\n\n});\nparcelRegister(\"h7nJT\", function(module, exports) {\n\n$parcel$export(module.exports, \"Circle\", () => $f9e7c5f8c3846477$export$c89a927ffc67e6fa);\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\"use strict\";\nclass $f9e7c5f8c3846477$export$c89a927ffc67e6fa {\n    /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */ constructor(x = 0, y = 0, radius = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */ this.type = \"circle\";\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n    /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */ clone() {\n        return new $f9e7c5f8c3846477$export$c89a927ffc67e6fa(this.x, this.y, this.radius);\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */ contains(x, y) {\n        if (this.radius <= 0) return false;\n        const r2 = this.radius * this.radius;\n        let dx = this.x - x;\n        let dy = this.y - y;\n        dx *= dx;\n        dy *= dy;\n        return dx + dy <= r2;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */ strokeContains(x, y, width) {\n        if (this.radius === 0) return false;\n        const dx = this.x - x;\n        const dy = this.y - y;\n        const r = this.radius;\n        const w2 = width / 2;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < r + w2 && distance > r - w2;\n    }\n    /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new (0, $fM4Mk.Rectangle)();\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n        return out;\n    }\n    /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(circle) {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n        return this;\n    }\n    /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(circle) {\n        circle.copyFrom(this);\n        return circle;\n    }\n    toString() {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n}\n\n});\n\nparcelRegister(\"9hswb\", function(module, exports) {\n\n$parcel$export(module.exports, \"Ellipse\", () => $985c1ca392a56bd1$export$80b0269ab108fa11);\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\"use strict\";\nclass $985c1ca392a56bd1$export$80b0269ab108fa11 {\n    /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */ constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */ this.type = \"ellipse\";\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n    /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */ clone() {\n        return new $985c1ca392a56bd1$export$80b0269ab108fa11(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */ contains(x, y) {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0) return false;\n        let normx = (x - this.x) / this.halfWidth;\n        let normy = (y - this.y) / this.halfHeight;\n        normx *= normx;\n        normy *= normy;\n        return normx + normy <= 1;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */ strokeContains(x, y, width) {\n        const { halfWidth: halfWidth, halfHeight: halfHeight } = this;\n        if (halfWidth <= 0 || halfHeight <= 0) return false;\n        const halfStrokeWidth = width / 2;\n        const innerA = halfWidth - halfStrokeWidth;\n        const innerB = halfHeight - halfStrokeWidth;\n        const outerA = halfWidth + halfStrokeWidth;\n        const outerB = halfHeight + halfStrokeWidth;\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n        const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n        const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n    /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @returns The framing rectangle\n   */ getBounds() {\n        return new (0, $fM4Mk.Rectangle)(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);\n    }\n    /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */ copyFrom(ellipse) {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n        return this;\n    }\n    /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(ellipse) {\n        ellipse.copyFrom(this);\n        return ellipse;\n    }\n    toString() {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n}\n\n});\n\nparcelRegister(\"hbpIN\", function(module, exports) {\n\n$parcel$export(module.exports, \"Polygon\", () => $11dc5aebdc9b56ee$export$7d31b617c820d435);\n\nvar $4sAiw = parcelRequire(\"4sAiw\");\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\"use strict\";\nclass $11dc5aebdc9b56ee$export$7d31b617c820d435 {\n    /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */ constructor(...points){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */ this.type = \"polygon\";\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n        if (typeof flat[0] !== \"number\") {\n            const p = [];\n            for(let i = 0, il = flat.length; i < il; i++)p.push(flat[i].x, flat[i].y);\n            flat = p;\n        }\n        this.points = flat;\n        this.closePath = true;\n    }\n    /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */ clone() {\n        const points = this.points.slice();\n        const polygon = new $11dc5aebdc9b56ee$export$7d31b617c820d435(points);\n        polygon.closePath = this.closePath;\n        return polygon;\n    }\n    /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */ contains(x, y) {\n        let inside = false;\n        const length = this.points.length / 2;\n        for(let i = 0, j = length - 1; i < length; j = i++){\n            const xi = this.points[i * 2];\n            const yi = this.points[i * 2 + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[j * 2 + 1];\n            const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n            if (intersect) inside = !inside;\n        }\n        return inside;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */ strokeContains(x, y, strokeWidth) {\n        const halfStrokeWidth = strokeWidth / 2;\n        const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n        const { points: points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n        for(let i = 0; i < iterationLength; i += 2){\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n            const distanceSqrd = (0, $4sAiw.squaredDistanceToLineSegment)(x, y, x1, y1, x2, y2);\n            if (distanceSqrd <= halfStrokeWidthSqrd) return true;\n        }\n        return false;\n    }\n    /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new (0, $fM4Mk.Rectangle)();\n        const points = this.points;\n        let minX = Infinity;\n        let maxX = -Infinity;\n        let minY = Infinity;\n        let maxY = -Infinity;\n        for(let i = 0, n = points.length; i < n; i += 2){\n            const x = points[i];\n            const y = points[i + 1];\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n        out.x = minX;\n        out.width = maxX - minX;\n        out.y = minY;\n        out.height = maxY - minY;\n        return out;\n    }\n    /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */ copyFrom(polygon) {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n        return this;\n    }\n    /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(polygon) {\n        polygon.copyFrom(this);\n        return polygon;\n    }\n    toString() {\n        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint)=>`${pointsDesc}, ${currentPoint}`, \"\")}]`;\n    }\n    /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */ get lastX() {\n        return this.points[this.points.length - 2];\n    }\n    /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */ get lastY() {\n        return this.points[this.points.length - 1];\n    }\n    /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */ get x() {\n        return this.points[this.points.length - 2];\n    }\n    /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */ get y() {\n        return this.points[this.points.length - 1];\n    }\n}\n\n});\nparcelRegister(\"4sAiw\", function(module, exports) {\n\n$parcel$export(module.exports, \"squaredDistanceToLineSegment\", () => $95fee67952e97042$export$db32ff20ff695a);\n\"use strict\";\nfunction $95fee67952e97042$export$db32ff20ff695a(x, y, x1, y1, x2, y2) {\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n    const dot = a * c + b * d;\n    const lenSq = c * c + d * d;\n    let param = -1;\n    if (lenSq !== 0) param = dot / lenSq;\n    let xx;\n    let yy;\n    if (param < 0) {\n        xx = x1;\n        yy = y1;\n    } else if (param > 1) {\n        xx = x2;\n        yy = y2;\n    } else {\n        xx = x1 + param * c;\n        yy = y1 + param * d;\n    }\n    const dx = x - xx;\n    const dy = y - yy;\n    return dx * dx + dy * dy;\n}\n\n});\n\n\nparcelRegister(\"7u40a\", function(module, exports) {\n\n$parcel$export(module.exports, \"RoundedRectangle\", () => $019041c7bdb3bf3e$export$d55ab2e3dc5a4263);\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\"use strict\";\nconst $019041c7bdb3bf3e$var$isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth)=>{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass $019041c7bdb3bf3e$export$d55ab2e3dc5a4263 {\n    /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */ constructor(x = 0, y = 0, width = 0, height = 0, radius = 20){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */ this.type = \"roundedRectangle\";\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n    /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new (0, $fM4Mk.Rectangle)();\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n        return out;\n    }\n    /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */ clone() {\n        return new $019041c7bdb3bf3e$export$d55ab2e3dc5a4263(this.x, this.y, this.width, this.height, this.radius);\n    }\n    /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(rectangle) {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n        return this;\n    }\n    /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(rectangle) {\n        rectangle.copyFrom(this);\n        return rectangle;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */ contains(x, y) {\n        if (this.width <= 0 || this.height <= 0) return false;\n        if (x >= this.x && x <= this.x + this.width) {\n            if (y >= this.y && y <= this.y + this.height) {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n                if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) return true;\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n                if (dx * dx + dy * dy <= radius2) return true;\n                dx = x - (this.x + this.width - radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n                dy = y - (this.y + this.height - radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n                dx = x - (this.x + radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */ strokeContains(pX, pY, strokeWidth) {\n        const { x: x, y: y, width: width, height: height, radius: radius } = this;\n        const halfStrokeWidth = strokeWidth / 2;\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - radius * 2;\n        const innerHeight = height - radius * 2;\n        const rightBound = x + width;\n        const bottomBound = y + height;\n        if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) return true;\n        if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) return true;\n        return(// Top-left\n        pX < innerX && pY < innerY && $019041c7bdb3bf3e$var$isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && $019041c7bdb3bf3e$var$isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && $019041c7bdb3bf3e$var$isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && $019041c7bdb3bf3e$var$isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth));\n    }\n    toString() {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n}\n\n});\n\nparcelRegister(\"lI2iN\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildAdaptiveBezier\", () => $4a51fd8da05fe222$export$7dab5eac414ecba2);\n\nvar $hFzkv = parcelRequire(\"hFzkv\");\n\"use strict\";\nconst $4a51fd8da05fe222$var$RECURSION_LIMIT = 8;\nconst $4a51fd8da05fe222$var$FLT_EPSILON = 11920929e-14;\nconst $4a51fd8da05fe222$var$PATH_DISTANCE_EPSILON = 1;\nconst $4a51fd8da05fe222$var$curveAngleToleranceEpsilon = 0.01;\nconst $4a51fd8da05fe222$var$mAngleTolerance = 0;\nconst $4a51fd8da05fe222$var$mCuspLimit = 0;\nfunction $4a51fd8da05fe222$export$7dab5eac414ecba2(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n    const scale = 1;\n    const smoothing = Math.min(0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? (0, $hFzkv.GraphicsContextSystem).defaultOptions.bezierSmoothness));\n    let distanceTolerance = ($4a51fd8da05fe222$var$PATH_DISTANCE_EPSILON - smoothing) / scale;\n    distanceTolerance *= distanceTolerance;\n    $4a51fd8da05fe222$var$begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n    return points;\n}\nfunction $4a51fd8da05fe222$var$begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n    $4a51fd8da05fe222$var$recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\nfunction $4a51fd8da05fe222$var$recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n    if (level > $4a51fd8da05fe222$var$RECURSION_LIMIT) return;\n    const pi = Math.PI;\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n    if (level > 0) {\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n        const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n        const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n        let da1;\n        let da2;\n        if (d2 > $4a51fd8da05fe222$var$FLT_EPSILON && d3 > $4a51fd8da05fe222$var$FLT_EPSILON) {\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($4a51fd8da05fe222$var$mAngleTolerance < $4a51fd8da05fe222$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da2 >= pi) da2 = 2 * pi - da2;\n                if (da1 + da2 < $4a51fd8da05fe222$var$mAngleTolerance) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                if ($4a51fd8da05fe222$var$mCuspLimit !== 0) {\n                    if (da1 > $4a51fd8da05fe222$var$mCuspLimit) {\n                        points.push(x2, y2);\n                        return;\n                    }\n                    if (da2 > $4a51fd8da05fe222$var$mCuspLimit) {\n                        points.push(x3, y3);\n                        return;\n                    }\n                }\n            }\n        } else if (d2 > $4a51fd8da05fe222$var$FLT_EPSILON) {\n            if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($4a51fd8da05fe222$var$mAngleTolerance < $4a51fd8da05fe222$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da1 < $4a51fd8da05fe222$var$mAngleTolerance) {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n                    return;\n                }\n                if ($4a51fd8da05fe222$var$mCuspLimit !== 0) {\n                    if (da1 > $4a51fd8da05fe222$var$mCuspLimit) {\n                        points.push(x2, y2);\n                        return;\n                    }\n                }\n            }\n        } else if (d3 > $4a51fd8da05fe222$var$FLT_EPSILON) {\n            if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($4a51fd8da05fe222$var$mAngleTolerance < $4a51fd8da05fe222$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da1 < $4a51fd8da05fe222$var$mAngleTolerance) {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n                    return;\n                }\n                if ($4a51fd8da05fe222$var$mCuspLimit !== 0) {\n                    if (da1 > $4a51fd8da05fe222$var$mCuspLimit) {\n                        points.push(x3, y3);\n                        return;\n                    }\n                }\n            }\n        } else {\n            dx = x1234 - (x1 + x4) / 2;\n            dy = y1234 - (y1 + y4) / 2;\n            if (dx * dx + dy * dy <= distanceTolerance) {\n                points.push(x1234, y1234);\n                return;\n            }\n        }\n    }\n    $4a51fd8da05fe222$var$recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    $4a51fd8da05fe222$var$recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n});\n\nparcelRegister(\"eRV6E\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildAdaptiveQuadratic\", () => $39a9db3afcc2f789$export$d53ce9debfe7a6c2);\n\nvar $hFzkv = parcelRequire(\"hFzkv\");\n\"use strict\";\nconst $39a9db3afcc2f789$var$RECURSION_LIMIT = 8;\nconst $39a9db3afcc2f789$var$FLT_EPSILON = 11920929e-14;\nconst $39a9db3afcc2f789$var$PATH_DISTANCE_EPSILON = 1;\nconst $39a9db3afcc2f789$var$curveAngleToleranceEpsilon = 0.01;\nconst $39a9db3afcc2f789$var$mAngleTolerance = 0;\nfunction $39a9db3afcc2f789$export$d53ce9debfe7a6c2(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n    const scale = 1;\n    const smoothing = Math.min(0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? (0, $hFzkv.GraphicsContextSystem).defaultOptions.bezierSmoothness));\n    let distanceTolerance = ($39a9db3afcc2f789$var$PATH_DISTANCE_EPSILON - smoothing) / scale;\n    distanceTolerance *= distanceTolerance;\n    $39a9db3afcc2f789$var$begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n    return points;\n}\nfunction $39a9db3afcc2f789$var$begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n    $39a9db3afcc2f789$var$recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n    points.push(eX, eY);\n}\nfunction $39a9db3afcc2f789$var$recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n    if (level > $39a9db3afcc2f789$var$RECURSION_LIMIT) return;\n    const pi = Math.PI;\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n    if (d > $39a9db3afcc2f789$var$FLT_EPSILON) {\n        if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n            if ($39a9db3afcc2f789$var$mAngleTolerance < $39a9db3afcc2f789$var$curveAngleToleranceEpsilon) {\n                points.push(x123, y123);\n                return;\n            }\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n            if (da >= pi) da = 2 * pi - da;\n            if (da < $39a9db3afcc2f789$var$mAngleTolerance) {\n                points.push(x123, y123);\n                return;\n            }\n        }\n    } else {\n        dx = x123 - (x1 + x3) / 2;\n        dy = y123 - (y1 + y3) / 2;\n        if (dx * dx + dy * dy <= distanceTolerance) {\n            points.push(x123, y123);\n            return;\n        }\n    }\n    $39a9db3afcc2f789$var$recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    $39a9db3afcc2f789$var$recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n});\n\nparcelRegister(\"aiLPr\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArc\", () => $4598c98f5bbae757$export$ed8eebdc6998f0f6);\n\"use strict\";\nfunction $4598c98f5bbae757$export$ed8eebdc6998f0f6(points, x, y, radius, start, end, clockwise, steps) {\n    let dist = Math.abs(start - end);\n    if (!clockwise && start > end) dist = 2 * Math.PI - dist;\n    else if (clockwise && end > start) dist = 2 * Math.PI - dist;\n    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n    steps = Math.max(steps, 3);\n    let f = dist / steps;\n    let t = start;\n    f *= clockwise ? -1 : 1;\n    for(let i = 0; i < steps + 1; i++){\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n        const nx = x + cs * radius;\n        const ny = y + sn * radius;\n        points.push(nx, ny);\n        t += f;\n    }\n}\n\n});\n\nparcelRegister(\"boMdH\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArcTo\", () => $35a2eb588826e37c$export$d46b7933b415e02f);\n\nvar $aiLPr = parcelRequire(\"aiLPr\");\n\"use strict\";\nfunction $35a2eb588826e37c$export$d46b7933b415e02f(points, x1, y1, x2, y2, radius) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1e-8 || radius === 0) {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) points.push(x1, y1);\n        return;\n    }\n    const dd = a1 * a1 + b1 * b1;\n    const cc = a2 * a2 + b2 * b2;\n    const tt = a1 * a2 + b1 * b2;\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = k1 * b2 + k2 * b1;\n    const cy = k1 * a2 + k2 * a1;\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n    (0, $aiLPr.buildArc)(points, cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n}\n\n});\n\nparcelRegister(\"jjbCG\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArcToSvg\", () => $d859b1787749b4c9$export$71ccaa6dca53075e);\n\nvar $lI2iN = parcelRequire(\"lI2iN\");\n\"use strict\";\nconst $d859b1787749b4c9$var$TAU = Math.PI * 2;\nconst $d859b1787749b4c9$var$out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\nconst $d859b1787749b4c9$var$mapToEllipse = ({ x: x, y: y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2)=>{\n    x *= rx;\n    y *= ry;\n    const xp = cosPhi * x - sinPhi * y;\n    const yp = sinPhi * x + cosPhi * y;\n    out2.x = xp + centerX;\n    out2.y = yp + centerY;\n    return out2;\n};\nfunction $d859b1787749b4c9$var$approxUnitArc(ang1, ang2) {\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n    return [\n        {\n            x: x1 - y1 * a,\n            y: y1 + x1 * a\n        },\n        {\n            x: x2 + y2 * a,\n            y: y2 - x2 * a\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\nconst $d859b1787749b4c9$var$vectorAngle = (ux, uy, vx, vy)=>{\n    const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n    let dot = ux * vx + uy * vy;\n    if (dot > 1) dot = 1;\n    if (dot < -1) dot = -1;\n    return sign * Math.acos(dot);\n};\nconst $d859b1787749b4c9$var$getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2)=>{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n    let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n    if (radicant < 0) radicant = 0;\n    radicant /= rxSq * pypSq + rySq * pxpSq;\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n    const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n    const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n    const ang1 = $d859b1787749b4c9$var$vectorAngle(1, 0, vx1, vy1);\n    let ang2 = $d859b1787749b4c9$var$vectorAngle(vx1, vy1, vx2, vy2);\n    if (sweepFlag === 0 && ang2 > 0) ang2 -= $d859b1787749b4c9$var$TAU;\n    if (sweepFlag === 1 && ang2 < 0) ang2 += $d859b1787749b4c9$var$TAU;\n    out2.centerX = centerX;\n    out2.centerY = centerY;\n    out2.ang1 = ang1;\n    out2.ang2 = ang2;\n};\nfunction $d859b1787749b4c9$export$71ccaa6dca53075e(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n    if (rx === 0 || ry === 0) return;\n    const sinPhi = Math.sin(xAxisRotation * $d859b1787749b4c9$var$TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * $d859b1787749b4c9$var$TAU / 360);\n    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n    if (pxp === 0 && pyp === 0) return;\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n    if (lambda > 1) {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n    $d859b1787749b4c9$var$getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, $d859b1787749b4c9$var$out);\n    let { ang1: ang1, ang2: ang2 } = $d859b1787749b4c9$var$out;\n    const { centerX: centerX, centerY: centerY } = $d859b1787749b4c9$var$out;\n    let ratio = Math.abs(ang2) / ($d859b1787749b4c9$var$TAU / 4);\n    if (Math.abs(1 - ratio) < 1e-7) ratio = 1;\n    const segments = Math.max(Math.ceil(ratio), 1);\n    ang2 /= segments;\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n    const outCurvePoint = {\n        x: 0,\n        y: 0\n    };\n    for(let i = 0; i < segments; i++){\n        const curve = $d859b1787749b4c9$var$approxUnitArc(ang1, ang2);\n        const { x: x1, y: y1 } = $d859b1787749b4c9$var$mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = $d859b1787749b4c9$var$mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x, y: y } = $d859b1787749b4c9$var$mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        (0, $lI2iN.buildAdaptiveBezier)(points, lastX, lastY, x1, y1, x2, y2, x, y);\n        lastX = x;\n        lastY = y;\n        ang1 += ang2;\n    }\n}\n\n});\n\nparcelRegister(\"9ad7k\", function(module, exports) {\n\n$parcel$export(module.exports, \"roundedShapeArc\", () => $9769dc3699a7c802$export$ae1f43bc280f09be);\n$parcel$export(module.exports, \"roundedShapeQuadraticCurve\", () => $9769dc3699a7c802$export$cf503f371c53af9e);\n\"use strict\";\nfunction $9769dc3699a7c802$export$ae1f43bc280f09be(g, points, radius) {\n    const vecFrom = (p, pp)=>{\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt(x * x + y * y);\n        const nx = x / len;\n        const ny = y / len;\n        return {\n            len: len,\n            nx: nx,\n            ny: ny\n        };\n    };\n    const sharpCorner = (i, p)=>{\n        if (i === 0) g.moveTo(p.x, p.y);\n        else g.lineTo(p.x, p.y);\n    };\n    let p1 = points[points.length - 1];\n    for(let i = 0; i < points.length; i++){\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n        if (pRadius <= 0) {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n        if (v1.len < 1e-4 || v2.len < 1e-4) {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n        let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n        let radDirection = 1;\n        let drawDirection = false;\n        if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n            if (angle < 0) angle = Math.PI + angle;\n            else {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        } else if (angle > 0) {\n            radDirection = -1;\n            drawDirection = true;\n        }\n        const halfAngle = angle / 2;\n        let cRadius;\n        let lenOut = Math.abs(Math.cos(halfAngle) * pRadius / Math.sin(halfAngle));\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n        } else cRadius = pRadius;\n        const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n        const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n        const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n        const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n        if (i === 0) g.moveTo(cX + Math.cos(startAngle) * cRadius, cY + Math.sin(startAngle) * cRadius);\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n        p1 = p2;\n    }\n}\nfunction $9769dc3699a7c802$export$cf503f371c53af9e(g, points, radius, smoothness) {\n    const distance = (p1, p2)=>Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n    const pointLerp = (p1, p2, t)=>({\n            x: p1.x + (p2.x - p1.x) * t,\n            y: p1.y + (p2.y - p1.y) * t\n        });\n    const numPoints = points.length;\n    for(let i = 0; i < numPoints; i++){\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n        if (pRadius <= 0) {\n            if (i === 0) g.moveTo(thisPoint.x, thisPoint.y);\n            else g.lineTo(thisPoint.x, thisPoint.y);\n            continue;\n        }\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n        if (lastEdgeLength < 1e-4) start = thisPoint;\n        else {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n            start = pointLerp(thisPoint, lastPoint, lastOffsetDistance / lastEdgeLength);\n        }\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n        if (nextEdgeLength < 1e-4) end = thisPoint;\n        else {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n            end = pointLerp(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);\n        }\n        if (i === 0) g.moveTo(start.x, start.y);\n        else g.lineTo(start.x, start.y);\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n\n});\n\n\n\nparcelRegister(\"6ph3G\", function(module, exports) {\n\n$parcel$export(module.exports, \"SVGParser\", () => $ff733ce48c045e93$export$2cc2aaca18109aab);\n\nvar $a2eTA = parcelRequire(\"a2eTA\");\n\nvar $c9xxq = parcelRequire(\"c9xxq\");\n\"use strict\";\nfunction $ff733ce48c045e93$export$2cc2aaca18109aab(svg, graphicsContext) {\n    if (typeof svg === \"string\") {\n        const div = document.createElement(\"div\");\n        div.innerHTML = svg.trim();\n        svg = div.querySelector(\"svg\");\n    }\n    const session = {\n        context: graphicsContext,\n        path: new (0, $c9xxq.GraphicsPath)()\n    };\n    $ff733ce48c045e93$var$renderChildren(svg, session, null, null);\n    return graphicsContext;\n}\nfunction $ff733ce48c045e93$var$renderChildren(svg, session, fillStyle, strokeStyle) {\n    const children = svg.children;\n    const { fillStyle: f1, strokeStyle: s1 } = $ff733ce48c045e93$var$parseStyle(svg);\n    if (f1 && fillStyle) fillStyle = {\n        ...fillStyle,\n        ...f1\n    };\n    else if (f1) fillStyle = f1;\n    if (s1 && strokeStyle) strokeStyle = {\n        ...strokeStyle,\n        ...s1\n    };\n    else if (s1) strokeStyle = s1;\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n    switch(svg.nodeName.toLowerCase()){\n        case \"path\":\n            d = svg.getAttribute(\"d\");\n            graphicsPath = new (0, $c9xxq.GraphicsPath)(d);\n            session.context.path(graphicsPath);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"circle\":\n            cx = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"cx\", 0);\n            cy = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"cy\", 0);\n            r = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"r\", 0);\n            session.context.ellipse(cx, cy, r, r);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"rect\":\n            x = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"x\", 0);\n            y = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"y\", 0);\n            width = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"width\", 0);\n            height = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"height\", 0);\n            rx = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"rx\", 0);\n            ry = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"ry\", 0);\n            if (rx || ry) session.context.roundRect(x, y, width, height, rx || ry);\n            else session.context.rect(x, y, width, height);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"ellipse\":\n            cx = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"cx\", 0);\n            cy = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"cy\", 0);\n            rx = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"rx\", 0);\n            ry = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"ry\", 0);\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"line\":\n            x1 = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"x1\", 0);\n            y1 = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"y1\", 0);\n            x2 = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"x2\", 0);\n            y2 = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"y2\", 0);\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"polygon\":\n            pointsString = svg.getAttribute(\"points\");\n            points = pointsString.match(/\\d+/g).map((n)=>parseInt(n, 10));\n            session.context.poly(points, true);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"polyline\":\n            pointsString = svg.getAttribute(\"points\");\n            points = pointsString.match(/\\d+/g).map((n)=>parseInt(n, 10));\n            session.context.poly(points, false);\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"g\":\n        case \"svg\":\n            break;\n        default:\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n    }\n    for(let i = 0; i < children.length; i++)$ff733ce48c045e93$var$renderChildren(children[i], session, fillStyle, strokeStyle);\n}\nfunction $ff733ce48c045e93$var$parseFloatAttribute(svg, id, defaultValue) {\n    const value = svg.getAttribute(id);\n    return value ? Number(value) : defaultValue;\n}\nfunction $ff733ce48c045e93$var$parseStyle(svg) {\n    const style = svg.getAttribute(\"style\");\n    const strokeStyle = {};\n    const fillStyle = {};\n    let useFill = false;\n    let useStroke = false;\n    if (style) {\n        const styleParts = style.split(\";\");\n        for(let i = 0; i < styleParts.length; i++){\n            const stylePart = styleParts[i];\n            const [key, value] = stylePart.split(\":\");\n            switch(key){\n                case \"stroke\":\n                    if (value !== \"none\") {\n                        strokeStyle.color = (0, $a2eTA.Color).shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n                    break;\n                case \"stroke-width\":\n                    strokeStyle.width = Number(value);\n                    break;\n                case \"fill\":\n                    if (value !== \"none\") {\n                        useFill = true;\n                        fillStyle.color = (0, $a2eTA.Color).shared.setValue(value).toNumber();\n                    }\n                    break;\n                case \"fill-opacity\":\n                    fillStyle.alpha = Number(value);\n                    break;\n                case \"stroke-opacity\":\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case \"opacity\":\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    } else {\n        const stroke = svg.getAttribute(\"stroke\");\n        if (stroke && stroke !== \"none\") {\n            useStroke = true;\n            strokeStyle.color = (0, $a2eTA.Color).shared.setValue(stroke).toNumber();\n            strokeStyle.width = $ff733ce48c045e93$var$parseFloatAttribute(svg, \"stroke-width\", 1);\n        }\n        const fill = svg.getAttribute(\"fill\");\n        if (fill && fill !== \"none\") {\n            useFill = true;\n            fillStyle.color = (0, $a2eTA.Color).shared.setValue(fill).toNumber();\n        }\n    }\n    return {\n        strokeStyle: useStroke ? strokeStyle : null,\n        fillStyle: useFill ? fillStyle : null\n    };\n}\n\n});\n\nparcelRegister(\"6mQKv\", function(module, exports) {\n\n$parcel$export(module.exports, \"convertFillInputToFillStyle\", () => $ee0f76cca9221b48$export$816bdeacb94f608f);\n\nvar $a2eTA = parcelRequire(\"a2eTA\");\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $gwwtL = parcelRequire(\"gwwtL\");\n\nvar $ktCpi = parcelRequire(\"ktCpi\");\n\"use strict\";\nfunction $ee0f76cca9221b48$export$816bdeacb94f608f(value, defaultStyle) {\n    if (value === void 0 || value === null) return null;\n    let fillStyleToParse;\n    let styleToMerge;\n    if (value?.fill) {\n        styleToMerge = value.fill;\n        fillStyleToParse = {\n            ...defaultStyle,\n            ...value\n        };\n    } else {\n        styleToMerge = value;\n        fillStyleToParse = defaultStyle;\n    }\n    if ((0, $a2eTA.Color).isColorLike(styleToMerge)) {\n        const temp = (0, $a2eTA.Color).shared.setValue(styleToMerge ?? 0);\n        const opts = {\n            ...fillStyleToParse,\n            color: temp.toNumber(),\n            alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,\n            texture: (0, $bLlTJ.Texture).WHITE\n        };\n        return opts;\n    } else if (styleToMerge instanceof (0, $ktCpi.FillPattern)) {\n        const pattern = styleToMerge;\n        return {\n            ...fillStyleToParse,\n            color: 16777215,\n            texture: pattern.texture,\n            matrix: pattern.transform,\n            fill: fillStyleToParse.fill ?? null\n        };\n    } else if (styleToMerge instanceof (0, $gwwtL.FillGradient)) {\n        const gradient = styleToMerge;\n        gradient.buildLinearGradient();\n        return {\n            ...fillStyleToParse,\n            color: 16777215,\n            texture: gradient.texture,\n            matrix: gradient.transform\n        };\n    }\n    const style = {\n        ...defaultStyle,\n        ...value\n    };\n    if (style.texture) {\n        if (style.texture !== (0, $bLlTJ.Texture).WHITE) {\n            const m = style.matrix?.invert() || new (0, $eY4rt.Matrix)();\n            m.scale(1 / style.texture.frame.width, 1 / style.texture.frame.height);\n            style.matrix = m;\n        }\n        const sourceStyle = style.texture.source.style;\n        if (sourceStyle.addressMode === \"clamp-to-edge\") sourceStyle.addressMode = \"repeat\";\n    }\n    const color = (0, $a2eTA.Color).shared.setValue(style.color);\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null;\n    return style;\n}\n\n});\n\n\n\nparcelRegister(\"8jdbq\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshGeometry\", () => $e3d5e55f90a865ef$export$8d075a36a73d54bc);\n\nvar $lvEAL = parcelRequire(\"lvEAL\");\n\nvar $1UZ6r = parcelRequire(\"1UZ6r\");\n\nvar $cOnev = parcelRequire(\"cOnev\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\"use strict\";\nconst $e3d5e55f90a865ef$var$_MeshGeometry = class _MeshGeometry extends (0, $cOnev.Geometry) {\n    constructor(...args){\n        let options = args[0] ?? {};\n        if (options instanceof Float32Array) {\n            (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2]\n            };\n        }\n        options = {\n            ..._MeshGeometry.defaultOptions,\n            ...options\n        };\n        const positions = options.positions || new Float32Array([\n            0,\n            0,\n            1,\n            0,\n            1,\n            1,\n            0,\n            1\n        ]);\n        const uvs = options.uvs || new Float32Array([\n            0,\n            0,\n            1,\n            0,\n            1,\n            1,\n            0,\n            1\n        ]);\n        const indices = options.indices || new Uint32Array([\n            0,\n            1,\n            2,\n            0,\n            2,\n            3\n        ]);\n        const shrinkToFit = options.shrinkBuffersToFit;\n        const positionBuffer = new (0, $lvEAL.Buffer)({\n            data: positions,\n            label: \"attribute-mesh-positions\",\n            shrinkToFit: shrinkToFit,\n            usage: (0, $1UZ6r.BufferUsage).VERTEX | (0, $1UZ6r.BufferUsage).COPY_DST\n        });\n        const uvBuffer = new (0, $lvEAL.Buffer)({\n            data: uvs,\n            label: \"attribute-mesh-uvs\",\n            shrinkToFit: shrinkToFit,\n            usage: (0, $1UZ6r.BufferUsage).VERTEX | (0, $1UZ6r.BufferUsage).COPY_DST\n        });\n        const indexBuffer = new (0, $lvEAL.Buffer)({\n            data: indices,\n            label: \"index-mesh-buffer\",\n            shrinkToFit: shrinkToFit,\n            usage: (0, $1UZ6r.BufferUsage).INDEX | (0, $1UZ6r.BufferUsage).COPY_DST\n        });\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: \"float32x2\",\n                    stride: 8,\n                    offset: 0\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: \"float32x2\",\n                    stride: 8,\n                    offset: 0\n                }\n            },\n            indexBuffer: indexBuffer,\n            topology: options.topology\n        });\n        this.batchMode = \"auto\";\n    }\n    /** The positions of the mesh. */ get positions() {\n        return this.attributes.aPosition.buffer.data;\n    }\n    set positions(value) {\n        this.attributes.aPosition.buffer.data = value;\n    }\n    /** The UVs of the mesh. */ get uvs() {\n        return this.attributes.aUV.buffer.data;\n    }\n    set uvs(value) {\n        this.attributes.aUV.buffer.data = value;\n    }\n    /** The indices of the mesh. */ get indices() {\n        return this.indexBuffer.data;\n    }\n    set indices(value) {\n        this.indexBuffer.data = value;\n    }\n};\n$e3d5e55f90a865ef$var$_MeshGeometry.defaultOptions = {\n    topology: \"triangle-list\",\n    shrinkBuffersToFit: false\n};\nlet $e3d5e55f90a865ef$export$8d075a36a73d54bc = $e3d5e55f90a865ef$var$_MeshGeometry;\n\n});\n\nparcelRegister(\"hIpDK\", function(module, exports) {\n\n$parcel$export(module.exports, \"NineSliceGeometry\", () => $d33396e76d204642$export$a1f405faf7381142);\n\nvar $39gek = parcelRequire(\"39gek\");\n\"use strict\";\nconst $d33396e76d204642$var$_NineSliceGeometry = class _NineSliceGeometry extends (0, $39gek.PlaneGeometry) {\n    constructor(options = {}){\n        options = {\n            ..._NineSliceGeometry.defaultOptions,\n            ...options\n        };\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4\n        });\n        this.update(options);\n    }\n    /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */ update(options) {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n        this.updateUvs();\n        this.updatePositions();\n    }\n    /** Updates the positions of the vertices. */ updatePositions() {\n        const positions = this.positions;\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1 : this.width / w;\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1 : this.height / h;\n        const scale = Math.min(scaleW, scaleH);\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n        this.getBuffer(\"aPosition\").update();\n    }\n    /** Updates the UVs of the vertices. */ updateUvs() {\n        const uvs = this.uvs;\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n        const _uvw = 1 / this._originalWidth;\n        const _uvh = 1 / this._originalHeight;\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n        this.getBuffer(\"aUV\").update();\n    }\n};\n/** The default options for the NineSliceGeometry. */ $d33396e76d204642$var$_NineSliceGeometry.defaultOptions = {\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */ width: 100,\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */ height: 100,\n    /** The width of the left column. */ leftWidth: 10,\n    /** The height of the top row. */ topHeight: 10,\n    /** The width of the right column. */ rightWidth: 10,\n    /** The height of the bottom row. */ bottomHeight: 10,\n    /** The original width of the texture */ originalWidth: 100,\n    /** The original height of the texture */ originalHeight: 100\n};\nlet $d33396e76d204642$export$a1f405faf7381142 = $d33396e76d204642$var$_NineSliceGeometry;\n\n});\nparcelRegister(\"39gek\", function(module, exports) {\n\n$parcel$export(module.exports, \"PlaneGeometry\", () => $049cc868daf00d34$export$967d831af31f69ce);\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\nvar $8jdbq = parcelRequire(\"8jdbq\");\n\"use strict\";\nconst $049cc868daf00d34$var$_PlaneGeometry = class _PlaneGeometry extends (0, $8jdbq.MeshGeometry) {\n    constructor(...args){\n        super({});\n        let options = args[0] ?? {};\n        if (typeof options === \"number\") {\n            (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead\");\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3]\n            };\n        }\n        this.build(options);\n    }\n    /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */ build(options) {\n        options = {\n            ..._PlaneGeometry.defaultOptions,\n            ...options\n        };\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n        const sizeX = this.width / verticesX;\n        const sizeY = this.height / verticesY;\n        for(let i = 0; i < total; i++){\n            const x = i % this.verticesX;\n            const y = i / this.verticesX | 0;\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n        const totalSub = verticesX * verticesY;\n        for(let i = 0; i < totalSub; i++){\n            const xpos = i % verticesX;\n            const ypos = i / verticesX | 0;\n            const value = ypos * this.verticesX + xpos;\n            const value2 = ypos * this.verticesX + xpos + 1;\n            const value3 = (ypos + 1) * this.verticesX + xpos;\n            const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n            indices.push(value, value2, value3, value2, value4, value3);\n        }\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n};\n$049cc868daf00d34$var$_PlaneGeometry.defaultOptions = {\n    width: 100,\n    height: 100,\n    verticesX: 10,\n    verticesY: 10\n};\nlet $049cc868daf00d34$export$967d831af31f69ce = $049cc868daf00d34$var$_PlaneGeometry;\n\n});\n\n\nparcelRegister(\"wLFHs\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasTextMetrics\", () => $3648baf7179c08cc$export$b12f6bdc825d944f);\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $fI0NC = parcelRequire(\"fI0NC\");\n\"use strict\";\nconst $3648baf7179c08cc$var$contextSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true\n};\nconst $3648baf7179c08cc$var$_CanvasTextMetrics = class _CanvasTextMetrics {\n    /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */ static get experimentalLetterSpacingSupported() {\n        let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n        if (result !== void 0) {\n            const proto = (0, $iCGeI.DOMAdapter).get().getCanvasRenderingContext2D().prototype;\n            result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n        }\n        return result;\n    }\n    /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */ constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties){\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n    /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */ static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n        const textKey = `${text}:${style.styleKey}`;\n        if (_CanvasTextMetrics._measurementCache[textKey]) return _CanvasTextMetrics._measurementCache[textKey];\n        const font = (0, $fI0NC.fontStringFromTextStyle)(style);\n        const fontProperties = _CanvasTextMetrics.measureFont(font);\n        if (fontProperties.fontSize === 0) {\n            fontProperties.fontSize = style.fontSize;\n            fontProperties.ascent = style.fontSize;\n        }\n        const context = _CanvasTextMetrics.__context;\n        context.font = font;\n        const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array(lines.length);\n        let maxLineWidth = 0;\n        for(let i = 0; i < lines.length; i++){\n            const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n        const strokeWidth = style._stroke?.width || 0;\n        let width = maxLineWidth + strokeWidth;\n        if (style.dropShadow) width += style.dropShadow.distance;\n        const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n        let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);\n        if (style.dropShadow) height += style.dropShadow.distance;\n        const measurements = new _CanvasTextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);\n        return measurements;\n    }\n    static _measureText(text, letterSpacing, context) {\n        let useExperimentalLetterSpacing = false;\n        if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n            if (_CanvasTextMetrics.experimentalLetterSpacing) {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            } else {\n                context.letterSpacing = \"0px\";\n                context.textLetterSpacing = \"0px\";\n            }\n        }\n        let width = context.measureText(text).width;\n        if (width > 0) {\n            if (useExperimentalLetterSpacing) width -= letterSpacing;\n            else width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n        }\n        return width;\n    }\n    /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */ static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n        const context = canvas.getContext(\"2d\", $3648baf7179c08cc$var$contextSettings);\n        let width = 0;\n        let line = \"\";\n        let lines = \"\";\n        const cache = /* @__PURE__ */ Object.create(null);\n        const { letterSpacing: letterSpacing, whiteSpace: whiteSpace } = style;\n        const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n        let canPrependSpaces = !collapseSpaces;\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n        const tokens = _CanvasTextMetrics._tokenize(text);\n        for(let i = 0; i < tokens.length; i++){\n            let token = tokens[i];\n            if (_CanvasTextMetrics._isNewline(token)) {\n                if (!collapseNewlines) {\n                    lines += _CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = \"\";\n                    width = 0;\n                    continue;\n                }\n                token = \" \";\n            }\n            if (collapseSpaces) {\n                const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n                if (currIsBreakingSpace && lastIsBreakingSpace) continue;\n            }\n            const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n            if (tokenWidth > wordWrapWidth) {\n                if (line !== \"\") {\n                    lines += _CanvasTextMetrics._addLine(line);\n                    line = \"\";\n                    width = 0;\n                }\n                if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n                    const characters = _CanvasTextMetrics.wordWrapSplit(token);\n                    for(let j = 0; j < characters.length; j++){\n                        let char = characters[j];\n                        let lastChar = char;\n                        let k = 1;\n                        while(characters[j + k]){\n                            const nextChar = characters[j + k];\n                            if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) char += nextChar;\n                            else break;\n                            lastChar = nextChar;\n                            k++;\n                        }\n                        j += k - 1;\n                        const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n                        if (characterWidth + width > wordWrapWidth) {\n                            lines += _CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = \"\";\n                            width = 0;\n                        }\n                        line += char;\n                        width += characterWidth;\n                    }\n                } else {\n                    if (line.length > 0) {\n                        lines += _CanvasTextMetrics._addLine(line);\n                        line = \"\";\n                        width = 0;\n                    }\n                    const isLastToken = i === tokens.length - 1;\n                    lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = \"\";\n                    width = 0;\n                }\n            } else {\n                if (tokenWidth + width > wordWrapWidth) {\n                    canPrependSpaces = false;\n                    lines += _CanvasTextMetrics._addLine(line);\n                    line = \"\";\n                    width = 0;\n                }\n                if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n                    line += token;\n                    width += tokenWidth;\n                }\n            }\n        }\n        lines += _CanvasTextMetrics._addLine(line, false);\n        return lines;\n    }\n    /**\n   * Convienience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */ static _addLine(line, newLine = true) {\n        line = _CanvasTextMetrics._trimRight(line);\n        line = newLine ? `${line}\n` : line;\n        return line;\n    }\n    /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */ static _getFromCache(key, letterSpacing, cache, context) {\n        let width = cache[key];\n        if (typeof width !== \"number\") {\n            width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n        return width;\n    }\n    /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */ static _collapseSpaces(whiteSpace) {\n        return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n    }\n    /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */ static _collapseNewlines(whiteSpace) {\n        return whiteSpace === \"normal\";\n    }\n    /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */ static _trimRight(text) {\n        if (typeof text !== \"string\") return \"\";\n        for(let i = text.length - 1; i >= 0; i--){\n            const char = text[i];\n            if (!_CanvasTextMetrics.isBreakingSpace(char)) break;\n            text = text.slice(0, -1);\n        }\n        return text;\n    }\n    /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */ static _isNewline(char) {\n        if (typeof char !== \"string\") return false;\n        return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n    /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */ static isBreakingSpace(char, _nextChar) {\n        if (typeof char !== \"string\") return false;\n        return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n    /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */ static _tokenize(text) {\n        const tokens = [];\n        let token = \"\";\n        if (typeof text !== \"string\") return tokens;\n        for(let i = 0; i < text.length; i++){\n            const char = text[i];\n            const nextChar = text[i + 1];\n            if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n                if (token !== \"\") {\n                    tokens.push(token);\n                    token = \"\";\n                }\n                tokens.push(char);\n                continue;\n            }\n            token += char;\n        }\n        if (token !== \"\") tokens.push(token);\n        return tokens;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */ static canBreakWords(_token, breakWords) {\n        return breakWords;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */ static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n        return true;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */ static wordWrapSplit(token) {\n        return _CanvasTextMetrics.graphemeSegmenter(token);\n    }\n    /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */ static measureFont(font) {\n        if (_CanvasTextMetrics._fonts[font]) return _CanvasTextMetrics._fonts[font];\n        const context = _CanvasTextMetrics._context;\n        context.font = font;\n        const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n        _CanvasTextMetrics._fonts[font] = properties;\n        return properties;\n    }\n    /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */ static clearMetrics(font = \"\") {\n        if (font) delete _CanvasTextMetrics._fonts[font];\n        else _CanvasTextMetrics._fonts = {};\n    }\n    /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */ static get _canvas() {\n        if (!_CanvasTextMetrics.__canvas) {\n            let canvas;\n            try {\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext(\"2d\", $3648baf7179c08cc$var$contextSettings);\n                if (context?.measureText) {\n                    _CanvasTextMetrics.__canvas = c;\n                    return c;\n                }\n                canvas = (0, $iCGeI.DOMAdapter).get().createCanvas();\n            } catch (ex) {\n                canvas = (0, $iCGeI.DOMAdapter).get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            _CanvasTextMetrics.__canvas = canvas;\n        }\n        return _CanvasTextMetrics.__canvas;\n    }\n    /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */ static get _context() {\n        if (!_CanvasTextMetrics.__context) _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", $3648baf7179c08cc$var$contextSettings);\n        return _CanvasTextMetrics.__context;\n    }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */ $3648baf7179c08cc$var$_CanvasTextMetrics.METRICS_STRING = \"|\\xc9q\\xc5\";\n/** Baseline symbol for calculate font metrics. */ $3648baf7179c08cc$var$_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */ $3648baf7179c08cc$var$_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */ $3648baf7179c08cc$var$_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */ $3648baf7179c08cc$var$_CanvasTextMetrics.graphemeSegmenter = (()=>{\n    if (typeof Intl?.Segmenter === \"function\") {\n        const segmenter = new Intl.Segmenter();\n        return (s)=>[\n                ...segmenter.segment(s)\n            ].map((x)=>x.segment);\n    }\n    return (s)=>[\n            ...s\n        ];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */ $3648baf7179c08cc$var$_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */ $3648baf7179c08cc$var$_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */ $3648baf7179c08cc$var$_CanvasTextMetrics._newlines = [\n    10,\n    // line feed\n    13\n];\n/** Cache of breaking spaces. */ $3648baf7179c08cc$var$_CanvasTextMetrics._breakingSpaces = [\n    9,\n    // character tabulation\n    32,\n    // space\n    8192,\n    // en quad\n    8193,\n    // em quad\n    8194,\n    // en space\n    8195,\n    // em space\n    8196,\n    // three-per-em space\n    8197,\n    // four-per-em space\n    8198,\n    // six-per-em space\n    8200,\n    // punctuation space\n    8201,\n    // thin space\n    8202,\n    // hair space\n    8287,\n    // medium mathematical space\n    12288\n];\n$3648baf7179c08cc$var$_CanvasTextMetrics._measurementCache = {};\nlet $3648baf7179c08cc$export$b12f6bdc825d944f = $3648baf7179c08cc$var$_CanvasTextMetrics;\n\n});\nparcelRegister(\"fI0NC\", function(module, exports) {\n\n$parcel$export(module.exports, \"fontStringFromTextStyle\", () => $432516f32dcd2061$export$b7b5edb82ac3fc66);\n\"use strict\";\nconst $432516f32dcd2061$var$genericFontFamilies = [\n    \"serif\",\n    \"sans-serif\",\n    \"monospace\",\n    \"cursive\",\n    \"fantasy\",\n    \"system-ui\"\n];\nfunction $432516f32dcd2061$export$b7b5edb82ac3fc66(style) {\n    const fontSizeString = typeof style.fontSize === \"number\" ? `${style.fontSize}px` : style.fontSize;\n    let fontFamilies = style.fontFamily;\n    if (!Array.isArray(style.fontFamily)) fontFamilies = style.fontFamily.split(\",\");\n    for(let i = fontFamilies.length - 1; i >= 0; i--){\n        let fontFamily = fontFamilies[i].trim();\n        if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && !$432516f32dcd2061$var$genericFontFamilies.includes(fontFamily)) fontFamily = `\"${fontFamily}\"`;\n        fontFamilies[i] = fontFamily;\n    }\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(\",\")}`;\n}\n\n});\n\n\nparcelRegister(\"eKNW7\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextStyle\", () => $d76c68b7f9f9bbea$export$1df879243bf2e42d);\n\nvar $3vRz3 = parcelRequire(\"3vRz3\");\n\nvar $a2eTA = parcelRequire(\"a2eTA\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\nvar $gwwtL = parcelRequire(\"gwwtL\");\n\nvar $8aC7P = parcelRequire(\"8aC7P\");\n\nvar $6mQKv = parcelRequire(\"6mQKv\");\n\nvar $6XitK = parcelRequire(\"6XitK\");\n\"use strict\";\nconst $d76c68b7f9f9bbea$var$_TextStyle = class _TextStyle extends (0, (/*@__PURE__*/$parcel$interopDefault($3vRz3))) {\n    constructor(style = {}){\n        super();\n        $d76c68b7f9f9bbea$var$convertV7Tov8Style(style);\n        const fullStyle = {\n            ..._TextStyle.defaultTextStyle,\n            ...style\n        };\n        for(const key in fullStyle){\n            const thisKey = key;\n            this[thisKey] = fullStyle[key];\n        }\n        this.update();\n    }\n    /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */ get align() {\n        return this._align;\n    }\n    set align(value) {\n        this._align = value;\n        this.update();\n    }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */ get breakWords() {\n        return this._breakWords;\n    }\n    set breakWords(value) {\n        this._breakWords = value;\n        this.update();\n    }\n    /** Set a drop shadow for the text. */ get dropShadow() {\n        return this._dropShadow;\n    }\n    set dropShadow(value) {\n        if (value !== null && typeof value === \"object\") this._dropShadow = {\n            ..._TextStyle.defaultDropShadow,\n            ...value\n        };\n        else this._dropShadow = value ? {\n            ..._TextStyle.defaultDropShadow\n        } : null;\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */ get fontFamily() {\n        return this._fontFamily;\n    }\n    set fontFamily(value) {\n        this._fontFamily = value;\n        this.update();\n    }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */ get fontSize() {\n        return this._fontSize;\n    }\n    set fontSize(value) {\n        if (typeof value === \"string\") this._fontSize = parseInt(value, 10);\n        else this._fontSize = value;\n        this.update();\n    }\n    /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */ get fontStyle() {\n        return this._fontStyle;\n    }\n    set fontStyle(value) {\n        this._fontStyle = value;\n        this.update();\n    }\n    /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */ get fontVariant() {\n        return this._fontVariant;\n    }\n    set fontVariant(value) {\n        this._fontVariant = value;\n        this.update();\n    }\n    /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */ get fontWeight() {\n        return this._fontWeight;\n    }\n    set fontWeight(value) {\n        this._fontWeight = value;\n        this.update();\n    }\n    /** The space between lines. */ get leading() {\n        return this._leading;\n    }\n    set leading(value) {\n        this._leading = value;\n        this.update();\n    }\n    /** The amount of spacing between letters, default is 0. */ get letterSpacing() {\n        return this._letterSpacing;\n    }\n    set letterSpacing(value) {\n        this._letterSpacing = value;\n        this.update();\n    }\n    /** The line height, a number that represents the vertical space that a letter uses. */ get lineHeight() {\n        return this._lineHeight;\n    }\n    set lineHeight(value) {\n        this._lineHeight = value;\n        this.update();\n    }\n    /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */ get padding() {\n        return this._padding;\n    }\n    set padding(value) {\n        this._padding = value;\n        this.update();\n    }\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */ get trim() {\n        return this._trim;\n    }\n    set trim(value) {\n        this._trim = value;\n        this.update();\n    }\n    /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */ get textBaseline() {\n        return this._textBaseline;\n    }\n    set textBaseline(value) {\n        this._textBaseline = value;\n        this.update();\n    }\n    /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */ get whiteSpace() {\n        return this._whiteSpace;\n    }\n    set whiteSpace(value) {\n        this._whiteSpace = value;\n        this.update();\n    }\n    /** Indicates if word wrap should be used. */ get wordWrap() {\n        return this._wordWrap;\n    }\n    set wordWrap(value) {\n        this._wordWrap = value;\n        this.update();\n    }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */ get wordWrapWidth() {\n        return this._wordWrapWidth;\n    }\n    set wordWrapWidth(value) {\n        this._wordWrapWidth = value;\n        this.update();\n    }\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */ get fill() {\n        return this._originalFill;\n    }\n    set fill(value) {\n        if (value === this._originalFill) return;\n        this._originalFill = value;\n        this._fill = (0, $6mQKv.convertFillInputToFillStyle)(value === 0 ? \"black\" : value, (0, $8aC7P.GraphicsContext).defaultFillStyle);\n        this.update();\n    }\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */ get stroke() {\n        return this._originalStroke;\n    }\n    set stroke(value) {\n        if (value === this._originalStroke) return;\n        this._originalStroke = value;\n        this._stroke = (0, $6mQKv.convertFillInputToFillStyle)(value, (0, $8aC7P.GraphicsContext).defaultStrokeStyle);\n        this.update();\n    }\n    _generateKey() {\n        this._styleKey = (0, $6XitK.generateTextStyleKey)(this);\n        return this._styleKey;\n    }\n    update() {\n        this._styleKey = null;\n        this.emit(\"update\", this);\n    }\n    /** Resets all properties to the default values */ reset() {\n        const defaultStyle = _TextStyle.defaultTextStyle;\n        for(const key in defaultStyle)this[key] = defaultStyle[key];\n    }\n    get styleKey() {\n        return this._styleKey || this._generateKey();\n    }\n    /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */ clone() {\n        return new _TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth\n        });\n    }\n    /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */ destroy(options = false) {\n        this.removeAllListeners();\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            if (this._fill?.texture) this._fill.texture.destroy(destroyTextureSource);\n            if (this._originalFill?.texture) this._originalFill.texture.destroy(destroyTextureSource);\n            if (this._stroke?.texture) this._stroke.texture.destroy(destroyTextureSource);\n            if (this._originalStroke?.texture) this._originalStroke.texture.destroy(destroyTextureSource);\n        }\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n};\n/** The default drop shadow settings */ $d76c68b7f9f9bbea$var$_TextStyle.defaultDropShadow = {\n    /** Set alpha for the drop shadow */ alpha: 1,\n    /** Set a angle of the drop shadow */ angle: Math.PI / 6,\n    /** Set a shadow blur radius */ blur: 0,\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */ color: \"black\",\n    /** Set a distance of the drop shadow */ distance: 5\n};\n/** The default text style settings */ $d76c68b7f9f9bbea$var$_TextStyle.defaultTextStyle = {\n    /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */ align: \"left\",\n    /** See {@link TextStyle.breakWords} */ breakWords: false,\n    /** See {@link TextStyle.dropShadow} */ dropShadow: null,\n    /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */ fill: \"black\",\n    /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */ fontFamily: \"Arial\",\n    /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */ fontSize: 26,\n    /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */ fontStyle: \"normal\",\n    /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */ fontVariant: \"normal\",\n    /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */ fontWeight: \"normal\",\n    /** See {@link TextStyle.leading} */ leading: 0,\n    /** See {@link TextStyle.letterSpacing} */ letterSpacing: 0,\n    /** See {@link TextStyle.lineHeight} */ lineHeight: 0,\n    /** See {@link TextStyle.padding} */ padding: 0,\n    /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */ stroke: null,\n    /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */ textBaseline: \"alphabetic\",\n    /** See {@link TextStyle.trim} */ trim: false,\n    /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */ whiteSpace: \"pre\",\n    /** See {@link TextStyle.wordWrap} */ wordWrap: false,\n    /** See {@link TextStyle.wordWrapWidth} */ wordWrapWidth: 100\n};\nlet $d76c68b7f9f9bbea$export$1df879243bf2e42d = $d76c68b7f9f9bbea$var$_TextStyle;\nfunction $d76c68b7f9f9bbea$var$convertV7Tov8Style(style) {\n    const oldStyle = style;\n    if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n        const defaults = $d76c68b7f9f9bbea$export$1df879243bf2e42d.defaultDropShadow;\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance: oldStyle.dropShadowDistance ?? defaults.distance\n        };\n    }\n    if (oldStyle.strokeThickness) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"strokeThickness is now a part of stroke\");\n        const color = oldStyle.stroke;\n        style.stroke = {\n            color: color,\n            width: oldStyle.strokeThickness\n        };\n    }\n    if (Array.isArray(oldStyle.fill)) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n        const gradientFill = new (0, $gwwtL.FillGradient)(0, 0, 0, style.fontSize * 1.7);\n        const fills = oldStyle.fill.map((color)=>(0, $a2eTA.Color).shared.setValue(color).toNumber());\n        fills.forEach((number, index)=>{\n            const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n            gradientFill.addColorStop(ratio, number);\n        });\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n});\nparcelRegister(\"6XitK\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateTextStyleKey\", () => $9b4def45185a5f6c$export$8a3681e2b47964bb);\n\"use strict\";\nconst $9b4def45185a5f6c$var$valuesToIterateForKeys = [\n    \"_fontFamily\",\n    \"_fontStyle\",\n    \"_fontSize\",\n    \"_fontVariant\",\n    \"_fontWeight\",\n    \"_breakWords\",\n    \"_align\",\n    \"_leading\",\n    \"_letterSpacing\",\n    \"_lineHeight\",\n    \"_textBaseline\",\n    \"_whiteSpace\",\n    \"_wordWrap\",\n    \"_wordWrapWidth\",\n    \"_padding\",\n    \"_cssOverrides\",\n    \"_trim\"\n];\nfunction $9b4def45185a5f6c$export$8a3681e2b47964bb(style) {\n    const key = [];\n    let index = 0;\n    for(let i = 0; i < $9b4def45185a5f6c$var$valuesToIterateForKeys.length; i++){\n        const prop = $9b4def45185a5f6c$var$valuesToIterateForKeys[i];\n        key[index++] = style[prop];\n    }\n    index = $9b4def45185a5f6c$var$addFillStyleKey(style._fill, key, index);\n    index = $9b4def45185a5f6c$var$addStokeStyleKey(style._stroke, key, index);\n    return key.join(\"-\");\n}\nfunction $9b4def45185a5f6c$var$addFillStyleKey(fillStyle, key, index) {\n    if (!fillStyle) return index;\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = fillStyle.fill?.uid;\n    return index;\n}\nfunction $9b4def45185a5f6c$var$addStokeStyleKey(strokeStyle, key, index) {\n    if (!strokeStyle) return index;\n    index = $9b4def45185a5f6c$var$addFillStyleKey(strokeStyle, key, index);\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n    return index;\n}\n\n});\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ var $5c96a02c592fcff1$var$extendStatics = function(d, b) {\n    $5c96a02c592fcff1$var$extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return $5c96a02c592fcff1$var$extendStatics(d, b);\n};\nfunction $5c96a02c592fcff1$export$a8ba968b8961cb8a(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    $5c96a02c592fcff1$var$extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar $5c96a02c592fcff1$export$18ce0697a983be9b = function() {\n    $5c96a02c592fcff1$export$18ce0697a983be9b = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return $5c96a02c592fcff1$export$18ce0697a983be9b.apply(this, arguments);\n};\nfunction $5c96a02c592fcff1$export$3c9a16f847548506(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") {\n        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction $5c96a02c592fcff1$export$29e00dfd3077644b(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction $5c96a02c592fcff1$export$d5ad3fd78186038f(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n}\nfunction $5c96a02c592fcff1$export$3a84e1ae4e97e9b0(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) {\n        if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n        return f;\n    }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for(var i = decorators.length - 1; i >= 0; i--){\n        var context = {};\n        for(var p in contextIn)context[p] = p === \"access\" ? {} : contextIn[p];\n        for(var p in contextIn.access)context.access[p] = contextIn.access[p];\n        context.addInitializer = function(f) {\n            if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n            extraInitializers.push(accept(f || null));\n        };\n        var result = (0, decorators[i])(kind === \"accessor\" ? {\n            get: descriptor.get,\n            set: descriptor.set\n        } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        } else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n}\nfunction $5c96a02c592fcff1$export$d831c04e792af3d(thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for(var i = 0; i < initializers.length; i++)value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    return useValue ? value : void 0;\n}\nfunction $5c96a02c592fcff1$export$6a2a36740a146cb8(x) {\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\n}\nfunction $5c96a02c592fcff1$export$d1a06452d3489bc7(f, name, prefix) {\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n    return Object.defineProperty(f, \"name\", {\n        configurable: true,\n        value: prefix ? \"\".concat(prefix, \" \", name) : name\n    });\n}\nfunction $5c96a02c592fcff1$export$f1db080c865becb9(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction $5c96a02c592fcff1$export$1050f835b63b671e(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction $5c96a02c592fcff1$export$67ebef60e6f28a6(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar $5c96a02c592fcff1$export$45d3717a4c69092e = Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n};\nfunction $5c96a02c592fcff1$export$f33643c0debef087(m, o) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) $5c96a02c592fcff1$export$45d3717a4c69092e(o, m, p);\n}\nfunction $5c96a02c592fcff1$export$19a8beecd37a4c45(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction $5c96a02c592fcff1$export$8d051b38c9118094(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\nfunction $5c96a02c592fcff1$export$afc72e2116322959() {\n    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat($5c96a02c592fcff1$export$8d051b38c9118094(arguments[i]));\n    return ar;\n}\nfunction $5c96a02c592fcff1$export$6388937ca91ccae8() {\n    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;\n    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];\n    return r;\n}\nfunction $5c96a02c592fcff1$export$1216008129fb82ed(to, from, pack) {\n    if (pack || arguments.length === 2) {\n        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction $5c96a02c592fcff1$export$10c90e4f7922046c(v) {\n    return this instanceof $5c96a02c592fcff1$export$10c90e4f7922046c ? (this.v = v, this) : new $5c96a02c592fcff1$export$10c90e4f7922046c(v);\n}\nfunction $5c96a02c592fcff1$export$e427f37a30a4de9b(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof $5c96a02c592fcff1$export$10c90e4f7922046c ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction $5c96a02c592fcff1$export$bbd80228419bb833(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n        throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function() {\n        return this;\n    }, i;\n    function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n            return (p = !p) ? {\n                value: $5c96a02c592fcff1$export$10c90e4f7922046c(o[n](v)),\n                done: false\n            } : f ? f(v) : v;\n        } : f;\n    }\n}\nfunction $5c96a02c592fcff1$export$e3b29a3d6162315f(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof $5c96a02c592fcff1$export$19a8beecd37a4c45 === \"function\" ? $5c96a02c592fcff1$export$19a8beecd37a4c45(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nfunction $5c96a02c592fcff1$export$4fb47efe1390b86f(cooked, raw) {\n    if (Object.defineProperty) Object.defineProperty(cooked, \"raw\", {\n        value: raw\n    });\n    else cooked.raw = raw;\n    return cooked;\n}\nvar $5c96a02c592fcff1$var$__setModuleDefault = Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n};\nfunction $5c96a02c592fcff1$export$c21735bcef00d192(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $5c96a02c592fcff1$export$45d3717a4c69092e(result, mod, k);\n    }\n    $5c96a02c592fcff1$var$__setModuleDefault(result, mod);\n    return result;\n}\nfunction $5c96a02c592fcff1$export$da59b14a69baef04(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n}\nfunction $5c96a02c592fcff1$export$d5dcaf168c640c35(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction $5c96a02c592fcff1$export$d40a35129aaff81f(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nfunction $5c96a02c592fcff1$export$81fdc39f203e4e04(state, receiver) {\n    if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\") throw new TypeError(\"Cannot use 'in' operator on non-object\");\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\nfunction $5c96a02c592fcff1$export$88ac25d8e944e405(env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose;\n        if (async) {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        env.stack.push({\n            value: value,\n            dispose: dispose,\n            async: async\n        });\n    } else if (async) env.stack.push({\n        async: true\n    });\n    return value;\n}\nvar $5c96a02c592fcff1$var$_SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nfunction $5c96a02c592fcff1$export$8f076105dc360e92(env) {\n    function fail(e) {\n        env.error = env.hasError ? new $5c96a02c592fcff1$var$_SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n        env.hasError = true;\n    }\n    function next() {\n        while(env.stack.length){\n            var rec = env.stack.pop();\n            try {\n                var result = rec.dispose && rec.dispose.call(rec.value);\n                if (rec.async) return Promise.resolve(result).then(next, function(e) {\n                    fail(e);\n                    return next();\n                });\n            } catch (e) {\n                fail(e);\n            }\n        }\n        if (env.hasError) throw env.error;\n    }\n    return next();\n}\nvar $5c96a02c592fcff1$export$2e2bcd8739ae039 = {\n    __extends: $5c96a02c592fcff1$export$a8ba968b8961cb8a,\n    __assign: $5c96a02c592fcff1$export$18ce0697a983be9b,\n    __rest: $5c96a02c592fcff1$export$3c9a16f847548506,\n    __decorate: $5c96a02c592fcff1$export$29e00dfd3077644b,\n    __param: $5c96a02c592fcff1$export$d5ad3fd78186038f,\n    __metadata: $5c96a02c592fcff1$export$f1db080c865becb9,\n    __awaiter: $5c96a02c592fcff1$export$1050f835b63b671e,\n    __generator: $5c96a02c592fcff1$export$67ebef60e6f28a6,\n    __createBinding: $5c96a02c592fcff1$export$45d3717a4c69092e,\n    __exportStar: $5c96a02c592fcff1$export$f33643c0debef087,\n    __values: $5c96a02c592fcff1$export$19a8beecd37a4c45,\n    __read: $5c96a02c592fcff1$export$8d051b38c9118094,\n    __spread: $5c96a02c592fcff1$export$afc72e2116322959,\n    __spreadArrays: $5c96a02c592fcff1$export$6388937ca91ccae8,\n    __spreadArray: $5c96a02c592fcff1$export$1216008129fb82ed,\n    __await: $5c96a02c592fcff1$export$10c90e4f7922046c,\n    __asyncGenerator: $5c96a02c592fcff1$export$e427f37a30a4de9b,\n    __asyncDelegator: $5c96a02c592fcff1$export$bbd80228419bb833,\n    __asyncValues: $5c96a02c592fcff1$export$e3b29a3d6162315f,\n    __makeTemplateObject: $5c96a02c592fcff1$export$4fb47efe1390b86f,\n    __importStar: $5c96a02c592fcff1$export$c21735bcef00d192,\n    __importDefault: $5c96a02c592fcff1$export$da59b14a69baef04,\n    __classPrivateFieldGet: $5c96a02c592fcff1$export$d5dcaf168c640c35,\n    __classPrivateFieldSet: $5c96a02c592fcff1$export$d40a35129aaff81f,\n    __classPrivateFieldIn: $5c96a02c592fcff1$export$81fdc39f203e4e04,\n    __addDisposableResource: $5c96a02c592fcff1$export$88ac25d8e944e405,\n    __disposeResources: $5c96a02c592fcff1$export$8f076105dc360e92\n};\n\n\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ const $3233927aa82734f9$var$t = globalThis, $3233927aa82734f9$export$b4d10f6001c083c2 = $3233927aa82734f9$var$t.ShadowRoot && (void 0 === $3233927aa82734f9$var$t.ShadyCSS || $3233927aa82734f9$var$t.ShadyCSS.nativeShadow) && \"adoptedStyleSheets\" in Document.prototype && \"replace\" in CSSStyleSheet.prototype, $3233927aa82734f9$var$s = Symbol(), $3233927aa82734f9$var$o = new WeakMap;\nclass $3233927aa82734f9$export$505d1e8739bad805 {\n    constructor(t, e, o){\n        if (this._$cssResult$ = !0, o !== $3233927aa82734f9$var$s) throw Error(\"CSSResult is not constructable. Use `unsafeCSS` or `css` instead.\");\n        this.cssText = t, this.t = e;\n    }\n    get styleSheet() {\n        let t = this.o;\n        const s = this.t;\n        if ($3233927aa82734f9$export$b4d10f6001c083c2 && void 0 === t) {\n            const e = void 0 !== s && 1 === s.length;\n            e && (t = $3233927aa82734f9$var$o.get(s)), void 0 === t && ((this.o = t = new CSSStyleSheet).replaceSync(this.cssText), e && $3233927aa82734f9$var$o.set(s, t));\n        }\n        return t;\n    }\n    toString() {\n        return this.cssText;\n    }\n}\nconst $3233927aa82734f9$export$8d80f9cac07cdb3 = (t)=>new $3233927aa82734f9$export$505d1e8739bad805(\"string\" == typeof t ? t : t + \"\", void 0, $3233927aa82734f9$var$s), $3233927aa82734f9$export$dbf350e5966cf602 = (t, ...e)=>{\n    const o = 1 === t.length ? t[0] : e.reduce((e, s, o)=>e + ((t)=>{\n            if (!0 === t._$cssResult$) return t.cssText;\n            if (\"number\" == typeof t) return t;\n            throw Error(\"Value passed to 'css' function must be a 'css' function result: \" + t + \". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.\");\n        })(s) + t[o + 1], t[0]);\n    return new $3233927aa82734f9$export$505d1e8739bad805(o, t, $3233927aa82734f9$var$s);\n}, $3233927aa82734f9$export$2ca4a66ec4cecb90 = (s, o)=>{\n    if ($3233927aa82734f9$export$b4d10f6001c083c2) s.adoptedStyleSheets = o.map((t)=>t instanceof CSSStyleSheet ? t : t.styleSheet);\n    else for (const e of o){\n        const o = document.createElement(\"style\"), n = $3233927aa82734f9$var$t.litNonce;\n        void 0 !== n && o.setAttribute(\"nonce\", n), o.textContent = e.cssText, s.appendChild(o);\n    }\n}, $3233927aa82734f9$export$ee69dfd951e24778 = $3233927aa82734f9$export$b4d10f6001c083c2 ? (t)=>t : (t)=>t instanceof CSSStyleSheet ? ((t)=>{\n        let e = \"\";\n        for (const s of t.cssRules)e += s.cssText;\n        return $3233927aa82734f9$export$8d80f9cac07cdb3(e);\n    })(t) : t;\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ const { is: $27fcf98b67c2a783$var$i, defineProperty: $27fcf98b67c2a783$var$e, getOwnPropertyDescriptor: $27fcf98b67c2a783$var$r, getOwnPropertyNames: $27fcf98b67c2a783$var$h, getOwnPropertySymbols: $27fcf98b67c2a783$var$o, getPrototypeOf: $27fcf98b67c2a783$var$n } = Object, $27fcf98b67c2a783$var$a = globalThis, $27fcf98b67c2a783$var$c = $27fcf98b67c2a783$var$a.trustedTypes, $27fcf98b67c2a783$var$l = $27fcf98b67c2a783$var$c ? $27fcf98b67c2a783$var$c.emptyScript : \"\", $27fcf98b67c2a783$var$p = $27fcf98b67c2a783$var$a.reactiveElementPolyfillSupport, $27fcf98b67c2a783$var$d = (t, s)=>t, $27fcf98b67c2a783$export$7312b35fbf521afb = {\n    toAttribute (t, s) {\n        switch(s){\n            case Boolean:\n                t = t ? $27fcf98b67c2a783$var$l : null;\n                break;\n            case Object:\n            case Array:\n                t = null == t ? t : JSON.stringify(t);\n        }\n        return t;\n    },\n    fromAttribute (t, s) {\n        let i = t;\n        switch(s){\n            case Boolean:\n                i = null !== t;\n                break;\n            case Number:\n                i = null === t ? null : Number(t);\n                break;\n            case Object:\n            case Array:\n                try {\n                    i = JSON.parse(t);\n                } catch (t) {\n                    i = null;\n                }\n        }\n        return i;\n    }\n}, $27fcf98b67c2a783$export$53a6892c50694894 = (t, s)=>!$27fcf98b67c2a783$var$i(t, s), $27fcf98b67c2a783$var$y = {\n    attribute: !0,\n    type: String,\n    converter: $27fcf98b67c2a783$export$7312b35fbf521afb,\n    reflect: !1,\n    hasChanged: $27fcf98b67c2a783$export$53a6892c50694894\n};\nSymbol.metadata ??= Symbol(\"metadata\"), $27fcf98b67c2a783$var$a.litPropertyMetadata ??= new WeakMap;\nclass $27fcf98b67c2a783$export$c7c07a37856565d extends HTMLElement {\n    static addInitializer(t) {\n        this._$Ei(), (this.l ??= []).push(t);\n    }\n    static get observedAttributes() {\n        return this.finalize(), this._$Eh && [\n            ...this._$Eh.keys()\n        ];\n    }\n    static createProperty(t, s = $27fcf98b67c2a783$var$y) {\n        if (s.state && (s.attribute = !1), this._$Ei(), this.elementProperties.set(t, s), !s.noAccessor) {\n            const i = Symbol(), r = this.getPropertyDescriptor(t, i, s);\n            void 0 !== r && $27fcf98b67c2a783$var$e(this.prototype, t, r);\n        }\n    }\n    static getPropertyDescriptor(t, s, i) {\n        const { get: e, set: h } = $27fcf98b67c2a783$var$r(this.prototype, t) ?? {\n            get () {\n                return this[s];\n            },\n            set (t) {\n                this[s] = t;\n            }\n        };\n        return {\n            get () {\n                return e?.call(this);\n            },\n            set (s) {\n                const r = e?.call(this);\n                h.call(this, s), this.requestUpdate(t, r, i);\n            },\n            configurable: !0,\n            enumerable: !0\n        };\n    }\n    static getPropertyOptions(t) {\n        return this.elementProperties.get(t) ?? $27fcf98b67c2a783$var$y;\n    }\n    static _$Ei() {\n        if (this.hasOwnProperty($27fcf98b67c2a783$var$d(\"elementProperties\"))) return;\n        const t = $27fcf98b67c2a783$var$n(this);\n        t.finalize(), void 0 !== t.l && (this.l = [\n            ...t.l\n        ]), this.elementProperties = new Map(t.elementProperties);\n    }\n    static finalize() {\n        if (this.hasOwnProperty($27fcf98b67c2a783$var$d(\"finalized\"))) return;\n        if (this.finalized = !0, this._$Ei(), this.hasOwnProperty($27fcf98b67c2a783$var$d(\"properties\"))) {\n            const t = this.properties, s = [\n                ...$27fcf98b67c2a783$var$h(t),\n                ...$27fcf98b67c2a783$var$o(t)\n            ];\n            for (const i of s)this.createProperty(i, t[i]);\n        }\n        const t = this[Symbol.metadata];\n        if (null !== t) {\n            const s = litPropertyMetadata.get(t);\n            if (void 0 !== s) for (const [t, i] of s)this.elementProperties.set(t, i);\n        }\n        this._$Eh = new Map;\n        for (const [t, s] of this.elementProperties){\n            const i = this._$Eu(t, s);\n            void 0 !== i && this._$Eh.set(i, t);\n        }\n        this.elementStyles = this.finalizeStyles(this.styles);\n    }\n    static finalizeStyles(s) {\n        const i = [];\n        if (Array.isArray(s)) {\n            const e = new Set(s.flat(1 / 0).reverse());\n            for (const s of e)i.unshift((0, $3233927aa82734f9$export$ee69dfd951e24778)(s));\n        } else void 0 !== s && i.push((0, $3233927aa82734f9$export$ee69dfd951e24778)(s));\n        return i;\n    }\n    static _$Eu(t, s) {\n        const i = s.attribute;\n        return !1 === i ? void 0 : \"string\" == typeof i ? i : \"string\" == typeof t ? t.toLowerCase() : void 0;\n    }\n    constructor(){\n        super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();\n    }\n    _$Ev() {\n        this._$ES = new Promise((t)=>this.enableUpdating = t), this._$AL = new Map, this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t)=>t(this));\n    }\n    addController(t) {\n        (this._$EO ??= new Set).add(t), void 0 !== this.renderRoot && this.isConnected && t.hostConnected?.();\n    }\n    removeController(t) {\n        this._$EO?.delete(t);\n    }\n    _$E_() {\n        const t = new Map, s = this.constructor.elementProperties;\n        for (const i of s.keys())this.hasOwnProperty(i) && (t.set(i, this[i]), delete this[i]);\n        t.size > 0 && (this._$Ep = t);\n    }\n    createRenderRoot() {\n        const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);\n        return (0, $3233927aa82734f9$export$2ca4a66ec4cecb90)(t, this.constructor.elementStyles), t;\n    }\n    connectedCallback() {\n        this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach((t)=>t.hostConnected?.());\n    }\n    enableUpdating(t) {}\n    disconnectedCallback() {\n        this._$EO?.forEach((t)=>t.hostDisconnected?.());\n    }\n    attributeChangedCallback(t, s, i) {\n        this._$AK(t, i);\n    }\n    _$EC(t, s) {\n        const i = this.constructor.elementProperties.get(t), e = this.constructor._$Eu(t, i);\n        if (void 0 !== e && !0 === i.reflect) {\n            const r = (void 0 !== i.converter?.toAttribute ? i.converter : $27fcf98b67c2a783$export$7312b35fbf521afb).toAttribute(s, i.type);\n            this._$Em = t, null == r ? this.removeAttribute(e) : this.setAttribute(e, r), this._$Em = null;\n        }\n    }\n    _$AK(t, s) {\n        const i = this.constructor, e = i._$Eh.get(t);\n        if (void 0 !== e && this._$Em !== e) {\n            const t = i.getPropertyOptions(e), r = \"function\" == typeof t.converter ? {\n                fromAttribute: t.converter\n            } : void 0 !== t.converter?.fromAttribute ? t.converter : $27fcf98b67c2a783$export$7312b35fbf521afb;\n            this._$Em = e, this[e] = r.fromAttribute(s, t.type), this._$Em = null;\n        }\n    }\n    requestUpdate(t, s, i) {\n        if (void 0 !== t) {\n            if (i ??= this.constructor.getPropertyOptions(t), !(i.hasChanged ?? $27fcf98b67c2a783$export$53a6892c50694894)(this[t], s)) return;\n            this.P(t, s, i);\n        }\n        !1 === this.isUpdatePending && (this._$ES = this._$ET());\n    }\n    P(t, s, i) {\n        this._$AL.has(t) || this._$AL.set(t, s), !0 === i.reflect && this._$Em !== t && (this._$Ej ??= new Set).add(t);\n    }\n    async _$ET() {\n        this.isUpdatePending = !0;\n        try {\n            await this._$ES;\n        } catch (t) {\n            Promise.reject(t);\n        }\n        const t = this.scheduleUpdate();\n        return null != t && await t, !this.isUpdatePending;\n    }\n    scheduleUpdate() {\n        return this.performUpdate();\n    }\n    performUpdate() {\n        if (!this.isUpdatePending) return;\n        if (!this.hasUpdated) {\n            if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {\n                for (const [t, s] of this._$Ep)this[t] = s;\n                this._$Ep = void 0;\n            }\n            const t = this.constructor.elementProperties;\n            if (t.size > 0) for (const [s, i] of t)!0 !== i.wrapped || this._$AL.has(s) || void 0 === this[s] || this.P(s, this[s], i);\n        }\n        let t = !1;\n        const s = this._$AL;\n        try {\n            t = this.shouldUpdate(s), t ? (this.willUpdate(s), this._$EO?.forEach((t)=>t.hostUpdate?.()), this.update(s)) : this._$EU();\n        } catch (s) {\n            throw t = !1, this._$EU(), s;\n        }\n        t && this._$AE(s);\n    }\n    willUpdate(t) {}\n    _$AE(t) {\n        this._$EO?.forEach((t)=>t.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);\n    }\n    _$EU() {\n        this._$AL = new Map, this.isUpdatePending = !1;\n    }\n    get updateComplete() {\n        return this.getUpdateComplete();\n    }\n    getUpdateComplete() {\n        return this._$ES;\n    }\n    shouldUpdate(t) {\n        return !0;\n    }\n    update(t) {\n        this._$Ej &&= this._$Ej.forEach((t)=>this._$EC(t, this[t])), this._$EU();\n    }\n    updated(t) {}\n    firstUpdated(t) {}\n}\n$27fcf98b67c2a783$export$c7c07a37856565d.elementStyles = [], $27fcf98b67c2a783$export$c7c07a37856565d.shadowRootOptions = {\n    mode: \"open\"\n}, $27fcf98b67c2a783$export$c7c07a37856565d[$27fcf98b67c2a783$var$d(\"elementProperties\")] = new Map, $27fcf98b67c2a783$export$c7c07a37856565d[$27fcf98b67c2a783$var$d(\"finalized\")] = new Map, $27fcf98b67c2a783$var$p?.({\n    ReactiveElement: $27fcf98b67c2a783$export$c7c07a37856565d\n}), ($27fcf98b67c2a783$var$a.reactiveElementVersions ??= []).push(\"2.0.4\");\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ const $e5ed8027d647799b$var$t = globalThis, $e5ed8027d647799b$var$i = $e5ed8027d647799b$var$t.trustedTypes, $e5ed8027d647799b$var$s = $e5ed8027d647799b$var$i ? $e5ed8027d647799b$var$i.createPolicy(\"lit-html\", {\n    createHTML: (t)=>t\n}) : void 0, $e5ed8027d647799b$var$e = \"$lit$\", $e5ed8027d647799b$var$h = `lit$${Math.random().toFixed(9).slice(2)}$`, $e5ed8027d647799b$var$o = \"?\" + $e5ed8027d647799b$var$h, $e5ed8027d647799b$var$n = `<${$e5ed8027d647799b$var$o}>`, $e5ed8027d647799b$var$r = document, $e5ed8027d647799b$var$l = ()=>$e5ed8027d647799b$var$r.createComment(\"\"), $e5ed8027d647799b$var$c = (t)=>null === t || \"object\" != typeof t && \"function\" != typeof t, $e5ed8027d647799b$var$a = Array.isArray, $e5ed8027d647799b$var$u = (t)=>$e5ed8027d647799b$var$a(t) || \"function\" == typeof t?.[Symbol.iterator], $e5ed8027d647799b$var$d = \"[ \t\\n\\f\\r]\", $e5ed8027d647799b$var$f = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g, $e5ed8027d647799b$var$v = /-->/g, $e5ed8027d647799b$var$_ = />/g, $e5ed8027d647799b$var$m = RegExp(`>|${$e5ed8027d647799b$var$d}(?:([^\\\\s\"'>=/]+)(${$e5ed8027d647799b$var$d}*=${$e5ed8027d647799b$var$d}*(?:[^ \\t\\n\\f\\r\"'\\`<>=]|(\"|')|))|$)`, \"g\"), $e5ed8027d647799b$var$p = /'/g, $e5ed8027d647799b$var$g = /\"/g, $e5ed8027d647799b$var$$ = /^(?:script|style|textarea|title)$/i, $e5ed8027d647799b$var$y = (t)=>(i, ...s)=>({\n            _$litType$: t,\n            strings: i,\n            values: s\n        }), $e5ed8027d647799b$export$c0bb0b647f701bb5 = $e5ed8027d647799b$var$y(1), $e5ed8027d647799b$export$7ed1367e7fa1ad68 = $e5ed8027d647799b$var$y(2), $e5ed8027d647799b$export$9c068ae9cc5db4e8 = Symbol.for(\"lit-noChange\"), $e5ed8027d647799b$export$45b790e32b2810ee = Symbol.for(\"lit-nothing\"), $e5ed8027d647799b$var$A = new WeakMap, $e5ed8027d647799b$var$E = $e5ed8027d647799b$var$r.createTreeWalker($e5ed8027d647799b$var$r, 129);\nfunction $e5ed8027d647799b$var$C(t, i) {\n    if (!Array.isArray(t) || !t.hasOwnProperty(\"raw\")) throw Error(\"invalid template strings array\");\n    return void 0 !== $e5ed8027d647799b$var$s ? $e5ed8027d647799b$var$s.createHTML(i) : i;\n}\nconst $e5ed8027d647799b$var$P = (t, i)=>{\n    const s = t.length - 1, o = [];\n    let r, l = 2 === i ? \"<svg>\" : \"\", c = $e5ed8027d647799b$var$f;\n    for(let i = 0; i < s; i++){\n        const s = t[i];\n        let a, u, d = -1, y = 0;\n        for(; y < s.length && (c.lastIndex = y, u = c.exec(s), null !== u);)y = c.lastIndex, c === $e5ed8027d647799b$var$f ? \"!--\" === u[1] ? c = $e5ed8027d647799b$var$v : void 0 !== u[1] ? c = $e5ed8027d647799b$var$_ : void 0 !== u[2] ? ($e5ed8027d647799b$var$$.test(u[2]) && (r = RegExp(\"</\" + u[2], \"g\")), c = $e5ed8027d647799b$var$m) : void 0 !== u[3] && (c = $e5ed8027d647799b$var$m) : c === $e5ed8027d647799b$var$m ? \">\" === u[0] ? (c = r ?? $e5ed8027d647799b$var$f, d = -1) : void 0 === u[1] ? d = -2 : (d = c.lastIndex - u[2].length, a = u[1], c = void 0 === u[3] ? $e5ed8027d647799b$var$m : '\"' === u[3] ? $e5ed8027d647799b$var$g : $e5ed8027d647799b$var$p) : c === $e5ed8027d647799b$var$g || c === $e5ed8027d647799b$var$p ? c = $e5ed8027d647799b$var$m : c === $e5ed8027d647799b$var$v || c === $e5ed8027d647799b$var$_ ? c = $e5ed8027d647799b$var$f : (c = $e5ed8027d647799b$var$m, r = void 0);\n        const x = c === $e5ed8027d647799b$var$m && t[i + 1].startsWith(\"/>\") ? \" \" : \"\";\n        l += c === $e5ed8027d647799b$var$f ? s + $e5ed8027d647799b$var$n : d >= 0 ? (o.push(a), s.slice(0, d) + $e5ed8027d647799b$var$e + s.slice(d) + $e5ed8027d647799b$var$h + x) : s + $e5ed8027d647799b$var$h + (-2 === d ? i : x);\n    }\n    return [\n        $e5ed8027d647799b$var$C(t, l + (t[s] || \"<?>\") + (2 === i ? \"</svg>\" : \"\")),\n        o\n    ];\n};\nclass $e5ed8027d647799b$var$V {\n    constructor({ strings: t, _$litType$: s }, n){\n        let r;\n        this.parts = [];\n        let c = 0, a = 0;\n        const u = t.length - 1, d = this.parts, [f, v] = $e5ed8027d647799b$var$P(t, s);\n        if (this.el = $e5ed8027d647799b$var$V.createElement(f, n), $e5ed8027d647799b$var$E.currentNode = this.el.content, 2 === s) {\n            const t = this.el.content.firstChild;\n            t.replaceWith(...t.childNodes);\n        }\n        for(; null !== (r = $e5ed8027d647799b$var$E.nextNode()) && d.length < u;){\n            if (1 === r.nodeType) {\n                if (r.hasAttributes()) for (const t of r.getAttributeNames())if (t.endsWith($e5ed8027d647799b$var$e)) {\n                    const i = v[a++], s = r.getAttribute(t).split($e5ed8027d647799b$var$h), e = /([.?@])?(.*)/.exec(i);\n                    d.push({\n                        type: 1,\n                        index: c,\n                        name: e[2],\n                        strings: s,\n                        ctor: \".\" === e[1] ? $e5ed8027d647799b$var$k : \"?\" === e[1] ? $e5ed8027d647799b$var$H : \"@\" === e[1] ? $e5ed8027d647799b$var$I : $e5ed8027d647799b$var$R\n                    }), r.removeAttribute(t);\n                } else t.startsWith($e5ed8027d647799b$var$h) && (d.push({\n                    type: 6,\n                    index: c\n                }), r.removeAttribute(t));\n                if ($e5ed8027d647799b$var$$.test(r.tagName)) {\n                    const t = r.textContent.split($e5ed8027d647799b$var$h), s = t.length - 1;\n                    if (s > 0) {\n                        r.textContent = $e5ed8027d647799b$var$i ? $e5ed8027d647799b$var$i.emptyScript : \"\";\n                        for(let i = 0; i < s; i++)r.append(t[i], $e5ed8027d647799b$var$l()), $e5ed8027d647799b$var$E.nextNode(), d.push({\n                            type: 2,\n                            index: ++c\n                        });\n                        r.append(t[s], $e5ed8027d647799b$var$l());\n                    }\n                }\n            } else if (8 === r.nodeType) {\n                if (r.data === $e5ed8027d647799b$var$o) d.push({\n                    type: 2,\n                    index: c\n                });\n                else {\n                    let t = -1;\n                    for(; -1 !== (t = r.data.indexOf($e5ed8027d647799b$var$h, t + 1));)d.push({\n                        type: 7,\n                        index: c\n                    }), t += $e5ed8027d647799b$var$h.length - 1;\n                }\n            }\n            c++;\n        }\n    }\n    static createElement(t, i) {\n        const s = $e5ed8027d647799b$var$r.createElement(\"template\");\n        return s.innerHTML = t, s;\n    }\n}\nfunction $e5ed8027d647799b$var$N(t, i, s = t, e) {\n    if (i === $e5ed8027d647799b$export$9c068ae9cc5db4e8) return i;\n    let h = void 0 !== e ? s._$Co?.[e] : s._$Cl;\n    const o = $e5ed8027d647799b$var$c(i) ? void 0 : i._$litDirective$;\n    return h?.constructor !== o && (h?._$AO?.(!1), void 0 === o ? h = void 0 : (h = new o(t), h._$AT(t, s, e)), void 0 !== e ? (s._$Co ??= [])[e] = h : s._$Cl = h), void 0 !== h && (i = $e5ed8027d647799b$var$N(t, h._$AS(t, i.values), h, e)), i;\n}\nclass $e5ed8027d647799b$var$S {\n    constructor(t, i){\n        this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = i;\n    }\n    get parentNode() {\n        return this._$AM.parentNode;\n    }\n    get _$AU() {\n        return this._$AM._$AU;\n    }\n    u(t) {\n        const { el: { content: i }, parts: s } = this._$AD, e = (t?.creationScope ?? $e5ed8027d647799b$var$r).importNode(i, !0);\n        $e5ed8027d647799b$var$E.currentNode = e;\n        let h = $e5ed8027d647799b$var$E.nextNode(), o = 0, n = 0, l = s[0];\n        for(; void 0 !== l;){\n            if (o === l.index) {\n                let i;\n                2 === l.type ? i = new $e5ed8027d647799b$var$M(h, h.nextSibling, this, t) : 1 === l.type ? i = new l.ctor(h, l.name, l.strings, this, t) : 6 === l.type && (i = new $e5ed8027d647799b$var$L(h, this, t)), this._$AV.push(i), l = s[++n];\n            }\n            o !== l?.index && (h = $e5ed8027d647799b$var$E.nextNode(), o++);\n        }\n        return $e5ed8027d647799b$var$E.currentNode = $e5ed8027d647799b$var$r, e;\n    }\n    p(t) {\n        let i = 0;\n        for (const s of this._$AV)void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++;\n    }\n}\nclass $e5ed8027d647799b$var$M {\n    get _$AU() {\n        return this._$AM?._$AU ?? this._$Cv;\n    }\n    constructor(t, i, s, e){\n        this.type = 2, this._$AH = $e5ed8027d647799b$export$45b790e32b2810ee, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cv = e?.isConnected ?? !0;\n    }\n    get parentNode() {\n        let t = this._$AA.parentNode;\n        const i = this._$AM;\n        return void 0 !== i && 11 === t?.nodeType && (t = i.parentNode), t;\n    }\n    get startNode() {\n        return this._$AA;\n    }\n    get endNode() {\n        return this._$AB;\n    }\n    _$AI(t, i = this) {\n        t = $e5ed8027d647799b$var$N(this, t, i), $e5ed8027d647799b$var$c(t) ? t === $e5ed8027d647799b$export$45b790e32b2810ee || null == t || \"\" === t ? (this._$AH !== $e5ed8027d647799b$export$45b790e32b2810ee && this._$AR(), this._$AH = $e5ed8027d647799b$export$45b790e32b2810ee) : t !== this._$AH && t !== $e5ed8027d647799b$export$9c068ae9cc5db4e8 && this._(t) : void 0 !== t._$litType$ ? this.$(t) : void 0 !== t.nodeType ? this.T(t) : $e5ed8027d647799b$var$u(t) ? this.k(t) : this._(t);\n    }\n    S(t) {\n        return this._$AA.parentNode.insertBefore(t, this._$AB);\n    }\n    T(t) {\n        this._$AH !== t && (this._$AR(), this._$AH = this.S(t));\n    }\n    _(t) {\n        this._$AH !== $e5ed8027d647799b$export$45b790e32b2810ee && $e5ed8027d647799b$var$c(this._$AH) ? this._$AA.nextSibling.data = t : this.T($e5ed8027d647799b$var$r.createTextNode(t)), this._$AH = t;\n    }\n    $(t) {\n        const { values: i, _$litType$: s } = t, e = \"number\" == typeof s ? this._$AC(t) : (void 0 === s.el && (s.el = $e5ed8027d647799b$var$V.createElement($e5ed8027d647799b$var$C(s.h, s.h[0]), this.options)), s);\n        if (this._$AH?._$AD === e) this._$AH.p(i);\n        else {\n            const t = new $e5ed8027d647799b$var$S(e, this), s = t.u(this.options);\n            t.p(i), this.T(s), this._$AH = t;\n        }\n    }\n    _$AC(t) {\n        let i = $e5ed8027d647799b$var$A.get(t.strings);\n        return void 0 === i && $e5ed8027d647799b$var$A.set(t.strings, i = new $e5ed8027d647799b$var$V(t)), i;\n    }\n    k(t) {\n        $e5ed8027d647799b$var$a(this._$AH) || (this._$AH = [], this._$AR());\n        const i = this._$AH;\n        let s, e = 0;\n        for (const h of t)e === i.length ? i.push(s = new $e5ed8027d647799b$var$M(this.S($e5ed8027d647799b$var$l()), this.S($e5ed8027d647799b$var$l()), this, this.options)) : s = i[e], s._$AI(h), e++;\n        e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);\n    }\n    _$AR(t = this._$AA.nextSibling, i) {\n        for(this._$AP?.(!1, !0, i); t && t !== this._$AB;){\n            const i = t.nextSibling;\n            t.remove(), t = i;\n        }\n    }\n    setConnected(t) {\n        void 0 === this._$AM && (this._$Cv = t, this._$AP?.(t));\n    }\n}\nclass $e5ed8027d647799b$var$R {\n    get tagName() {\n        return this.element.tagName;\n    }\n    get _$AU() {\n        return this._$AM._$AU;\n    }\n    constructor(t, i, s, e, h){\n        this.type = 1, this._$AH = $e5ed8027d647799b$export$45b790e32b2810ee, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = h, s.length > 2 || \"\" !== s[0] || \"\" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String), this.strings = s) : this._$AH = $e5ed8027d647799b$export$45b790e32b2810ee;\n    }\n    _$AI(t, i = this, s, e) {\n        const h = this.strings;\n        let o = !1;\n        if (void 0 === h) t = $e5ed8027d647799b$var$N(this, t, i, 0), o = !$e5ed8027d647799b$var$c(t) || t !== this._$AH && t !== $e5ed8027d647799b$export$9c068ae9cc5db4e8, o && (this._$AH = t);\n        else {\n            const e = t;\n            let n, r;\n            for(t = h[0], n = 0; n < h.length - 1; n++)r = $e5ed8027d647799b$var$N(this, e[s + n], i, n), r === $e5ed8027d647799b$export$9c068ae9cc5db4e8 && (r = this._$AH[n]), o ||= !$e5ed8027d647799b$var$c(r) || r !== this._$AH[n], r === $e5ed8027d647799b$export$45b790e32b2810ee ? t = $e5ed8027d647799b$export$45b790e32b2810ee : t !== $e5ed8027d647799b$export$45b790e32b2810ee && (t += (r ?? \"\") + h[n + 1]), this._$AH[n] = r;\n        }\n        o && !e && this.j(t);\n    }\n    j(t) {\n        t === $e5ed8027d647799b$export$45b790e32b2810ee ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? \"\");\n    }\n}\nclass $e5ed8027d647799b$var$k extends $e5ed8027d647799b$var$R {\n    constructor(){\n        super(...arguments), this.type = 3;\n    }\n    j(t) {\n        this.element[this.name] = t === $e5ed8027d647799b$export$45b790e32b2810ee ? void 0 : t;\n    }\n}\nclass $e5ed8027d647799b$var$H extends $e5ed8027d647799b$var$R {\n    constructor(){\n        super(...arguments), this.type = 4;\n    }\n    j(t) {\n        this.element.toggleAttribute(this.name, !!t && t !== $e5ed8027d647799b$export$45b790e32b2810ee);\n    }\n}\nclass $e5ed8027d647799b$var$I extends $e5ed8027d647799b$var$R {\n    constructor(t, i, s, e, h){\n        super(t, i, s, e, h), this.type = 5;\n    }\n    _$AI(t, i = this) {\n        if ((t = $e5ed8027d647799b$var$N(this, t, i, 0) ?? $e5ed8027d647799b$export$45b790e32b2810ee) === $e5ed8027d647799b$export$9c068ae9cc5db4e8) return;\n        const s = this._$AH, e = t === $e5ed8027d647799b$export$45b790e32b2810ee && s !== $e5ed8027d647799b$export$45b790e32b2810ee || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, h = t !== $e5ed8027d647799b$export$45b790e32b2810ee && (s === $e5ed8027d647799b$export$45b790e32b2810ee || e);\n        e && this.element.removeEventListener(this.name, this, s), h && this.element.addEventListener(this.name, this, t), this._$AH = t;\n    }\n    handleEvent(t) {\n        \"function\" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t) : this._$AH.handleEvent(t);\n    }\n}\nclass $e5ed8027d647799b$var$L {\n    constructor(t, i, s){\n        this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;\n    }\n    get _$AU() {\n        return this._$AM._$AU;\n    }\n    _$AI(t) {\n        $e5ed8027d647799b$var$N(this, t);\n    }\n}\nconst $e5ed8027d647799b$export$8613d1ca9052b22e = {\n    P: $e5ed8027d647799b$var$e,\n    A: $e5ed8027d647799b$var$h,\n    C: $e5ed8027d647799b$var$o,\n    M: 1,\n    L: $e5ed8027d647799b$var$P,\n    R: $e5ed8027d647799b$var$S,\n    D: $e5ed8027d647799b$var$u,\n    V: $e5ed8027d647799b$var$N,\n    I: $e5ed8027d647799b$var$M,\n    H: $e5ed8027d647799b$var$R,\n    N: $e5ed8027d647799b$var$H,\n    U: $e5ed8027d647799b$var$I,\n    B: $e5ed8027d647799b$var$k,\n    F: $e5ed8027d647799b$var$L\n}, $e5ed8027d647799b$var$Z = $e5ed8027d647799b$var$t.litHtmlPolyfillSupport;\n$e5ed8027d647799b$var$Z?.($e5ed8027d647799b$var$V, $e5ed8027d647799b$var$M), ($e5ed8027d647799b$var$t.litHtmlVersions ??= []).push(\"3.1.3\");\nconst $e5ed8027d647799b$export$b3890eb0ae9dca99 = (t, i, s)=>{\n    const e = s?.renderBefore ?? i;\n    let h = e._$litPart$;\n    if (void 0 === h) {\n        const t = s?.renderBefore ?? null;\n        e._$litPart$ = h = new $e5ed8027d647799b$var$M(i.insertBefore($e5ed8027d647799b$var$l(), t), t, void 0, s ?? {});\n    }\n    return h._$AI(t), h;\n};\n\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ class $fe586ba0757c37f7$export$3f2f9f5909897157 extends (0, $27fcf98b67c2a783$export$c7c07a37856565d) {\n    constructor(){\n        super(...arguments), this.renderOptions = {\n            host: this\n        }, this._$Do = void 0;\n    }\n    createRenderRoot() {\n        const t = super.createRenderRoot();\n        return this.renderOptions.renderBefore ??= t.firstChild, t;\n    }\n    update(t) {\n        const i = this.render();\n        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = (0, $e5ed8027d647799b$export$b3890eb0ae9dca99)(i, this.renderRoot, this.renderOptions);\n    }\n    connectedCallback() {\n        super.connectedCallback(), this._$Do?.setConnected(!0);\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback(), this._$Do?.setConnected(!1);\n    }\n    render() {\n        return 0, $e5ed8027d647799b$export$9c068ae9cc5db4e8;\n    }\n}\n$fe586ba0757c37f7$export$3f2f9f5909897157._$litElement$ = !0, $fe586ba0757c37f7$export$3f2f9f5909897157[\"finalized\"] = !0, globalThis.litElementHydrateSupport?.({\n    LitElement: $fe586ba0757c37f7$export$3f2f9f5909897157\n});\nconst $fe586ba0757c37f7$var$r = globalThis.litElementPolyfillSupport;\n$fe586ba0757c37f7$var$r?.({\n    LitElement: $fe586ba0757c37f7$export$3f2f9f5909897157\n});\nconst $fe586ba0757c37f7$export$f5c524615a7708d6 = {\n    _$AK: (t, e, i)=>{\n        t._$AK(e, i);\n    },\n    _$AL: (t)=>t._$AL\n};\n(globalThis.litElementVersions ??= []).push(\"4.0.5\");\n\n\n/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ const $650ed036964a13b8$export$6acf61af03e62db = !1;\n\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ const $07706bf0c990b886$export$da64fc29f17f9d0e = (t)=>(e, o)=>{\n        void 0 !== o ? o.addInitializer(()=>{\n            customElements.define(t, e);\n        }) : customElements.define(t, e);\n    };\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ const $b2fdcbe153c88f81$var$o = {\n    attribute: !0,\n    type: String,\n    converter: (0, $27fcf98b67c2a783$export$7312b35fbf521afb),\n    reflect: !1,\n    hasChanged: (0, $27fcf98b67c2a783$export$53a6892c50694894)\n}, $b2fdcbe153c88f81$export$8d623b1670eb40f4 = (t = $b2fdcbe153c88f81$var$o, e, r)=>{\n    const { kind: n, metadata: i } = r;\n    let s = globalThis.litPropertyMetadata.get(i);\n    if (void 0 === s && globalThis.litPropertyMetadata.set(i, s = new Map), s.set(r.name, t), \"accessor\" === n) {\n        const { name: o } = r;\n        return {\n            set (r) {\n                const n = e.get.call(this);\n                e.set.call(this, r), this.requestUpdate(o, n, t);\n            },\n            init (e) {\n                return void 0 !== e && this.P(o, void 0, t), e;\n            }\n        };\n    }\n    if (\"setter\" === n) {\n        const { name: o } = r;\n        return function(r) {\n            const n = this[o];\n            e.call(this, r), this.requestUpdate(o, n, t);\n        };\n    }\n    throw Error(\"Unsupported decorator location: \" + n);\n};\nfunction $b2fdcbe153c88f81$export$d541bacb2bda4494(t) {\n    return (e, o)=>\"object\" == typeof o ? $b2fdcbe153c88f81$export$8d623b1670eb40f4(t, e, o) : ((t, e, o)=>{\n            const r = e.hasOwnProperty(o);\n            return e.constructor.createProperty(o, r ? {\n                ...t,\n                wrapped: !0\n            } : t), r ? Object.getOwnPropertyDescriptor(e, o) : void 0;\n        })(t, e, o);\n}\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ function $7162e77b40ffab5c$export$ca000e230c0caa3e(r) {\n    return (0, $b2fdcbe153c88f81$export$d541bacb2bda4494)({\n        ...r,\n        state: !0,\n        attribute: !1\n    });\n}\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ function $e5c3d47edfef3b02$export$b2b799818fbabcf3(t) {\n    return (n, o)=>{\n        const c = \"function\" == typeof n ? n : n[o];\n        Object.assign(c, t);\n    };\n}\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ const $15c76e2f7983b497$export$51987bb50e1f6752 = (e, t, c)=>(c.configurable = !0, c.enumerable = !0, Reflect.decorate && \"object\" != typeof t && Object.defineProperty(e, t, c), c);\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ function $10a410638b7df95b$export$2fa187e846a241c4(e, r) {\n    return (n, s, i)=>{\n        const o = (t)=>t.renderRoot?.querySelector(e) ?? null;\n        if (r) {\n            const { get: e, set: r } = \"object\" == typeof s ? n : i ?? (()=>{\n                const t = Symbol();\n                return {\n                    get () {\n                        return this[t];\n                    },\n                    set (e) {\n                        this[t] = e;\n                    }\n                };\n            })();\n            return (0, $15c76e2f7983b497$export$51987bb50e1f6752)(n, s, {\n                get () {\n                    let t = e.call(this);\n                    return void 0 === t && (t = o(this), (null !== t || this.hasUpdated) && r.call(this, t)), t;\n                }\n            });\n        }\n        return (0, $15c76e2f7983b497$export$51987bb50e1f6752)(n, s, {\n            get () {\n                return o(this);\n            }\n        });\n    };\n}\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ let $24ba95ebfbdcf6b8$var$e;\nfunction $24ba95ebfbdcf6b8$export$dcd0d083aa86c355(r) {\n    return (n, o)=>(0, $15c76e2f7983b497$export$51987bb50e1f6752)(n, o, {\n            get () {\n                return (this.renderRoot ?? ($24ba95ebfbdcf6b8$var$e ??= document.createDocumentFragment())).querySelectorAll(r);\n            }\n        });\n}\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ function $1f45ba04a1effcd1$export$163dfc35cc43f240(r) {\n    return (n, e)=>(0, $15c76e2f7983b497$export$51987bb50e1f6752)(n, e, {\n            async get () {\n                return await this.updateComplete, this.renderRoot?.querySelector(r) ?? null;\n            }\n        });\n}\n\n\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ function $43ca3aec390b0561$export$4682af2d9ee91415(o) {\n    return (e, n)=>{\n        const { slot: r, selector: s } = o ?? {}, c = \"slot\" + (r ? `[name=${r}]` : \":not([name])\");\n        return (0, $15c76e2f7983b497$export$51987bb50e1f6752)(e, n, {\n            get () {\n                const t = this.renderRoot?.querySelector(c), e = t?.assignedElements(o) ?? [];\n                return void 0 === s ? e : e.filter((t)=>t.matches(s));\n            }\n        });\n    };\n}\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ function $965e44d5bf066bc5$export$1bdbe53f9df1b8(n) {\n    return (o, r)=>{\n        const { slot: e } = n ?? {}, s = \"slot\" + (e ? `[name=${e}]` : \":not([name])\");\n        return (0, $15c76e2f7983b497$export$51987bb50e1f6752)(o, r, {\n            get () {\n                const t = this.renderRoot?.querySelector(s);\n                return t?.assignedNodes(n) ?? [];\n            }\n        });\n    };\n}\n\n\n\n\n\nvar $a32F4 = parcelRequire(\"a32F4\");\n\nvar $1HooC = parcelRequire(\"1HooC\");\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\nvar $1HooC = parcelRequire(\"1HooC\");\n\"use strict\";\nconst $38d513fd875e37ff$export$d7b50392f15c447d = {\n    /**\n   * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method add\n   * @memberof maths.Point#\n   * @param {maths.PointData} other - The point to add to `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the addition.\n   */ /**\n   * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method add\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} other - The point to add to `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the addition.\n   */ add (other, outPoint) {\n        if (!outPoint) outPoint = new (0, $1HooC.Point)();\n        outPoint.x = this.x + other.x;\n        outPoint.y = this.y + other.y;\n        return outPoint;\n    },\n    /**\n   * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method subtract\n   * @memberof maths.Point#\n   * @param {maths.PointData} other - The point to subtract to `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n   */ /**\n   * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method subtract\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} other - The point to subtract to `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n   */ subtract (other, outPoint) {\n        if (!outPoint) outPoint = new (0, $1HooC.Point)();\n        outPoint.x = this.x - other.x;\n        outPoint.y = this.y - other.y;\n        return outPoint;\n    },\n    /**\n   * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method multiply\n   * @memberof maths.Point#\n   * @param {maths.PointData} other - The point to multiply with `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n   */ /**\n   * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method multiply\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} other - The point to multiply with `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n   */ multiply (other, outPoint) {\n        if (!outPoint) outPoint = new (0, $1HooC.Point)();\n        outPoint.x = this.x * other.x;\n        outPoint.y = this.y * other.y;\n        return outPoint;\n    },\n    /**\n   * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method multiplyScalar\n   * @memberof maths.Point#\n   * @param {number} scalar - The number to multiply both components of `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the multiplication.\n   */ /**\n   * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method multiplyScalar\n   * @memberof maths.ObservablePoint#\n   * @param {number} scalar - The number to multiply both components of `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the multiplication.\n   */ multiplyScalar (scalar, outPoint) {\n        if (!outPoint) outPoint = new (0, $1HooC.Point)();\n        outPoint.x = this.x * scalar;\n        outPoint.y = this.y * scalar;\n        return outPoint;\n    },\n    /**\n   * Computes the dot product of `other` with `this` point.\n   * The dot product is the sum of the products of the corresponding components of two vectors.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method dot\n   * @memberof maths.Point#\n   * @param {maths.PointData} other - The other point to calculate the dot product with `this`.\n   * @returns {number} The result of the dot product. This is an scalar value.\n   */ /**\n   * Computes the dot product of `other` with `this` point.\n   * The dot product is the sum of the products of the corresponding components of two vectors.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method dot\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} other - The other point to calculate the dot product with `this`.\n   * @returns {number} The result of the dot product. This is an scalar value.\n   */ dot (other) {\n        return this.x * other.x + this.y * other.y;\n    },\n    /**\n   * Computes the cross product of `other` with `this` point.\n   * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n   * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n   * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n   * the result becomes a vector that will only have magnitude on the z axis.\n   *\n   * This function returns the z component of the cross product of the two points.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method cross\n   * @memberof maths.Point#\n   * @param {maths.PointData} other - The other point to calculate the cross product with `this`.\n   * @returns {number} The z component of the result of the cross product.\n   */ /**\n   * Computes the cross product of `other` with `this` point.\n   * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n   * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n   * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n   * the result becomes a vector that will only have magnitude on the z axis.\n   *\n   * This function returns the z component of the cross product of the two points.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method cross\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} other - The other point to calculate the cross product with `this`.\n   * @returns {number} The z component of the result of the cross product.\n   */ cross (other) {\n        return this.x * other.y - this.y * other.x;\n    },\n    /**\n   * Computes a normalized version of `this` point.\n   *\n   * A normalized vector is a vector of magnitude (length) 1\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method normalize\n   * @memberof maths.Point#\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The normalized point.\n   */ /**\n   * Computes a normalized version of `this` point.\n   *\n   * A normalized vector is a vector of magnitude (length) 1\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method normalize\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The normalized point.\n   */ normalize (outPoint) {\n        if (!outPoint) outPoint = new (0, $1HooC.Point)();\n        const magnitude = Math.sqrt(this.x * this.x + this.y * this.y);\n        outPoint.x = this.x / magnitude;\n        outPoint.y = this.y / magnitude;\n        return outPoint;\n    },\n    /**\n   * Computes the magnitude of this point (Euclidean distance from 0, 0).\n   *\n   * Defined as the square root of the sum of the squares of each component.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method magnitude\n   * @memberof maths.Point#\n   * @returns {number} The magnitude (length) of the vector.\n   */ /**\n   * Computes the magnitude of this point (Euclidean distance from 0, 0).\n   *\n   * Defined as the square root of the sum of the squares of each component.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method magnitude\n   * @memberof maths.ObservablePoint#\n   * @returns {number} The magnitude (length) of the vector.\n   */ magnitude () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n    /**\n   * Computes the square magnitude of this point.\n   * If you are comparing the lengths of vectors, you should compare the length squared instead\n   * as it is slightly more efficient to calculate.\n   *\n   * Defined as the sum of the squares of each component.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method magnitudeSquared\n   * @memberof maths.Point#\n   * @returns {number} The magnitude squared (length squared) of the vector.\n   */ /**\n   * Computes the square magnitude of this point.\n   * If you are comparing the lengths of vectors, you should compare the length squared instead\n   * as it is slightly more efficient to calculate.\n   *\n   * Defined as the sum of the squares of each component.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method magnitudeSquared\n   * @memberof maths.ObservablePoint#\n   * @returns {number} The magnitude squared (length squared) of the vector.\n   */ magnitudeSquared () {\n        return this.x * this.x + this.y * this.y;\n    },\n    /**\n   * Computes vector projection of `this` on `onto`.\n   *\n   * Imagine a light source, parallel to `onto`, above `this`.\n   * The light would cast rays perpendicular to `onto`.\n   * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method project\n   * @memberof maths.Point#\n   * @param {maths.PointData} onto - A non zero vector describing a line on which to project `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `this` on `onto` projection.\n   */ /**\n   * Computes vector projection of `this` on `onto`.\n   *\n   * Imagine a light source, parallel to `onto`, above `this`.\n   * The light would cast rays perpendicular to `onto`.\n   * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method project\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} onto - A non zero vector describing a line on which to project `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `this` on `onto` projection.\n   */ project (onto, outPoint) {\n        if (!outPoint) outPoint = new (0, $1HooC.Point)();\n        const normalizedScalarProjection = (this.x * onto.x + this.y * onto.y) / (onto.x * onto.x + onto.y * onto.y);\n        outPoint.x = onto.x * normalizedScalarProjection;\n        outPoint.y = onto.y * normalizedScalarProjection;\n        return outPoint;\n    },\n    /**\n   * Reflects `this` vector off of a plane orthogonal to `normal`.\n   * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n   *\n   * Imagine a light source bouncing onto a mirror.\n   * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n   * `this.reflect(normal)` is the reflection of `this` on that mirror.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method reflect\n   * @memberof maths.Point#\n   * @param {maths.PointData} normal - The normal vector of your reflecting plane.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The reflection of `this` on your reflecting plane.\n   */ /**\n   * Reflects `this` vector off of a plane orthogonal to `normal`.\n   * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n   *\n   * Imagine a light source bouncing onto a mirror.\n   * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n   * `this.reflect(normal)` is the reflection of `this` on that mirror.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method reflect\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} normal - The normal vector of your reflecting plane.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The reflection of `this` on your reflecting plane.\n   */ reflect (normal, outPoint) {\n        if (!outPoint) outPoint = new (0, $1HooC.Point)();\n        const dotProduct = this.x * normal.x + this.y * normal.y;\n        outPoint.x = this.x - 2 * dotProduct * normal.x;\n        outPoint.y = this.y - 2 * dotProduct * normal.y;\n        return outPoint;\n    }\n};\n\n\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\"use strict\";\nconst $15b419f9c76643e1$export$6557277b6e57c16c = {\n    /**\n   * Determines whether the `other` Rectangle is contained within `this` Rectangle object.\n   * Rectangles that occupy the same space are considered to be containing each other.\n   * Rectangles without area (width or height equal to zero) can't contain anything,\n   * not even other arealess rectangles.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method containsRect\n   * @memberof maths.Rectangle#\n   * @param {Rectangle} other - The Rectangle to fit inside `this`.\n   * @returns {boolean} A value of `true` if `this` Rectangle contains `other`; otherwise `false`.\n   */ containsRect (other) {\n        if (other.width <= 0 || other.height <= 0) return other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom;\n        return other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;\n    },\n    /**\n   * Accepts `other` Rectangle and returns true if the given Rectangle is equal to `this` Rectangle.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method equals\n   * @memberof maths.Rectangle#\n   * @param {Rectangle} other - The Rectangle to compare with `this`\n   * @returns {boolean} Returns true if all `x`, `y`, `width`, and `height` are equal.\n   */ equals (other) {\n        if (other === this) return true;\n        return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n    },\n    /**\n   * If the area of the intersection between the Rectangles `other` and `this` is not zero,\n   * returns the area of intersection as a Rectangle object. Otherwise, return an empty Rectangle\n   * with its properties set to zero.\n   * Rectangles without area (width or height equal to zero) can't intersect or be intersected\n   * and will always return an empty rectangle with its properties set to zero.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method intersection\n   * @memberof maths.Rectangle#\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n   * optional (otherwise will create a new Rectangle).\n   * @returns {Rectangle} The intersection of `this` and `other`.\n   */ intersection (other, outRect) {\n        if (!outRect) outRect = new (0, $fM4Mk.Rectangle)();\n        const x0 = this.x < other.x ? other.x : this.x;\n        const x1 = this.right > other.right ? other.right : this.right;\n        if (x1 <= x0) {\n            outRect.x = outRect.y = outRect.width = outRect.height = 0;\n            return outRect;\n        }\n        const y0 = this.y < other.y ? other.y : this.y;\n        const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n        if (y1 <= y0) {\n            outRect.x = outRect.y = outRect.width = outRect.height = 0;\n            return outRect;\n        }\n        outRect.x = x0;\n        outRect.y = y0;\n        outRect.width = x1 - x0;\n        outRect.height = y1 - y0;\n        return outRect;\n    },\n    /**\n   * Adds `this` and `other` Rectangles together to create a new Rectangle object filling\n   * the horizontal and vertical space between the two rectangles.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method union\n   * @memberof maths.Rectangle#\n   * @param {Rectangle} other - The Rectangle to unite with `this`.\n   * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n   * optional (otherwise will create a new Rectangle).\n   * @returns {Rectangle} The union of `this` and `other`.\n   */ union (other, outRect) {\n        if (!outRect) outRect = new (0, $fM4Mk.Rectangle)();\n        const x1 = Math.min(this.x, other.x);\n        const x2 = Math.max(this.x + this.width, other.x + other.width);\n        const y1 = Math.min(this.y, other.y);\n        const y2 = Math.max(this.y + this.height, other.y + other.height);\n        outRect.x = x1;\n        outRect.y = y1;\n        outRect.width = x2 - x1;\n        outRect.height = y2 - y1;\n        return outRect;\n    }\n};\n\n\n\"use strict\";\nObject.assign((0, $1HooC.Point).prototype, (0, $38d513fd875e37ff$export$d7b50392f15c447d));\nObject.assign((0, $a32F4.ObservablePoint).prototype, (0, $38d513fd875e37ff$export$d7b50392f15c447d));\nObject.assign((0, $fM4Mk.Rectangle).prototype, (0, $15b419f9c76643e1$export$6557277b6e57c16c));\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\n\nconst $c220e1d99a2da004$export$a6aad6334ef58a1c = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).Environment,\n        name: \"browser\",\n        priority: -1\n    },\n    test: ()=>true,\n    load: async ()=>{\n        await (parcelRequire(\"dLk2N\"));\n    }\n};\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\n\nconst $a52ecd5a016ebe0a$export$ee43dd1acddf6cf8 = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).Environment,\n        name: \"webworker\",\n        priority: 0\n    },\n    test: ()=>typeof self !== \"undefined\" && self.WorkerGlobalScope !== void 0,\n    load: async ()=>{\n        await (parcelRequire(\"dwO65\"));\n    }\n};\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\nparcelRequire(\"7dx1H\");\nparcelRequire(\"4RJM2\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\nconst $326e7279631cea1a$var$environments = [];\n(0, $i9BKe.extensions).handleByNamedList((0, $i9BKe.ExtensionType).Environment, $326e7279631cea1a$var$environments);\nasync function $326e7279631cea1a$export$72225172dd907279(manageImports) {\n    if (!manageImports) return;\n    for(let i = 0; i < $326e7279631cea1a$var$environments.length; i++){\n        const env = $326e7279631cea1a$var$environments[i];\n        if (env.value.test()) {\n            await env.value.load();\n            return;\n        }\n    }\n}\n\n\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $3UUq4 = parcelRequire(\"3UUq4\");\n\"use strict\";\nlet $21de405eafa0c0bb$var$_isWebGLSupported;\nfunction $21de405eafa0c0bb$export$83dc396b76015322(failIfMajorPerformanceCaveat) {\n    if ($21de405eafa0c0bb$var$_isWebGLSupported !== void 0) return $21de405eafa0c0bb$var$_isWebGLSupported;\n    $21de405eafa0c0bb$var$_isWebGLSupported = (()=>{\n        const contextOptions = {\n            stencil: true,\n            failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? (0, $3UUq4.AbstractRenderer).defaultOptions.failIfMajorPerformanceCaveat\n        };\n        try {\n            if (!(0, $iCGeI.DOMAdapter).get().getWebGLRenderingContext()) return false;\n            const canvas = (0, $iCGeI.DOMAdapter).get().createCanvas();\n            let gl = canvas.getContext(\"webgl\", contextOptions);\n            const success = !!gl?.getContextAttributes()?.stencil;\n            if (gl) {\n                const loseContext = gl.getExtension(\"WEBGL_lose_context\");\n                if (loseContext) loseContext.loseContext();\n            }\n            gl = null;\n            return success;\n        } catch (e) {\n            return false;\n        }\n    })();\n    return $21de405eafa0c0bb$var$_isWebGLSupported;\n}\n\n\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\"use strict\";\nlet $7cb4832c2de4c977$var$_isWebGPUSupported;\nasync function $7cb4832c2de4c977$export$216169f30082c873(options = {}) {\n    if ($7cb4832c2de4c977$var$_isWebGPUSupported !== void 0) return $7cb4832c2de4c977$var$_isWebGPUSupported;\n    $7cb4832c2de4c977$var$_isWebGPUSupported = await (async ()=>{\n        const gpu = (0, $iCGeI.DOMAdapter).get().getNavigator().gpu;\n        if (!gpu) return false;\n        try {\n            const adapter = await navigator.gpu.requestAdapter(options);\n            await adapter.requestDevice();\n            return true;\n        } catch (e) {\n            return false;\n        }\n    })();\n    return $7cb4832c2de4c977$var$_isWebGPUSupported;\n}\n\n\n\nvar $3UUq4 = parcelRequire(\"3UUq4\");\n\"use strict\";\nconst $bf7ca24d384e2f55$var$renderPriority = [\n    \"webgl\",\n    \"webgpu\",\n    \"canvas\"\n];\n\n\nasync function $bf7ca24d384e2f55$export$3583b92ab8150eb6(options) {\n    let preferredOrder = [];\n    if (options.preference) {\n        preferredOrder.push(options.preference);\n        $bf7ca24d384e2f55$var$renderPriority.forEach((item)=>{\n            if (item !== options.preference) preferredOrder.push(item);\n        });\n    } else preferredOrder = $bf7ca24d384e2f55$var$renderPriority.slice();\n    let RendererClass;\n    await (0, $326e7279631cea1a$export$72225172dd907279)(options.manageImports ?? true);\n    let finalOptions = {};\n    for(let i = 0; i < preferredOrder.length; i++){\n        const rendererType = preferredOrder[i];\n        if (rendererType === \"webgpu\" && await (0, $7cb4832c2de4c977$export$216169f30082c873)()) {\n            const { WebGPURenderer: WebGPURenderer } = await (parcelRequire(\"2OFKu\"));\n            RendererClass = WebGPURenderer;\n            finalOptions = {\n                ...options,\n                ...options.webgpu\n            };\n            break;\n        } else if (rendererType === \"webgl\" && (0, $21de405eafa0c0bb$export$83dc396b76015322)(options.failIfMajorPerformanceCaveat ?? (0, $3UUq4.AbstractRenderer).defaultOptions.failIfMajorPerformanceCaveat)) {\n            const { WebGLRenderer: WebGLRenderer } = await (parcelRequire(\"dcZu1\"));\n            RendererClass = WebGLRenderer;\n            finalOptions = {\n                ...options,\n                ...options.webgl\n            };\n            break;\n        } else if (rendererType === \"canvas\") {\n            finalOptions = {\n                ...options\n            };\n            break;\n        }\n    }\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n    const renderer = new RendererClass();\n    await renderer.init(finalOptions);\n    return renderer;\n}\n\n\n\nvar $eicwU = parcelRequire(\"eicwU\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\"use strict\";\nconst $2202931bfc9ee5c9$var$_Application = class _Application {\n    /** @ignore */ constructor(...args){\n        /** The root display container that's rendered. */ this.stage = new (0, $eicwU.Container)();\n        if (args[0] !== void 0) (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Application constructor options are deprecated, please use Application.init() instead.\");\n    }\n    /**\n   * @param options - The optional application and renderer parameters.\n   */ async init(options) {\n        options = {\n            ...options\n        };\n        this.renderer = await (0, $bf7ca24d384e2f55$export$3583b92ab8150eb6)(options);\n        _Application._plugins.forEach((plugin)=>{\n            plugin.init.call(this, options);\n        });\n    }\n    /** Render the current stage. */ render() {\n        this.renderer.render({\n            container: this.stage\n        });\n    }\n    /**\n   * Reference to the renderer's canvas element.\n   * @readonly\n   * @member {HTMLCanvasElement}\n   */ get canvas() {\n        return this.renderer.canvas;\n    }\n    /**\n   * Reference to the renderer's canvas element.\n   * @member {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   */ get view() {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"Application.view is deprecated, please use Application.canvas instead.\");\n        return this.renderer.canvas;\n    }\n    /**\n   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @readonly\n   */ get screen() {\n        return this.renderer.screen;\n    }\n    /**\n   * Destroys the application and all of its resources.\n   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n   * @param {object|boolean} [options=false] - The options for destroying the stage.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n   * called as well. `options` will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true,\n   * it should destroy the texture of the child sprite.\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   *  If options.children is set to true,\n   * it should destroy the texture source of the child sprite.\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true,\n   * it should destroy the context of the child graphics.\n   */ destroy(rendererDestroyOptions = false, options = false) {\n        const plugins = _Application._plugins.slice(0);\n        plugins.reverse();\n        plugins.forEach((plugin)=>{\n            plugin.destroy.call(this);\n        });\n        this.stage.destroy(options);\n        this.stage = null;\n        this.renderer.destroy(rendererDestroyOptions);\n        this.renderer = null;\n    }\n};\n/**\n * Collection of installed plugins.\n * @alias _plugins\n */ $2202931bfc9ee5c9$var$_Application._plugins = [];\nlet $2202931bfc9ee5c9$export$16975c34e60e1e61 = $2202931bfc9ee5c9$var$_Application;\n(0, $i9BKe.extensions).handleByList((0, $i9BKe.ExtensionType).Application, $2202931bfc9ee5c9$export$16975c34e60e1e61._plugins);\n\n\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\"use strict\";\nclass $1adc37b2cea8de16$export$1949379a83b843d5 {\n    /**\n   * @param loader\n   * @param verbose - should the loader log to the console\n   */ constructor(loader, verbose = false){\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n    /**\n   * Adds an array of assets to load.\n   * @param assetUrls - assets to load\n   */ add(assetUrls) {\n        assetUrls.forEach((a)=>{\n            this._assetList.push(a);\n        });\n        if (this.verbose) console.log(\"[BackgroundLoader] assets: \", this._assetList);\n        if (this._isActive && !this._isLoading) this._next();\n    }\n    /**\n   * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n   *\n   * The max assets it will try to load at one time will be 4.\n   */ async _next() {\n        if (this._assetList.length && this._isActive) {\n            this._isLoading = true;\n            const toLoad = [];\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n            for(let i = 0; i < toLoadAmount; i++)toLoad.push(this._assetList.pop());\n            await this._loader.load(toLoad);\n            this._isLoading = false;\n            this._next();\n        }\n    }\n    /**\n   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n   * @returns whether the class is active\n   */ get active() {\n        return this._isActive;\n    }\n    set active(value) {\n        if (this._isActive === value) return;\n        this._isActive = value;\n        if (value && !this._isLoading) this._next();\n    }\n}\n\n\n\nvar $2IhKp = parcelRequire(\"2IhKp\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\"use strict\";\nconst $df4c0fb70a898168$export$407b4625a915919d = {\n    extension: (0, $i9BKe.ExtensionType).CacheParser,\n    test: (asset)=>Array.isArray(asset) && asset.every((t)=>t instanceof (0, $bLlTJ.Texture)),\n    getCacheableAssets: (keys, asset)=>{\n        const out = {};\n        keys.forEach((key)=>{\n            asset.forEach((item, i)=>{\n                out[key + (i === 0 ? \"\" : i + 1)] = item;\n            });\n        });\n        return out;\n    }\n};\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\nasync function $36c6a70b0c6633f6$export$7c459e568e7cea2c(imageData) {\n    if (\"Image\" in globalThis) return new Promise((resolve)=>{\n        const image = new Image();\n        image.onload = ()=>{\n            resolve(true);\n        };\n        image.onerror = ()=>{\n            resolve(false);\n        };\n        image.src = imageData;\n    });\n    if (\"createImageBitmap\" in globalThis && \"fetch\" in globalThis) {\n        try {\n            const blob = await (await fetch(imageData)).blob();\n            await createImageBitmap(blob);\n        } catch (e) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n\n\n\"use strict\";\nconst $ca5df6e874c0bc98$export$a60d2d4a3c570783 = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).DetectionParser,\n        priority: 1\n    },\n    test: async ()=>(0, $36c6a70b0c6633f6$export$7c459e568e7cea2c)(// eslint-disable-next-line max-len\n        \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=\"),\n    add: async (formats)=>[\n            ...formats,\n            \"avif\"\n        ],\n    remove: async (formats)=>formats.filter((f)=>f !== \"avif\")\n};\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\nconst $c65eb9bc0713cb5d$var$imageFormats = [\n    \"png\",\n    \"jpg\",\n    \"jpeg\"\n];\nconst $c65eb9bc0713cb5d$export$b106d7c2de3b4d89 = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).DetectionParser,\n        priority: -1\n    },\n    test: ()=>Promise.resolve(true),\n    add: async (formats)=>[\n            ...formats,\n            ...$c65eb9bc0713cb5d$var$imageFormats\n        ],\n    remove: async (formats)=>formats.filter((f)=>!$c65eb9bc0713cb5d$var$imageFormats.includes(f))\n};\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\nconst $2ba590fe27c747f9$var$inWorker = \"WorkerGlobalScope\" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;\nfunction $2ba590fe27c747f9$export$7a571c147b03abb1(mimeType) {\n    if ($2ba590fe27c747f9$var$inWorker) return false;\n    const video = document.createElement(\"video\");\n    return video.canPlayType(mimeType) !== \"\";\n}\n\n\n\"use strict\";\nconst $8c93018bb9bae76f$export$7726d83fee274e25 = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).DetectionParser,\n        priority: 0\n    },\n    test: async ()=>(0, $2ba590fe27c747f9$export$7a571c147b03abb1)(\"video/mp4\"),\n    add: async (formats)=>[\n            ...formats,\n            \"mp4\",\n            \"m4v\"\n        ],\n    remove: async (formats)=>formats.filter((f)=>f !== \"mp4\" && f !== \"m4v\")\n};\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\n\"use strict\";\nconst $dfa8be665f85221f$export$5a1da481121f806a = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).DetectionParser,\n        priority: 0\n    },\n    test: async ()=>(0, $2ba590fe27c747f9$export$7a571c147b03abb1)(\"video/ogg\"),\n    add: async (formats)=>[\n            ...formats,\n            \"ogv\"\n        ],\n    remove: async (formats)=>formats.filter((f)=>f !== \"ogv\")\n};\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\n\"use strict\";\nconst $64abecc9a39a8c54$export$a041d698a1896657 = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).DetectionParser,\n        priority: 0\n    },\n    test: async ()=>(0, $2ba590fe27c747f9$export$7a571c147b03abb1)(\"video/webm\"),\n    add: async (formats)=>[\n            ...formats,\n            \"webm\"\n        ],\n    remove: async (formats)=>formats.filter((f)=>f !== \"webm\")\n};\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\n\"use strict\";\nconst $c494cf4c5ea6913a$export$d19529a9ed9823d4 = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).DetectionParser,\n        priority: 0\n    },\n    test: async ()=>(0, $36c6a70b0c6633f6$export$7c459e568e7cea2c)(\"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=\"),\n    add: async (formats)=>[\n            ...formats,\n            \"webp\"\n        ],\n    remove: async (formats)=>formats.filter((f)=>f !== \"webp\")\n};\n\n\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $lzfZe = parcelRequire(\"lzfZe\");\n\nvar $3CHiv = parcelRequire(\"3CHiv\");\n\nvar $4DmkB = parcelRequire(\"4DmkB\");\n\"use strict\";\nclass $be4c9d6031b69343$export$3b0d6d7590275603 {\n    constructor(){\n        this._parsers = [];\n        this._parsersValidated = false;\n        /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */ this.parsers = new Proxy(this._parsers, {\n            set: (target, key, value)=>{\n                this._parsersValidated = false;\n                target[key] = value;\n                return true;\n            }\n        });\n        /** Cache loading promises that ae currently active */ this.promiseCache = {};\n    }\n    /** function used for testing */ reset() {\n        this._parsersValidated = false;\n        this.promiseCache = {};\n    }\n    /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */ _getLoadPromiseAndParser(url, data) {\n        const result = {\n            promise: null,\n            parser: null\n        };\n        result.promise = (async ()=>{\n            let asset = null;\n            let parser = null;\n            if (data.loadParser) {\n                parser = this._parserHash[data.loadParser];\n                if (!parser) (0, $hUCK4.warn)(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n            }\n            if (!parser) {\n                for(let i = 0; i < this.parsers.length; i++){\n                    const parserX = this.parsers[i];\n                    if (parserX.load && parserX.test?.(url, data, this)) {\n                        parser = parserX;\n                        break;\n                    }\n                }\n                if (!parser) {\n                    (0, $hUCK4.warn)(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n                    return null;\n                }\n            }\n            asset = await parser.load(url, data, this);\n            result.parser = parser;\n            for(let i = 0; i < this.parsers.length; i++){\n                const parser2 = this.parsers[i];\n                if (parser2.parse) {\n                    if (parser2.parse && await parser2.testParse?.(asset, data, this)) {\n                        asset = await parser2.parse(asset, data, this) || asset;\n                        result.parser = parser2;\n                    }\n                }\n            }\n            return asset;\n        })();\n        return result;\n    }\n    async load(assetsToLoadIn, onProgress) {\n        if (!this._parsersValidated) this._validateParsers();\n        let count = 0;\n        const assets = {};\n        const singleAsset = (0, $4DmkB.isSingleItem)(assetsToLoadIn);\n        const assetsToLoad = (0, $3CHiv.convertToList)(assetsToLoadIn, (item)=>({\n                alias: [\n                    item\n                ],\n                src: item\n            }));\n        const total = assetsToLoad.length;\n        const promises = assetsToLoad.map(async (asset)=>{\n            const url = (0, $lzfZe.path).toAbsolute(asset.src);\n            if (!assets[asset.src]) try {\n                if (!this.promiseCache[url]) this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                assets[asset.src] = await this.promiseCache[url].promise;\n                if (onProgress) onProgress(++count / total);\n            } catch (e) {\n                delete this.promiseCache[url];\n                delete assets[asset.src];\n                throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n            }\n        });\n        await Promise.all(promises);\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n    /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load('cool.png');\n   *\n   * await Loader.unload('cool.png');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */ async unload(assetsToUnloadIn) {\n        const assetsToUnload = (0, $3CHiv.convertToList)(assetsToUnloadIn, (item)=>({\n                alias: [\n                    item\n                ],\n                src: item\n            }));\n        const promises = assetsToUnload.map(async (asset)=>{\n            const url = (0, $lzfZe.path).toAbsolute(asset.src);\n            const loadPromise = this.promiseCache[url];\n            if (loadPromise) {\n                const loadedAsset = await loadPromise.promise;\n                delete this.promiseCache[url];\n                await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n            }\n        });\n        await Promise.all(promises);\n    }\n    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */ _validateParsers() {\n        this._parsersValidated = true;\n        this._parserHash = this._parsers.filter((parser)=>parser.name).reduce((hash, parser)=>{\n            if (!parser.name) (0, $hUCK4.warn)(`[Assets] loadParser should have a name`);\n            else if (hash[parser.name]) (0, $hUCK4.warn)(`[Assets] loadParser name conflict \"${parser.name}\"`);\n            return {\n                ...hash,\n                [parser.name]: parser\n            };\n        }, {});\n    }\n}\n\n\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\nfunction $d89e452ad91824ca$export$7ff8b059fb914323(url, mimes) {\n    if (Array.isArray(mimes)) {\n        for (const mime of mimes){\n            if (url.startsWith(`data:${mime}`)) return true;\n        }\n        return false;\n    }\n    return url.startsWith(`data:${mimes}`);\n}\n\n\n\nvar $lzfZe = parcelRequire(\"lzfZe\");\n\"use strict\";\nfunction $8f487e3828a5ee92$export$fd0180357b95b812(url, extension) {\n    const tempURL = url.split(\"?\")[0];\n    const ext = (0, $lzfZe.path).extname(tempURL).toLowerCase();\n    if (Array.isArray(extension)) return extension.includes(ext);\n    return ext === extension;\n}\n\n\n\nvar $iEtN5 = parcelRequire(\"iEtN5\");\n\"use strict\";\nconst $c569a63b2f914437$var$validJSONExtension = \".json\";\nconst $c569a63b2f914437$var$validJSONMIME = \"application/json\";\nconst $c569a63b2f914437$export$e7c8553478f3aac7 = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).LoadParser,\n        priority: (0, $iEtN5.LoaderParserPriority).Low\n    },\n    name: \"loadJson\",\n    test (url) {\n        return (0, $d89e452ad91824ca$export$7ff8b059fb914323)(url, $c569a63b2f914437$var$validJSONMIME) || (0, $8f487e3828a5ee92$export$fd0180357b95b812)(url, $c569a63b2f914437$var$validJSONExtension);\n    },\n    async load (url) {\n        const response = await (0, $iCGeI.DOMAdapter).get().fetch(url);\n        const json = await response.json();\n        return json;\n    }\n};\n\n\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\n\n\nvar $iEtN5 = parcelRequire(\"iEtN5\");\n\"use strict\";\nconst $779da4c964b62347$var$validTXTExtension = \".txt\";\nconst $779da4c964b62347$var$validTXTMIME = \"text/plain\";\nconst $779da4c964b62347$export$3835b7ee6dbebde8 = {\n    name: \"loadTxt\",\n    extension: {\n        type: (0, $i9BKe.ExtensionType).LoadParser,\n        priority: (0, $iEtN5.LoaderParserPriority).Low\n    },\n    test (url) {\n        return (0, $d89e452ad91824ca$export$7ff8b059fb914323)(url, $779da4c964b62347$var$validTXTMIME) || (0, $8f487e3828a5ee92$export$fd0180357b95b812)(url, $779da4c964b62347$var$validTXTExtension);\n    },\n    async load (url) {\n        const response = await (0, $iCGeI.DOMAdapter).get().fetch(url);\n        const txt = await response.text();\n        return txt;\n    }\n};\n\n\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $lzfZe = parcelRequire(\"lzfZe\");\n\nvar $2IhKp = parcelRequire(\"2IhKp\");\n\n\n\nvar $iEtN5 = parcelRequire(\"iEtN5\");\n\"use strict\";\nconst $0568dcd95d86dd78$var$validWeights = [\n    \"normal\",\n    \"bold\",\n    \"100\",\n    \"200\",\n    \"300\",\n    \"400\",\n    \"500\",\n    \"600\",\n    \"700\",\n    \"800\",\n    \"900\"\n];\nconst $0568dcd95d86dd78$var$validFontExtensions = [\n    \".ttf\",\n    \".otf\",\n    \".woff\",\n    \".woff2\"\n];\nconst $0568dcd95d86dd78$var$validFontMIMEs = [\n    \"font/ttf\",\n    \"font/otf\",\n    \"font/woff\",\n    \"font/woff2\"\n];\nconst $0568dcd95d86dd78$var$CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\nfunction $0568dcd95d86dd78$export$c461ca8f39d93d9b(url) {\n    const ext = (0, $lzfZe.path).extname(url);\n    const name = (0, $lzfZe.path).basename(url, ext);\n    const nameWithSpaces = name.replace(/(-|_)/g, \" \");\n    const nameTokens = nameWithSpaces.toLowerCase().split(\" \").map((word)=>word.charAt(0).toUpperCase() + word.slice(1));\n    let valid = nameTokens.length > 0;\n    for (const token of nameTokens)if (!token.match($0568dcd95d86dd78$var$CSS_IDENT_TOKEN_REGEX)) {\n        valid = false;\n        break;\n    }\n    let fontFamilyName = nameTokens.join(\" \");\n    if (!valid) fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, \"\\\\$&\")}\"`;\n    return fontFamilyName;\n}\nconst $0568dcd95d86dd78$var$validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\nfunction $0568dcd95d86dd78$var$encodeURIWhenNeeded(uri) {\n    if ($0568dcd95d86dd78$var$validURICharactersRegex.test(uri)) return uri;\n    return encodeURI(uri);\n}\nconst $0568dcd95d86dd78$export$129ed93ad26b0298 = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).LoadParser,\n        priority: (0, $iEtN5.LoaderParserPriority).Low\n    },\n    name: \"loadWebFont\",\n    test (url) {\n        return (0, $d89e452ad91824ca$export$7ff8b059fb914323)(url, $0568dcd95d86dd78$var$validFontMIMEs) || (0, $8f487e3828a5ee92$export$fd0180357b95b812)(url, $0568dcd95d86dd78$var$validFontExtensions);\n    },\n    async load (url, options) {\n        const fonts = (0, $iCGeI.DOMAdapter).get().getFontFaceSet();\n        if (fonts) {\n            const fontFaces = [];\n            const name = options.data?.family ?? $0568dcd95d86dd78$export$c461ca8f39d93d9b(url);\n            const weights = options.data?.weights?.filter((weight)=>$0568dcd95d86dd78$var$validWeights.includes(weight)) ?? [\n                \"normal\"\n            ];\n            const data = options.data ?? {};\n            for(let i = 0; i < weights.length; i++){\n                const weight = weights[i];\n                const font = new FontFace(name, `url(${$0568dcd95d86dd78$var$encodeURIWhenNeeded(url)})`, {\n                    ...data,\n                    weight: weight\n                });\n                await font.load();\n                fonts.add(font);\n                fontFaces.push(font);\n            }\n            (0, $2IhKp.Cache).set(`${name}-and-url`, {\n                url: url,\n                fontFaces: fontFaces\n            });\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n        (0, $hUCK4.warn)(\"[loadWebFont] FontFace API is not supported. Skipping loading font\");\n        return null;\n    },\n    unload (font) {\n        (Array.isArray(font) ? font : [\n            font\n        ]).forEach((t)=>{\n            (0, $2IhKp.Cache).remove(t.family);\n            (0, $iCGeI.DOMAdapter).get().getFontFaceSet().delete(t);\n        });\n    }\n};\n\n\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $aQPld = parcelRequire(\"aQPld\");\n\nvar $8aC7P = parcelRequire(\"8aC7P\");\n\nvar $8kCsw = parcelRequire(\"8kCsw\");\n\"use strict\";\nfunction $69836a01b04ce50b$export$8695ab2f322d2637(url, defaultValue = 1) {\n    const resolution = (0, $8kCsw.Resolver).RETINA_PREFIX?.exec(url);\n    if (resolution) return parseFloat(resolution[1]);\n    return defaultValue;\n}\n\n\n\n\n\nvar $iEtN5 = parcelRequire(\"iEtN5\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $2IhKp = parcelRequire(\"2IhKp\");\n\"use strict\";\nfunction $703462f38e5d63e3$export$37b981a8c575f415(source, loader, url) {\n    source.label = url;\n    source._sourceOrigin = url;\n    const texture = new (0, $bLlTJ.Texture)({\n        source: source,\n        label: url\n    });\n    const unload = ()=>{\n        delete loader.promiseCache[url];\n        if ((0, $2IhKp.Cache).has(url)) (0, $2IhKp.Cache).remove(url);\n    };\n    texture.source.once(\"destroy\", ()=>{\n        if (loader.promiseCache[url]) {\n            (0, $hUCK4.warn)(\"[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.\");\n            unload();\n        }\n    });\n    texture.once(\"destroy\", ()=>{\n        if (!source.destroyed) {\n            (0, $hUCK4.warn)(\"[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.\");\n            unload();\n        }\n    });\n    return texture;\n}\n\n\n\"use strict\";\nconst $258a91d856307e86$var$validSVGExtension = \".svg\";\nconst $258a91d856307e86$var$validSVGMIME = \"image/svg+xml\";\nconst $258a91d856307e86$export$b6a2e78b63791dfa = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).LoadParser,\n        priority: (0, $iEtN5.LoaderParserPriority).Low\n    },\n    name: \"loadSVG\",\n    config: {\n        crossOrigin: \"anonymous\",\n        parseAsGraphicsContext: false\n    },\n    test (url) {\n        return (0, $d89e452ad91824ca$export$7ff8b059fb914323)(url, $258a91d856307e86$var$validSVGMIME) || (0, $8f487e3828a5ee92$export$fd0180357b95b812)(url, $258a91d856307e86$var$validSVGExtension);\n    },\n    async load (url, asset, loader) {\n        if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) return $258a91d856307e86$var$loadAsGraphics(url);\n        return $258a91d856307e86$var$loadAsTexture(url, asset, loader, this.config.crossOrigin);\n    },\n    unload (asset) {\n        asset.destroy(true);\n    }\n};\nasync function $258a91d856307e86$var$loadAsTexture(url, asset, loader, crossOrigin) {\n    const response = await (0, $iCGeI.DOMAdapter).get().fetch(url);\n    const blob = await response.blob();\n    const blobUrl = URL.createObjectURL(blob);\n    const image = new Image();\n    image.src = blobUrl;\n    image.crossOrigin = crossOrigin;\n    await image.decode();\n    URL.revokeObjectURL(blobUrl);\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    const resolution = asset.data?.resolution || (0, $69836a01b04ce50b$export$8695ab2f322d2637)(url);\n    const width = asset.data?.width ?? image.width;\n    const height = asset.data?.height ?? image.height;\n    canvas.width = width * resolution;\n    canvas.height = height * resolution;\n    context.drawImage(image, 0, 0, width * resolution, height * resolution);\n    const { parseAsGraphicsContext: _p, ...rest } = asset.data;\n    const base = new (0, $aQPld.ImageSource)({\n        resource: canvas,\n        alphaMode: \"premultiply-alpha-on-upload\",\n        resolution: resolution,\n        ...rest\n    });\n    return (0, $703462f38e5d63e3$export$37b981a8c575f415)(base, loader, url);\n}\nasync function $258a91d856307e86$var$loadAsGraphics(url) {\n    const response = await (0, $iCGeI.DOMAdapter).get().fetch(url);\n    const svgSource = await response.text();\n    const context = new (0, $8aC7P.GraphicsContext)();\n    context.svg(svgSource);\n    return context;\n}\n\n\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $aQPld = parcelRequire(\"aQPld\");\n\n\n\nconst $9a21140edc3f77d8$var$WORKER_CODE = '(function () {\\n    \\'use strict\\';\\n\\n    const WHITE_PNG = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\";\\n    async function checkImageBitmap() {\\n      try {\\n        if (typeof createImageBitmap !== \"function\")\\n          return false;\\n        const response = await fetch(WHITE_PNG);\\n        const imageBlob = await response.blob();\\n        const imageBitmap = await createImageBitmap(imageBlob);\\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\\n      } catch (e) {\\n        return false;\\n      }\\n    }\\n    void checkImageBitmap().then((result) => {\\n      self.postMessage(result);\\n    });\\n\\n})();\\n';\nlet $9a21140edc3f77d8$var$WORKER_URL = null;\nclass $9a21140edc3f77d8$export$2e2bcd8739ae039 {\n    constructor(){\n        if (!$9a21140edc3f77d8$var$WORKER_URL) $9a21140edc3f77d8$var$WORKER_URL = URL.createObjectURL(new Blob([\n            $9a21140edc3f77d8$var$WORKER_CODE\n        ], {\n            type: \"application/javascript\"\n        }));\n        this.worker = new Worker($9a21140edc3f77d8$var$WORKER_URL);\n    }\n}\n$9a21140edc3f77d8$export$2e2bcd8739ae039.revokeObjectURL = function revokeObjectURL() {\n    if ($9a21140edc3f77d8$var$WORKER_URL) {\n        URL.revokeObjectURL($9a21140edc3f77d8$var$WORKER_URL);\n        $9a21140edc3f77d8$var$WORKER_URL = null;\n    }\n};\n\n\nconst $361d1ede8b4541ed$var$WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    async function loadImageBitmap(url) {\\n      const response = await fetch(url);\\n      if (!response.ok) {\\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\\n      }\\n      const imageBlob = await response.blob();\\n      const imageBitmap = await createImageBitmap(imageBlob);\\n      return imageBitmap;\\n    }\\n    self.onmessage = async (event) => {\\n      try {\\n        const imageBitmap = await loadImageBitmap(event.data.data[0]);\\n        self.postMessage({\\n          data: imageBitmap,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        }, [imageBitmap]);\\n      } catch (e) {\\n        self.postMessage({\\n          error: e,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        });\\n      }\\n    };\\n\\n})();\\n\";\nlet $361d1ede8b4541ed$var$WORKER_URL = null;\nclass $361d1ede8b4541ed$export$2e2bcd8739ae039 {\n    constructor(){\n        if (!$361d1ede8b4541ed$var$WORKER_URL) $361d1ede8b4541ed$var$WORKER_URL = URL.createObjectURL(new Blob([\n            $361d1ede8b4541ed$var$WORKER_CODE\n        ], {\n            type: \"application/javascript\"\n        }));\n        this.worker = new Worker($361d1ede8b4541ed$var$WORKER_URL);\n    }\n}\n$361d1ede8b4541ed$export$2e2bcd8739ae039.revokeObjectURL = function revokeObjectURL() {\n    if ($361d1ede8b4541ed$var$WORKER_URL) {\n        URL.revokeObjectURL($361d1ede8b4541ed$var$WORKER_URL);\n        $361d1ede8b4541ed$var$WORKER_URL = null;\n    }\n};\n\n\n\"use strict\";\nlet $778464c1601fd395$var$UUID = 0;\nlet $778464c1601fd395$var$MAX_WORKERS;\nclass $778464c1601fd395$var$WorkerManagerClass {\n    constructor(){\n        this._initialized = false;\n        this._createdWorkers = 0;\n        this._workerPool = [];\n        this._queue = [];\n        this._resolveHash = {};\n    }\n    isImageBitmapSupported() {\n        if (this._isImageBitmapSupported !== void 0) return this._isImageBitmapSupported;\n        this._isImageBitmapSupported = new Promise((resolve)=>{\n            const { worker: worker } = new (0, $9a21140edc3f77d8$export$2e2bcd8739ae039)();\n            worker.addEventListener(\"message\", (event)=>{\n                worker.terminate();\n                (0, $9a21140edc3f77d8$export$2e2bcd8739ae039).revokeObjectURL();\n                resolve(event.data);\n            });\n        });\n        return this._isImageBitmapSupported;\n    }\n    loadImageBitmap(src) {\n        return this._run(\"loadImageBitmap\", [\n            src\n        ]);\n    }\n    async _initWorkers() {\n        if (this._initialized) return;\n        this._initialized = true;\n    }\n    _getWorker() {\n        if ($778464c1601fd395$var$MAX_WORKERS === void 0) $778464c1601fd395$var$MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        let worker = this._workerPool.pop();\n        if (!worker && this._createdWorkers < $778464c1601fd395$var$MAX_WORKERS) {\n            this._createdWorkers++;\n            worker = new (0, $361d1ede8b4541ed$export$2e2bcd8739ae039)().worker;\n            worker.addEventListener(\"message\", (event)=>{\n                this._complete(event.data);\n                this._returnWorker(event.target);\n                this._next();\n            });\n        }\n        return worker;\n    }\n    _returnWorker(worker) {\n        this._workerPool.push(worker);\n    }\n    _complete(data) {\n        if (data.error !== void 0) this._resolveHash[data.uuid].reject(data.error);\n        else this._resolveHash[data.uuid].resolve(data.data);\n        this._resolveHash[data.uuid] = null;\n    }\n    async _run(id, args) {\n        await this._initWorkers();\n        const promise = new Promise((resolve, reject)=>{\n            this._queue.push({\n                id: id,\n                arguments: args,\n                resolve: resolve,\n                reject: reject\n            });\n        });\n        this._next();\n        return promise;\n    }\n    _next() {\n        if (!this._queue.length) return;\n        const worker = this._getWorker();\n        if (!worker) return;\n        const toDo = this._queue.pop();\n        const id = toDo.id;\n        this._resolveHash[$778464c1601fd395$var$UUID] = {\n            resolve: toDo.resolve,\n            reject: toDo.reject\n        };\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: $778464c1601fd395$var$UUID++,\n            id: id\n        });\n    }\n}\nconst $778464c1601fd395$export$bcff6015853c67ce = new $778464c1601fd395$var$WorkerManagerClass();\n\n\n\nvar $iEtN5 = parcelRequire(\"iEtN5\");\n\n\"use strict\";\nconst $7390591d087b0cdb$var$validImageExtensions = [\n    \".jpeg\",\n    \".jpg\",\n    \".png\",\n    \".webp\",\n    \".avif\"\n];\nconst $7390591d087b0cdb$var$validImageMIMEs = [\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/webp\",\n    \"image/avif\"\n];\nasync function $7390591d087b0cdb$export$c614e6247302006d(url) {\n    const response = await (0, $iCGeI.DOMAdapter).get().fetch(url);\n    if (!response.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n    const imageBlob = await response.blob();\n    const imageBitmap = await createImageBitmap(imageBlob);\n    return imageBitmap;\n}\nconst $7390591d087b0cdb$export$897b113ee8307cd0 = {\n    name: \"loadTextures\",\n    extension: {\n        type: (0, $i9BKe.ExtensionType).LoadParser,\n        priority: (0, $iEtN5.LoaderParserPriority).High\n    },\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: \"anonymous\"\n    },\n    test (url) {\n        return (0, $d89e452ad91824ca$export$7ff8b059fb914323)(url, $7390591d087b0cdb$var$validImageMIMEs) || (0, $8f487e3828a5ee92$export$fd0180357b95b812)(url, $7390591d087b0cdb$var$validImageExtensions);\n    },\n    async load (url, asset, loader) {\n        let src = null;\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n            if (this.config.preferWorkers && await (0, $778464c1601fd395$export$bcff6015853c67ce).isImageBitmapSupported()) src = await (0, $778464c1601fd395$export$bcff6015853c67ce).loadImageBitmap(url);\n            else src = await $7390591d087b0cdb$export$c614e6247302006d(url);\n        } else src = await new Promise((resolve)=>{\n            src = new Image();\n            src.crossOrigin = this.config.crossOrigin;\n            src.src = url;\n            if (src.complete) resolve(src);\n            else src.onload = ()=>{\n                resolve(src);\n            };\n        });\n        const base = new (0, $aQPld.ImageSource)({\n            resource: src,\n            alphaMode: \"premultiply-alpha-on-upload\",\n            resolution: asset.data?.resolution || (0, $69836a01b04ce50b$export$8695ab2f322d2637)(url),\n            ...asset.data\n        });\n        return (0, $703462f38e5d63e3$export$37b981a8c575f415)(base, loader, url);\n    },\n    unload (texture) {\n        texture.destroy(true);\n    }\n};\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $hNatJ = parcelRequire(\"hNatJ\");\n\nvar $7blVu = parcelRequire(\"7blVu\");\n\n\n\n\n\"use strict\";\nconst $170b999e73028fac$var$validVideoExtensions = [\n    \".mp4\",\n    \".m4v\",\n    \".webm\",\n    \".ogg\",\n    \".ogv\",\n    \".h264\",\n    \".avi\",\n    \".mov\"\n];\nconst $170b999e73028fac$var$validVideoMIMEs = $170b999e73028fac$var$validVideoExtensions.map((ext)=>`video/${ext.substring(1)}`);\nfunction $170b999e73028fac$export$c47cb7c63271266e(element, url, crossorigin) {\n    if (crossorigin === void 0 && !url.startsWith(\"data:\")) element.crossOrigin = $170b999e73028fac$export$292083da55c5b406(url);\n    else if (crossorigin !== false) element.crossOrigin = typeof crossorigin === \"string\" ? crossorigin : \"anonymous\";\n}\nfunction $170b999e73028fac$export$856bfbe81968ff62(element) {\n    return new Promise((resolve, reject)=>{\n        element.addEventListener(\"canplaythrough\", loaded);\n        element.addEventListener(\"error\", error);\n        element.load();\n        function loaded() {\n            cleanup();\n            resolve();\n        }\n        function error(err) {\n            cleanup();\n            reject(err);\n        }\n        function cleanup() {\n            element.removeEventListener(\"canplaythrough\", loaded);\n            element.removeEventListener(\"error\", error);\n        }\n    });\n}\nfunction $170b999e73028fac$export$292083da55c5b406(url, loc = globalThis.location) {\n    if (url.startsWith(\"data:\")) return \"\";\n    loc = loc || globalThis.location;\n    const parsedUrl = new URL(url, document.baseURI);\n    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) return \"anonymous\";\n    return \"\";\n}\nconst $170b999e73028fac$export$68fa0976ba667d63 = {\n    name: \"loadVideo\",\n    extension: {\n        type: (0, $i9BKe.ExtensionType).LoadParser\n    },\n    config: null,\n    test (url) {\n        const isValidDataUrl = (0, $d89e452ad91824ca$export$7ff8b059fb914323)(url, $170b999e73028fac$var$validVideoMIMEs);\n        const isValidExtension = (0, $8f487e3828a5ee92$export$fd0180357b95b812)(url, $170b999e73028fac$var$validVideoExtensions);\n        return isValidDataUrl || isValidExtension;\n    },\n    async load (url, asset, loader) {\n        const options = {\n            ...(0, $hNatJ.VideoSource).defaultOptions,\n            resolution: asset.data?.resolution || (0, $69836a01b04ce50b$export$8695ab2f322d2637)(url),\n            alphaMode: asset.data?.alphaMode || await (0, $7blVu.detectVideoAlphaMode)(),\n            ...asset.data\n        };\n        const videoElement = document.createElement(\"video\");\n        const attributeMap = {\n            preload: options.autoLoad !== false ? \"auto\" : void 0,\n            \"webkit-playsinline\": options.playsinline !== false ? \"\" : void 0,\n            playsinline: options.playsinline !== false ? \"\" : void 0,\n            muted: options.muted === true ? \"\" : void 0,\n            loop: options.loop === true ? \"\" : void 0,\n            autoplay: options.autoPlay !== false ? \"\" : void 0\n        };\n        Object.keys(attributeMap).forEach((key)=>{\n            const value = attributeMap[key];\n            if (value !== void 0) videoElement.setAttribute(key, value);\n        });\n        if (options.muted === true) videoElement.muted = true;\n        $170b999e73028fac$export$c47cb7c63271266e(videoElement, url, options.crossorigin);\n        const sourceElement = document.createElement(\"source\");\n        let mime;\n        if (url.startsWith(\"data:\")) mime = url.slice(5, url.indexOf(\";\"));\n        else if (!url.startsWith(\"blob:\")) {\n            const ext = url.split(\"?\")[0].slice(url.lastIndexOf(\".\") + 1).toLowerCase();\n            mime = (0, $hNatJ.VideoSource).MIME_TYPES[ext] || `video/${ext}`;\n        }\n        sourceElement.src = url;\n        if (mime) sourceElement.type = mime;\n        return new Promise((resolve)=>{\n            const onCanPlay = async ()=>{\n                const base = new (0, $hNatJ.VideoSource)({\n                    ...options,\n                    resource: videoElement\n                });\n                videoElement.removeEventListener(\"canplay\", onCanPlay);\n                if (asset.data.preload) await $170b999e73028fac$export$856bfbe81968ff62(videoElement);\n                resolve((0, $703462f38e5d63e3$export$37b981a8c575f415)(base, loader, url));\n            };\n            videoElement.addEventListener(\"canplay\", onCanPlay);\n            videoElement.appendChild(sourceElement);\n        });\n    },\n    unload (texture) {\n        texture.destroy(true);\n    }\n};\n\n\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $8kCsw = parcelRequire(\"8kCsw\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\n\nvar $8kCsw = parcelRequire(\"8kCsw\");\n\"use strict\";\nconst $f9f0a4a658d5e519$export$cc356fa83de02bea = {\n    extension: (0, $i9BKe.ExtensionType).ResolveParser,\n    test: (0, $7390591d087b0cdb$export$897b113ee8307cd0).test,\n    parse: (value)=>({\n            resolution: parseFloat((0, $8kCsw.Resolver).RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n            format: value.split(\".\").pop(),\n            src: value\n        })\n};\n\n\n\"use strict\";\nconst $7c85897abf6bc2d6$export$2b5cca0b89cb089c = {\n    extension: (0, $i9BKe.ExtensionType).ResolveParser,\n    test: (value)=>(0, $8kCsw.Resolver).RETINA_PREFIX.test(value) && value.endsWith(\".json\"),\n    parse: (0, $f9f0a4a658d5e519$export$cc356fa83de02bea).parse\n};\n\n\n\n\nvar $8kCsw = parcelRequire(\"8kCsw\");\n\nvar $3CHiv = parcelRequire(\"3CHiv\");\n\nvar $4DmkB = parcelRequire(\"4DmkB\");\n\"use strict\";\nclass $f4e4ce59fcdafcd2$export$137d4dd907afac85 {\n    constructor(){\n        this._detections = [];\n        this._initialized = false;\n        this.resolver = new (0, $8kCsw.Resolver)();\n        this.loader = new (0, $be4c9d6031b69343$export$3b0d6d7590275603)();\n        this.cache = (0, $2IhKp.Cache);\n        this._backgroundLoader = new (0, $1adc37b2cea8de16$export$1949379a83b843d5)(this.loader);\n        this._backgroundLoader.active = true;\n        this.reset();\n    }\n    /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Assets manager with\n   */ async init(options = {}) {\n        if (this._initialized) {\n            (0, $hUCK4.warn)(\"[Assets]AssetManager already initialized, did you load before calling this Assets.init()?\");\n            return;\n        }\n        this._initialized = true;\n        if (options.defaultSearchParams) this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        if (options.basePath) this.resolver.basePath = options.basePath;\n        if (options.bundleIdentifier) this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        if (options.manifest) {\n            let manifest = options.manifest;\n            if (typeof manifest === \"string\") manifest = await this.load(manifest);\n            this.resolver.addManifest(manifest);\n        }\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = typeof resolutionPref === \"number\" ? [\n            resolutionPref\n        ] : resolutionPref;\n        const formats = await this._detectFormats({\n            preferredFormats: options.texturePreference?.format,\n            skipDetections: options.skipDetections,\n            detections: this._detections\n        });\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution: resolution\n            }\n        });\n        if (options.preferences) this.setPreferences(options.preferences);\n    }\n    /**\n   * Allows you to specify how to resolve any assets load requests.\n   * There are a few ways to add things here as shown below:\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Simple\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n   * const bunny = await Assets.load('bunnyBooBoo');\n   *\n   * // Multiple keys:\n   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n   *\n   * const bunny = await Assets.load('burger');\n   * const bunny2 = await Assets.load('chicken');\n   *\n   * // passing options to to the object\n   * Assets.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * // Multiple assets\n   *\n   * // The following all do the same thing:\n   *\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});\n   *\n   * Assets.add({\n   *     alias: 'bunnyBooBoo',\n   *     src: [\n   *         'bunny.png',\n   *         'bunny.webp',\n   *    ],\n   * });\n   *\n   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n   * @param assets - the unresolved assets to add to the resolver\n   */ add(assets) {\n        this.resolver.add(assets);\n    }\n    async load(urls, onProgress) {\n        if (!this._initialized) await this.init();\n        const singleAsset = (0, $4DmkB.isSingleItem)(urls);\n        const urlArray = (0, $3CHiv.convertToList)(urls).map((url)=>{\n            if (typeof url !== \"string\") {\n                const aliases = this.resolver.getAlias(url);\n                if (aliases.some((alias)=>!this.resolver.hasKey(alias))) this.add(url);\n                return Array.isArray(aliases) ? aliases[0] : aliases;\n            }\n            if (!this.resolver.hasKey(url)) this.add({\n                alias: url,\n                src: url\n            });\n            return url;\n        });\n        const resolveResults = this.resolver.resolve(urlArray);\n        const out = await this._mapLoadToResolve(resolveResults, onProgress);\n        return singleAsset ? out[urlArray[0]] : out;\n    }\n    /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * Assets.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const assets = await Assets.loadBundle('animals');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */ addBundle(bundleId, assets) {\n        this.resolver.addBundle(bundleId, assets);\n    }\n    /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle('load-screen');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle('game-screen');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */ async loadBundle(bundleIds, onProgress) {\n        if (!this._initialized) await this.init();\n        let singleAsset = false;\n        if (typeof bundleIds === \"string\") {\n            singleAsset = true;\n            bundleIds = [\n                bundleIds\n            ];\n        }\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n        const out = {};\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = ()=>{\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId)=>{\n            const resolveResult = resolveResults[bundleId];\n            total += Object.keys(resolveResult).length;\n            return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2)=>{\n                out[bundleId] = resolveResult2;\n            });\n        });\n        await Promise.all(promises);\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n    /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your inital load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.backgroundLoad('bunny.png');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */ async backgroundLoad(urls) {\n        if (!this._initialized) await this.init();\n        if (typeof urls === \"string\") urls = [\n            urls\n        ];\n        const resolveResults = this.resolver.resolve(urls);\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n    /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: 'load-screen',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle('load-screen');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */ async backgroundLoadBundle(bundleIds) {\n        if (!this._initialized) await this.init();\n        if (typeof bundleIds === \"string\") bundleIds = [\n            bundleIds\n        ];\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n        Object.values(resolveResults).forEach((resolveResult)=>{\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n    /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */ reset() {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n        this._initialized = false;\n    }\n    get(keys) {\n        if (typeof keys === \"string\") return (0, $2IhKp.Cache).get(keys);\n        const assets = {};\n        for(let i = 0; i < keys.length; i++)assets[i] = (0, $2IhKp.Cache).get(keys[i]);\n        return assets;\n    }\n    /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */ async _mapLoadToResolve(resolveResults, onProgress) {\n        const resolveArray = [\n            ...new Set(Object.values(resolveResults))\n        ];\n        this._backgroundLoader.active = false;\n        const loadedAssets = await this.loader.load(resolveArray, onProgress);\n        this._backgroundLoader.active = true;\n        const out = {};\n        resolveArray.forEach((resolveResult)=>{\n            const asset = loadedAssets[resolveResult.src];\n            const keys = [\n                resolveResult.src\n            ];\n            if (resolveResult.alias) keys.push(...resolveResult.alias);\n            keys.forEach((key)=>{\n                out[key] = asset;\n            });\n            (0, $2IhKp.Cache).set(keys, asset);\n        });\n        return out;\n    }\n    /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n   *\n   * await Assets.unload('http://some.url.com/image.png')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload(['thumper', 'chicko']);\n   * @param urls - the urls to unload\n   */ async unload(urls) {\n        if (!this._initialized) await this.init();\n        const urlArray = (0, $3CHiv.convertToList)(urls).map((url)=>typeof url !== \"string\" ? url.src : url);\n        const resolveResults = this.resolver.resolve(urlArray);\n        await this._unloadFromResolved(resolveResults);\n    }\n    /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle({\n   *     'thumper': 'http://some.url.com/thumper.png',\n   * })\n   *\n   * const assets = await Assets.loadBundle('thumper');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle('thumper');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */ async unloadBundle(bundleIds) {\n        if (!this._initialized) await this.init();\n        bundleIds = (0, $3CHiv.convertToList)(bundleIds);\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n        const promises = Object.keys(resolveResults).map((bundleId)=>this._unloadFromResolved(resolveResults[bundleId]));\n        await Promise.all(promises);\n    }\n    async _unloadFromResolved(resolveResult) {\n        const resolveArray = Object.values(resolveResult);\n        resolveArray.forEach((resolveResult2)=>{\n            (0, $2IhKp.Cache).remove(resolveResult2.src);\n        });\n        await this.loader.unload(resolveArray);\n    }\n    /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */ async _detectFormats(options) {\n        let formats = [];\n        if (options.preferredFormats) formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [\n            options.preferredFormats\n        ];\n        for (const detection of options.detections){\n            if (options.skipDetections || await detection.test()) formats = await detection.add(formats);\n            else if (!options.skipDetections) formats = await detection.remove(formats);\n        }\n        formats = formats.filter((format, index)=>formats.indexOf(format) === index);\n        return formats;\n    }\n    /** All the detection parsers currently added to the Assets class. */ get detections() {\n        return this._detections;\n    }\n    /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */ setPreferences(preferences) {\n        this.loader.parsers.forEach((parser)=>{\n            if (!parser.config) return;\n            Object.keys(parser.config).filter((key)=>key in preferences).forEach((key)=>{\n                parser.config[key] = preferences[key];\n            });\n        });\n    }\n}\nconst $f4e4ce59fcdafcd2$export$c8eca95e306f7116 = new $f4e4ce59fcdafcd2$export$137d4dd907afac85();\n(0, $i9BKe.extensions).handleByList((0, $i9BKe.ExtensionType).LoadParser, $f4e4ce59fcdafcd2$export$c8eca95e306f7116.loader.parsers).handleByList((0, $i9BKe.ExtensionType).ResolveParser, $f4e4ce59fcdafcd2$export$c8eca95e306f7116.resolver.parsers).handleByList((0, $i9BKe.ExtensionType).CacheParser, $f4e4ce59fcdafcd2$export$c8eca95e306f7116.cache.parsers).handleByList((0, $i9BKe.ExtensionType).DetectionParser, $f4e4ce59fcdafcd2$export$c8eca95e306f7116.detections);\n(0, $i9BKe.extensions).add((0, $df4c0fb70a898168$export$407b4625a915919d), (0, $c65eb9bc0713cb5d$export$b106d7c2de3b4d89), (0, $ca5df6e874c0bc98$export$a60d2d4a3c570783), (0, $c494cf4c5ea6913a$export$d19529a9ed9823d4), (0, $8c93018bb9bae76f$export$7726d83fee274e25), (0, $dfa8be665f85221f$export$5a1da481121f806a), (0, $64abecc9a39a8c54$export$a041d698a1896657), (0, $c569a63b2f914437$export$e7c8553478f3aac7), (0, $779da4c964b62347$export$3835b7ee6dbebde8), (0, $0568dcd95d86dd78$export$129ed93ad26b0298), (0, $258a91d856307e86$export$b6a2e78b63791dfa), (0, $7390591d087b0cdb$export$897b113ee8307cd0), (0, $170b999e73028fac$export$68fa0976ba667d63), (0, $f9f0a4a658d5e519$export$cc356fa83de02bea), (0, $7c85897abf6bc2d6$export$2b5cca0b89cb089c));\nconst $f4e4ce59fcdafcd2$var$assetKeyMap = {\n    loader: (0, $i9BKe.ExtensionType).LoadParser,\n    resolver: (0, $i9BKe.ExtensionType).ResolveParser,\n    cache: (0, $i9BKe.ExtensionType).CacheParser,\n    detection: (0, $i9BKe.ExtensionType).DetectionParser\n};\n(0, $i9BKe.extensions).handle((0, $i9BKe.ExtensionType).Asset, (extension)=>{\n    const ref = extension.ref;\n    Object.entries($f4e4ce59fcdafcd2$var$assetKeyMap).filter(([key])=>!!ref[key]).forEach(([key, type])=>(0, $i9BKe.extensions).add(Object.assign(ref[key], // Allow the function to optionally define it's own\n        // ExtensionMetadata, the use cases here is priority for LoaderParsers\n        {\n            extension: ref[key].extension ?? type\n        })));\n}, (extension)=>{\n    const ref = extension.ref;\n    Object.keys($f4e4ce59fcdafcd2$var$assetKeyMap).filter((key)=>!!ref[key]).forEach((key)=>(0, $i9BKe.extensions).remove(ref[key]));\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $1HooC = parcelRequire(\"1HooC\");\n\n\n\nvar $hbpIN = parcelRequire(\"hbpIN\");\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\n\n\n\n\n\n\n\n\n\nvar $8QN7n = parcelRequire(\"8QN7n\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $eicwU = parcelRequire(\"eicwU\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $3cebA = parcelRequire(\"3cebA\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\nvar $eicwU = parcelRequire(\"eicwU\");\n\nvar $hIpDK = parcelRequire(\"hIpDK\");\n\"use strict\";\nconst $e9e4a9e44b3c9d74$var$_NineSliceSprite = class _NineSliceSprite extends (0, $eicwU.Container) {\n    /**\n   * @param {scene.NineSliceSpriteOptions|Texture} options - Options to use\n   * @param options.texture - The texture to use on the NineSliceSprite.\n   * @param options.leftWidth - Width of the left vertical bar (A)\n   * @param options.topHeight - Height of the top horizontal bar (C)\n   * @param options.rightWidth - Width of the right vertical bar (B)\n   * @param options.bottomHeight - Height of the bottom horizontal bar (D)\n   * @param options.width - Width of the NineSliceSprite,\n   * setting this will actually modify the vertices and not the UV's of this plane.\n   * @param options.height - Height of the NineSliceSprite,\n   * setting this will actually modify the vertices and not UV's of this plane.\n   */ constructor(options){\n        if (options instanceof (0, $bLlTJ.Texture)) options = {\n            texture: options\n        };\n        const { width: width, height: height, leftWidth: leftWidth, rightWidth: rightWidth, topHeight: topHeight, bottomHeight: bottomHeight, texture: texture, roundPixels: roundPixels, ...rest } = options;\n        super({\n            label: \"NineSliceSprite\",\n            ...rest\n        });\n        this._roundPixels = 0;\n        this.renderPipeId = \"nineSliceSprite\";\n        this.batched = true;\n        this._didSpriteUpdate = true;\n        this.bounds = {\n            minX: 0,\n            minY: 0,\n            maxX: 0,\n            maxY: 0\n        };\n        this._leftWidth = leftWidth ?? texture?.defaultBorders?.left ?? (0, $hIpDK.NineSliceGeometry).defaultOptions.leftWidth;\n        this._topHeight = topHeight ?? texture?.defaultBorders?.top ?? (0, $hIpDK.NineSliceGeometry).defaultOptions.topHeight;\n        this._rightWidth = rightWidth ?? texture?.defaultBorders?.right ?? (0, $hIpDK.NineSliceGeometry).defaultOptions.rightWidth;\n        this._bottomHeight = bottomHeight ?? texture?.defaultBorders?.bottom ?? (0, $hIpDK.NineSliceGeometry).defaultOptions.bottomHeight;\n        this.bounds.maxX = this._width = width ?? texture.width ?? (0, $hIpDK.NineSliceGeometry).defaultOptions.width;\n        this.bounds.maxY = this._height = height ?? texture.height ?? (0, $hIpDK.NineSliceGeometry).defaultOptions.height;\n        this.allowChildren = false;\n        this.texture = texture ?? _NineSliceSprite.defaultOptions.texture;\n        this.roundPixels = roundPixels ?? false;\n    }\n    /** The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */ get width() {\n        return this._width;\n    }\n    set width(value) {\n        this.bounds.maxX = this._width = value;\n        this.onViewUpdate();\n    }\n    /** The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */ get height() {\n        return this._height;\n    }\n    set height(value) {\n        this.bounds.maxY = this._height = value;\n        this.onViewUpdate();\n    }\n    /** The width of the left column (a) of the NineSliceSprite. */ get leftWidth() {\n        return this._leftWidth;\n    }\n    set leftWidth(value) {\n        this._leftWidth = value;\n        this.onViewUpdate();\n    }\n    /** The width of the right column (b) of the NineSliceSprite. */ get topHeight() {\n        return this._topHeight;\n    }\n    set topHeight(value) {\n        this._topHeight = value;\n        this.onViewUpdate();\n    }\n    /** The width of the right column (b) of the NineSliceSprite. */ get rightWidth() {\n        return this._rightWidth;\n    }\n    set rightWidth(value) {\n        this._rightWidth = value;\n        this.onViewUpdate();\n    }\n    /** The width of the right column (b) of the NineSliceSprite. */ get bottomHeight() {\n        return this._bottomHeight;\n    }\n    set bottomHeight(value) {\n        this._bottomHeight = value;\n        this.onViewUpdate();\n    }\n    /** The texture that the NineSliceSprite is using. */ get texture() {\n        return this._texture;\n    }\n    set texture(value) {\n        value || (value = (0, $bLlTJ.Texture).EMPTY);\n        const currentTexture = this._texture;\n        if (currentTexture === value) return;\n        if (currentTexture && currentTexture.dynamic) currentTexture.off(\"update\", this.onViewUpdate, this);\n        if (value.dynamic) value.on(\"update\", this.onViewUpdate, this);\n        this._texture = value;\n        this.onViewUpdate();\n    }\n    /**\n   *  Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */ get roundPixels() {\n        return !!this._roundPixels;\n    }\n    set roundPixels(value) {\n        this._roundPixels = value ? 1 : 0;\n    }\n    /** The original width of the texture */ get originalWidth() {\n        return this._texture.width;\n    }\n    /** The original height of the texture */ get originalHeight() {\n        return this._texture.height;\n    }\n    onViewUpdate() {\n        this._didChangeId += 4096;\n        this._didSpriteUpdate = true;\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n        if (this.renderGroup) this.renderGroup.onChildViewUpdate(this);\n    }\n    /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */ addBounds(bounds) {\n        const _bounds = this.bounds;\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n    /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        const bounds = this.bounds;\n        if (point.x >= bounds.minX && point.x <= bounds.maxX) {\n            if (point.y >= bounds.minY && point.y <= bounds.maxY) return true;\n        }\n        return false;\n    }\n    /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */ destroy(options) {\n        super.destroy(options);\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            this._texture.destroy(destroyTextureSource);\n        }\n        this._texture = null;\n        this.bounds = null;\n    }\n};\n/** The default options, used to override the initial values of any options passed in the constructor. */ $e9e4a9e44b3c9d74$var$_NineSliceSprite.defaultOptions = {\n    /** @default Texture.EMPTY */ texture: (0, $bLlTJ.Texture).EMPTY\n};\nlet $e9e4a9e44b3c9d74$export$ea7c4e309714d712 = $e9e4a9e44b3c9d74$var$_NineSliceSprite;\nclass $e9e4a9e44b3c9d74$export$acdf4cb3f489544e extends $e9e4a9e44b3c9d74$export$ea7c4e309714d712 {\n    constructor(...args){\n        let options = args[0];\n        if (options instanceof (0, $bLlTJ.Texture)) {\n            (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}\");\n            options = {\n                texture: options,\n                leftWidth: args[1],\n                topHeight: args[2],\n                rightWidth: args[3],\n                bottomHeight: args[4]\n            };\n        }\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"NineSlicePlane is deprecated. Use NineSliceSprite instead.\");\n        super(options);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $4rhnu = parcelRequire(\"4rhnu\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $a32F4 = parcelRequire(\"a32F4\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\nvar $7wtv9 = parcelRequire(\"7wtv9\");\n\nvar $eicwU = parcelRequire(\"eicwU\");\n\"use strict\";\nclass $7e36113173fcb92e$export$daf74670712de91 extends (0, $eicwU.Container) {\n    constructor(options, styleClass){\n        const { text: text, resolution: resolution, style: style, anchor: anchor, width: width, height: height, roundPixels: roundPixels, ...rest } = options;\n        super({\n            ...rest\n        });\n        this.batched = true;\n        /**\n     * The resolution / device pixel ratio of the canvas.\n     * @default 1\n     */ this.resolution = null;\n        this._didTextUpdate = true;\n        this._roundPixels = 0;\n        this._bounds = new (0, $7wtv9.Bounds)();\n        this._boundsDirty = true;\n        this._styleClass = styleClass;\n        this.text = text ?? \"\";\n        this.style = style;\n        this.resolution = resolution ?? null;\n        this.allowChildren = false;\n        this._anchor = new (0, $a32F4.ObservablePoint)({\n            _onUpdate: ()=>{\n                this.onViewUpdate();\n            }\n        });\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n        if (width) this.width = width;\n        if (height) this.height = height;\n    }\n    /**\n   * The anchor sets the origin point of the text.\n   * The default is `(0,0)`, this means the text's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Text } from 'pixi.js';\n   *\n   * const text = new Text('hello world');\n   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */ get anchor() {\n        return this._anchor;\n    }\n    set anchor(value) {\n        typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n    /**\n   *  Whether or not to round the x/y position of the text.\n   * @type {boolean}\n   */ get roundPixels() {\n        return !!this._roundPixels;\n    }\n    set roundPixels(value) {\n        this._roundPixels = value ? 1 : 0;\n    }\n    /** Set the copy for the text object. To split a line you can use '\\n'. */ set text(value) {\n        value = value.toString();\n        if (this._text === value) return;\n        this._text = value;\n        this.onViewUpdate();\n    }\n    get text() {\n        return this._text;\n    }\n    get style() {\n        return this._style;\n    }\n    /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n   * @type {\n   * text.TextStyle |\n   * Partial<text.TextStyle> |\n   * text.TextStyleOptions |\n   * text.HTMLTextStyle |\n   * Partial<text.HTMLTextStyle> |\n   * text.HTMLTextStyleOptions\n   * }\n   */ set style(style) {\n        style = style || {};\n        this._style?.off(\"update\", this.onViewUpdate, this);\n        if (style instanceof this._styleClass) this._style = style;\n        else this._style = new this._styleClass(style);\n        this._style.on(\"update\", this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n    /**\n   * The local bounds of the Text.\n   * @type {rendering.Bounds}\n   */ get bounds() {\n        if (this._boundsDirty) {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n        return this._bounds;\n    }\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */ get width() {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n    set width(value) {\n        this._setWidth(value, this.bounds.width);\n    }\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */ get height() {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n    set height(value) {\n        this._setHeight(value, this.bounds.height);\n    }\n    /**\n   * Retrieves the size of the Text as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Text.\n   */ getSize(out) {\n        if (!out) out = {};\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n        return out;\n    }\n    /**\n   * Sets the size of the Text to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */ setSize(value, height) {\n        let convertedWidth;\n        let convertedHeight;\n        if (typeof value !== \"object\") {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        } else {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n        if (convertedWidth !== void 0) this._setWidth(convertedWidth, this.bounds.width);\n        if (convertedHeight !== void 0) this._setHeight(convertedHeight, this.bounds.height);\n    }\n    /**\n   * Adds the bounds of this text to the bounds object.\n   * @param bounds - The output bounds object.\n   */ addBounds(bounds) {\n        const _bounds = this.bounds;\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n    /**\n   * Checks if the text contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        const width = this.bounds.maxX;\n        const height = this.bounds.maxY;\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n        if (point.x >= x1 && point.x <= x1 + width) {\n            y1 = -height * this.anchor.y;\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n        return false;\n    }\n    onViewUpdate() {\n        this._didChangeId += 4096;\n        this._boundsDirty = true;\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n        this._didTextUpdate = true;\n        if (this.renderGroup) this.renderGroup.onChildViewUpdate(this);\n    }\n    _getKey() {\n        return `${this.text}:${this._style.styleKey}`;\n    }\n    /**\n   * Destroys this text renderable and optionally its style texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n   * @param {boolean} [options.style=false] - Should it destroy the style of the text\n   */ destroy(options = false) {\n        super.destroy(options);\n        this.owner = null;\n        this._bounds = null;\n        this._anchor = null;\n        if (typeof options === \"boolean\" ? options : options?.style) this._style.destroy(options);\n        this._style = null;\n        this._text = null;\n    }\n}\nfunction $7e36113173fcb92e$export$1f008a47b72e40d9(args, name) {\n    let options = args[0] ?? {};\n    if (typeof options === \"string\" || args[1]) {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), `use new ${name}({ text: \"hi!\", style }) instead`);\n        options = {\n            text: options,\n            style: args[1]\n        };\n    }\n    return options;\n}\n\n\n\nvar $wLFHs = parcelRequire(\"wLFHs\");\n\nvar $eKNW7 = parcelRequire(\"eKNW7\");\n\"use strict\";\nclass $dd84afd4ef9f1e09$export$5f1af8db9871e1d6 extends (0, $7e36113173fcb92e$export$daf74670712de91) {\n    constructor(...args){\n        const options = (0, $7e36113173fcb92e$export$1f008a47b72e40d9)(args, \"Text\");\n        super(options, (0, $eKNW7.TextStyle));\n        this.renderPipeId = \"text\";\n    }\n    _updateBounds() {\n        const bounds = this._bounds;\n        const padding = this._style.padding;\n        const anchor = this._anchor;\n        const canvasMeasurement = (0, $wLFHs.CanvasTextMetrics).measureText(this._text, this._style);\n        const { width: width, height: height } = canvasMeasurement;\n        bounds.minX = -anchor._x * width - padding;\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = -anchor._y * height - padding;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n\n\n\nvar $eKNW7 = parcelRequire(\"eKNW7\");\n\n\n\n\n\n\n\nvar $4J7WL = parcelRequire(\"4J7WL\");\n\n\n\n\n\n\n\n\n\n\nvar $3vRz3 = parcelRequire(\"3vRz3\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $2jYVZ = parcelRequire(\"2jYVZ\");\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $c220e1d99a2da004$export$a6aad6334ef58a1c), (0, $a52ecd5a016ebe0a$export$ee43dd1acddf6cf8));\n\n\n\nvar $eicwU = parcelRequire(\"eicwU\");\nvar $3cebA = parcelRequire(\"3cebA\");\nvar $4J7WL = parcelRequire(\"4J7WL\");\nconst $99105ae177c29e38$var$CLOCK_PADDING = 16;\nconst $99105ae177c29e38$var$CLOCK_RADIUS = 16;\nclass $99105ae177c29e38$export$6ff07836956a79aa {\n    constructor(app, delegate, /** Uses zero indexing (0 === first week). */ week){\n        this.app = app;\n        this.delegate = delegate;\n        this.week = week;\n        this.lifetime = 10000;\n        this.cumulativeMS = 0;\n        this.succeedOnTimeout = false;\n        this.container = new (0, $eicwU.Container)();\n        this.clock = new (0, $3cebA.Graphics)();\n        this.clock.zIndex = 9999998;\n        this.clockArc = new (0, $3cebA.Graphics)();\n        this.clockArc.zIndex = 9999999;\n        this.clock.fillStyle = \"#f0cfbb\";\n        this.clock.circle($99105ae177c29e38$var$CLOCK_PADDING + $99105ae177c29e38$var$CLOCK_RADIUS, this.app.screen.height - $99105ae177c29e38$var$CLOCK_PADDING - $99105ae177c29e38$var$CLOCK_RADIUS, $99105ae177c29e38$var$CLOCK_RADIUS);\n        this.clock.fill();\n    }\n    async attach() {\n        this.ticker = new (0, $4J7WL.Ticker)();\n        if (this.lifetime !== undefined) {\n            this.ticker.add(()=>void this.onTick());\n            this.app.stage.addChild(this.clock);\n        }\n        this.ticker.start();\n        await this.populateContainer();\n        this.app.stage.addChild(this.container);\n    }\n    detach() {\n        this.ticker?.destroy();\n        this.ticker = null;\n        this.app.stage.removeChild(this.container);\n        if (this.lifetime !== undefined) {\n            this.app.stage.removeChild(this.clock);\n            this.app.stage.removeChild(this.clockArc);\n        }\n    }\n    async populateContainer() {\n        const square = new (0, $3cebA.Graphics)();\n        const x = (this.app.screen.width - 100) * Math.random();\n        const y = (this.app.screen.height - 100) * Math.random();\n        square.rect(x, y, 100, 100);\n        square.fill(0xde3249);\n        square.eventMode = \"static\";\n        square.on(\"pointerdown\", ()=>{\n            square.removeFromParent();\n            this.finishMinigame(true);\n        });\n        this.container.addChild(square);\n    }\n    // It's recommended to not use `this.ticker()` for these final promises.\n    // Create your own.\n    async finishMinigame(passed, pendingPromises) {\n        this.ticker.stop();\n        await pendingPromises;\n        // Show the player they've won or lost.\n        this.delegate.onMinigameEnd(passed);\n    }\n    onTick() {\n        this.cumulativeMS += this.ticker.elapsedMS;\n        this.clockArc.removeFromParent();\n        this.clockArc = new (0, $3cebA.Graphics)();\n        this.clockArc.zIndex = 9999999;\n        const percentage = this.cumulativeMS / this.lifetime;\n        const start = -Math.PI / 2 + percentage * 2 * Math.PI;\n        const x = $99105ae177c29e38$var$CLOCK_PADDING + $99105ae177c29e38$var$CLOCK_RADIUS;\n        const y = this.app.screen.height - $99105ae177c29e38$var$CLOCK_PADDING - $99105ae177c29e38$var$CLOCK_RADIUS;\n        this.clockArc.arc(x, y, $99105ae177c29e38$var$CLOCK_RADIUS - 2, start, -Math.PI / 2);\n        this.clockArc.lineTo(x, y);\n        this.clockArc.fill(\"#A0484C\");\n        this.app.stage.addChild(this.clockArc);\n        if (this.cumulativeMS > this.lifetime) this.delegate.onMinigameEnd(this.succeedOnTimeout);\n    }\n}\n\n\n\nvar $1HooC = parcelRequire(\"1HooC\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\n\nvar $eicwU = parcelRequire(\"eicwU\");\nvar $3cebA = parcelRequire(\"3cebA\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $4rhnu = parcelRequire(\"4rhnu\");\nfunction $eada55855a105cab$export$513f42987b822fd7(view) {\n    if (typeof view === \"string\") return (0, $4rhnu.Sprite).from(view);\n    return view;\n}\nfunction $eada55855a105cab$export$75f80544f8184343(view) {\n    if (typeof view === \"string\") return (0, $4rhnu.Sprite).from(view);\n    return view;\n}\n\n\nvar $64dbf4c474740b9a$var$__defProp = Object.defineProperty;\nvar $64dbf4c474740b9a$var$__defNormalProp = (obj, key, value)=>key in obj ? $64dbf4c474740b9a$var$__defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\nvar $64dbf4c474740b9a$var$__publicField = (obj, key, value)=>{\n    $64dbf4c474740b9a$var$__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass $64dbf4c474740b9a$export$c17561cb55d4db30 extends (0, $eicwU.Container) {\n    /**\n   * Creates a ProgressBar.\n   * @param options - Options.\n   * @param { Sprite | Graphics | string } options.bg - Background of the ProgressBar.\n   * @param { Sprite | Graphics | string } options.fill - Fill of the ProgressBar.\n   * @param { FillPaddings } options.fillPaddings - Fill offsets.\n   * @param { number } options.fillPaddings.top - Fill top offset.\n   * @param { number } options.fillPaddings.right - Fill right offset.\n   * @param { number } options.fillPaddings.bottom - Fill bottom offset.\n   * @param { number } options.fillPaddings.left - Fill left offset.\n   * @param { NineSliceSprite } options.nineSliceSprite - NineSliceSprite values for bg and fill.\n   * @param { Array } options.nineSliceSprite.bg - NineSliceSprite config for bg ([number, number, number, number]).\n   * @param { Array } options.nineSliceSprite.fill - NineSliceSprite config fill ([number, number, number, number]).\n   * @param { number } options.progress - Initial progress value.\n   */ constructor(options){\n        super();\n        $64dbf4c474740b9a$var$__publicField(this, \"bg\");\n        $64dbf4c474740b9a$var$__publicField(this, \"fill\");\n        $64dbf4c474740b9a$var$__publicField(this, \"fillMask\");\n        $64dbf4c474740b9a$var$__publicField(this, \"progressStart\", 0);\n        $64dbf4c474740b9a$var$__publicField(this, \"_progress\", 0);\n        $64dbf4c474740b9a$var$__publicField(this, \"options\");\n        /** Container, that holds all inner views. */ $64dbf4c474740b9a$var$__publicField(this, \"innerView\");\n        /** Container, given as a constructor parameter that is a button view. */ $64dbf4c474740b9a$var$__publicField(this, \"_view\");\n        this.options = options;\n        this.innerView = new (0, $eicwU.Container)();\n        this.addChild(this.innerView);\n        if (options?.bg && options?.fill) this.init(options);\n    }\n    /**\n   * Initialize ProgressBar.\n   * @param root0\n   * @param root0.bg - Background texture.\n   * @param root0.fill - Fill texture.\n   * @param root0.fillPaddings - Fill offset.\n   * @param root0.progress - Initial progress value.\n   */ init({ bg: bg, fill: fill, fillPaddings: fillPaddings, progress: progress }) {\n        this.setBackground(bg);\n        this.setFill(fill, fillPaddings);\n        this.progress = progress;\n    }\n    /**\n   * Set bg.\n   * @param bg\n   */ setBackground(bg) {\n        if (this.bg) this.bg.destroy();\n        if (this.options?.nineSliceSprite) {\n            if (typeof bg === \"string\") this.bg = new (0, $e9e4a9e44b3c9d74$export$ea7c4e309714d712)({\n                texture: (0, $bLlTJ.Texture).from(bg),\n                leftWidth: this.options.nineSliceSprite.bg[0],\n                topHeight: this.options.nineSliceSprite.bg[1],\n                rightWidth: this.options.nineSliceSprite.bg[2],\n                bottomHeight: this.options.nineSliceSprite.bg[3]\n            });\n            else console.warn(\"NineSliceSprite can not be used with views set as Container.\");\n        }\n        if (bg instanceof (0, $3cebA.Graphics)) this.bg = bg;\n        if (!this.bg && (typeof bg === \"string\" || bg instanceof (0, $4rhnu.Sprite))) this.bg = (0, $eada55855a105cab$export$75f80544f8184343)(bg);\n        this.innerView.addChildAt(this.bg, 0);\n    }\n    /**\n   * Set fill.\n   * @param fill\n   * @param fillPadding\n   */ setFill(fill, fillPadding) {\n        if (this.fill) this.fill.destroy();\n        if (this.bg instanceof (0, $4rhnu.Sprite) && fill === this.bg) {\n            console.warn(\"Can not use same Sprite instance for bg and fill.\");\n            return;\n        }\n        if (this.options?.nineSliceSprite) {\n            if (typeof fill === \"string\") this.fill = new (0, $e9e4a9e44b3c9d74$export$ea7c4e309714d712)({\n                texture: (0, $bLlTJ.Texture).from(fill),\n                leftWidth: this.options.nineSliceSprite.fill[0],\n                topHeight: this.options.nineSliceSprite.fill[1],\n                rightWidth: this.options.nineSliceSprite.fill[2],\n                bottomHeight: this.options.nineSliceSprite.fill[3]\n            });\n            else console.warn(\"NineSliceSprite can not be used with views set as Container.\");\n        }\n        if (!this.fill) {\n            if (fill instanceof (0, $3cebA.Graphics)) this.fill = fill;\n            else this.fill = (0, $eada55855a105cab$export$75f80544f8184343)(fill);\n        }\n        this.innerView.addChildAt(this.fill, 1);\n        const offsetX = fillPadding?.left ?? 0;\n        const offsetY = fillPadding?.top ?? 0;\n        this.fill.x = offsetX;\n        this.fill.y = offsetY;\n        if (this.fillMask) {\n            this.fill.mask = null;\n            this.fillMask.destroy();\n        }\n        const leftWidth = this.fill.width / 2;\n        const rightWidth = this.fill.width / 2;\n        const topHeight = this.fill.height / 2;\n        const bottomHeight = this.fill.height / 2;\n        let texture = (0, $bLlTJ.Texture).WHITE;\n        if (this.fill instanceof (0, $4rhnu.Sprite) && this.fill.texture) texture = this.fill.texture;\n        this.fillMask = new (0, $e9e4a9e44b3c9d74$export$ea7c4e309714d712)({\n            texture: texture,\n            leftWidth: leftWidth,\n            topHeight: topHeight,\n            rightWidth: rightWidth,\n            bottomHeight: bottomHeight\n        });\n        this.fillMask.position.copyFrom(this.fill);\n        this.addChild(this.fillMask);\n        this.fill.mask = this.fillMask;\n    }\n    validate(progress) {\n        progress = Math.round(progress);\n        if (progress < 0) return 0;\n        if (progress > 100) return 100;\n        return progress;\n    }\n    /** Set current progress percentage value. */ set progress(progress) {\n        this._progress = this.validate(progress);\n        if (!this.fill) return;\n        if (this.fillMask) {\n            this.fill.mask = null;\n            this.fillMask.width = this.fill.width / 100 * (this._progress - this.progressStart);\n            this.fillMask.x = this.progressStart / 100 * this.fill.width + this.fill.x;\n            this.fillMask.height = this.fill.height;\n            this.fill.mask = this.fillMask;\n        }\n    }\n    /** Return current progress percentage value. */ get progress() {\n        return this._progress;\n    }\n    /**\n   * Sets width of a ProgressBars background and fill.\n   * If nineSliceSprite is set, then width will be set to nineSliceSprite.\n   * If nineSliceSprite is not set, then width will control components width as Container.\n   * @param width - Width value.\n   */ set width(width) {\n        if (this.options?.nineSliceSprite) {\n            if (this.bg) this.bg.width = width;\n            if (this.fill) {\n                const leftPadding = this.options.fillPaddings?.left ?? 0;\n                const rightPadding = this.options.fillPaddings?.right ?? 0;\n                this.fill.width = width - leftPadding - rightPadding;\n                this.fillMask.width = width - leftPadding - rightPadding;\n            }\n            this.progress = this._progress;\n        } else super.width = width;\n    }\n    /** Gets width of a ProgressBar. */ get width() {\n        return super.width;\n    }\n    /**\n   * Sets height of a ProgressBars background and fill.\n   * If nineSliceSprite is set, then height will be set to nineSliceSprite.\n   * If nineSliceSprite is not set, then height will control components height as Container.\n   * @param height - Height value.\n   */ set height(height) {\n        if (this.options?.nineSliceSprite) {\n            if (this.bg) this.bg.height = height;\n            if (this.fill) {\n                const topPadding = this.options.fillPaddings?.top ?? 0;\n                const bottomPadding = this.options.fillPaddings?.bottom ?? 0;\n                this.fill.height = height - topPadding - bottomPadding;\n                this.fillMask.height = height - topPadding - bottomPadding;\n            }\n            this.progress = this._progress;\n        } else super.height = height;\n    }\n    /** Gets height of a ProgressBar. */ get height() {\n        return super.height;\n    }\n}\n\n\n\nvar $6e1e16f555a84269$export$1a264e8727077b82;\n(function(MINIGAME_ASSET_ALIASES) {\n    /* Typing minigame */ MINIGAME_ASSET_ALIASES[\"PHONE_SCREEN\"] = \"phone-screen\";\n    /* Bath minigame */ MINIGAME_ASSET_ALIASES[\"BATH_BG_1\"] = \"bath-bg-1\";\n    MINIGAME_ASSET_ALIASES[\"BATH_DIRT_1\"] = \"bath-dirt-1\";\n    MINIGAME_ASSET_ALIASES[\"BATH_DIRT_2\"] = \"bath-dirt-2\";\n    MINIGAME_ASSET_ALIASES[\"BATH_DIRT_3\"] = \"bath-dirt-3\";\n    MINIGAME_ASSET_ALIASES[\"BATH_DIRT_4\"] = \"bath-dirt-4\";\n    MINIGAME_ASSET_ALIASES[\"BATH_MC_1\"] = \"bath-mc-1\";\n    MINIGAME_ASSET_ALIASES[\"BATH_MC_2\"] = \"bath-mc-2\";\n    MINIGAME_ASSET_ALIASES[\"BATH_MC_3\"] = \"bath-mc-3\";\n    /* Shopping minigame */ MINIGAME_ASSET_ALIASES[\"SHOPPING_BACKGROUND\"] = \"shopping-background\";\n    MINIGAME_ASSET_ALIASES[\"SHOPPING_PHONE\"] = \"shopping-phone\";\n    MINIGAME_ASSET_ALIASES[\"BASKET\"] = \"basket\";\n    MINIGAME_ASSET_ALIASES[\"SECURITY_ON\"] = \"security-on\";\n    MINIGAME_ASSET_ALIASES[\"SECURITY_OFF\"] = \"security-off\";\n    MINIGAME_ASSET_ALIASES[\"TILL\"] = \"till\";\n    /* Checkpoint sprites */ MINIGAME_ASSET_ALIASES[\"CHECKPOINT_1_1\"] = \"check-1-1\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_1_2\"] = \"check-1-2\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_1_3\"] = \"check-1-3\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_1_4\"] = \"check-1-4\";\n    MINIGAME_ASSET_ALIASES[\"ROOMBA\"] = \"roomba\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_2_1\"] = \"check-2-1\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_2_2\"] = \"check-2-2\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_2_3\"] = \"check-2-3\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_2_4\"] = \"check-2-4\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_2_5\"] = \"check-2-5\";\n    MINIGAME_ASSET_ALIASES[\"RABBIT\"] = \"rabbit\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_3_1\"] = \"check-3-1\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_3_2\"] = \"check-3-2\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_3_3\"] = \"check-3-3\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_3_4\"] = \"check-3-4\";\n    MINIGAME_ASSET_ALIASES[\"CHECKPOINT_3_5\"] = \"check-3-5\";\n    MINIGAME_ASSET_ALIASES[\"BAR\"] = \"bar\";\n    /* Common sprites */ MINIGAME_ASSET_ALIASES[\"BANANA\"] = \"banana\";\n    MINIGAME_ASSET_ALIASES[\"MILK\"] = \"milk\";\n    MINIGAME_ASSET_ALIASES[\"PEANUT_BUTTER\"] = \"peanut-butter\";\n    MINIGAME_ASSET_ALIASES[\"PROTEIN\"] = \"protein\";\n    MINIGAME_ASSET_ALIASES[\"STRAWBERRIES\"] = \"strawberries\";\n    MINIGAME_ASSET_ALIASES[\"YOGHURT\"] = \"yoghurt\";\n    MINIGAME_ASSET_ALIASES[\"PROGRESS_BAR\"] = \"progress-bar\";\n    /* Browser game sprites */ MINIGAME_ASSET_ALIASES[\"BLOG_POST_1\"] = \"blog-post-1\";\n    MINIGAME_ASSET_ALIASES[\"BLOG_POST_2\"] = \"blog-post-2\";\n    MINIGAME_ASSET_ALIASES[\"BLOG_POST_3\"] = \"blog-post-3\";\n    MINIGAME_ASSET_ALIASES[\"POPUP_1\"] = \"popup-1\";\n    MINIGAME_ASSET_ALIASES[\"POPUP_2\"] = \"popup-2\";\n    MINIGAME_ASSET_ALIASES[\"POPUP_3\"] = \"popup-3\";\n    MINIGAME_ASSET_ALIASES[\"POPUP_4\"] = \"popup-4\";\n    MINIGAME_ASSET_ALIASES[\"POPUP_5\"] = \"popup-5\";\n    MINIGAME_ASSET_ALIASES[\"LEARNING_PROGRESS_CONTAINER\"] = \"learning-progress-container\";\n    MINIGAME_ASSET_ALIASES[\"PROGRESS\"] = \"progress\";\n    MINIGAME_ASSET_ALIASES[\"BLENDERPROG\"] = \"blenderProgress\";\n    MINIGAME_ASSET_ALIASES[\"BLENDERFILL\"] = \"barFill\";\n    MINIGAME_ASSET_ALIASES[\"BLENDER\"] = \"blender\";\n    MINIGAME_ASSET_ALIASES[\"BALANCE_BG\"] = \"balancebg\";\n    MINIGAME_ASSET_ALIASES[\"BALANCE_C1\"] = \"balancec1\";\n    MINIGAME_ASSET_ALIASES[\"BALANCE_C2\"] = \"balancec2\";\n    MINIGAME_ASSET_ALIASES[\"BALANCE_C3\"] = \"balancec3\";\n})($6e1e16f555a84269$export$1a264e8727077b82 || ($6e1e16f555a84269$export$1a264e8727077b82 = {}));\nconst $6e1e16f555a84269$var$MINIGAME_ASSET_FILENAMES = {\n    [\"phone-screen\"]: $6e1e16f555a84269$var$getAssetPath(\"phonescreen.png\"),\n    [\"shopping-background\"]: $6e1e16f555a84269$var$getAssetPath(\"shopping_background.png\"),\n    [\"shopping-phone\"]: $6e1e16f555a84269$var$getAssetPath(\"shopping_phone.png\"),\n    [\"basket\"]: $6e1e16f555a84269$var$getAssetPath(\"basket.png\"),\n    [\"security-on\"]: $6e1e16f555a84269$var$getAssetPath(\"security_on.png\"),\n    [\"security-off\"]: $6e1e16f555a84269$var$getAssetPath(\"security_off.png\"),\n    [\"till\"]: $6e1e16f555a84269$var$getAssetPath(\"till.png\"),\n    [\"banana\"]: $6e1e16f555a84269$var$getAssetPath(\"banana.png\"),\n    [\"milk\"]: $6e1e16f555a84269$var$getAssetPath(\"milk.png\"),\n    [\"peanut-butter\"]: $6e1e16f555a84269$var$getAssetPath(\"peanutbutter.png\"),\n    [\"protein\"]: $6e1e16f555a84269$var$getAssetPath(\"protein.png\"),\n    [\"strawberries\"]: $6e1e16f555a84269$var$getAssetPath(\"strawberries.png\"),\n    [\"yoghurt\"]: $6e1e16f555a84269$var$getAssetPath(\"yoghurt.png\"),\n    [\"bath-bg-1\"]: $6e1e16f555a84269$var$getAssetPath(\"bath_bg_1.png\"),\n    [\"bath-dirt-1\"]: $6e1e16f555a84269$var$getAssetPath(\"bath_dirt_1.png\"),\n    [\"bath-dirt-2\"]: $6e1e16f555a84269$var$getAssetPath(\"bath_dirt_2.png\"),\n    [\"bath-dirt-3\"]: $6e1e16f555a84269$var$getAssetPath(\"bath_dirt_3.png\"),\n    [\"bath-dirt-4\"]: $6e1e16f555a84269$var$getAssetPath(\"bath_dirt_4.png\"),\n    [\"bath-mc-1\"]: $6e1e16f555a84269$var$getAssetPath(\"bath_mc_1.png\"),\n    [\"bath-mc-2\"]: $6e1e16f555a84269$var$getAssetPath(\"bath_mc_2.png\"),\n    [\"bath-mc-3\"]: $6e1e16f555a84269$var$getAssetPath(\"bath_mc_3.png\"),\n    [\"check-1-1\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check1.1.png\"),\n    [\"check-1-2\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check1.2.png\"),\n    [\"check-1-3\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check1.3.png\"),\n    [\"check-1-4\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check1.4.png\"),\n    [\"roomba\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/roomba.png\"),\n    [\"check-2-1\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check2.1.png\"),\n    [\"check-2-2\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check2.2.png\"),\n    [\"check-2-3\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check2.3.png\"),\n    [\"check-2-4\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check2.4.png\"),\n    [\"check-2-5\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check2.5.png\"),\n    [\"rabbit\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/rabbit-flying.png\"),\n    [\"check-3-1\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check-3.1.png\"),\n    [\"check-3-2\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check-3.2.png\"),\n    [\"check-3-3\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check-3.3.png\"),\n    [\"check-3-4\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check-3.4.png\"),\n    [\"check-3-5\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/check-3.5.png\"),\n    [\"bar\"]: $6e1e16f555a84269$var$getAssetPath(\"checkpoints/bar.png\"),\n    [\"blog-post-1\"]: $6e1e16f555a84269$var$getAssetPath(\"blog_post_1.png\"),\n    [\"blog-post-2\"]: $6e1e16f555a84269$var$getAssetPath(\"blog_post_2.png\"),\n    [\"blog-post-3\"]: $6e1e16f555a84269$var$getAssetPath(\"blog_post_3.png\"),\n    [\"popup-1\"]: $6e1e16f555a84269$var$getAssetPath(\"popup_1.png\"),\n    [\"popup-2\"]: $6e1e16f555a84269$var$getAssetPath(\"popup_2.png\"),\n    [\"popup-3\"]: $6e1e16f555a84269$var$getAssetPath(\"popup_3.png\"),\n    [\"popup-4\"]: $6e1e16f555a84269$var$getAssetPath(\"popup_4.png\"),\n    [\"popup-5\"]: $6e1e16f555a84269$var$getAssetPath(\"popup_5.png\"),\n    [\"learning-progress-container\"]: $6e1e16f555a84269$var$getAssetPath(\"progress_learning.png\"),\n    [\"progress-bar\"]: $6e1e16f555a84269$var$getAssetPath(\"progress_bar.png\"),\n    [\"progress\"]: $6e1e16f555a84269$var$getAssetPath(\"progress.png\"),\n    [\"blenderProgress\"]: $6e1e16f555a84269$var$getAssetPath(\"progress_blender.png\"),\n    [\"barFill\"]: $6e1e16f555a84269$var$getAssetPath(\"progress_bar.png\"),\n    [\"blender\"]: $6e1e16f555a84269$var$getAssetPath(\"blender.png\"),\n    [\"balancebg\"]: $6e1e16f555a84269$var$getAssetPath(\"balance_background.png\"),\n    [\"balancec1\"]: $6e1e16f555a84269$var$getAssetPath(\"balance_character-1.png\")\n};\nfunction $6e1e16f555a84269$var$getAssetPath(filename) {\n    return `./assets/sprites/minigames/${filename}`;\n}\nfunction $6e1e16f555a84269$export$8deeb594a331b243() {\n    const aliases = Object.keys($6e1e16f555a84269$var$MINIGAME_ASSET_FILENAMES);\n    aliases.forEach((alias)=>{\n        (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).add({\n            alias: alias,\n            src: $6e1e16f555a84269$var$MINIGAME_ASSET_FILENAMES[alias]\n        });\n    });\n    (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).backgroundLoad(aliases);\n}\n\n\n\nconst $fa9ef9bbaee2fee2$var$POPUP_ASSETS = [\n    (0, $6e1e16f555a84269$export$1a264e8727077b82).POPUP_1,\n    (0, $6e1e16f555a84269$export$1a264e8727077b82).POPUP_2,\n    (0, $6e1e16f555a84269$export$1a264e8727077b82).POPUP_3,\n    (0, $6e1e16f555a84269$export$1a264e8727077b82).POPUP_4,\n    (0, $6e1e16f555a84269$export$1a264e8727077b82).POPUP_5\n];\nclass $fa9ef9bbaee2fee2$export$6a635c9f58e69db2 extends (0, $99105ae177c29e38$export$6ff07836956a79aa) {\n    async addPopup() {\n        const popupAssetId = $fa9ef9bbaee2fee2$var$POPUP_ASSETS[Math.floor($fa9ef9bbaee2fee2$var$POPUP_ASSETS.length * Math.random())];\n        const square = new (0, $4rhnu.Sprite)(await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load(popupAssetId));\n        square.label = String(this.spawnedPopups++);\n        const { screen: screen } = this.app;\n        const aspectRatio = square.height / square.width;\n        square.width = screen.width * 0.3;\n        square.height = square.width * aspectRatio;\n        square.anchor = 0.5;\n        const x = screen.width * 0.2 + Math.random() * (screen.width * 0.6);\n        const y = screen.height * 0.2 + Math.random() * (screen.height * 0.6);\n        square.position = new (0, $1HooC.Point)(x, y);\n        this.velocityInfo[square.label] = new (0, $1HooC.Point)(0, 0);\n        square.eventMode = \"static\";\n        square.cursor = \"pointer\";\n        square.on(\"pointerdown\", ()=>this.onDragStart(square));\n        const checkSquarePos = ()=>{\n            const squarePos = square.getGlobalPosition();\n            if (squarePos.x < 0 || squarePos.x > this.app.screen.width || squarePos.y < 0 || squarePos.y > this.app.screen.height) {\n                this.popupsOnScreen--;\n                // Clean up ticker.\n                const tickerCallbacks = this.tickerCallbacks[square.label];\n                if (tickerCallbacks) tickerCallbacks.forEach((callback)=>{\n                    this.app.ticker.remove(callback);\n                });\n                square.removeFromParent();\n            }\n        };\n        const handleSquarePhysics = (time)=>this.handlePhysics(time, square);\n        this.app.ticker.add(checkSquarePos);\n        this.app.ticker.add(handleSquarePhysics);\n        this.tickerCallbacks[square.label] = [\n            checkSquarePos,\n            handleSquarePhysics\n        ];\n        this.popupsOnScreen++;\n        this.container.addChild(square);\n    }\n    async populateContainer() {\n        const bgAsset = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load([\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).BLOG_POST_1,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).BLOG_POST_2,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).BLOG_POST_3\n        ][this.week]);\n        const bg = new (0, $4rhnu.Sprite)(bgAsset);\n        bg.width = this.app.screen.width;\n        bg.height = this.app.screen.height;\n        bg.zIndex = -1;\n        this.container.addChild(bg);\n        const progressBar = new (0, $64dbf4c474740b9a$export$c17561cb55d4db30)({\n            bg: new (0, $4rhnu.Sprite)(await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).LEARNING_PROGRESS_CONTAINER)),\n            fill: new (0, $4rhnu.Sprite)(await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).PROGRESS_BAR)),\n            progress: 0,\n            fillPaddings: {\n                top: 75,\n                bottom: 0,\n                right: 0,\n                left: 228\n            }\n        });\n        const aspectRatio = progressBar.width / progressBar.height;\n        progressBar.height = 48;\n        progressBar.width = aspectRatio * 48;\n        progressBar.x = 16;\n        progressBar.y = 16;\n        this.container.addChild(progressBar);\n        for(let i = 0; i < 3 + this.week; i++)this.addPopup();\n        this.container.eventMode = \"static\";\n        this.container.hitArea = this.app.screen;\n        this.container.on(\"pointerup\", ()=>this.onDragEnd());\n        this.container.on(\"pointerupoutside\", ()=>this.onDragEnd());\n        this.ticker.add((ticker)=>void this.processPopups(ticker, progressBar));\n    }\n    async processPopups(ticker, progressBar) {\n        if (this.popupsOnScreen < 1) this.learningTime += ticker.deltaMS;\n        this.timeToNextPopup -= ticker.deltaMS;\n        const goal = this.lifetime * 0.3;\n        const minTime = [\n            1000,\n            700,\n            500\n        ][this.week];\n        if (this.learningTime > goal) {\n            this.finishMinigame(true);\n            return;\n        }\n        progressBar.progress = this.learningTime / goal * 100;\n        if (this.timeToNextPopup <= 0) {\n            await this.addPopup();\n            this.timeToNextPopup = minTime + Math.random() * 2000;\n        }\n    }\n    handlePhysics(time, object) {\n        if (this.dragTarget === object) return;\n        const vel = this.velocityInfo[object.label];\n        const adjustedVel = vel;\n        adjustedVel.x = vel.x * time.deltaTime;\n        adjustedVel.y = vel.y * time.deltaTime;\n        object.position.add(vel.multiplyScalar(time.deltaTime), object.position);\n    }\n    onDragStart(object) {\n        if (!!this.dragTarget) return;\n        this.velocityInfo[object.label] = new (0, $1HooC.Point)(0, 0);\n        this.dragTarget = object;\n        this.container.on(\"pointermove\", this.dragListener);\n    }\n    onDragEnd() {\n        if (!this.dragTarget) return;\n        this.container.off(\"pointermove\", this.dragListener);\n        this.velocityInfo[this.dragTarget.label] = this.dragTargetVelocity;\n        this.dragTargetVelocity = new (0, $1HooC.Point)(0, 0);\n        this.dragTarget = undefined;\n    }\n    onDragMove(event) {\n        if (!this.dragTarget) return;\n        const previousPos = this.dragTarget.position.clone();\n        this.dragTarget.position = event.getLocalPosition(this.dragTarget.parent);\n        this.dragTargetVelocity = this.dragTarget.position.subtract(previousPos);\n    }\n    constructor(...args){\n        super(...args);\n        this.dragListener = (e)=>void this.onDragMove(e);\n        this.dragTargetVelocity = new (0, $1HooC.Point)(0, 0);\n        this.timeToNextPopup = 0;\n        this.velocityInfo = {};\n        this.tickerCallbacks = {};\n        this.spawnedPopups = 0;\n        this.popupsOnScreen = 0;\n        this.learningTime = 0;\n        this.lifetime = 20000;\n    }\n}\n\n\nvar $ea94ad80bc7b40ba$export$f46b48023fc0dbb0;\nvar $ea94ad80bc7b40ba$export$73571c50d0f2507e;\n/**\n * datastructures-js/trie\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */ var $bff485a8fc680118$export$73571c50d0f2507e;\n/**\n * datastructures-js/trie\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n *\n * @class TrieNode\n */ var $df2d689f8a3c506f$export$f46b48023fc0dbb0;\nclass $df2d689f8a3c506f$var$TrieNode {\n    constructor(char){\n        this._char = char;\n        this._isEndOfWord = false;\n        this._parent = null;\n        this._children = new Map();\n    }\n    /**\n   * @public\n   * @return {boolean}\n   */ isRoot() {\n        return this._char === \"\";\n    }\n    /**\n   * @public\n   * @return {boolean}\n   */ isLeaf() {\n        return this._children.size === 0;\n    }\n    /**\n   * @public\n   * @returns {string}\n   */ getChar() {\n        return this._char;\n    }\n    /**\n   * @internal\n   * @param {TrieNode} parentNode\n   */ setParent(parentNode) {\n        this._parent = parentNode;\n        return this;\n    }\n    /**\n   * @public\n   * @return {TrieNode}\n   */ getParent() {\n        return this._parent;\n    }\n    /**\n   * @internal\n   * @param {boolean} isEndOfWord\n   */ setEndOfWord(isEndOfWord) {\n        this._isEndOfWord = isEndOfWord;\n        return this;\n    }\n    /**\n   * @public\n   * @return {boolean}\n   */ isEndOfWord() {\n        return this._isEndOfWord;\n    }\n    /**\n   * @internal\n   * @param {string} char\n   */ addChild(char) {\n        const childNode = new $df2d689f8a3c506f$var$TrieNode(char);\n        childNode.setParent(this);\n        this._children.set(char, childNode);\n        return this;\n    }\n    /**\n   * @internal\n   * @param {string} char\n   * @return {boolean}\n   */ removeChild(char) {\n        return this._children.delete(char);\n    }\n    /**\n   * @public\n   * @param {string} char\n   * @return {TrieNode}\n   */ getChild(char) {\n        return this._children.get(char) || null;\n    }\n    /**\n   * @public\n   * @param {string} char\n   * @return {boolean}\n   */ hasChild(char) {\n        return this._children.has(char);\n    }\n    /**\n   * @internal\n   * @return {Map}\n   */ children() {\n        return this._children;\n    }\n    /**\n   * @public\n   * @return {number}\n   */ childrenCount() {\n        return this._children.size;\n    }\n}\n$df2d689f8a3c506f$export$f46b48023fc0dbb0 = $df2d689f8a3c506f$var$TrieNode;\n\n\nvar $bff485a8fc680118$require$TrieNode = $df2d689f8a3c506f$export$f46b48023fc0dbb0;\n/**\n * @class Trie\n */ class $bff485a8fc680118$var$Trie {\n    constructor(){\n        this._root = new $bff485a8fc680118$require$TrieNode(\"\");\n        this._wordsCount = 0;\n        this._nodesCount = 1; // root node\n    }\n    /**\n   * Inserts a word into the trie\n   * @public\n   * @param {any} value\n   * @returns {Trie}\n   */ insert(value) {\n        if (value === undefined || value === null) return this;\n        const word = value.toString();\n        let currentNode = this._root;\n        for(let i = 0; i < word.length; i += 1){\n            if (!currentNode.hasChild(word[i])) {\n                currentNode.addChild(word[i]);\n                this._nodesCount += 1;\n            }\n            currentNode = currentNode.getChild(word[i]);\n        }\n        if (!currentNode.isEndOfWord()) {\n            currentNode.setEndOfWord(true);\n            this._wordsCount += 1;\n        }\n        return this;\n    }\n    /**\n   * Checks if a word exists in the trie\n   * @public\n   * @param {any} value\n   * @returns {boolean}\n   */ has(value) {\n        if (value === undefined || value === null) return false;\n        const word = value.toString();\n        let currentNode = this._root;\n        for(let i = 0; i < word.length; i += 1){\n            if (!currentNode.hasChild(word[i])) return false;\n            currentNode = currentNode.getChild(word[i]);\n        }\n        if (!currentNode.isEndOfWord()) return false;\n        return true;\n    }\n    /**\n   * Finds a word in the trie and returns its last char node\n   * @public\n   * @param {any} value\n   * @returns {TrieNode}\n   */ find(value) {\n        if (value === undefined || value === null) return null;\n        const word = value.toString();\n        let currentNode = this._root;\n        for(let i = 0; i < word.length; i += 1){\n            if (!currentNode.hasChild(word[i])) return null;\n            currentNode = currentNode.getChild(word[i]);\n        }\n        if (!currentNode.isEndOfWord()) return null;\n        return currentNode;\n    }\n    /**\n   * Removes a word from the trie\n   * @public\n   * @param {string} word\n   * @returns {string | null}\n   */ remove(value) {\n        if (value === undefined || value === null) return null;\n        const word = value.toString();\n        let currentNode = this._root;\n        for(let i = 0; i < word.length; i += 1){\n            if (!currentNode.hasChild(word[i])) return null;\n            currentNode = currentNode.getChild(word[i]);\n        }\n        if (!currentNode.isEndOfWord()) return null;\n        if (currentNode.childrenCount() > 0 || word === \"\") {\n            currentNode.setEndOfWord(false);\n            this._wordsCount -= 1;\n            return word;\n        }\n        do {\n            currentNode.getParent().removeChild(currentNode.getChar());\n            this._nodesCount -= 1;\n            currentNode = currentNode.getParent();\n        }while (currentNode.isLeaf() && !currentNode.isEndOfWord() && !currentNode.isRoot());\n        this._wordsCount -= 1;\n        return word;\n    }\n    /**\n   * Traverse the trie and pass words to a callback\n   * @public\n   * @param {function} cb\n   */ forEach(cb) {\n        if (typeof cb !== \"function\") throw new Error(\"Trie.forEach expects a callback function\");\n        const forEachRecursive = (node = this._root, word = \"\")=>{\n            if (node.isEndOfWord()) cb(word);\n            node.children().forEach((child)=>{\n                forEachRecursive(child, word + child.getChar());\n            });\n        };\n        return forEachRecursive();\n    }\n    /**\n   * Converts the trie into an array of words\n   * @public\n   * @returns {array}\n   */ toArray() {\n        const result = [];\n        this.forEach((word)=>result.push(word));\n        return result;\n    }\n    /**\n   * @public\n   * @returns {number}\n   */ nodesCount() {\n        return this._nodesCount;\n    }\n    /**\n   * @public\n   * @returns {number}\n   */ wordsCount() {\n        return this._wordsCount;\n    }\n    /**\n   * Clears the trie\n   * @public\n   */ clear() {\n        this._root = new $bff485a8fc680118$require$TrieNode(\"\");\n        this._nodesCount = 1;\n        this._wordsCount = 0;\n    }\n    /**\n   * Converts an existing list into a trie\n   * @public\n   * @static\n   * @returns {Trie}\n   */ static fromArray(values) {\n        const trie = new $bff485a8fc680118$var$Trie();\n        values.forEach((value)=>trie.insert(value));\n        return trie;\n    }\n}\n$bff485a8fc680118$export$73571c50d0f2507e = $bff485a8fc680118$var$Trie;\n\n\nvar $ea94ad80bc7b40ba$require$Trie = $bff485a8fc680118$export$73571c50d0f2507e;\n\nvar $ea94ad80bc7b40ba$require$TrieNode = $df2d689f8a3c506f$export$f46b48023fc0dbb0;\n$ea94ad80bc7b40ba$export$f46b48023fc0dbb0 = $ea94ad80bc7b40ba$require$TrieNode;\n$ea94ad80bc7b40ba$export$73571c50d0f2507e = $ea94ad80bc7b40ba$require$Trie;\n\n\n\nvar $eKNW7 = parcelRequire(\"eKNW7\");\n\nclass $068f3b50daf3346f$export$248346f792cea416 extends (0, $99105ae177c29e38$export$6ff07836956a79aa) {\n    async attach() {\n        await super.attach();\n        window.addEventListener(\"keydown\", this.keyDownListener);\n    }\n    detach() {\n        window.removeEventListener(\"keydown\", this.keyDownListener);\n        super.detach();\n    }\n    async populateContainer() {\n        const text = new (0, $dd84afd4ef9f1e09$export$5f1af8db9871e1d6)({\n            label: \"text\",\n            text: Math.floor(Math.random() * 10).toString(),\n            style: new (0, $eKNW7.TextStyle)({\n                fill: \"#de3249\"\n            })\n        });\n        this.container.addChild(text);\n    }\n    onKeyDown(key, e) {\n        console.log(key, \"pressed\");\n        const text = this.container.getChildByLabel(\"text\");\n        if (!text || !(text instanceof (0, $dd84afd4ef9f1e09$export$5f1af8db9871e1d6))) this.finishMinigame(false);\n        this.finishMinigame(key === text.text);\n    }\n    constructor(...args){\n        super(...args);\n        this.keyDownListener = (e)=>void this.onKeyDown(e.key, e);\n    }\n}\n\n\n\nvar $1HooC = parcelRequire(\"1HooC\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\nvar $eKNW7 = parcelRequire(\"eKNW7\");\n\n// TODO: Update this list later.\nconst $9b8bd60ae59c3c3c$var$ALL_WORDS = [\n    \"act\",\n    \"ale\",\n    \"all\",\n    \"and\",\n    \"ball\",\n    \"bang\",\n    \"bat\"\n];\nclass $9b8bd60ae59c3c3c$export$4281ad43e89fce79 extends (0, $068f3b50daf3346f$export$248346f792cea416) {\n    async populateContainer() {\n        const phonescreenTexture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).PHONE_SCREEN);\n        const phonescreen = new (0, $4rhnu.Sprite)(phonescreenTexture);\n        phonescreen.anchor = 0.5;\n        const aspectRatio = phonescreen.width / phonescreen.height;\n        phonescreen.height = this.app.screen.height;\n        phonescreen.width = phonescreen.height * aspectRatio;\n        phonescreen.position = new (0, $1HooC.Point)(this.app.screen.width / 2, this.app.screen.height / 2);\n        this.container.addChild(phonescreen);\n        $9b8bd60ae59c3c3c$var$ALL_WORDS.forEach((word)=>{\n            this.trie.insert(word);\n            const text = new (0, $dd84afd4ef9f1e09$export$5f1af8db9871e1d6)({\n                label: word,\n                text: word,\n                style: new (0, $eKNW7.TextStyle)({\n                    fill: \"#de3249\"\n                })\n            });\n            const x = (this.app.screen.width - 100) * Math.random() + 50;\n            const y = (this.app.screen.height - 100) * Math.random() + 50;\n            text.position = new (0, $1HooC.Point)(x, y);\n            this.container.addChild(text);\n        });\n        this.trie.insert(\"\");\n        this.currentNode = this.trie.find(\"\");\n    }\n    onKeyDown(key) {\n        if (!this.currentNode.hasChild(key)) {\n            // No words match the current string. Reset the search from the beginning.\n            this.currentNode = this.trie.find(\"\");\n            // Try match the key that was just pressed, for a smoother gameplay experience.\n            // Note this means we don't support any one-letter words.\n            if (this.currentNode.hasChild(key)) this.currentNode = this.currentNode.getChild(key);\n            return;\n        }\n        this.currentNode = this.currentNode.getChild(key);\n        if (this.currentNode.isEndOfWord()) {\n            const word = this.getString(this.currentNode);\n            const text = this.container.getChildByLabel(word);\n            text.alpha = 0.2;\n            this.remainingWords.delete(word);\n            if (this.remainingWords.size === 0) this.finishMinigame(true);\n        }\n    }\n    getString(node) {\n        let string = \"\";\n        let infiniteLoopPreventer = 999999;\n        while(!node.isRoot() && infiniteLoopPreventer-- > 0){\n            string = node.getChar() + string;\n            node = node.getParent();\n        }\n        return string;\n    }\n    constructor(...args){\n        super(...args);\n        this.trie = new (0, $ea94ad80bc7b40ba$export$73571c50d0f2507e)();\n        this.remainingWords = new Set($9b8bd60ae59c3c3c$var$ALL_WORDS);\n    }\n}\n\n\n\nvar $eKNW7 = parcelRequire(\"eKNW7\");\n\nclass $3b5234182643f1ea$export$f967effa9359e517 extends (0, $068f3b50daf3346f$export$248346f792cea416) {\n    async populateContainer() {\n        this.text = new (0, $dd84afd4ef9f1e09$export$5f1af8db9871e1d6)({\n            label: \"text\",\n            text: \"3\",\n            style: new (0, $eKNW7.TextStyle)({\n                fill: \"#de3249\"\n            })\n        });\n        this.container.addChild(this.text);\n        this.countdown();\n    }\n    async countdown() {\n        await this.waitFor(1000);\n        this.text.text = \"2\";\n        await this.waitFor(1000);\n        this.text.text = \"1\";\n        await this.waitFor(1000);\n        this.text.text = \"NOW\";\n        this.waitingForPress = true;\n        await this.waitFor(500);\n        this.waitingForPress = false;\n    }\n    async waitFor(time) {\n        return new Promise((resolve)=>setTimeout(resolve, time));\n    }\n    onKeyDown(key) {\n        console.log(key, \"pressed\");\n        if (this.waitingForPress == true) {\n            this.finishMinigame(true);\n            this.waitingForPress = false;\n        } else this.finishMinigame(false);\n    }\n    constructor(...args){\n        super(...args);\n        //private keyDownListener = (e: KeyboardEvent) => void this.onKeyDown(e.key);\n        this.text = null;\n        this.waitingForPress = false;\n    }\n}\n\n\n\nvar $1HooC = parcelRequire(\"1HooC\");\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\n\n\nconst $a0a284949824ccdb$var$DIRT_ASSETS = [\n    (0, $6e1e16f555a84269$export$1a264e8727077b82).BATH_DIRT_1,\n    (0, $6e1e16f555a84269$export$1a264e8727077b82).BATH_DIRT_2,\n    (0, $6e1e16f555a84269$export$1a264e8727077b82).BATH_DIRT_3,\n    (0, $6e1e16f555a84269$export$1a264e8727077b82).BATH_DIRT_4\n];\nconst $a0a284949824ccdb$var$DIRT_SIZE = 50;\nclass $a0a284949824ccdb$var$DirtySpot {\n    constructor(delegate){\n        this.delegate = delegate;\n        this.health = 100;\n    }\n    async getObject(area) {\n        const dirtAssetId = $a0a284949824ccdb$var$DIRT_ASSETS[Math.floor($a0a284949824ccdb$var$DIRT_ASSETS.length * Math.random())];\n        const dirtAsset = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load(dirtAssetId);\n        const spot = new (0, $4rhnu.Sprite)(dirtAsset);\n        const x = area.x + area.width * Math.random();\n        const y = area.y + area.height * Math.random();\n        spot.width = $a0a284949824ccdb$var$DIRT_SIZE;\n        spot.height = $a0a284949824ccdb$var$DIRT_SIZE;\n        spot.anchor = 0.5;\n        spot.position = new (0, $1HooC.Point)(x, y);\n        spot.eventMode = \"static\";\n        spot.on(\"mousemove\", (event)=>{\n            if (!this.delegate.isPointerDown()) return;\n            this.health = Math.max(this.health - event.movement.magnitude() * 0.3, 0);\n            spot.alpha = 0.15 + 0.7 * (this.health / 100);\n            if (this.health === 0) {\n                this.delegate.markCleaned(this);\n                spot.removeFromParent();\n            }\n        });\n        return spot;\n    }\n}\nclass $a0a284949824ccdb$export$31f8a9e359578bc3 extends (0, $99105ae177c29e38$export$6ff07836956a79aa) {\n    async attach() {\n        await super.attach();\n        // Sometimes attach gets called before canvas sets it's own cursor state.\n        // Only update the cursor _after_ this to make sure we don't get overriden.\n        await new Promise((resolve)=>void setTimeout(resolve, 200));\n        this.app.canvas.style.cursor = `url('./assets/sprites/minigames/loofa.png'), auto`;\n    }\n    detach() {\n        super.detach();\n        this.app.canvas.style.cursor = \"auto\";\n    }\n    async populateContainer() {\n        const bgAsset = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).BATH_BG_1);\n        const characterAssetId = [\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).BATH_MC_1,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).BATH_MC_2,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).BATH_MC_3\n        ][this.week];\n        const numSpots = 3 + 2 * this.week;\n        const characterAsset = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load(characterAssetId);\n        const { screen: screen } = this.app;\n        const bg = new (0, $4rhnu.Sprite)(bgAsset);\n        bg.width = this.app.screen.width;\n        bg.height = this.app.screen.height;\n        bg.zIndex = -1;\n        this.container.addChild(bg);\n        const mc = new (0, $4rhnu.Sprite)(characterAsset);\n        const heightScale = [\n            0.8,\n            0.9,\n            1\n        ][this.week];\n        const characterSize = {\n            width: screen.height * heightScale * (mc.width / mc.height),\n            height: screen.height * heightScale\n        };\n        mc.width = characterSize.width;\n        mc.height = characterSize.height;\n        mc.anchor = 0.5;\n        mc.x = screen.width / 2;\n        mc.y = screen.height / 2;\n        this.container.addChild(mc);\n        const torsoRatio = [\n            0.5,\n            0.4,\n            0.35\n        ][this.week];\n        const dirtableSize = {\n            width: characterSize.width * torsoRatio,\n            height: characterSize.height * torsoRatio\n        };\n        const dirtableArea = new (0, $fM4Mk.Rectangle)(screen.width / 2 - dirtableSize.width / 2, screen.height / 2 - dirtableSize.height / 2, dirtableSize.width, dirtableSize.height);\n        for(let i = 0; i < numSpots; i++){\n            const spot = new $a0a284949824ccdb$var$DirtySpot(this);\n            this.remainingDirtySpots.add(spot);\n            this.container.addChild(await spot.getObject(dirtableArea));\n        }\n        this.container.eventMode = \"static\";\n        this.container.hitArea = this.app.screen;\n        this.container.on(\"pointerdown\", ()=>this.pointerDown = true).on(\"pointerup\", ()=>this.pointerDown = false).on(\"pointerupoutside\", ()=>this.pointerDown = false);\n    }\n    isPointerDown() {\n        return this.pointerDown;\n    }\n    markCleaned(spot) {\n        this.remainingDirtySpots.delete(spot);\n        if (this.remainingDirtySpots.size === 0) this.finishMinigame(true);\n    }\n    constructor(...args){\n        super(...args);\n        this.pointerDown = false;\n        this.remainingDirtySpots = new Set();\n        this.lifetime = 15000;\n    }\n}\n\n\n\nvar $1HooC = parcelRequire(\"1HooC\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\n\n\n\nclass $a670c05e32afb8b4$export$ab7924da727ab963 extends (0, $99105ae177c29e38$export$6ff07836956a79aa) {\n    async attach() {\n        super.attach();\n        this.scoreToPass = 3000;\n        this.container.eventMode = \"static\";\n        this.container.hitArea = this.app.screen;\n        this.container.on(\"pointerup\", ()=>void this.onDragEnd());\n        this.container.on(\"pointerupoutside\", ()=>void this.onDragEnd());\n    }\n    async populateContainer() {\n        const shakeAble = new (0, $4rhnu.Sprite)(await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).BLENDER));\n        const x = (this.app.screen.width - 100) * Math.random();\n        const y = (this.app.screen.height - 100) * Math.random();\n        const loadSprite = new (0, $4rhnu.Sprite)(await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).BLENDERFILL));\n        const progSprite = new (0, $4rhnu.Sprite)(await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).BLENDERPROG));\n        this.prog = new (0, $64dbf4c474740b9a$export$c17561cb55d4db30)({\n            bg: progSprite,\n            fill: loadSprite,\n            fillPaddings: {\n                top: 75,\n                bottom: 0,\n                right: 0,\n                left: 228\n            },\n            progress: 0\n        });\n        var aspect = this.prog.height / this.prog.width;\n        this.prog.width = this.app.screen.width / 6;\n        this.prog.height = this.prog.width * aspect;\n        //shakeAble.rect(0, 0, 60, 60);\n        //shakeAble.fill(0xde3249);\n        //shakeAble.scale.set(10);\n        aspect = shakeAble.height / shakeAble.width;\n        shakeAble.width = this.app.screen.width / 4;\n        shakeAble.height = shakeAble.width * aspect;\n        shakeAble.anchor = 0.5;\n        shakeAble.position = new (0, $1HooC.Point)(this.app.screen.width / 2, this.app.screen.height / 2);\n        shakeAble.eventMode = \"static\";\n        shakeAble.on(\"pointerdown\", ()=>{\n            this.dragObject = shakeAble;\n            this.container.on(\"pointermove\", this.dragListener);\n        });\n        this.container.addChild(shakeAble);\n        this.container.addChild(this.prog);\n    }\n    onDragEnd() {\n        if (this.dragObject) {\n            console.log(\"ENDED\");\n            this.container.off(\"pointermove\", this.dragListener);\n            this.dragObject = null;\n        }\n    }\n    onDrag(event) {\n        if (!this.dragObject) return;\n        const previousPos = this.dragObject.position.clone();\n        this.dragObject.position = event.getLocalPosition(this.dragObject.parent);\n        this.vel = this.dragObject.position.subtract(previousPos);\n        this.score += Math.floor((Math.abs(this.vel.x) + Math.abs(this.vel.y)) / 10);\n        //console.log(this.score);\n        //this.scoreText.text = this.score;\n        this.prog.progress = this.score / this.scoreToPass * 100;\n        if (this.score > this.scoreToPass) this.finishMinigame(true);\n    }\n    constructor(...args){\n        super(...args);\n        this.dragObject = null;\n        this.dragListener = (e)=>void this.onDrag(e);\n        this.score = 0;\n        this.scoreText = null;\n    }\n}\n\n\n\nvar $1HooC = parcelRequire(\"1HooC\");\nvar $hbpIN = parcelRequire(\"hbpIN\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\nvar $4J7WL = parcelRequire(\"4J7WL\");\n\n\n\nvar $3cebA = parcelRequire(\"3cebA\");\nfunction $ec1b68aa6a9802f7$export$39fab2494f708073(container, hitArea) {\n    if (!new URLSearchParams(window.location.search).get(\"dev\")) return;\n    const graphics = new (0, $3cebA.Graphics)();\n    graphics.poly(hitArea.points);\n    graphics.fill(0xde3249);\n    graphics.alpha = 0.3;\n    container.addChild(graphics);\n}\n\n\nvar $8b679de7a6842c56$var$GroceryItemType;\n/* This needs to match up 1:1 with the strings in `minigames/assets.ts`. */ (function(GroceryItemType) {\n    GroceryItemType[\"BANANA\"] = \"banana\";\n    GroceryItemType[\"MILK\"] = \"milk\";\n    GroceryItemType[\"PEANUT_BUTTER\"] = \"peanut-butter\";\n    GroceryItemType[\"PROTEIN\"] = \"protein\";\n    GroceryItemType[\"STRAWBERRIES\"] = \"strawberries\";\n    GroceryItemType[\"YOGHURT\"] = \"yoghurt\";\n})($8b679de7a6842c56$var$GroceryItemType || ($8b679de7a6842c56$var$GroceryItemType = {}));\nclass $8b679de7a6842c56$export$5a028d41c825ae10 extends (0, $99105ae177c29e38$export$6ff07836956a79aa) {\n    async populateContainer() {\n        const appDimensions = this.app.screen;\n        this.container.eventMode = \"static\";\n        this.container.hitArea = appDimensions;\n        this.container.on(\"pointerup\", ()=>this.onDragEnd());\n        this.container.on(\"pointerupoutside\", ()=>this.onDragEnd());\n        this.container.addChild(await this.constructBackground(appDimensions));\n        this.basket = await this.constructBasket(appDimensions);\n        this.basket.on(\"pointerup\", ()=>this.onBasketDrop());\n        this.container.addChild(this.basket);\n        if (this.week >= 1) {\n            const security = await this.constructSecurity(appDimensions);\n            this.ticker.add((time)=>void this.periodicallyToggleSecurity(time, security));\n            this.container.addChild(security);\n        }\n        const allItems = [\n            \"banana\",\n            \"milk\",\n            \"peanut-butter\",\n            \"protein\",\n            \"strawberries\",\n            \"yoghurt\"\n        ];\n        for(let i = 0; i < 5; i++){\n            const randomItem = allItems[Math.floor(Math.random() * allItems.length)];\n            this.shoppingList[randomItem]++;\n        }\n        // TODO: Display this graphically.\n        console.log(\"Your shopping list is:\", Object.keys(this.shoppingList).map((item)=>`${item}: ${this.shoppingList[item]}`).join(\", \"));\n        const allPositions = [\n            new (0, $1HooC.Point)(appDimensions.width * 0.1, appDimensions.height * 0.15),\n            new (0, $1HooC.Point)(appDimensions.width * 0.3, appDimensions.height * 0.15),\n            new (0, $1HooC.Point)(appDimensions.width * 0.5, appDimensions.height * 0.15),\n            new (0, $1HooC.Point)(appDimensions.width * 0.1, appDimensions.height * 0.4),\n            new (0, $1HooC.Point)(appDimensions.width * 0.3, appDimensions.height * 0.4),\n            new (0, $1HooC.Point)(appDimensions.width * 0.5, appDimensions.height * 0.4),\n            new (0, $1HooC.Point)(appDimensions.width * 0.7, appDimensions.height * 0.4)\n        ];\n        this.ticker.add((time)=>void this.periodicallyAddItems(time, allPositions, appDimensions));\n    }\n    onDragStart(item) {\n        if (!!this.dragTarget) return;\n        this.dragTarget = item;\n        this.container.on(\"pointermove\", this.dragListener);\n    }\n    onDragEnd() {\n        if (!this.dragTarget) return;\n        this.container.off(\"pointermove\", this.dragListener);\n        this.dragTarget = undefined;\n    }\n    onBasketDrop() {\n        if (!this.dragTarget) return;\n        if (this.securityIsWatching) {\n            const ticker = new (0, $4J7WL.Ticker)();\n            const item = this.dragTarget.sprite;\n            const originalPosition = this.dragTarget.originalPosition.clone();\n            ticker.add((time)=>this.easeToPos(time, item.position, originalPosition, 1000, item, `caughtredhanded${$8b679de7a6842c56$var$stringifyPoint(originalPosition)}`));\n            ticker.start();\n            return;\n        }\n        const item = this.dragTarget.sprite;\n        // Prevent drag and drop for this item.\n        item.eventMode = \"none\";\n        const collectedItemPosition = this.basket.position.clone();\n        collectedItemPosition.y -= item.height / 2;\n        collectedItemPosition.x += this.basket.width / 2 - item.width * 0.6;\n        // Stack the items from left to right\n        collectedItemPosition.x += item.width * 0.3 * (this.collectedItemCount % 5);\n        item.zIndex = this.collectedItemCount;\n        const ticker = new (0, $4J7WL.Ticker)();\n        ticker.add((time)=>this.easeToPos(time, item.position, collectedItemPosition, 1000, item, `collected${this.collectedItemCount}`));\n        ticker.start();\n        delete this.shelves[$8b679de7a6842c56$var$stringifyPoint(this.dragTarget.originalPosition)];\n        this.shoppingList[this.dragTarget.type]--;\n        this.collectedItemCount++;\n        if (Object.values(this.shoppingList).filter((remaining)=>remaining > 0).length === 0) this.finishMinigame(true);\n    }\n    onDragMove(event) {\n        if (!this.dragTarget) return;\n        this.dragTarget.sprite.position = event.getLocalPosition(this.dragTarget.sprite.parent);\n    }\n    async periodicallyToggleSecurity(time, security) {\n        this.timeUntilNextSecurityToggleMs -= time.deltaMS;\n        if (this.timeUntilNextSecurityToggleMs > 0) return;\n        this.timeUntilNextSecurityToggleMs = 2000;\n        this.securityIsWatching = !this.securityIsWatching;\n        security.texture = this.securityIsWatching ? await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).SECURITY_ON) : await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).SECURITY_OFF);\n    }\n    async periodicallyAddItems(time, allPositions, appDimensions) {\n        this.timeUntilNextStockMs -= time.deltaMS;\n        if (this.timeUntilNextStockMs > 0) return;\n        this.timeUntilNextStockMs = 400;\n        // Find an item that needs to be purchased which is not already accounted\n        // for by stock on the shelves.\n        const currentlyOnShelf = {\n            [\"banana\"]: 0,\n            [\"milk\"]: 0,\n            [\"peanut-butter\"]: 0,\n            [\"protein\"]: 0,\n            [\"strawberries\"]: 0,\n            [\"yoghurt\"]: 0\n        };\n        Object.values(this.shelves).forEach((item)=>void currentlyOnShelf[item.type]++);\n        const requiredUnstockedItems = [];\n        Object.keys(this.shoppingList).forEach((item)=>{\n            for(let i = 0; i < this.shoppingList[item] - currentlyOnShelf[item]; i++)requiredUnstockedItems.push(item);\n        });\n        if (requiredUnstockedItems.length === 0) return;\n        // Look for a free spot on the shelves.\n        const availablePositions = allPositions.filter((position)=>!Object.keys(this.shelves).includes($8b679de7a6842c56$var$stringifyPoint(position)));\n        if (availablePositions.length === 0) return;\n        // Choose an item to add, and a shelf position to place it.\n        const itemType = requiredUnstockedItems[Math.floor(Math.random() * requiredUnstockedItems.length)];\n        const position = availablePositions[Math.floor(Math.random() * availablePositions.length)];\n        const itemSprite = await this.constructItem(itemType, position, appDimensions);\n        const item = {\n            type: itemType,\n            originalPosition: position,\n            sprite: itemSprite\n        };\n        itemSprite.on(\"pointerdown\", ()=>this.onDragStart(item));\n        this.container.addChild(itemSprite);\n        this.shelves[$8b679de7a6842c56$var$stringifyPoint(position)] = item;\n    }\n    async constructBackground(appDimensions) {\n        const texture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).SHOPPING_BACKGROUND);\n        const background = new (0, $4rhnu.Sprite)(texture);\n        background.setSize(appDimensions);\n        background.zIndex = -1;\n        return background;\n    }\n    async constructBasket(appDimensions) {\n        const texture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).BASKET);\n        const basket = new (0, $4rhnu.Sprite)(texture);\n        const aspectRatio = basket.width / basket.height;\n        basket.height = appDimensions.height * 0.4;\n        basket.width = basket.height * aspectRatio;\n        basket.anchor = new (0, $1HooC.Point)(0, 1);\n        basket.position = new (0, $1HooC.Point)(appDimensions.width * 0.05, appDimensions.height * 1.05);\n        basket.zIndex = 99999;\n        // minY because we've set the anchor to be at the bottom left corner.\n        const { maxX: boundsWidth, minY: boundsHeight } = basket.bounds;\n        const hitArea = new (0, $hbpIN.Polygon)(new (0, $1HooC.Point)(0, boundsHeight), new (0, $1HooC.Point)(0, boundsHeight * 0.89), new (0, $1HooC.Point)(boundsWidth * 0.06, boundsHeight * 0.89), new (0, $1HooC.Point)(boundsWidth * 0.17, 0), new (0, $1HooC.Point)(boundsWidth * 0.83, 0), new (0, $1HooC.Point)(boundsWidth * 0.94, boundsHeight * 0.89), new (0, $1HooC.Point)(boundsWidth, boundsHeight * 0.89), new (0, $1HooC.Point)(boundsWidth, boundsHeight));\n        (0, $ec1b68aa6a9802f7$export$39fab2494f708073)(basket, hitArea);\n        basket.hitArea = hitArea;\n        basket.eventMode = \"static\";\n        return basket;\n    }\n    async constructSecurity(appDimensions) {\n        const texture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).SECURITY_OFF);\n        // Cache the other texture.\n        await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).SECURITY_ON);\n        const security = new (0, $4rhnu.Sprite)(texture);\n        const aspectRatio = security.width / security.height;\n        security.height = appDimensions.height * 0.3;\n        security.width = security.height * aspectRatio;\n        security.anchor = new (0, $1HooC.Point)(1, 0);\n        security.position = new (0, $1HooC.Point)(appDimensions.width, appDimensions.height * 0.05);\n        security.zIndex = 1;\n        return security;\n    }\n    async constructItem(itemType, position, appDimensions) {\n        const texture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load(itemType);\n        const item = new (0, $4rhnu.Sprite)(texture);\n        const aspectRatio = item.width / item.height;\n        item.height = appDimensions.height * 0.2;\n        item.width = item.height * aspectRatio;\n        item.anchor = 0.5;\n        item.position = position;\n        const hitArea = $8b679de7a6842c56$var$getHitAreaForItem(itemType, item.bounds);\n        (0, $ec1b68aa6a9802f7$export$39fab2494f708073)(item, hitArea);\n        item.hitArea = hitArea;\n        item.eventMode = \"static\";\n        return item;\n    }\n    async easeToPos(ticker, startPos, endPos, timeToArriveMs, object, id) {\n        this.easeMap[id] = Math.min((this.easeMap[id] ?? 0) + ticker.deltaMS / timeToArriveMs, 1);\n        const ease = (f)=>Math.sqrt(1 - Math.pow(f - 1, 2)); // https://easings.net/#easeOutCirc\n        const directionVector = endPos.subtract(startPos);\n        object.position = startPos.clone().add(directionVector.multiplyScalar(ease(this.easeMap[id])));\n        if (this.easeMap[id] === 1) {\n            this.easeMap[id] = 0;\n            ticker.destroy();\n        }\n    }\n    constructor(...args){\n        super(...args);\n        this.shoppingList = {\n            [\"banana\"]: 0,\n            [\"milk\"]: 0,\n            [\"peanut-butter\"]: 0,\n            [\"protein\"]: 0,\n            [\"strawberries\"]: 0,\n            [\"yoghurt\"]: 0\n        };\n        this.shelves = {};\n        this.timeUntilNextStockMs = 0;\n        this.collectedItemCount = 0;\n        this.securityIsWatching = false;\n        this.timeUntilNextSecurityToggleMs = 0;\n        this.dragListener = (e)=>void this.onDragMove(e);\n        // Maps some ID to the elapsed percentage (from 0~1) for this ease.\n        this.easeMap = {};\n    }\n}\nfunction $8b679de7a6842c56$var$getHitAreaForItem(type, bounds) {\n    const left = bounds.minX;\n    const top = bounds.minY;\n    const width = bounds.maxX - left;\n    const height = bounds.maxY - top;\n    function relativePoint(x, y) {\n        return new (0, $1HooC.Point)(left + width * x, top + height * y);\n    }\n    switch(type){\n        case \"banana\":\n            return new (0, $hbpIN.Polygon)(relativePoint(0.09, 0.31), relativePoint(0.02, 0.46), relativePoint(0, 0.7), relativePoint(0.18, 0.91), relativePoint(0.4, 1), relativePoint(0.58, 0.99), relativePoint(0.72, 0.92), relativePoint(0.81, 0.86), relativePoint(0.93, 0.7), relativePoint(0.98, 0.5), relativePoint(0.98, 0.42), relativePoint(0.94, 0.2), relativePoint(1, 0.12), relativePoint(0.97, 0.04), relativePoint(0.84, 0), relativePoint(0.8, 0.04), relativePoint(0.82, 0.13), relativePoint(0.64, 0.33), relativePoint(0.45, 0.39));\n        case \"milk\":\n            return new (0, $hbpIN.Polygon)(relativePoint(0.11, 0), relativePoint(0.11, 0.16), relativePoint(0.0, 0.34), relativePoint(0.0, 0.85), relativePoint(0.13, 0.94), relativePoint(0.75, 1), relativePoint(1, 0.86), relativePoint(1, 0.34), relativePoint(0.85, 0.14), relativePoint(0.84, 0));\n        case \"peanut-butter\":\n            return new (0, $hbpIN.Polygon)(relativePoint(0.3, 0), relativePoint(0.12, 0.05), relativePoint(0.08, 0.1), relativePoint(0.08, 0.28), relativePoint(0.0, 0.4), relativePoint(0.0, 0.75), relativePoint(0.12, 0.93), relativePoint(0.55, 1), relativePoint(0.94, 0.97), relativePoint(1, 0.86), relativePoint(1, 0.6), relativePoint(0.94, 0.35), relativePoint(0.9, 0.3), relativePoint(0.86, 0.06), relativePoint(0.7, 0));\n        case \"protein\":\n            return new (0, $hbpIN.Polygon)(relativePoint(0.3, 0), relativePoint(0.12, 0.05), relativePoint(0.08, 0.1), relativePoint(0.08, 0.18), relativePoint(0, 0.4), relativePoint(0.02, 0.85), relativePoint(0.08, 0.96), relativePoint(0.55, 1), relativePoint(0.87, 0.97), relativePoint(0.99, 0.88), relativePoint(1, 0.38), relativePoint(0.96, 0.28), relativePoint(0.89, 0.2), relativePoint(0.89, 0.06), relativePoint(0.73, 0));\n        case \"strawberries\":\n            return new (0, $hbpIN.Polygon)(relativePoint(0.28, 0), relativePoint(0.12, 0.23), relativePoint(0, 0.52), relativePoint(0.03, 0.63), relativePoint(0.38, 1), relativePoint(0.47, 1), relativePoint(0.6, 0.92), relativePoint(0.9, 0.6), relativePoint(0.98, 0.5), relativePoint(1, 0.38), relativePoint(0.96, 0.24), relativePoint(0.83, 0));\n        case \"yoghurt\":\n            return new (0, $hbpIN.Polygon)(relativePoint(0.25, 0), relativePoint(0, 0.1), relativePoint(0, 0.16), relativePoint(0.12, 0.82), relativePoint(0.22, 0.94), relativePoint(0.31, 0.99), relativePoint(0.72, 1), relativePoint(0.83, 0.95), relativePoint(0.91, 0.82), relativePoint(1, 0.18), relativePoint(1, 0.08), relativePoint(0.7, 0));\n        default:\n            return new (0, $hbpIN.Polygon)();\n    }\n}\nfunction $8b679de7a6842c56$var$stringifyPoint(position) {\n    return `x${position.x},y${position.y}`;\n}\n\n\n\n\nvar $1HooC = parcelRequire(\"1HooC\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\n\n\nclass $2ae28b1c56a1c5d6$export$d56d71bc59825611 extends (0, $068f3b50daf3346f$export$248346f792cea416) {\n    //temporary pos for the graphic instantiation\n    async attach() {\n        super.attach();\n        const texture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).BALANCE_BG);\n        const background = new (0, $4rhnu.Sprite)(texture);\n        background.setSize(this.app.screen);\n        background.zIndex = -1;\n        this.container.addChild(background);\n        this.ticker.add((time)=>this.onUpdate(time));\n    }\n    async populateContainer() {\n        this.pos = new (0, $1HooC.Point)(this.app.screen.height / 6 * 5, this.app.screen.width / 2);\n        this.balancingObject = new (0, $4rhnu.Sprite)(await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).BALANCE_C1));\n        this.balancingObject.position = this.pos;\n        this.balancingObject.anchor = new (0, $1HooC.Point)(0.5, 0.85);\n        this.container.addChild(this.balancingObject);\n    }\n    onKeyDown(key, e) {\n        if (e.repeat) return;\n        if (key == \"ArrowRight\") this.addRotForce(this.forceAmount);\n        if (key == \"ArrowLeft\") this.addRotForce(-this.forceAmount);\n    }\n    addRotForce(amount) {\n        if (this.currentForce * amount > 0) this.currentForce += amount;\n        else this.currentForce = amount;\n        console.log(this.currentForce);\n    }\n    onUpdate(time) {\n        console.log(this.balancingObject.rotation);\n        const increment = this.currentForce * time.deltaTime * 0.1;\n        this.balancingObject.rotation += increment;\n        this.currentForce -= increment;\n        if (Math.abs(this.balancingObject.rotation) >= 2) this.finishMinigame(false);\n        if (this.balancingObject.rotation >= 0) this.balancingObject.rotation += 0.003 + Math.abs(this.balancingObject.rotation) * 0.008;\n        else this.balancingObject.rotation -= 0.003 + Math.abs(this.balancingObject.rotation) * 0.008;\n    }\n    constructor(...args){\n        super(...args);\n        this.balancingObject = null;\n        this.pos = new (0, $1HooC.Point)(1300, 1200);\n        this.currentForce = 0;\n        this.forceAmount = 0.8;\n        this.succeedOnTimeout = true;\n    }\n}\n\n\n\nvar $4J7WL = parcelRequire(\"4J7WL\");\n\nvar $eicwU = parcelRequire(\"eicwU\");\nvar $3cebA = parcelRequire(\"3cebA\");\nvar $1HooC = parcelRequire(\"1HooC\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\nvar $eKNW7 = parcelRequire(\"eKNW7\");\nasync function $00fae121cfaa6e06$export$9847db861136c05a(app, assetAlias, additionalObjects = [], advanceMode = \"click\", autoAdvanceMs = 400) {\n    const frame = new (0, $eicwU.Container)();\n    frame.hitArea = app.screen;\n    const texture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load(assetAlias);\n    const sprite = new (0, $4rhnu.Sprite)(texture);\n    sprite.setSize(app.screen);\n    sprite.zIndex = -1;\n    frame.addChild(sprite, ...additionalObjects);\n    return {\n        container: frame,\n        advanceMode: advanceMode,\n        autoAdvanceMs: autoAdvanceMs\n    };\n}\nfunction $00fae121cfaa6e06$export$e8e0592187a724b2(content, screen, relativeBounds, drawBubble = true) {\n    const { x: x, y: y, width: width, height: height } = relativeBounds;\n    const borderWidth = screen.height / 150;\n    const container = new (0, $eicwU.Container)();\n    const bubble = new (0, $3cebA.Graphics)();\n    bubble.rect(0, 0, screen.width * width, screen.height * height);\n    bubble.fill(0xffffff);\n    bubble.stroke({\n        color: 0x000000,\n        width: screen.height / 100\n    });\n    if (drawBubble) container.addChild(bubble);\n    const textStyle = new (0, $eKNW7.TextStyle)({\n        fontFamily: '\"Poppins\", sans-serif',\n        fontSize: screen.height / 40,\n        wordWrap: true,\n        wordWrapWidth: bubble.width - borderWidth * 4\n    });\n    const text = new (0, $dd84afd4ef9f1e09$export$5f1af8db9871e1d6)({\n        text: content,\n        style: textStyle\n    });\n    text.zIndex = 1;\n    text.position = new (0, $1HooC.Point)(borderWidth * 2, borderWidth * 2);\n    container.addChild(text);\n    container.position = new (0, $1HooC.Point)(screen.width * x, screen.height * y);\n    return container;\n}\n\n\nconst $d435b25f36463079$export$a764318a87fcdb1c = async (app)=>{\n    if (new URLSearchParams(window.location.search).get(\"skipIntro\")) return [];\n    const { screen: screen } = app;\n    const allFrames = [\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro1\", [\n            $d435b25f36463079$var$getSpeech1(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro2\", [\n            $d435b25f36463079$var$getSpeech1(screen),\n            $d435b25f36463079$var$getSpeech2(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro3\", [\n            $d435b25f36463079$var$getSpeech1(screen),\n            $d435b25f36463079$var$getSpeech2(screen),\n            $d435b25f36463079$var$getSpeech3(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro4\", [], \"auto\"),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro5\", [], \"auto\"),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro6\", [], \"auto\"),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro7\", [], \"auto\"),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro8\", [], \"auto\"),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro9\", [\n            $d435b25f36463079$var$getSpeech4(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro10\", [\n            $d435b25f36463079$var$getSpeech5(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro11\", [\n            $d435b25f36463079$var$getSpeech5(screen),\n            $d435b25f36463079$var$getSpeech6(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro12\", [\n            $d435b25f36463079$var$getSpeech5(screen),\n            $d435b25f36463079$var$getSpeech6(screen),\n            $d435b25f36463079$var$getSpeech7(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro13\", [], \"auto\", 1200),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro14\", [\n            $d435b25f36463079$var$getSpeech8(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"intro15\", [\n            $d435b25f36463079$var$getSpeech8(screen),\n            $d435b25f36463079$var$getSpeech9(screen)\n        ])\n    ];\n    return allFrames;\n};\nfunction $d435b25f36463079$var$getSpeech1(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"These days I just feel so powerless.\", screen, {\n        x: 0.465,\n        y: 0.075,\n        width: 0.11,\n        height: 0.21\n    });\n}\nfunction $d435b25f36463079$var$getSpeech2(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"They say that the gym is a good place to get stronger.\", screen, {\n        x: 0.345,\n        y: 0.41,\n        width: 0.225,\n        height: 0.165\n    });\n}\nfunction $d435b25f36463079$var$getSpeech3(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"Ever since moving out I haven't been able to motivate myself to do anything. I've never exercised before, but there's not harm in trying, right?\", screen, {\n        x: 0.65,\n        y: 0.11,\n        width: 0.3,\n        height: 0.23\n    });\n}\nfunction $d435b25f36463079$var$getSpeech4(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"Nope, it's no good. Exercising is harder than it looks - it just makes me feel even weaker than I already did. Maybe there's no hope for me...\", screen, {\n        x: 0.76,\n        y: 0.495,\n        width: 0.2,\n        height: 0.435\n    });\n}\nfunction $d435b25f36463079$var$getSpeech5(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"Snap out of it! Rome wasn't built in a day, I just need to keep at it!\", screen, {\n        x: 0.749,\n        y: 0.32,\n        width: 0.2,\n        height: 0.12\n    });\n}\nfunction $d435b25f36463079$var$getSpeech6(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"I might not be able to see it now, but I need to keep going! If I can build up a good routine, with a healthy diet, surely some day, somehow, I can...!\", screen, {\n        x: 0.09,\n        y: 0.69,\n        width: 0.36,\n        height: 0.19\n    });\n}\nfunction $d435b25f36463079$var$getSpeech7(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)('\"Hey kiddo. Looks like you are struggling pretty hard over there! *snicker* I know just what you need-\"', screen, {\n        x: 0.56,\n        y: 0.545,\n        width: 0.18,\n        height: 0.17\n    });\n}\nfunction $d435b25f36463079$var$getSpeech8(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"No thanks. That seems super shady. I'm going to get stronger through my own hard work, just you watch.\", screen, {\n        x: 0.84,\n        y: 0.1,\n        width: 0.12,\n        height: 0.33\n    });\n}\nfunction $d435b25f36463079$var$getSpeech9(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"I need to do my best to prove just how powerful I can be!\", screen, {\n        x: 0.779,\n        y: 0.54,\n        width: 0.175,\n        height: 0.14\n    });\n}\n\n\n\nconst $aeb6aa7d4e276ee0$export$e1d6017afb733620 = async (app)=>{\n    const { screen: screen } = app;\n    const allFrames = [\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"beforeComp1\", [\n            $aeb6aa7d4e276ee0$var$getSpeech1(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"beforeComp2\", [\n            $aeb6aa7d4e276ee0$var$getSpeech1(screen)\n        ], \"auto\", 800),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"beforeComp3\", [\n            $aeb6aa7d4e276ee0$var$getSpeech1(screen)\n        ], \"auto\", 800),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"beforeComp4\", [\n            $aeb6aa7d4e276ee0$var$getSpeech1(screen),\n            $aeb6aa7d4e276ee0$var$getSpeech2(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"beforeComp5\", [\n            $aeb6aa7d4e276ee0$var$getSpeech1(screen),\n            $aeb6aa7d4e276ee0$var$getSpeech2(screen),\n            $aeb6aa7d4e276ee0$var$getSpeech3(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"beforeComp6\", [\n            $aeb6aa7d4e276ee0$var$getSpeech4(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"beforeComp7\", [\n            $aeb6aa7d4e276ee0$var$getSpeech4(screen),\n            $aeb6aa7d4e276ee0$var$getSpeech5(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"beforeComp8\", [\n            $aeb6aa7d4e276ee0$var$getSpeech4(screen),\n            $aeb6aa7d4e276ee0$var$getSpeech5(screen),\n            $aeb6aa7d4e276ee0$var$getSpeech6(screen)\n        ])\n    ];\n    return allFrames;\n};\nfunction $aeb6aa7d4e276ee0$var$getSpeech1(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"It's been 3 weeks...\", screen, {\n        x: 0.28,\n        y: 0.07,\n        width: 0.095,\n        height: 0.12\n    });\n}\nfunction $aeb6aa7d4e276ee0$var$getSpeech2(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"What's this? A powerlifting competition? Maybe with this-\", screen, {\n        x: 0.315,\n        y: 0.67,\n        width: 0.11,\n        height: 0.25\n    });\n}\nfunction $aeb6aa7d4e276ee0$var$getSpeech3(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"I can show that wolf how far I've come!\", screen, {\n        x: 0.838,\n        y: 0.57,\n        width: 0.125,\n        height: 0.122\n    });\n}\nfunction $aeb6aa7d4e276ee0$var$getSpeech4(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"Today's the day.\", screen, {\n        x: 0.465,\n        y: 0.075,\n        width: 0.11,\n        height: 0.21\n    });\n}\nfunction $aeb6aa7d4e276ee0$var$getSpeech5(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"I know I can win this competition. I've been training non-stop for it.\", screen, {\n        x: 0.345,\n        y: 0.41,\n        width: 0.225,\n        height: 0.165\n    });\n}\nfunction $aeb6aa7d4e276ee0$var$getSpeech6(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"It's time for me to blow the roof off the competition!\", screen, {\n        x: 0.65,\n        y: 0.11,\n        width: 0.3,\n        height: 0.23\n    });\n}\n\n\n\nconst $a07f1723987cafba$export$ac31031d3a176ccd = async (app)=>{\n    const { screen: screen } = app;\n    const allFrames = [\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"afterComp1\", [\n            $a07f1723987cafba$var$getSpeech1(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"afterComp2\", [\n            $a07f1723987cafba$var$getSpeech1(screen),\n            $a07f1723987cafba$var$getSpeech2(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"afterComp3\", [\n            $a07f1723987cafba$var$getSpeech1(screen),\n            $a07f1723987cafba$var$getSpeech2(screen),\n            $a07f1723987cafba$var$getSpeech3(screen),\n            $a07f1723987cafba$var$getSpeech4(screen)\n        ]),\n        await (0, $00fae121cfaa6e06$export$9847db861136c05a)(app, \"afterComp3\", [\n            $a07f1723987cafba$var$getSpeech1(screen),\n            $a07f1723987cafba$var$getSpeech2(screen),\n            $a07f1723987cafba$var$getSpeech3(screen),\n            $a07f1723987cafba$var$getSpeech4(screen),\n            $a07f1723987cafba$var$getSpeech5(screen)\n        ])\n    ];\n    return allFrames;\n};\nfunction $a07f1723987cafba$var$getSpeech1(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"\\\"Sorry pal, you're disqualified. You can't just go breaking the fifth wall like that.\\\"\", screen, {\n        x: 0.07,\n        y: 0.69,\n        width: 0.215,\n        height: 0.2\n    });\n}\nfunction $a07f1723987cafba$var$getSpeech2(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"After all that... did I accomplish nothing? *sigh* Maybe I should pay mum a visit\", screen, {\n        x: 0.668,\n        y: 0.39,\n        width: 0.27,\n        height: 0.12\n    });\n}\nfunction $a07f1723987cafba$var$getSpeech3(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)('\"Welcome home son, I\\'ve missed you. Help me bring in the groceries, would you?\"', screen, {\n        x: 0.65,\n        y: 0.78,\n        width: 0.18,\n        height: 0.14\n    });\n}\nfunction $a07f1723987cafba$var$getSpeech4(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"In that moment it was clear. The power I could use for good meant so much more to me than any competition.\", screen, {\n        x: 0.85,\n        y: 0.57,\n        width: 0.1,\n        height: 0.365\n    });\n}\nfunction $a07f1723987cafba$var$getSpeech5(screen) {\n    return (0, $00fae121cfaa6e06$export$e8e0592187a724b2)(\"Fin.\", screen, {\n        x: 0.92,\n        y: 0.93,\n        width: 0.05,\n        height: 0.05\n    }, /* drawBubble= */ false);\n}\n\n\nconst $fbd5350d83bd6d7d$var$INTERLUDE_ASSET_PATHS = {\n    intro1: \"./assets/sprites/intro/opening-gym-panel-1.png\",\n    intro2: \"./assets/sprites/intro/opening-gym-panel-2.png\",\n    intro3: \"./assets/sprites/intro/opening-gym-panel-3.png\",\n    intro4: \"./assets/sprites/intro/exercise1.png\",\n    intro5: \"./assets/sprites/intro/exercise2.png\",\n    intro6: \"./assets/sprites/intro/exercise3.png\",\n    intro7: \"./assets/sprites/intro/exercise4.png\",\n    intro8: \"./assets/sprites/intro/exercise5.png\",\n    intro9: \"./assets/sprites/intro/exercise6.png\",\n    intro10: \"./assets/sprites/intro/gymconvo1.png\",\n    intro11: \"./assets/sprites/intro/gymconvo2.png\",\n    intro12: \"./assets/sprites/intro/gymconvo3.png\",\n    intro13: \"./assets/sprites/intro/gymconvo4.png\",\n    intro14: \"./assets/sprites/intro/gymconvo5.png\",\n    intro15: \"./assets/sprites/intro/gymconvo6.png\",\n    beforeComp1: \"./assets/sprites/beforecomp/before-comp-1.png\",\n    beforeComp2: \"./assets/sprites/beforecomp/before-comp-2.png\",\n    beforeComp3: \"./assets/sprites/beforecomp/before-comp-3.png\",\n    beforeComp4: \"./assets/sprites/beforecomp/before-comp-4.png\",\n    beforeComp5: \"./assets/sprites/beforecomp/before-comp-5.png\",\n    beforeComp6: \"./assets/sprites/beforecomp/lastday-gym-1.png\",\n    beforeComp7: \"./assets/sprites/beforecomp/lastday-gym-2.png\",\n    beforeComp8: \"./assets/sprites/beforecomp/lastday-gym-3.png\",\n    afterComp1: \"./assets/sprites/aftercomp/aftercomp1.png\",\n    afterComp2: \"./assets/sprites/aftercomp/aftercomp2.png\",\n    afterComp3: \"./assets/sprites/aftercomp/aftercomp3.png\"\n};\nfunction $fbd5350d83bd6d7d$export$9e4435986e337332() {\n    const aliases = Object.keys($fbd5350d83bd6d7d$var$INTERLUDE_ASSET_PATHS);\n    aliases.forEach((alias)=>{\n        (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).add({\n            alias: alias,\n            src: $fbd5350d83bd6d7d$var$INTERLUDE_ASSET_PATHS[alias]\n        });\n    });\n    (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).backgroundLoad(aliases);\n}\nconst $fbd5350d83bd6d7d$var$framesList = [\n    (0, $d435b25f36463079$export$a764318a87fcdb1c),\n    ()=>[],\n    ()=>[],\n    (0, $aeb6aa7d4e276ee0$export$e1d6017afb733620),\n    (0, $a07f1723987cafba$export$ac31031d3a176ccd)\n];\nclass $fbd5350d83bd6d7d$export$6aceaa2aadf4b436 {\n    constructor(app, delegate, week){\n        this.app = app;\n        this.delegate = delegate;\n        this.week = week;\n        this.frames = [];\n        this.currentFrame = -1;\n    }\n    async start() {\n        const getFrames = $fbd5350d83bd6d7d$var$framesList[this.week];\n        if (getFrames !== undefined) this.frames = await getFrames(this.app);\n        this.showNextFrame();\n    }\n    showNextFrame() {\n        this.currentFrame++;\n        if (this.currentFrame >= this.frames.length) {\n            this.delegate.onInterludeEnd();\n            return;\n        }\n        const { container: container, advanceMode: advanceMode, autoAdvanceMs: autoAdvanceMs } = this.frames[this.currentFrame];\n        container.eventMode = \"static\";\n        if (advanceMode === \"click\") container.on(\"click\", ()=>{\n            this.app.stage.removeChild(container);\n            this.showNextFrame();\n        });\n        else if (advanceMode === \"auto\") {\n            let remainingTime = autoAdvanceMs;\n            const ticker = new (0, $4J7WL.Ticker)();\n            ticker.add((time)=>{\n                remainingTime -= time.deltaMS;\n                if (remainingTime > 0) return;\n                this.app.stage.removeChild(container);\n                this.showNextFrame();\n                ticker.destroy();\n            });\n            ticker.start();\n        }\n        this.app.stage.addChild(container);\n    }\n}\n\n\n\nvar $1HooC = parcelRequire(\"1HooC\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\nvar $4J7WL = parcelRequire(\"4J7WL\");\n\n\nvar $1HooC = parcelRequire(\"1HooC\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\nvar $4J7WL = parcelRequire(\"4J7WL\");\n\n\nclass $147878e7c7ba608b$export$a890a978955b9c6 extends (0, $068f3b50daf3346f$export$248346f792cea416) {\n    async populateContainer() {\n        const { screen: screen } = this.app;\n        await this.cacheAssets();\n        const texture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load(this.initialBackgroundAlias);\n        this.background = new (0, $4rhnu.Sprite)(texture);\n        this.background.setSize(screen);\n        this.background.anchor = 0.5;\n        this.background.position = new (0, $1HooC.Point)(screen.width / 2, screen.height / 2);\n        this.initialBackgroundScale = this.background.scale.clone();\n        this.background.zIndex = -1;\n        this.container.addChild(this.background);\n        this.ticker.add(async (time)=>{\n            if (this.chargeBar > 0 && this.chargeBar < 100) // Slowly drain.\n            this.chargeBar -= this.drainRate * time.deltaTime;\n            await this.updateBackground();\n            if (this.chargeBar === 100) this.finishCheckpoint();\n        });\n    }\n    async cacheAssets() {}\n    async updateBackground() {}\n    async changeBackgroundTexture(alias) {\n        this.background.texture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load(alias);\n    }\n    async endContent() {}\n    onKeyDown(key, e) {\n        // Prevent holding down the key to win.\n        if (this.minigameComplete || key != \" \" || e.repeat) return;\n        this.chargeBar = Math.min(this.chargeBar + this.chargeRate, 100);\n        const ticker = new (0, $4J7WL.Ticker)();\n        ticker.add((time)=>this.bounce(time, this.initialBackgroundScale.clone().multiplyScalar(1.05), 150));\n        ticker.start();\n    }\n    finishCheckpoint() {\n        this.minigameComplete = true;\n        this.finishMinigame(true, this.endContent());\n    }\n    async bounce(ticker, peakScale, timeToFinishMs) {\n        this.bounceProgress = Math.min(this.bounceProgress + ticker.deltaMS / timeToFinishMs, 1);\n        const bounce = (f)=>-Math.pow(1 - 2 * f, 2) + 1;\n        const directionVector = peakScale.clone().subtract(this.initialBackgroundScale);\n        this.background.scale = this.initialBackgroundScale.clone().add(directionVector.multiplyScalar(bounce(this.bounceProgress)));\n        if (this.bounceProgress === 1) {\n            this.bounceProgress = 0;\n            ticker.destroy();\n        }\n    }\n    constructor(...args){\n        super(...args);\n        // Checkpoints have no time limit.\n        this.lifetime = undefined;\n        // Charge bar goes from 0 -> 100 but drains at some rate.\n        this.chargeBar = 0;\n        this.chargeRate = 10;\n        this.drainRate = 0.1;\n        this.initialBackgroundAlias = (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_1_1;\n        this.minigameComplete = false;\n        this.bounceProgress = 0;\n    }\n}\n\n\nclass $0fc9e5698905dde8$export$7fa05bad4e631cc4 extends (0, $147878e7c7ba608b$export$a890a978955b9c6) {\n    async cacheAssets() {\n        await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load([\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_1_1,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_1_2,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_1_3,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_1_4,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).ROOMBA\n        ]);\n    }\n    async updateBackground() {\n        if (this.chargeBar < 33) await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_1_1);\n        else if (this.chargeBar < 66) await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_1_2);\n        else if (this.chargeBar < 100) await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_1_3);\n        else await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_1_4);\n    }\n    async endContent() {\n        const { screen: screen } = this.app;\n        const texture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).ROOMBA);\n        const roomba = new (0, $4rhnu.Sprite)(texture);\n        const aspectRatio = roomba.width / roomba.height;\n        roomba.width = screen.width * 0.15;\n        roomba.height = roomba.width / aspectRatio;\n        roomba.anchor = new (0, $1HooC.Point)(0, 1);\n        roomba.position = new (0, $1HooC.Point)(-roomba.width, screen.height * 0.85);\n        roomba.zIndex = 1;\n        this.container.addChild(roomba);\n        const ticker = new (0, $4J7WL.Ticker)();\n        ticker.autoStart = true;\n        await new Promise((res)=>{\n            ticker.add((time)=>{\n                roomba.x += 8 * time.deltaTime;\n                if (roomba.x > screen.width) {\n                    res();\n                    ticker.destroy();\n                }\n            });\n        });\n        await new Promise((res)=>setTimeout(res, 2000));\n    }\n    constructor(...args){\n        super(...args);\n        this.chargeRate = 10;\n        this.drainRate = 0.1;\n        this.initialBackgroundAlias = (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_1_1;\n    }\n}\n\n\n\nvar $1HooC = parcelRequire(\"1HooC\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\nvar $4J7WL = parcelRequire(\"4J7WL\");\n\n\nclass $82075403d4ddd3bc$export$d155972b9bf563b2 extends (0, $147878e7c7ba608b$export$a890a978955b9c6) {\n    async cacheAssets() {\n        await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load([\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_2_1,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_2_2,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_2_3,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_2_4,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_2_5,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).RABBIT\n        ]);\n    }\n    async updateBackground() {\n        if (this.chargeBar < 33) await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_2_1);\n        else if (this.chargeBar < 66) await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_2_2);\n        else if (this.chargeBar < 100) await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_2_3);\n        else await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_2_4);\n    }\n    async endContent() {\n        const { screen: screen } = this.app;\n        const texture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).RABBIT);\n        const rabbit = new (0, $4rhnu.Sprite)(texture);\n        const aspectRatio = rabbit.width / rabbit.height;\n        rabbit.width = screen.width * 0.18;\n        rabbit.height = rabbit.width / aspectRatio;\n        rabbit.anchor = new (0, $1HooC.Point)(0, 1);\n        rabbit.position = new (0, $1HooC.Point)(screen.width * 0.2, screen.height * 0.65);\n        rabbit.zIndex = 1;\n        this.container.addChild(rabbit);\n        const ticker = new (0, $4J7WL.Ticker)();\n        ticker.autoStart = true;\n        const destination = new (0, $1HooC.Point)(screen.width * 0.55, screen.height * 0.3);\n        const directionVector = destination.clone().subtract(rabbit.position.clone());\n        await new Promise((res)=>{\n            ticker.add((time)=>{\n                rabbit.position = rabbit.position.add(directionVector.normalize().multiplyScalar(10 * time.deltaTime));\n                if (rabbit.position.x > destination.x) {\n                    res();\n                    ticker.destroy();\n                }\n            });\n        });\n        rabbit.removeFromParent();\n        await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_2_5);\n        await new Promise((res)=>setTimeout(res, 2000));\n    }\n    constructor(...args){\n        super(...args);\n        this.chargeRate = 8;\n        this.drainRate = 0.2;\n        this.initialBackgroundAlias = (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_2_1;\n    }\n}\n\n\n\nvar $1HooC = parcelRequire(\"1HooC\");\nvar $4rhnu = parcelRequire(\"4rhnu\");\nvar $4J7WL = parcelRequire(\"4J7WL\");\n\n\nclass $1a642378d14820d1$export$f9f2f5e841ffbc58 extends (0, $147878e7c7ba608b$export$a890a978955b9c6) {\n    async cacheAssets() {\n        await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load([\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_3_1,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_3_2,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_3_3,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_3_4,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_3_5,\n            (0, $6e1e16f555a84269$export$1a264e8727077b82).BAR\n        ]);\n    }\n    async updateBackground() {\n        if (this.chargeBar < 33) await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_3_1);\n        else if (this.chargeBar < 66) await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_3_2);\n        else if (this.chargeBar < 100) await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_3_3);\n        else await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_3_4);\n    }\n    async endContent() {\n        const { screen: screen } = this.app;\n        const texture = await (0, $f4e4ce59fcdafcd2$export$c8eca95e306f7116).load((0, $6e1e16f555a84269$export$1a264e8727077b82).BAR);\n        const bar = new (0, $4rhnu.Sprite)(texture);\n        const aspectRatio = bar.width / bar.height;\n        bar.width = screen.width * 0.64;\n        bar.height = bar.width / aspectRatio;\n        bar.anchor = new (0, $1HooC.Point)(0.5, 1);\n        bar.position = new (0, $1HooC.Point)(screen.width * 0.51, screen.height * 0.25);\n        bar.zIndex = 1;\n        this.container.addChild(bar);\n        let ticker = new (0, $4J7WL.Ticker)();\n        ticker.autoStart = true;\n        await new Promise((res)=>{\n            ticker.add((time)=>{\n                bar.y -= 25 * time.deltaTime;\n                if (bar.y < 0) {\n                    res();\n                    ticker.destroy();\n                }\n            });\n        });\n        await new Promise((res)=>setTimeout(res, 300));\n        await this.changeBackgroundTexture((0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_3_5);\n        await new Promise((res)=>setTimeout(res, 500));\n        bar.position = new (0, $1HooC.Point)(screen.width * 0.5, screen.height * 1.2);\n        bar.angle = -6;\n        bar.scale = bar.scale.clone().multiplyScalar(0.6);\n        ticker = new (0, $4J7WL.Ticker)();\n        ticker.autoStart = true;\n        await new Promise((res)=>{\n            ticker.add((time)=>{\n                bar.y -= 19 * time.deltaTime;\n                if (bar.y < -bar.width) {\n                    res();\n                    ticker.destroy();\n                }\n            });\n        });\n        await new Promise((res)=>setTimeout(res, 2000));\n    }\n    constructor(...args){\n        super(...args);\n        this.chargeRate = 6;\n        this.drainRate = 0.25;\n        this.initialBackgroundAlias = (0, $6e1e16f555a84269$export$1a264e8727077b82).CHECKPOINT_3_1;\n    }\n}\n\n\nconst $a93d756e0c61289b$var$MINIGAMES_POOL = new URLSearchParams(window.location.search).get(\"quick\") ? [\n    (0, $99105ae177c29e38$export$6ff07836956a79aa)\n] : [\n    (0, $9b8bd60ae59c3c3c$export$4281ad43e89fce79),\n    (0, $2ae28b1c56a1c5d6$export$d56d71bc59825611),\n    (0, $8b679de7a6842c56$export$5a028d41c825ae10),\n    (0, $a670c05e32afb8b4$export$ab7924da727ab963),\n    (0, $3b5234182643f1ea$export$f967effa9359e517),\n    (0, $a0a284949824ccdb$export$31f8a9e359578bc3),\n    (0, $fa9ef9bbaee2fee2$export$6a635c9f58e69db2)\n];\nclass $a93d756e0c61289b$export$bd0bf19f25da8474 {\n    constructor(app){\n        this.app = app;\n        this.completedMinigamePhases = 0;\n        this.minigameQueue = [];\n        this.minigameLoseCount = 0;\n    }\n    preload() {\n        (0, $fbd5350d83bd6d7d$export$9e4435986e337332)();\n        (0, $6e1e16f555a84269$export$8deeb594a331b243)();\n    }\n    start() {\n        const intro = new (0, $fbd5350d83bd6d7d$export$6aceaa2aadf4b436)(this.app, this, 0);\n        intro.start();\n    }\n    onMinigameEnd(passed) {\n        this.currentMinigame.detach();\n        if (!passed) this.minigameLoseCount++;\n        else this.minigameLoseCount = 0;\n        if (this.minigameLoseCount > 1) {\n            // Player has run out of chances to proceed to the next phase.\n            console.log(\"You lose!\");\n            return;\n        }\n        if (this.minigameQueue.length === 0) {\n            this.completedMinigamePhases++;\n            this.minigameLoseCount = 0;\n        }\n        if (this.completedMinigamePhases >= 3) {\n            // Trigger end game loop.\n            this.startNextInterlude();\n            return;\n        }\n        if (this.minigameQueue.length === 0) {\n            // Trigger check point and go around again.\n            this.currentMinigame = this.completedMinigamePhases === 1 ? new (0, $0fc9e5698905dde8$export$7fa05bad4e631cc4)(this.app, this, this.completedMinigamePhases) : new (0, $82075403d4ddd3bc$export$d155972b9bf563b2)(this.app, this, this.completedMinigamePhases);\n            this.currentMinigame.attach(); // No await.\n            this.populateMinigameQueue();\n        } else this.startNextMinigame();\n    }\n    onInterludeEnd() {\n        if (this.completedMinigamePhases === 3) {\n            this.currentMinigame = new (0, $1a642378d14820d1$export$f9f2f5e841ffbc58)(this.app, this, this.completedMinigamePhases);\n            this.currentMinigame.attach(); // No await.\n            return;\n        }\n        if (this.completedMinigamePhases > 3) {\n            console.log(\"The end!\");\n            return;\n        }\n        this.populateMinigameQueue();\n        this.startNextMinigame();\n    }\n    populateMinigameQueue() {\n        // Reset the current queue.\n        this.minigameQueue.length = 0;\n        for(let i = 0; i < $a93d756e0c61289b$var$MINIGAMES_POOL.length; i++){\n            const minigame = new $a93d756e0c61289b$var$MINIGAMES_POOL[i](this.app, this, this.completedMinigamePhases);\n            this.minigameQueue.push(minigame);\n        }\n    }\n    startNextMinigame() {\n        this.currentMinigame = this.minigameQueue.shift();\n        this.currentMinigame.attach(); // No await.\n    }\n    startNextInterlude() {\n        const interlude = new (0, $fbd5350d83bd6d7d$export$6aceaa2aadf4b436)(this.app, this, this.completedMinigamePhases);\n        interlude.start();\n    }\n}\n\n\nvar $f89d8ffbdc18f2ab$export$c9d39ca3bcd93abb;\nvar $f89d8ffbdc18f2ab$export$b791fe48eec8032a;\n/*!\n *  howler.js v2.2.4\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */ (function() {\n    \"use strict\";\n    /** Global Methods **/ /***************************************************************************/ /**\n   * Create the global controller. All contained methods and properties apply\n   * to all sounds that are currently playing or will be in the future.\n   */ var HowlerGlobal1 = function() {\n        this.init();\n    };\n    HowlerGlobal1.prototype = {\n        /**\n     * Initialize the global Howler object.\n     * @return {Howler}\n     */ init: function() {\n            var self = this || Howler1;\n            // Create a global ID counter.\n            self._counter = 1000;\n            // Pool of unlocked HTML5 Audio objects.\n            self._html5AudioPool = [];\n            self.html5PoolSize = 10;\n            // Internal properties.\n            self._codecs = {};\n            self._howls = [];\n            self._muted = false;\n            self._volume = 1;\n            self._canPlayEvent = \"canplaythrough\";\n            self._navigator = typeof window !== \"undefined\" && window.navigator ? window.navigator : null;\n            // Public properties.\n            self.masterGain = null;\n            self.noAudio = false;\n            self.usingWebAudio = true;\n            self.autoSuspend = true;\n            self.ctx = null;\n            // Set to false to disable the auto audio unlocker.\n            self.autoUnlock = true;\n            // Setup the various state values for global tracking.\n            self._setup();\n            return self;\n        },\n        /**\n     * Get/set the global volume for all sounds.\n     * @param  {Float} vol Volume from 0.0 to 1.0.\n     * @return {Howler/Float}     Returns self or current volume.\n     */ volume: function(vol) {\n            var self = this || Howler1;\n            vol = parseFloat(vol);\n            // If we don't have an AudioContext created yet, run the setup.\n            if (!self.ctx) setupAudioContext();\n            if (typeof vol !== \"undefined\" && vol >= 0 && vol <= 1) {\n                self._volume = vol;\n                // Don't update any of the nodes if we are muted.\n                if (self._muted) return self;\n                // When using Web Audio, we just need to adjust the master gain.\n                if (self.usingWebAudio) self.masterGain.gain.setValueAtTime(vol, Howler1.ctx.currentTime);\n                // Loop through and change volume for all HTML5 audio nodes.\n                for(var i = 0; i < self._howls.length; i++)if (!self._howls[i]._webAudio) {\n                    // Get all of the sounds in this Howl group.\n                    var ids = self._howls[i]._getSoundIds();\n                    // Loop through all sounds and change the volumes.\n                    for(var j = 0; j < ids.length; j++){\n                        var sound = self._howls[i]._soundById(ids[j]);\n                        if (sound && sound._node) sound._node.volume = sound._volume * vol;\n                    }\n                }\n                return self;\n            }\n            return self._volume;\n        },\n        /**\n     * Handle muting and unmuting globally.\n     * @param  {Boolean} muted Is muted or not.\n     */ mute: function(muted) {\n            var self = this || Howler1;\n            // If we don't have an AudioContext created yet, run the setup.\n            if (!self.ctx) setupAudioContext();\n            self._muted = muted;\n            // With Web Audio, we just need to mute the master gain.\n            if (self.usingWebAudio) self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler1.ctx.currentTime);\n            // Loop through and mute all HTML5 Audio nodes.\n            for(var i = 0; i < self._howls.length; i++)if (!self._howls[i]._webAudio) {\n                // Get all of the sounds in this Howl group.\n                var ids = self._howls[i]._getSoundIds();\n                // Loop through all sounds and mark the audio node as muted.\n                for(var j = 0; j < ids.length; j++){\n                    var sound = self._howls[i]._soundById(ids[j]);\n                    if (sound && sound._node) sound._node.muted = muted ? true : sound._muted;\n                }\n            }\n            return self;\n        },\n        /**\n     * Handle stopping all sounds globally.\n     */ stop: function() {\n            var self = this || Howler1;\n            // Loop through all Howls and stop them.\n            for(var i = 0; i < self._howls.length; i++)self._howls[i].stop();\n            return self;\n        },\n        /**\n     * Unload and destroy all currently loaded Howl objects.\n     * @return {Howler}\n     */ unload: function() {\n            var self = this || Howler1;\n            for(var i = self._howls.length - 1; i >= 0; i--)self._howls[i].unload();\n            // Create a new AudioContext to make sure it is fully reset.\n            if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== \"undefined\") {\n                self.ctx.close();\n                self.ctx = null;\n                setupAudioContext();\n            }\n            return self;\n        },\n        /**\n     * Check for codec support of specific extension.\n     * @param  {String} ext Audio file extention.\n     * @return {Boolean}\n     */ codecs: function(ext) {\n            return (this || Howler1)._codecs[ext.replace(/^x-/, \"\")];\n        },\n        /**\n     * Setup various state values for global tracking.\n     * @return {Howler}\n     */ _setup: function() {\n            var self = this || Howler1;\n            // Keeps track of the suspend/resume state of the AudioContext.\n            self.state = self.ctx ? self.ctx.state || \"suspended\" : \"suspended\";\n            // Automatically begin the 30-second suspend process\n            self._autoSuspend();\n            // Check if audio is available.\n            if (!self.usingWebAudio) {\n                // No audio is available on this system if noAudio is set to true.\n                if (typeof Audio !== \"undefined\") try {\n                    var test = new Audio();\n                    // Check if the canplaythrough event is available.\n                    if (typeof test.oncanplaythrough === \"undefined\") self._canPlayEvent = \"canplay\";\n                } catch (e) {\n                    self.noAudio = true;\n                }\n                else self.noAudio = true;\n            }\n            // Test to make sure audio isn't disabled in Internet Explorer.\n            try {\n                var test = new Audio();\n                if (test.muted) self.noAudio = true;\n            } catch (e) {}\n            // Check for supported codecs.\n            if (!self.noAudio) self._setupCodecs();\n            return self;\n        },\n        /**\n     * Check for browser support for various codecs and cache the results.\n     * @return {Howler}\n     */ _setupCodecs: function() {\n            var self = this || Howler1;\n            var audioTest = null;\n            // Must wrap in a try/catch because IE11 in server mode throws an error.\n            try {\n                audioTest = typeof Audio !== \"undefined\" ? new Audio() : null;\n            } catch (err) {\n                return self;\n            }\n            if (!audioTest || typeof audioTest.canPlayType !== \"function\") return self;\n            var mpegTest = audioTest.canPlayType(\"audio/mpeg;\").replace(/^no$/, \"\");\n            // Opera version <33 has mixed MP3 support, so we need to check for and block it.\n            var ua = self._navigator ? self._navigator.userAgent : \"\";\n            var checkOpera = ua.match(/OPR\\/(\\d+)/g);\n            var isOldOpera = checkOpera && parseInt(checkOpera[0].split(\"/\")[1], 10) < 33;\n            var checkSafari = ua.indexOf(\"Safari\") !== -1 && ua.indexOf(\"Chrome\") === -1;\n            var safariVersion = ua.match(/Version\\/(.*?) /);\n            var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;\n            self._codecs = {\n                mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType(\"audio/mp3;\").replace(/^no$/, \"\"))),\n                mpeg: !!mpegTest,\n                opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, \"\"),\n                ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, \"\"),\n                oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, \"\"),\n                wav: !!(audioTest.canPlayType('audio/wav; codecs=\"1\"') || audioTest.canPlayType(\"audio/wav\")).replace(/^no$/, \"\"),\n                aac: !!audioTest.canPlayType(\"audio/aac;\").replace(/^no$/, \"\"),\n                caf: !!audioTest.canPlayType(\"audio/x-caf;\").replace(/^no$/, \"\"),\n                m4a: !!(audioTest.canPlayType(\"audio/x-m4a;\") || audioTest.canPlayType(\"audio/m4a;\") || audioTest.canPlayType(\"audio/aac;\")).replace(/^no$/, \"\"),\n                m4b: !!(audioTest.canPlayType(\"audio/x-m4b;\") || audioTest.canPlayType(\"audio/m4b;\") || audioTest.canPlayType(\"audio/aac;\")).replace(/^no$/, \"\"),\n                mp4: !!(audioTest.canPlayType(\"audio/x-mp4;\") || audioTest.canPlayType(\"audio/mp4;\") || audioTest.canPlayType(\"audio/aac;\")).replace(/^no$/, \"\"),\n                weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, \"\")),\n                webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, \"\")),\n                dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, \"\"),\n                flac: !!(audioTest.canPlayType(\"audio/x-flac;\") || audioTest.canPlayType(\"audio/flac;\")).replace(/^no$/, \"\")\n            };\n            return self;\n        },\n        /**\n     * Some browsers/devices will only allow audio to be played after a user interaction.\n     * Attempt to automatically unlock audio on the first user interaction.\n     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\n     * @return {Howler}\n     */ _unlockAudio: function() {\n            var self = this || Howler1;\n            // Only run this if Web Audio is supported and it hasn't already been unlocked.\n            if (self._audioUnlocked || !self.ctx) return;\n            self._audioUnlocked = false;\n            self.autoUnlock = false;\n            // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\n            // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\n            // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\n            if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\n                self._mobileUnloaded = true;\n                self.unload();\n            }\n            // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\n            // http://stackoverflow.com/questions/24119684\n            self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\n            // Call this method on touch start to create and play a buffer,\n            // then check if the audio actually played to determine if\n            // audio has now been unlocked on iOS, Android, etc.\n            var unlock = function(e) {\n                // Create a pool of unlocked HTML5 Audio objects that can\n                // be used for playing sounds without user interaction. HTML5\n                // Audio objects must be individually unlocked, as opposed\n                // to the WebAudio API which only needs a single activation.\n                // This must occur before WebAudio setup or the source.onended\n                // event will not fire.\n                while(self._html5AudioPool.length < self.html5PoolSize)try {\n                    var audioNode = new Audio();\n                    // Mark this Audio object as unlocked to ensure it can get returned\n                    // to the unlocked pool when released.\n                    audioNode._unlocked = true;\n                    // Add the audio node to the pool.\n                    self._releaseHtml5Audio(audioNode);\n                } catch (e) {\n                    self.noAudio = true;\n                    break;\n                }\n                // Loop through any assigned audio nodes and unlock them.\n                for(var i = 0; i < self._howls.length; i++)if (!self._howls[i]._webAudio) {\n                    // Get all of the sounds in this Howl group.\n                    var ids = self._howls[i]._getSoundIds();\n                    // Loop through all sounds and unlock the audio nodes.\n                    for(var j = 0; j < ids.length; j++){\n                        var sound = self._howls[i]._soundById(ids[j]);\n                        if (sound && sound._node && !sound._node._unlocked) {\n                            sound._node._unlocked = true;\n                            sound._node.load();\n                        }\n                    }\n                }\n                // Fix Android can not play in suspend state.\n                self._autoResume();\n                // Create an empty buffer.\n                var source = self.ctx.createBufferSource();\n                source.buffer = self._scratchBuffer;\n                source.connect(self.ctx.destination);\n                // Play the empty buffer.\n                if (typeof source.start === \"undefined\") source.noteOn(0);\n                else source.start(0);\n                // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\n                if (typeof self.ctx.resume === \"function\") self.ctx.resume();\n                // Setup a timeout to check that we are unlocked on the next event loop.\n                source.onended = function() {\n                    source.disconnect(0);\n                    // Update the unlocked state and prevent this check from happening again.\n                    self._audioUnlocked = true;\n                    // Remove the touch start listener.\n                    document.removeEventListener(\"touchstart\", unlock, true);\n                    document.removeEventListener(\"touchend\", unlock, true);\n                    document.removeEventListener(\"click\", unlock, true);\n                    document.removeEventListener(\"keydown\", unlock, true);\n                    // Let all sounds know that audio has been unlocked.\n                    for(var i = 0; i < self._howls.length; i++)self._howls[i]._emit(\"unlock\");\n                };\n            };\n            // Setup a touch start listener to attempt an unlock in.\n            document.addEventListener(\"touchstart\", unlock, true);\n            document.addEventListener(\"touchend\", unlock, true);\n            document.addEventListener(\"click\", unlock, true);\n            document.addEventListener(\"keydown\", unlock, true);\n            return self;\n        },\n        /**\n     * Get an unlocked HTML5 Audio object from the pool. If none are left,\n     * return a new Audio object and throw a warning.\n     * @return {Audio} HTML5 Audio object.\n     */ _obtainHtml5Audio: function() {\n            var self = this || Howler1;\n            // Return the next object from the pool if one exists.\n            if (self._html5AudioPool.length) return self._html5AudioPool.pop();\n            //.Check if the audio is locked and throw a warning.\n            var testPlay = new Audio().play();\n            if (testPlay && typeof Promise !== \"undefined\" && (testPlay instanceof Promise || typeof testPlay.then === \"function\")) testPlay.catch(function() {\n                console.warn(\"HTML5 Audio pool exhausted, returning potentially locked audio object.\");\n            });\n            return new Audio();\n        },\n        /**\n     * Return an activated HTML5 Audio object to the pool.\n     * @return {Howler}\n     */ _releaseHtml5Audio: function(audio) {\n            var self = this || Howler1;\n            // Don't add audio to the pool if we don't know if it has been unlocked.\n            if (audio._unlocked) self._html5AudioPool.push(audio);\n            return self;\n        },\n        /**\n     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\n     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\n     * @return {Howler}\n     */ _autoSuspend: function() {\n            var self = this;\n            if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === \"undefined\" || !Howler1.usingWebAudio) return;\n            // Check if any sounds are playing.\n            for(var i = 0; i < self._howls.length; i++){\n                if (self._howls[i]._webAudio) for(var j = 0; j < self._howls[i]._sounds.length; j++){\n                    if (!self._howls[i]._sounds[j]._paused) return self;\n                }\n            }\n            if (self._suspendTimer) clearTimeout(self._suspendTimer);\n            // If no sound has played after 30 seconds, suspend the context.\n            self._suspendTimer = setTimeout(function() {\n                if (!self.autoSuspend) return;\n                self._suspendTimer = null;\n                self.state = \"suspending\";\n                // Handle updating the state of the audio context after suspending.\n                var handleSuspension = function() {\n                    self.state = \"suspended\";\n                    if (self._resumeAfterSuspend) {\n                        delete self._resumeAfterSuspend;\n                        self._autoResume();\n                    }\n                };\n                // Either the state gets suspended or it is interrupted.\n                // Either way, we need to update the state to suspended.\n                self.ctx.suspend().then(handleSuspension, handleSuspension);\n            }, 30000);\n            return self;\n        },\n        /**\n     * Automatically resume the Web Audio AudioContext when a new sound is played.\n     * @return {Howler}\n     */ _autoResume: function() {\n            var self = this;\n            if (!self.ctx || typeof self.ctx.resume === \"undefined\" || !Howler1.usingWebAudio) return;\n            if (self.state === \"running\" && self.ctx.state !== \"interrupted\" && self._suspendTimer) {\n                clearTimeout(self._suspendTimer);\n                self._suspendTimer = null;\n            } else if (self.state === \"suspended\" || self.state === \"running\" && self.ctx.state === \"interrupted\") {\n                self.ctx.resume().then(function() {\n                    self.state = \"running\";\n                    // Emit to all Howls that the audio has resumed.\n                    for(var i = 0; i < self._howls.length; i++)self._howls[i]._emit(\"resume\");\n                });\n                if (self._suspendTimer) {\n                    clearTimeout(self._suspendTimer);\n                    self._suspendTimer = null;\n                }\n            } else if (self.state === \"suspending\") self._resumeAfterSuspend = true;\n            return self;\n        }\n    };\n    // Setup the global audio controller.\n    var Howler1 = new HowlerGlobal1();\n    /** Group Methods **/ /***************************************************************************/ /**\n   * Create an audio group controller.\n   * @param {Object} o Passed in properties for this group.\n   */ var Howl1 = function(o) {\n        var self = this;\n        // Throw an error if no source is provided.\n        if (!o.src || o.src.length === 0) {\n            console.error(\"An array of source files must be passed with any new Howl.\");\n            return;\n        }\n        self.init(o);\n    };\n    Howl1.prototype = {\n        /**\n     * Initialize a new Howl group object.\n     * @param  {Object} o Passed in properties for this group.\n     * @return {Howl}\n     */ init: function(o) {\n            var self = this;\n            // If we don't have an AudioContext created yet, run the setup.\n            if (!Howler1.ctx) setupAudioContext();\n            // Setup user-defined default properties.\n            self._autoplay = o.autoplay || false;\n            self._format = typeof o.format !== \"string\" ? o.format : [\n                o.format\n            ];\n            self._html5 = o.html5 || false;\n            self._muted = o.mute || false;\n            self._loop = o.loop || false;\n            self._pool = o.pool || 5;\n            self._preload = typeof o.preload === \"boolean\" || o.preload === \"metadata\" ? o.preload : true;\n            self._rate = o.rate || 1;\n            self._sprite = o.sprite || {};\n            self._src = typeof o.src !== \"string\" ? o.src : [\n                o.src\n            ];\n            self._volume = o.volume !== undefined ? o.volume : 1;\n            self._xhr = {\n                method: o.xhr && o.xhr.method ? o.xhr.method : \"GET\",\n                headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,\n                withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false\n            };\n            // Setup all other default properties.\n            self._duration = 0;\n            self._state = \"unloaded\";\n            self._sounds = [];\n            self._endTimers = {};\n            self._queue = [];\n            self._playLock = false;\n            // Setup event listeners.\n            self._onend = o.onend ? [\n                {\n                    fn: o.onend\n                }\n            ] : [];\n            self._onfade = o.onfade ? [\n                {\n                    fn: o.onfade\n                }\n            ] : [];\n            self._onload = o.onload ? [\n                {\n                    fn: o.onload\n                }\n            ] : [];\n            self._onloaderror = o.onloaderror ? [\n                {\n                    fn: o.onloaderror\n                }\n            ] : [];\n            self._onplayerror = o.onplayerror ? [\n                {\n                    fn: o.onplayerror\n                }\n            ] : [];\n            self._onpause = o.onpause ? [\n                {\n                    fn: o.onpause\n                }\n            ] : [];\n            self._onplay = o.onplay ? [\n                {\n                    fn: o.onplay\n                }\n            ] : [];\n            self._onstop = o.onstop ? [\n                {\n                    fn: o.onstop\n                }\n            ] : [];\n            self._onmute = o.onmute ? [\n                {\n                    fn: o.onmute\n                }\n            ] : [];\n            self._onvolume = o.onvolume ? [\n                {\n                    fn: o.onvolume\n                }\n            ] : [];\n            self._onrate = o.onrate ? [\n                {\n                    fn: o.onrate\n                }\n            ] : [];\n            self._onseek = o.onseek ? [\n                {\n                    fn: o.onseek\n                }\n            ] : [];\n            self._onunlock = o.onunlock ? [\n                {\n                    fn: o.onunlock\n                }\n            ] : [];\n            self._onresume = [];\n            // Web Audio or HTML5 Audio?\n            self._webAudio = Howler1.usingWebAudio && !self._html5;\n            // Automatically try to enable audio.\n            if (typeof Howler1.ctx !== \"undefined\" && Howler1.ctx && Howler1.autoUnlock) Howler1._unlockAudio();\n            // Keep track of this Howl group in the global controller.\n            Howler1._howls.push(self);\n            // If they selected autoplay, add a play event to the load queue.\n            if (self._autoplay) self._queue.push({\n                event: \"play\",\n                action: function() {\n                    self.play();\n                }\n            });\n            // Load the source file unless otherwise specified.\n            if (self._preload && self._preload !== \"none\") self.load();\n            return self;\n        },\n        /**\n     * Load the audio file.\n     * @return {Howler}\n     */ load: function() {\n            var self = this;\n            var url = null;\n            // If no audio is available, quit immediately.\n            if (Howler1.noAudio) {\n                self._emit(\"loaderror\", null, \"No audio support.\");\n                return;\n            }\n            // Make sure our source is in an array.\n            if (typeof self._src === \"string\") self._src = [\n                self._src\n            ];\n            // Loop through the sources and pick the first one that is compatible.\n            for(var i = 0; i < self._src.length; i++){\n                var ext, str;\n                if (self._format && self._format[i]) // If an extension was specified, use that instead.\n                ext = self._format[i];\n                else {\n                    // Make sure the source is a string.\n                    str = self._src[i];\n                    if (typeof str !== \"string\") {\n                        self._emit(\"loaderror\", null, \"Non-string found in selected audio sources - ignoring.\");\n                        continue;\n                    }\n                    // Extract the file extension from the URL or base64 data URI.\n                    ext = /^data:audio\\/([^;,]+);/i.exec(str);\n                    if (!ext) ext = /\\.([^.]+)$/.exec(str.split(\"?\", 1)[0]);\n                    if (ext) ext = ext[1].toLowerCase();\n                }\n                // Log a warning if no extension was found.\n                if (!ext) console.warn('No file extension was found. Consider using the \"format\" property or specify an extension.');\n                // Check if this extension is available.\n                if (ext && Howler1.codecs(ext)) {\n                    url = self._src[i];\n                    break;\n                }\n            }\n            if (!url) {\n                self._emit(\"loaderror\", null, \"No codec support for selected audio sources.\");\n                return;\n            }\n            self._src = url;\n            self._state = \"loading\";\n            // If the hosting page is HTTPS and the source isn't,\n            // drop down to HTML5 Audio to avoid Mixed Content errors.\n            if (window.location.protocol === \"https:\" && url.slice(0, 5) === \"http:\") {\n                self._html5 = true;\n                self._webAudio = false;\n            }\n            // Create a new sound object and add it to the pool.\n            new Sound1(self);\n            // Load and decode the audio data for playback.\n            if (self._webAudio) loadBuffer(self);\n            return self;\n        },\n        /**\n     * Play a sound or resume previous playback.\n     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Number}          Sound ID.\n     */ play: function(sprite, internal) {\n            var self = this;\n            var id = null;\n            // Determine if a sprite, sound id or nothing was passed\n            if (typeof sprite === \"number\") {\n                id = sprite;\n                sprite = null;\n            } else if (typeof sprite === \"string\" && self._state === \"loaded\" && !self._sprite[sprite]) // If the passed sprite doesn't exist, do nothing.\n            return null;\n            else if (typeof sprite === \"undefined\") {\n                // Use the default sound sprite (plays the full audio length).\n                sprite = \"__default\";\n                // Check if there is a single paused sound that isn't ended.\n                // If there is, play that sound. If not, continue as usual.\n                if (!self._playLock) {\n                    var num = 0;\n                    for(var i = 0; i < self._sounds.length; i++)if (self._sounds[i]._paused && !self._sounds[i]._ended) {\n                        num++;\n                        id = self._sounds[i]._id;\n                    }\n                    if (num === 1) sprite = null;\n                    else id = null;\n                }\n            }\n            // Get the selected node, or get one from the pool.\n            var sound = id ? self._soundById(id) : self._inactiveSound();\n            // If the sound doesn't exist, do nothing.\n            if (!sound) return null;\n            // Select the sprite definition.\n            if (id && !sprite) sprite = sound._sprite || \"__default\";\n            // If the sound hasn't loaded, we must wait to get the audio's duration.\n            // We also need to wait to make sure we don't run into race conditions with\n            // the order of function calls.\n            if (self._state !== \"loaded\") {\n                // Set the sprite value on this sound.\n                sound._sprite = sprite;\n                // Mark this sound as not ended in case another sound is played before this one loads.\n                sound._ended = false;\n                // Add the sound to the queue to be played on load.\n                var soundId = sound._id;\n                self._queue.push({\n                    event: \"play\",\n                    action: function() {\n                        self.play(soundId);\n                    }\n                });\n                return soundId;\n            }\n            // Don't play the sound if an id was passed and it is already playing.\n            if (id && !sound._paused) {\n                // Trigger the play event, in order to keep iterating through queue.\n                if (!internal) self._loadQueue(\"play\");\n                return sound._id;\n            }\n            // Make sure the AudioContext isn't suspended, and resume it if it is.\n            if (self._webAudio) Howler1._autoResume();\n            // Determine how long to play for and where to start playing.\n            var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\n            var duration = Math.max(0, (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000 - seek);\n            var timeout = duration * 1000 / Math.abs(sound._rate);\n            var start = self._sprite[sprite][0] / 1000;\n            var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\n            sound._sprite = sprite;\n            // Mark the sound as ended instantly so that this async playback\n            // doesn't get grabbed by another call to play while this one waits to start.\n            sound._ended = false;\n            // Update the parameters of the sound.\n            var setParams = function() {\n                sound._paused = false;\n                sound._seek = seek;\n                sound._start = start;\n                sound._stop = stop;\n                sound._loop = !!(sound._loop || self._sprite[sprite][2]);\n            };\n            // End the sound instantly if seek is at the end.\n            if (seek >= stop) {\n                self._ended(sound);\n                return;\n            }\n            // Begin the actual playback.\n            var node = sound._node;\n            if (self._webAudio) {\n                // Fire this when the sound is ready to play to begin Web Audio playback.\n                var playWebAudio = function() {\n                    self._playLock = false;\n                    setParams();\n                    self._refreshBuffer(sound);\n                    // Setup the playback params.\n                    var vol = sound._muted || self._muted ? 0 : sound._volume;\n                    node.gain.setValueAtTime(vol, Howler1.ctx.currentTime);\n                    sound._playStart = Howler1.ctx.currentTime;\n                    // Play the sound using the supported method.\n                    if (typeof node.bufferSource.start === \"undefined\") sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\n                    else sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\n                    // Start a new timer if none is present.\n                    if (timeout !== Infinity) self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n                    if (!internal) setTimeout(function() {\n                        self._emit(\"play\", sound._id);\n                        self._loadQueue();\n                    }, 0);\n                };\n                if (Howler1.state === \"running\" && Howler1.ctx.state !== \"interrupted\") playWebAudio();\n                else {\n                    self._playLock = true;\n                    // Wait for the audio context to resume before playing.\n                    self.once(\"resume\", playWebAudio);\n                    // Cancel the end timer.\n                    self._clearTimer(sound._id);\n                }\n            } else {\n                // Fire this when the sound is ready to play to begin HTML5 Audio playback.\n                var playHtml5 = function() {\n                    node.currentTime = seek;\n                    node.muted = sound._muted || self._muted || Howler1._muted || node.muted;\n                    node.volume = sound._volume * Howler1.volume();\n                    node.playbackRate = sound._rate;\n                    // Some browsers will throw an error if this is called without user interaction.\n                    try {\n                        var play = node.play();\n                        // Support older browsers that don't support promises, and thus don't have this issue.\n                        if (play && typeof Promise !== \"undefined\" && (play instanceof Promise || typeof play.then === \"function\")) {\n                            // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().\n                            self._playLock = true;\n                            // Set param values immediately.\n                            setParams();\n                            // Releases the lock and executes queued actions.\n                            play.then(function() {\n                                self._playLock = false;\n                                node._unlocked = true;\n                                if (!internal) self._emit(\"play\", sound._id);\n                                else self._loadQueue();\n                            }).catch(function() {\n                                self._playLock = false;\n                                self._emit(\"playerror\", sound._id, \"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.\");\n                                // Reset the ended and paused values.\n                                sound._ended = true;\n                                sound._paused = true;\n                            });\n                        } else if (!internal) {\n                            self._playLock = false;\n                            setParams();\n                            self._emit(\"play\", sound._id);\n                        }\n                        // Setting rate before playing won't work in IE, so we set it again here.\n                        node.playbackRate = sound._rate;\n                        // If the node is still paused, then we can assume there was a playback issue.\n                        if (node.paused) {\n                            self._emit(\"playerror\", sound._id, \"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.\");\n                            return;\n                        }\n                        // Setup the end timer on sprites or listen for the ended event.\n                        if (sprite !== \"__default\" || sound._loop) self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n                        else {\n                            self._endTimers[sound._id] = function() {\n                                // Fire ended on this audio node.\n                                self._ended(sound);\n                                // Clear this listener.\n                                node.removeEventListener(\"ended\", self._endTimers[sound._id], false);\n                            };\n                            node.addEventListener(\"ended\", self._endTimers[sound._id], false);\n                        }\n                    } catch (err) {\n                        self._emit(\"playerror\", sound._id, err);\n                    }\n                };\n                // If this is streaming audio, make sure the src is set and load again.\n                if (node.src === \"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA\") {\n                    node.src = self._src;\n                    node.load();\n                }\n                // Play immediately if ready, or wait for the 'canplaythrough'e vent.\n                var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler1._navigator.isCocoonJS;\n                if (node.readyState >= 3 || loadedNoReadyState) playHtml5();\n                else {\n                    self._playLock = true;\n                    self._state = \"loading\";\n                    var listener = function() {\n                        self._state = \"loaded\";\n                        // Begin playback.\n                        playHtml5();\n                        // Clear this listener.\n                        node.removeEventListener(Howler1._canPlayEvent, listener, false);\n                    };\n                    node.addEventListener(Howler1._canPlayEvent, listener, false);\n                    // Cancel the end timer.\n                    self._clearTimer(sound._id);\n                }\n            }\n            return sound._id;\n        },\n        /**\n     * Pause playback and save current position.\n     * @param  {Number} id The sound ID (empty to pause all in group).\n     * @return {Howl}\n     */ pause: function(id) {\n            var self = this;\n            // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.\n            if (self._state !== \"loaded\" || self._playLock) {\n                self._queue.push({\n                    event: \"pause\",\n                    action: function() {\n                        self.pause(id);\n                    }\n                });\n                return self;\n            }\n            // If no id is passed, get all ID's to be paused.\n            var ids = self._getSoundIds(id);\n            for(var i = 0; i < ids.length; i++){\n                // Clear the end timer.\n                self._clearTimer(ids[i]);\n                // Get the sound.\n                var sound = self._soundById(ids[i]);\n                if (sound && !sound._paused) {\n                    // Reset the seek position.\n                    sound._seek = self.seek(ids[i]);\n                    sound._rateSeek = 0;\n                    sound._paused = true;\n                    // Stop currently running fades.\n                    self._stopFade(ids[i]);\n                    if (sound._node) {\n                        if (self._webAudio) {\n                            // Make sure the sound has been created.\n                            if (!sound._node.bufferSource) continue;\n                            if (typeof sound._node.bufferSource.stop === \"undefined\") sound._node.bufferSource.noteOff(0);\n                            else sound._node.bufferSource.stop(0);\n                            // Clean up the buffer source.\n                            self._cleanBuffer(sound._node);\n                        } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) sound._node.pause();\n                    }\n                }\n                // Fire the pause event, unless `true` is passed as the 2nd argument.\n                if (!arguments[1]) self._emit(\"pause\", sound ? sound._id : null);\n            }\n            return self;\n        },\n        /**\n     * Stop playback and reset to start.\n     * @param  {Number} id The sound ID (empty to stop all in group).\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Howl}\n     */ stop: function(id, internal) {\n            var self = this;\n            // If the sound hasn't loaded, add it to the load queue to stop when capable.\n            if (self._state !== \"loaded\" || self._playLock) {\n                self._queue.push({\n                    event: \"stop\",\n                    action: function() {\n                        self.stop(id);\n                    }\n                });\n                return self;\n            }\n            // If no id is passed, get all ID's to be stopped.\n            var ids = self._getSoundIds(id);\n            for(var i = 0; i < ids.length; i++){\n                // Clear the end timer.\n                self._clearTimer(ids[i]);\n                // Get the sound.\n                var sound = self._soundById(ids[i]);\n                if (sound) {\n                    // Reset the seek position.\n                    sound._seek = sound._start || 0;\n                    sound._rateSeek = 0;\n                    sound._paused = true;\n                    sound._ended = true;\n                    // Stop currently running fades.\n                    self._stopFade(ids[i]);\n                    if (sound._node) {\n                        if (self._webAudio) // Make sure the sound's AudioBufferSourceNode has been created.\n                        {\n                            if (sound._node.bufferSource) {\n                                if (typeof sound._node.bufferSource.stop === \"undefined\") sound._node.bufferSource.noteOff(0);\n                                else sound._node.bufferSource.stop(0);\n                                // Clean up the buffer source.\n                                self._cleanBuffer(sound._node);\n                            }\n                        } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n                            sound._node.currentTime = sound._start || 0;\n                            sound._node.pause();\n                            // If this is a live stream, stop download once the audio is stopped.\n                            if (sound._node.duration === Infinity) self._clearSound(sound._node);\n                        }\n                    }\n                    if (!internal) self._emit(\"stop\", sound._id);\n                }\n            }\n            return self;\n        },\n        /**\n     * Mute/unmute a single sound or all sounds in this Howl group.\n     * @param  {Boolean} muted Set to true to mute and false to unmute.\n     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\n     * @return {Howl}\n     */ mute: function(muted, id) {\n            var self = this;\n            // If the sound hasn't loaded, add it to the load queue to mute when capable.\n            if (self._state !== \"loaded\" || self._playLock) {\n                self._queue.push({\n                    event: \"mute\",\n                    action: function() {\n                        self.mute(muted, id);\n                    }\n                });\n                return self;\n            }\n            // If applying mute/unmute to all sounds, update the group's value.\n            if (typeof id === \"undefined\") {\n                if (typeof muted === \"boolean\") self._muted = muted;\n                else return self._muted;\n            }\n            // If no id is passed, get all ID's to be muted.\n            var ids = self._getSoundIds(id);\n            for(var i = 0; i < ids.length; i++){\n                // Get the sound.\n                var sound = self._soundById(ids[i]);\n                if (sound) {\n                    sound._muted = muted;\n                    // Cancel active fade and set the volume to the end value.\n                    if (sound._interval) self._stopFade(sound._id);\n                    if (self._webAudio && sound._node) sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler1.ctx.currentTime);\n                    else if (sound._node) sound._node.muted = Howler1._muted ? true : muted;\n                    self._emit(\"mute\", sound._id);\n                }\n            }\n            return self;\n        },\n        /**\n     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\n     *   volume() -> Returns the group's volume value.\n     *   volume(id) -> Returns the sound id's current volume.\n     *   volume(vol) -> Sets the volume of all sounds in this Howl group.\n     *   volume(vol, id) -> Sets the volume of passed sound id.\n     * @return {Howl/Number} Returns self or current volume.\n     */ volume: function() {\n            var self = this;\n            var args = arguments;\n            var vol, id;\n            // Determine the values based on arguments.\n            if (args.length === 0) // Return the value of the groups' volume.\n            return self._volume;\n            else if (args.length === 1 || args.length === 2 && typeof args[1] === \"undefined\") {\n                // First check if this is an ID, and if not, assume it is a new volume.\n                var ids = self._getSoundIds();\n                var index = ids.indexOf(args[0]);\n                if (index >= 0) id = parseInt(args[0], 10);\n                else vol = parseFloat(args[0]);\n            } else if (args.length >= 2) {\n                vol = parseFloat(args[0]);\n                id = parseInt(args[1], 10);\n            }\n            // Update the volume or return the current volume.\n            var sound;\n            if (typeof vol !== \"undefined\" && vol >= 0 && vol <= 1) {\n                // If the sound hasn't loaded, add it to the load queue to change volume when capable.\n                if (self._state !== \"loaded\" || self._playLock) {\n                    self._queue.push({\n                        event: \"volume\",\n                        action: function() {\n                            self.volume.apply(self, args);\n                        }\n                    });\n                    return self;\n                }\n                // Set the group volume.\n                if (typeof id === \"undefined\") self._volume = vol;\n                // Update one or all volumes.\n                id = self._getSoundIds(id);\n                for(var i = 0; i < id.length; i++){\n                    // Get the sound.\n                    sound = self._soundById(id[i]);\n                    if (sound) {\n                        sound._volume = vol;\n                        // Stop currently running fades.\n                        if (!args[2]) self._stopFade(id[i]);\n                        if (self._webAudio && sound._node && !sound._muted) sound._node.gain.setValueAtTime(vol, Howler1.ctx.currentTime);\n                        else if (sound._node && !sound._muted) sound._node.volume = vol * Howler1.volume();\n                        self._emit(\"volume\", sound._id);\n                    }\n                }\n            } else {\n                sound = id ? self._soundById(id) : self._sounds[0];\n                return sound ? sound._volume : 0;\n            }\n            return self;\n        },\n        /**\n     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id (omit to fade all sounds).\n     * @return {Howl}\n     */ fade: function(from, to, len, id) {\n            var self = this;\n            // If the sound hasn't loaded, add it to the load queue to fade when capable.\n            if (self._state !== \"loaded\" || self._playLock) {\n                self._queue.push({\n                    event: \"fade\",\n                    action: function() {\n                        self.fade(from, to, len, id);\n                    }\n                });\n                return self;\n            }\n            // Make sure the to/from/len values are numbers.\n            from = Math.min(Math.max(0, parseFloat(from)), 1);\n            to = Math.min(Math.max(0, parseFloat(to)), 1);\n            len = parseFloat(len);\n            // Set the volume to the start position.\n            self.volume(from, id);\n            // Fade the volume of one or all sounds.\n            var ids = self._getSoundIds(id);\n            for(var i = 0; i < ids.length; i++){\n                // Get the sound.\n                var sound = self._soundById(ids[i]);\n                // Create a linear fade or fall back to timeouts with HTML5 Audio.\n                if (sound) {\n                    // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\n                    if (!id) self._stopFade(ids[i]);\n                    // If we are using Web Audio, let the native methods do the actual fade.\n                    if (self._webAudio && !sound._muted) {\n                        var currentTime = Howler1.ctx.currentTime;\n                        var end = currentTime + len / 1000;\n                        sound._volume = from;\n                        sound._node.gain.setValueAtTime(from, currentTime);\n                        sound._node.gain.linearRampToValueAtTime(to, end);\n                    }\n                    self._startFadeInterval(sound, from, to, len, ids[i], typeof id === \"undefined\");\n                }\n            }\n            return self;\n        },\n        /**\n     * Starts the internal interval to fade a sound.\n     * @param  {Object} sound Reference to sound to fade.\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id to fade.\n     * @param  {Boolean} isGroup   If true, set the volume on the group.\n     */ _startFadeInterval: function(sound, from, to, len, id, isGroup) {\n            var self = this;\n            var vol = from;\n            var diff = to - from;\n            var steps = Math.abs(diff / 0.01);\n            var stepLen = Math.max(4, steps > 0 ? len / steps : len);\n            var lastTick = Date.now();\n            // Store the value being faded to.\n            sound._fadeTo = to;\n            // Update the volume value on each interval tick.\n            sound._interval = setInterval(function() {\n                // Update the volume based on the time since the last tick.\n                var tick = (Date.now() - lastTick) / len;\n                lastTick = Date.now();\n                vol += diff * tick;\n                // Round to within 2 decimal points.\n                vol = Math.round(vol * 100) / 100;\n                // Make sure the volume is in the right bounds.\n                if (diff < 0) vol = Math.max(to, vol);\n                else vol = Math.min(to, vol);\n                // Change the volume.\n                if (self._webAudio) sound._volume = vol;\n                else self.volume(vol, sound._id, true);\n                // Set the group's volume.\n                if (isGroup) self._volume = vol;\n                // When the fade is complete, stop it and fire event.\n                if (to < from && vol <= to || to > from && vol >= to) {\n                    clearInterval(sound._interval);\n                    sound._interval = null;\n                    sound._fadeTo = null;\n                    self.volume(to, sound._id);\n                    self._emit(\"fade\", sound._id);\n                }\n            }, stepLen);\n        },\n        /**\n     * Internal method that stops the currently playing fade when\n     * a new fade starts, volume is changed or the sound is stopped.\n     * @param  {Number} id The sound id.\n     * @return {Howl}\n     */ _stopFade: function(id) {\n            var self = this;\n            var sound = self._soundById(id);\n            if (sound && sound._interval) {\n                if (self._webAudio) sound._node.gain.cancelScheduledValues(Howler1.ctx.currentTime);\n                clearInterval(sound._interval);\n                sound._interval = null;\n                self.volume(sound._fadeTo, id);\n                sound._fadeTo = null;\n                self._emit(\"fade\", id);\n            }\n            return self;\n        },\n        /**\n     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   loop() -> Returns the group's loop value.\n     *   loop(id) -> Returns the sound id's loop value.\n     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\n     *   loop(loop, id) -> Sets the loop value of passed sound id.\n     * @return {Howl/Boolean} Returns self or current loop value.\n     */ loop: function() {\n            var self = this;\n            var args = arguments;\n            var loop, id, sound;\n            // Determine the values for loop and id.\n            if (args.length === 0) // Return the grou's loop value.\n            return self._loop;\n            else if (args.length === 1) {\n                if (typeof args[0] === \"boolean\") {\n                    loop = args[0];\n                    self._loop = loop;\n                } else {\n                    // Return this sound's loop value.\n                    sound = self._soundById(parseInt(args[0], 10));\n                    return sound ? sound._loop : false;\n                }\n            } else if (args.length === 2) {\n                loop = args[0];\n                id = parseInt(args[1], 10);\n            }\n            // If no id is passed, get all ID's to be looped.\n            var ids = self._getSoundIds(id);\n            for(var i = 0; i < ids.length; i++){\n                sound = self._soundById(ids[i]);\n                if (sound) {\n                    sound._loop = loop;\n                    if (self._webAudio && sound._node && sound._node.bufferSource) {\n                        sound._node.bufferSource.loop = loop;\n                        if (loop) {\n                            sound._node.bufferSource.loopStart = sound._start || 0;\n                            sound._node.bufferSource.loopEnd = sound._stop;\n                            // If playing, restart playback to ensure looping updates.\n                            if (self.playing(ids[i])) {\n                                self.pause(ids[i], true);\n                                self.play(ids[i], true);\n                            }\n                        }\n                    }\n                }\n            }\n            return self;\n        },\n        /**\n     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   rate() -> Returns the first sound node's current playback rate.\n     *   rate(id) -> Returns the sound id's current playback rate.\n     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\n     *   rate(rate, id) -> Sets the playback rate of passed sound id.\n     * @return {Howl/Number} Returns self or the current playback rate.\n     */ rate: function() {\n            var self = this;\n            var args = arguments;\n            var rate, id;\n            // Determine the values based on arguments.\n            if (args.length === 0) // We will simply return the current rate of the first node.\n            id = self._sounds[0]._id;\n            else if (args.length === 1) {\n                // First check if this is an ID, and if not, assume it is a new rate value.\n                var ids = self._getSoundIds();\n                var index = ids.indexOf(args[0]);\n                if (index >= 0) id = parseInt(args[0], 10);\n                else rate = parseFloat(args[0]);\n            } else if (args.length === 2) {\n                rate = parseFloat(args[0]);\n                id = parseInt(args[1], 10);\n            }\n            // Update the playback rate or return the current value.\n            var sound;\n            if (typeof rate === \"number\") {\n                // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\n                if (self._state !== \"loaded\" || self._playLock) {\n                    self._queue.push({\n                        event: \"rate\",\n                        action: function() {\n                            self.rate.apply(self, args);\n                        }\n                    });\n                    return self;\n                }\n                // Set the group rate.\n                if (typeof id === \"undefined\") self._rate = rate;\n                // Update one or all volumes.\n                id = self._getSoundIds(id);\n                for(var i = 0; i < id.length; i++){\n                    // Get the sound.\n                    sound = self._soundById(id[i]);\n                    if (sound) {\n                        // Keep track of our position when the rate changed and update the playback\n                        // start position so we can properly adjust the seek position for time elapsed.\n                        if (self.playing(id[i])) {\n                            sound._rateSeek = self.seek(id[i]);\n                            sound._playStart = self._webAudio ? Howler1.ctx.currentTime : sound._playStart;\n                        }\n                        sound._rate = rate;\n                        // Change the playback rate.\n                        if (self._webAudio && sound._node && sound._node.bufferSource) sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler1.ctx.currentTime);\n                        else if (sound._node) sound._node.playbackRate = rate;\n                        // Reset the timers.\n                        var seek = self.seek(id[i]);\n                        var duration = (self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000 - seek;\n                        var timeout = duration * 1000 / Math.abs(sound._rate);\n                        // Start a new end timer if sound is already playing.\n                        if (self._endTimers[id[i]] || !sound._paused) {\n                            self._clearTimer(id[i]);\n                            self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\n                        }\n                        self._emit(\"rate\", sound._id);\n                    }\n                }\n            } else {\n                sound = self._soundById(id);\n                return sound ? sound._rate : self._rate;\n            }\n            return self;\n        },\n        /**\n     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   seek() -> Returns the first sound node's current seek position.\n     *   seek(id) -> Returns the sound id's current seek position.\n     *   seek(seek) -> Sets the seek position of the first sound node.\n     *   seek(seek, id) -> Sets the seek position of passed sound id.\n     * @return {Howl/Number} Returns self or the current seek position.\n     */ seek: function() {\n            var self = this;\n            var args = arguments;\n            var seek, id;\n            // Determine the values based on arguments.\n            if (args.length === 0) // We will simply return the current position of the first node.\n            {\n                if (self._sounds.length) id = self._sounds[0]._id;\n            } else if (args.length === 1) {\n                // First check if this is an ID, and if not, assume it is a new seek position.\n                var ids = self._getSoundIds();\n                var index = ids.indexOf(args[0]);\n                if (index >= 0) id = parseInt(args[0], 10);\n                else if (self._sounds.length) {\n                    id = self._sounds[0]._id;\n                    seek = parseFloat(args[0]);\n                }\n            } else if (args.length === 2) {\n                seek = parseFloat(args[0]);\n                id = parseInt(args[1], 10);\n            }\n            // If there is no ID, bail out.\n            if (typeof id === \"undefined\") return 0;\n            // If the sound hasn't loaded, add it to the load queue to seek when capable.\n            if (typeof seek === \"number\" && (self._state !== \"loaded\" || self._playLock)) {\n                self._queue.push({\n                    event: \"seek\",\n                    action: function() {\n                        self.seek.apply(self, args);\n                    }\n                });\n                return self;\n            }\n            // Get the sound.\n            var sound = self._soundById(id);\n            if (sound) {\n                if (typeof seek === \"number\" && seek >= 0) {\n                    // Pause the sound and update position for restarting playback.\n                    var playing = self.playing(id);\n                    if (playing) self.pause(id, true);\n                    // Move the position of the track and cancel timer.\n                    sound._seek = seek;\n                    sound._ended = false;\n                    self._clearTimer(id);\n                    // Update the seek position for HTML5 Audio.\n                    if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) sound._node.currentTime = seek;\n                    // Seek and emit when ready.\n                    var seekAndEmit = function() {\n                        // Restart the playback if the sound was playing.\n                        if (playing) self.play(id, true);\n                        self._emit(\"seek\", id);\n                    };\n                    // Wait for the play lock to be unset before emitting (HTML5 Audio).\n                    if (playing && !self._webAudio) {\n                        var emitSeek = function() {\n                            if (!self._playLock) seekAndEmit();\n                            else setTimeout(emitSeek, 0);\n                        };\n                        setTimeout(emitSeek, 0);\n                    } else seekAndEmit();\n                } else {\n                    if (self._webAudio) {\n                        var realTime = self.playing(id) ? Howler1.ctx.currentTime - sound._playStart : 0;\n                        var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\n                        return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\n                    } else return sound._node.currentTime;\n                }\n            }\n            return self;\n        },\n        /**\n     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\n     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\n     * @return {Boolean} True if playing and false if not.\n     */ playing: function(id) {\n            var self = this;\n            // Check the passed sound ID (if any).\n            if (typeof id === \"number\") {\n                var sound = self._soundById(id);\n                return sound ? !sound._paused : false;\n            }\n            // Otherwise, loop through all sounds and check if any are playing.\n            for(var i = 0; i < self._sounds.length; i++){\n                if (!self._sounds[i]._paused) return true;\n            }\n            return false;\n        },\n        /**\n     * Get the duration of this sound. Passing a sound id will return the sprite duration.\n     * @param  {Number} id The sound id to check. If none is passed, return full source duration.\n     * @return {Number} Audio duration in seconds.\n     */ duration: function(id) {\n            var self = this;\n            var duration = self._duration;\n            // If we pass an ID, get the sound and return the sprite length.\n            var sound = self._soundById(id);\n            if (sound) duration = self._sprite[sound._sprite][1] / 1000;\n            return duration;\n        },\n        /**\n     * Returns the current loaded state of this Howl.\n     * @return {String} 'unloaded', 'loading', 'loaded'\n     */ state: function() {\n            return this._state;\n        },\n        /**\n     * Unload and destroy the current Howl object.\n     * This will immediately stop all sound instances attached to this group.\n     */ unload: function() {\n            var self = this;\n            // Stop playing any active sounds.\n            var sounds = self._sounds;\n            for(var i = 0; i < sounds.length; i++){\n                // Stop the sound if it is currently playing.\n                if (!sounds[i]._paused) self.stop(sounds[i]._id);\n                // Remove the source or disconnect.\n                if (!self._webAudio) {\n                    // Set the source to 0-second silence to stop any downloading (except in IE).\n                    self._clearSound(sounds[i]._node);\n                    // Remove any event listeners.\n                    sounds[i]._node.removeEventListener(\"error\", sounds[i]._errorFn, false);\n                    sounds[i]._node.removeEventListener(Howler1._canPlayEvent, sounds[i]._loadFn, false);\n                    sounds[i]._node.removeEventListener(\"ended\", sounds[i]._endFn, false);\n                    // Release the Audio object back to the pool.\n                    Howler1._releaseHtml5Audio(sounds[i]._node);\n                }\n                // Empty out all of the nodes.\n                delete sounds[i]._node;\n                // Make sure all timers are cleared out.\n                self._clearTimer(sounds[i]._id);\n            }\n            // Remove the references in the global Howler object.\n            var index = Howler1._howls.indexOf(self);\n            if (index >= 0) Howler1._howls.splice(index, 1);\n            // Delete this sound from the cache (if no other Howl is using it).\n            var remCache = true;\n            for(i = 0; i < Howler1._howls.length; i++)if (Howler1._howls[i]._src === self._src || self._src.indexOf(Howler1._howls[i]._src) >= 0) {\n                remCache = false;\n                break;\n            }\n            if (cache && remCache) delete cache[self._src];\n            // Clear global errors.\n            Howler1.noAudio = false;\n            // Clear out `self`.\n            self._state = \"unloaded\";\n            self._sounds = [];\n            self = null;\n            return null;\n        },\n        /**\n     * Listen to a custom event.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\n     * @return {Howl}\n     */ on: function(event, fn, id, once) {\n            var self = this;\n            var events = self[\"_on\" + event];\n            if (typeof fn === \"function\") events.push(once ? {\n                id: id,\n                fn: fn,\n                once: once\n            } : {\n                id: id,\n                fn: fn\n            });\n            return self;\n        },\n        /**\n     * Remove a custom event. Call without parameters to remove all events.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to remove. Leave empty to remove all.\n     * @param  {Number}   id    (optional) Only remove events for this sound.\n     * @return {Howl}\n     */ off: function(event, fn, id) {\n            var self = this;\n            var events = self[\"_on\" + event];\n            var i = 0;\n            // Allow passing just an event and ID.\n            if (typeof fn === \"number\") {\n                id = fn;\n                fn = null;\n            }\n            if (fn || id) // Loop through event store and remove the passed function.\n            for(i = 0; i < events.length; i++){\n                var isId = id === events[i].id;\n                if (fn === events[i].fn && isId || !fn && isId) {\n                    events.splice(i, 1);\n                    break;\n                }\n            }\n            else if (event) // Clear out all events of this type.\n            self[\"_on\" + event] = [];\n            else {\n                // Clear out all events of every type.\n                var keys = Object.keys(self);\n                for(i = 0; i < keys.length; i++)if (keys[i].indexOf(\"_on\") === 0 && Array.isArray(self[keys[i]])) self[keys[i]] = [];\n            }\n            return self;\n        },\n        /**\n     * Listen to a custom event and remove it once fired.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @return {Howl}\n     */ once: function(event, fn, id) {\n            var self = this;\n            // Setup the event listener.\n            self.on(event, fn, id, 1);\n            return self;\n        },\n        /**\n     * Emit all events of a specific type and pass the sound id.\n     * @param  {String} event Event name.\n     * @param  {Number} id    Sound ID.\n     * @param  {Number} msg   Message to go with event.\n     * @return {Howl}\n     */ _emit: function(event, id, msg) {\n            var self = this;\n            var events = self[\"_on\" + event];\n            // Loop through event store and fire all functions.\n            for(var i = events.length - 1; i >= 0; i--)// Only fire the listener if the correct ID is used.\n            if (!events[i].id || events[i].id === id || event === \"load\") {\n                setTimeout((function(fn) {\n                    fn.call(this, id, msg);\n                }).bind(self, events[i].fn), 0);\n                // If this event was setup with `once`, remove it.\n                if (events[i].once) self.off(event, events[i].fn, events[i].id);\n            }\n            // Pass the event type into load queue so that it can continue stepping.\n            self._loadQueue(event);\n            return self;\n        },\n        /**\n     * Queue of actions initiated before the sound has loaded.\n     * These will be called in sequence, with the next only firing\n     * after the previous has finished executing (even if async like play).\n     * @return {Howl}\n     */ _loadQueue: function(event) {\n            var self = this;\n            if (self._queue.length > 0) {\n                var task = self._queue[0];\n                // Remove this task if a matching event was passed.\n                if (task.event === event) {\n                    self._queue.shift();\n                    self._loadQueue();\n                }\n                // Run the task if no event type is passed.\n                if (!event) task.action();\n            }\n            return self;\n        },\n        /**\n     * Fired when playback ends at the end of the duration.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */ _ended: function(sound) {\n            var self = this;\n            var sprite = sound._sprite;\n            // If we are using IE and there was network latency we may be clipping\n            // audio before it completes playing. Lets check the node to make sure it\n            // believes it has completed, before ending the playback.\n            if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {\n                setTimeout(self._ended.bind(self, sound), 100);\n                return self;\n            }\n            // Should this sound loop?\n            var loop = !!(sound._loop || self._sprite[sprite][2]);\n            // Fire the ended event.\n            self._emit(\"end\", sound._id);\n            // Restart the playback for HTML5 Audio loop.\n            if (!self._webAudio && loop) self.stop(sound._id, true).play(sound._id);\n            // Restart this timer if on a Web Audio loop.\n            if (self._webAudio && loop) {\n                self._emit(\"play\", sound._id);\n                sound._seek = sound._start || 0;\n                sound._rateSeek = 0;\n                sound._playStart = Howler1.ctx.currentTime;\n                var timeout = (sound._stop - sound._start) * 1000 / Math.abs(sound._rate);\n                self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n            // Mark the node as paused.\n            if (self._webAudio && !loop) {\n                sound._paused = true;\n                sound._ended = true;\n                sound._seek = sound._start || 0;\n                sound._rateSeek = 0;\n                self._clearTimer(sound._id);\n                // Clean up the buffer source.\n                self._cleanBuffer(sound._node);\n                // Attempt to auto-suspend AudioContext if no sounds are still playing.\n                Howler1._autoSuspend();\n            }\n            // When using a sprite, end the track.\n            if (!self._webAudio && !loop) self.stop(sound._id, true);\n            return self;\n        },\n        /**\n     * Clear the end timer for a sound playback.\n     * @param  {Number} id The sound ID.\n     * @return {Howl}\n     */ _clearTimer: function(id) {\n            var self = this;\n            if (self._endTimers[id]) {\n                // Clear the timeout or remove the ended listener.\n                if (typeof self._endTimers[id] !== \"function\") clearTimeout(self._endTimers[id]);\n                else {\n                    var sound = self._soundById(id);\n                    if (sound && sound._node) sound._node.removeEventListener(\"ended\", self._endTimers[id], false);\n                }\n                delete self._endTimers[id];\n            }\n            return self;\n        },\n        /**\n     * Return the sound identified by this ID, or return null.\n     * @param  {Number} id Sound ID\n     * @return {Object}    Sound object or null.\n     */ _soundById: function(id) {\n            var self = this;\n            // Loop through all sounds and find the one with this ID.\n            for(var i = 0; i < self._sounds.length; i++){\n                if (id === self._sounds[i]._id) return self._sounds[i];\n            }\n            return null;\n        },\n        /**\n     * Return an inactive sound from the pool or create a new one.\n     * @return {Sound} Sound playback object.\n     */ _inactiveSound: function() {\n            var self = this;\n            self._drain();\n            // Find the first inactive node to recycle.\n            for(var i = 0; i < self._sounds.length; i++){\n                if (self._sounds[i]._ended) return self._sounds[i].reset();\n            }\n            // If no inactive node was found, create a new one.\n            return new Sound1(self);\n        },\n        /**\n     * Drain excess inactive sounds from the pool.\n     */ _drain: function() {\n            var self = this;\n            var limit = self._pool;\n            var cnt = 0;\n            var i = 0;\n            // If there are less sounds than the max pool size, we are done.\n            if (self._sounds.length < limit) return;\n            // Count the number of inactive sounds.\n            for(i = 0; i < self._sounds.length; i++)if (self._sounds[i]._ended) cnt++;\n            // Remove excess inactive sounds, going in reverse order.\n            for(i = self._sounds.length - 1; i >= 0; i--){\n                if (cnt <= limit) return;\n                if (self._sounds[i]._ended) {\n                    // Disconnect the audio source when using Web Audio.\n                    if (self._webAudio && self._sounds[i]._node) self._sounds[i]._node.disconnect(0);\n                    // Remove sounds until we have the pool size.\n                    self._sounds.splice(i, 1);\n                    cnt--;\n                }\n            }\n        },\n        /**\n     * Get all ID's from the sounds pool.\n     * @param  {Number} id Only return one ID if one is passed.\n     * @return {Array}    Array of IDs.\n     */ _getSoundIds: function(id) {\n            var self = this;\n            if (typeof id === \"undefined\") {\n                var ids = [];\n                for(var i = 0; i < self._sounds.length; i++)ids.push(self._sounds[i]._id);\n                return ids;\n            } else return [\n                id\n            ];\n        },\n        /**\n     * Load the sound back into the buffer source.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */ _refreshBuffer: function(sound) {\n            var self = this;\n            // Setup the buffer source for playback.\n            sound._node.bufferSource = Howler1.ctx.createBufferSource();\n            sound._node.bufferSource.buffer = cache[self._src];\n            // Connect to the correct node.\n            if (sound._panner) sound._node.bufferSource.connect(sound._panner);\n            else sound._node.bufferSource.connect(sound._node);\n            // Setup looping and playback rate.\n            sound._node.bufferSource.loop = sound._loop;\n            if (sound._loop) {\n                sound._node.bufferSource.loopStart = sound._start || 0;\n                sound._node.bufferSource.loopEnd = sound._stop || 0;\n            }\n            sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler1.ctx.currentTime);\n            return self;\n        },\n        /**\n     * Prevent memory leaks by cleaning up the buffer source after playback.\n     * @param  {Object} node Sound's audio node containing the buffer source.\n     * @return {Howl}\n     */ _cleanBuffer: function(node) {\n            var self = this;\n            var isIOS = Howler1._navigator && Howler1._navigator.vendor.indexOf(\"Apple\") >= 0;\n            if (!node.bufferSource) return self;\n            if (Howler1._scratchBuffer && node.bufferSource) {\n                node.bufferSource.onended = null;\n                node.bufferSource.disconnect(0);\n                if (isIOS) try {\n                    node.bufferSource.buffer = Howler1._scratchBuffer;\n                } catch (e) {}\n            }\n            node.bufferSource = null;\n            return self;\n        },\n        /**\n     * Set the source to a 0-second silence to stop any downloading (except in IE).\n     * @param  {Object} node Audio node to clear.\n     */ _clearSound: function(node) {\n            var checkIE = /MSIE |Trident\\//.test(Howler1._navigator && Howler1._navigator.userAgent);\n            if (!checkIE) node.src = \"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA\";\n        }\n    };\n    /** Single Sound Methods **/ /***************************************************************************/ /**\n   * Setup the sound object, which each node attached to a Howl group is contained in.\n   * @param {Object} howl The Howl parent group.\n   */ var Sound1 = function(howl) {\n        this._parent = howl;\n        this.init();\n    };\n    Sound1.prototype = {\n        /**\n     * Initialize a new Sound object.\n     * @return {Sound}\n     */ init: function() {\n            var self = this;\n            var parent = self._parent;\n            // Setup the default parameters.\n            self._muted = parent._muted;\n            self._loop = parent._loop;\n            self._volume = parent._volume;\n            self._rate = parent._rate;\n            self._seek = 0;\n            self._paused = true;\n            self._ended = true;\n            self._sprite = \"__default\";\n            // Generate a unique ID for this sound.\n            self._id = ++Howler1._counter;\n            // Add itself to the parent's pool.\n            parent._sounds.push(self);\n            // Create the new node.\n            self.create();\n            return self;\n        },\n        /**\n     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\n     * @return {Sound}\n     */ create: function() {\n            var self = this;\n            var parent = self._parent;\n            var volume = Howler1._muted || self._muted || self._parent._muted ? 0 : self._volume;\n            if (parent._webAudio) {\n                // Create the gain node for controlling volume (the source will connect to this).\n                self._node = typeof Howler1.ctx.createGain === \"undefined\" ? Howler1.ctx.createGainNode() : Howler1.ctx.createGain();\n                self._node.gain.setValueAtTime(volume, Howler1.ctx.currentTime);\n                self._node.paused = true;\n                self._node.connect(Howler1.masterGain);\n            } else if (!Howler1.noAudio) {\n                // Get an unlocked Audio object from the pool.\n                self._node = Howler1._obtainHtml5Audio();\n                // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\n                self._errorFn = self._errorListener.bind(self);\n                self._node.addEventListener(\"error\", self._errorFn, false);\n                // Listen for 'canplaythrough' event to let us know the sound is ready.\n                self._loadFn = self._loadListener.bind(self);\n                self._node.addEventListener(Howler1._canPlayEvent, self._loadFn, false);\n                // Listen for the 'ended' event on the sound to account for edge-case where\n                // a finite sound has a duration of Infinity.\n                self._endFn = self._endListener.bind(self);\n                self._node.addEventListener(\"ended\", self._endFn, false);\n                // Setup the new audio node.\n                self._node.src = parent._src;\n                self._node.preload = parent._preload === true ? \"auto\" : parent._preload;\n                self._node.volume = volume * Howler1.volume();\n                // Begin loading the source.\n                self._node.load();\n            }\n            return self;\n        },\n        /**\n     * Reset the parameters of this sound to the original state (for recycle).\n     * @return {Sound}\n     */ reset: function() {\n            var self = this;\n            var parent = self._parent;\n            // Reset all of the parameters of this sound.\n            self._muted = parent._muted;\n            self._loop = parent._loop;\n            self._volume = parent._volume;\n            self._rate = parent._rate;\n            self._seek = 0;\n            self._rateSeek = 0;\n            self._paused = true;\n            self._ended = true;\n            self._sprite = \"__default\";\n            // Generate a new ID so that it isn't confused with the previous sound.\n            self._id = ++Howler1._counter;\n            return self;\n        },\n        /**\n     * HTML5 Audio error listener callback.\n     */ _errorListener: function() {\n            var self = this;\n            // Fire an error event and pass back the code.\n            self._parent._emit(\"loaderror\", self._id, self._node.error ? self._node.error.code : 0);\n            // Clear the event listener.\n            self._node.removeEventListener(\"error\", self._errorFn, false);\n        },\n        /**\n     * HTML5 Audio canplaythrough listener callback.\n     */ _loadListener: function() {\n            var self = this;\n            var parent = self._parent;\n            // Round up the duration to account for the lower precision in HTML5 Audio.\n            parent._duration = Math.ceil(self._node.duration * 10) / 10;\n            // Setup a sprite if none is defined.\n            if (Object.keys(parent._sprite).length === 0) parent._sprite = {\n                __default: [\n                    0,\n                    parent._duration * 1000\n                ]\n            };\n            if (parent._state !== \"loaded\") {\n                parent._state = \"loaded\";\n                parent._emit(\"load\");\n                parent._loadQueue();\n            }\n            // Clear the event listener.\n            self._node.removeEventListener(Howler1._canPlayEvent, self._loadFn, false);\n        },\n        /**\n     * HTML5 Audio ended listener callback.\n     */ _endListener: function() {\n            var self = this;\n            var parent = self._parent;\n            // Only handle the `ended`` event if the duration is Infinity.\n            if (parent._duration === Infinity) {\n                // Update the parent duration to match the real audio duration.\n                // Round up the duration to account for the lower precision in HTML5 Audio.\n                parent._duration = Math.ceil(self._node.duration * 10) / 10;\n                // Update the sprite that corresponds to the real duration.\n                if (parent._sprite.__default[1] === Infinity) parent._sprite.__default[1] = parent._duration * 1000;\n                // Run the regular ended method.\n                parent._ended(self);\n            }\n            // Clear the event listener since the duration is now correct.\n            self._node.removeEventListener(\"ended\", self._endFn, false);\n        }\n    };\n    /** Helper Methods **/ /***************************************************************************/ var cache = {};\n    /**\n   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\n   * @param  {Howl} self\n   */ var loadBuffer = function(self) {\n        var url = self._src;\n        // Check if the buffer has already been cached and use it instead.\n        if (cache[url]) {\n            // Set the duration from the cache.\n            self._duration = cache[url].duration;\n            // Load the sound into this Howl.\n            loadSound(self);\n            return;\n        }\n        if (/^data:[^;]+;base64,/.test(url)) {\n            // Decode the base64 data URI without XHR, since some browsers don't support it.\n            var data = atob(url.split(\",\")[1]);\n            var dataView = new Uint8Array(data.length);\n            for(var i = 0; i < data.length; ++i)dataView[i] = data.charCodeAt(i);\n            decodeAudioData(dataView.buffer, self);\n        } else {\n            // Load the buffer from the URL.\n            var xhr = new XMLHttpRequest();\n            xhr.open(self._xhr.method, url, true);\n            xhr.withCredentials = self._xhr.withCredentials;\n            xhr.responseType = \"arraybuffer\";\n            // Apply any custom headers to the request.\n            if (self._xhr.headers) Object.keys(self._xhr.headers).forEach(function(key) {\n                xhr.setRequestHeader(key, self._xhr.headers[key]);\n            });\n            xhr.onload = function() {\n                // Make sure we get a successful response back.\n                var code = (xhr.status + \"\")[0];\n                if (code !== \"0\" && code !== \"2\" && code !== \"3\") {\n                    self._emit(\"loaderror\", null, \"Failed loading audio file with status: \" + xhr.status + \".\");\n                    return;\n                }\n                decodeAudioData(xhr.response, self);\n            };\n            xhr.onerror = function() {\n                // If there is an error, switch to HTML5 Audio.\n                if (self._webAudio) {\n                    self._html5 = true;\n                    self._webAudio = false;\n                    self._sounds = [];\n                    delete cache[url];\n                    self.load();\n                }\n            };\n            safeXhrSend(xhr);\n        }\n    };\n    /**\n   * Send the XHR request wrapped in a try/catch.\n   * @param  {Object} xhr XHR to send.\n   */ var safeXhrSend = function(xhr) {\n        try {\n            xhr.send();\n        } catch (e) {\n            xhr.onerror();\n        }\n    };\n    /**\n   * Decode audio data from an array buffer.\n   * @param  {ArrayBuffer} arraybuffer The audio data.\n   * @param  {Howl}        self\n   */ var decodeAudioData = function(arraybuffer, self) {\n        // Fire a load error if something broke.\n        var error = function() {\n            self._emit(\"loaderror\", null, \"Decoding audio data failed.\");\n        };\n        // Load the sound on success.\n        var success = function(buffer) {\n            if (buffer && self._sounds.length > 0) {\n                cache[self._src] = buffer;\n                loadSound(self, buffer);\n            } else error();\n        };\n        // Decode the buffer into an audio source.\n        if (typeof Promise !== \"undefined\" && Howler1.ctx.decodeAudioData.length === 1) Howler1.ctx.decodeAudioData(arraybuffer).then(success).catch(error);\n        else Howler1.ctx.decodeAudioData(arraybuffer, success, error);\n    };\n    /**\n   * Sound is now loaded, so finish setting everything up and fire the loaded event.\n   * @param  {Howl} self\n   * @param  {Object} buffer The decoded buffer sound source.\n   */ var loadSound = function(self, buffer) {\n        // Set the duration.\n        if (buffer && !self._duration) self._duration = buffer.duration;\n        // Setup a sprite if none is defined.\n        if (Object.keys(self._sprite).length === 0) self._sprite = {\n            __default: [\n                0,\n                self._duration * 1000\n            ]\n        };\n        // Fire the loaded event.\n        if (self._state !== \"loaded\") {\n            self._state = \"loaded\";\n            self._emit(\"load\");\n            self._loadQueue();\n        }\n    };\n    /**\n   * Setup the audio context when available, or switch to HTML5 Audio mode.\n   */ var setupAudioContext = function() {\n        // If we have already detected that Web Audio isn't supported, don't run this step again.\n        if (!Howler1.usingWebAudio) return;\n        // Check if we are using Web Audio and setup the AudioContext if we are.\n        try {\n            if (typeof AudioContext !== \"undefined\") Howler1.ctx = new AudioContext();\n            else if (typeof webkitAudioContext !== \"undefined\") Howler1.ctx = new webkitAudioContext();\n            else Howler1.usingWebAudio = false;\n        } catch (e) {\n            Howler1.usingWebAudio = false;\n        }\n        // If the audio context creation still failed, set using web audio to false.\n        if (!Howler1.ctx) Howler1.usingWebAudio = false;\n        // Check if a webview is being used on iOS8 or earlier (rather than the browser).\n        // If it is, disable Web Audio as it causes crashing.\n        var iOS = /iP(hone|od|ad)/.test(Howler1._navigator && Howler1._navigator.platform);\n        var appVersion = Howler1._navigator && Howler1._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n        var version = appVersion ? parseInt(appVersion[1], 10) : null;\n        if (iOS && version && version < 9) {\n            var safari = /safari/.test(Howler1._navigator && Howler1._navigator.userAgent.toLowerCase());\n            if (Howler1._navigator && !safari) Howler1.usingWebAudio = false;\n        }\n        // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\n        if (Howler1.usingWebAudio) {\n            Howler1.masterGain = typeof Howler1.ctx.createGain === \"undefined\" ? Howler1.ctx.createGainNode() : Howler1.ctx.createGain();\n            Howler1.masterGain.gain.setValueAtTime(Howler1._muted ? 0 : Howler1._volume, Howler1.ctx.currentTime);\n            Howler1.masterGain.connect(Howler1.ctx.destination);\n        }\n        // Re-run the setup on Howler.\n        Howler1._setup();\n    };\n    // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\n    if (typeof define === \"function\" && define.amd) define([], function() {\n        return {\n            Howler: Howler1,\n            Howl: Howl1\n        };\n    });\n    $f89d8ffbdc18f2ab$export$c9d39ca3bcd93abb = Howler1;\n    $f89d8ffbdc18f2ab$export$b791fe48eec8032a = Howl1;\n    // Add to global in Node.js (for testing, etc).\n    if (typeof $parcel$global !== \"undefined\") {\n        $parcel$global.HowlerGlobal = HowlerGlobal1;\n        $parcel$global.Howler = Howler1;\n        $parcel$global.Howl = Howl1;\n        $parcel$global.Sound = Sound1;\n    } else if (typeof window !== \"undefined\") {\n        window.HowlerGlobal = HowlerGlobal1;\n        window.Howler = Howler1;\n        window.Howl = Howl1;\n        window.Sound = Sound1;\n    }\n})();\n/*!\n *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\n *  \n *  howler.js v2.2.4\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */ (function() {\n    \"use strict\";\n    // Setup default properties.\n    HowlerGlobal.prototype._pos = [\n        0,\n        0,\n        0\n    ];\n    HowlerGlobal.prototype._orientation = [\n        0,\n        0,\n        -1,\n        0,\n        1,\n        0\n    ];\n    /** Global Methods **/ /***************************************************************************/ /**\n   * Helper method to update the stereo panning position of all current Howls.\n   * Future Howls will not use this value unless explicitly set.\n   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @return {Howler/Number}     Self or current stereo panning value.\n   */ HowlerGlobal.prototype.stereo = function(pan) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self.ctx || !self.ctx.listener) return self;\n        // Loop through all Howls and update their stereo panning.\n        for(var i = self._howls.length - 1; i >= 0; i--)self._howls[i].stereo(pan);\n        return self;\n    };\n    /**\n   * Get/set the position of the listener in 3D cartesian space. Sounds using\n   * 3D position will be relative to the listener's position.\n   * @param  {Number} x The x-position of the listener.\n   * @param  {Number} y The y-position of the listener.\n   * @param  {Number} z The z-position of the listener.\n   * @return {Howler/Array}   Self or current listener position.\n   */ HowlerGlobal.prototype.pos = function(x, y, z) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self.ctx || !self.ctx.listener) return self;\n        // Set the defaults for optional 'y' & 'z'.\n        y = typeof y !== \"number\" ? self._pos[1] : y;\n        z = typeof z !== \"number\" ? self._pos[2] : z;\n        if (typeof x === \"number\") {\n            self._pos = [\n                x,\n                y,\n                z\n            ];\n            if (typeof self.ctx.listener.positionX !== \"undefined\") {\n                self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);\n            } else self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\n        } else return self._pos;\n        return self;\n    };\n    /**\n   * Get/set the direction the listener is pointing in the 3D cartesian space.\n   * A front and up vector must be provided. The front is the direction the\n   * face of the listener is pointing, and up is the direction the top of the\n   * listener is pointing. Thus, these values are expected to be at right angles\n   * from each other.\n   * @param  {Number} x   The x-orientation of the listener.\n   * @param  {Number} y   The y-orientation of the listener.\n   * @param  {Number} z   The z-orientation of the listener.\n   * @param  {Number} xUp The x-orientation of the top of the listener.\n   * @param  {Number} yUp The y-orientation of the top of the listener.\n   * @param  {Number} zUp The z-orientation of the top of the listener.\n   * @return {Howler/Array}     Returns self or the current orientation vectors.\n   */ HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self.ctx || !self.ctx.listener) return self;\n        // Set the defaults for optional 'y' & 'z'.\n        var or = self._orientation;\n        y = typeof y !== \"number\" ? or[1] : y;\n        z = typeof z !== \"number\" ? or[2] : z;\n        xUp = typeof xUp !== \"number\" ? or[3] : xUp;\n        yUp = typeof yUp !== \"number\" ? or[4] : yUp;\n        zUp = typeof zUp !== \"number\" ? or[5] : zUp;\n        if (typeof x === \"number\") {\n            self._orientation = [\n                x,\n                y,\n                z,\n                xUp,\n                yUp,\n                zUp\n            ];\n            if (typeof self.ctx.listener.forwardX !== \"undefined\") {\n                self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);\n            } else self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\n        } else return or;\n        return self;\n    };\n    /** Group Methods **/ /***************************************************************************/ /**\n   * Add new properties to the core init.\n   * @param  {Function} _super Core init method.\n   * @return {Howl}\n   */ Howl.prototype.init = function(_super) {\n        return function(o) {\n            var self = this;\n            // Setup user-defined default properties.\n            self._orientation = o.orientation || [\n                1,\n                0,\n                0\n            ];\n            self._stereo = o.stereo || null;\n            self._pos = o.pos || null;\n            self._pannerAttr = {\n                coneInnerAngle: typeof o.coneInnerAngle !== \"undefined\" ? o.coneInnerAngle : 360,\n                coneOuterAngle: typeof o.coneOuterAngle !== \"undefined\" ? o.coneOuterAngle : 360,\n                coneOuterGain: typeof o.coneOuterGain !== \"undefined\" ? o.coneOuterGain : 0,\n                distanceModel: typeof o.distanceModel !== \"undefined\" ? o.distanceModel : \"inverse\",\n                maxDistance: typeof o.maxDistance !== \"undefined\" ? o.maxDistance : 10000,\n                panningModel: typeof o.panningModel !== \"undefined\" ? o.panningModel : \"HRTF\",\n                refDistance: typeof o.refDistance !== \"undefined\" ? o.refDistance : 1,\n                rolloffFactor: typeof o.rolloffFactor !== \"undefined\" ? o.rolloffFactor : 1\n            };\n            // Setup event listeners.\n            self._onstereo = o.onstereo ? [\n                {\n                    fn: o.onstereo\n                }\n            ] : [];\n            self._onpos = o.onpos ? [\n                {\n                    fn: o.onpos\n                }\n            ] : [];\n            self._onorientation = o.onorientation ? [\n                {\n                    fn: o.onorientation\n                }\n            ] : [];\n            // Complete initilization with howler.js core's init function.\n            return _super.call(this, o);\n        };\n    }(Howl.prototype.init);\n    /**\n   * Get/set the stereo panning of the audio source for this sound or all in the group.\n   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Number}    Returns self or the current stereo panning value.\n   */ Howl.prototype.stereo = function(pan, id) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self._webAudio) return self;\n        // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\n        if (self._state !== \"loaded\") {\n            self._queue.push({\n                event: \"stereo\",\n                action: function() {\n                    self.stereo(pan, id);\n                }\n            });\n            return self;\n        }\n        // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\n        var pannerType = typeof Howler.ctx.createStereoPanner === \"undefined\" ? \"spatial\" : \"stereo\";\n        // Setup the group's stereo panning if no ID is passed.\n        if (typeof id === \"undefined\") {\n            // Return the group's stereo panning if no parameters are passed.\n            if (typeof pan === \"number\") {\n                self._stereo = pan;\n                self._pos = [\n                    pan,\n                    0,\n                    0\n                ];\n            } else return self._stereo;\n        }\n        // Change the streo panning of one or all sounds in group.\n        var ids = self._getSoundIds(id);\n        for(var i = 0; i < ids.length; i++){\n            // Get the sound.\n            var sound = self._soundById(ids[i]);\n            if (sound) {\n                if (typeof pan === \"number\") {\n                    sound._stereo = pan;\n                    sound._pos = [\n                        pan,\n                        0,\n                        0\n                    ];\n                    if (sound._node) {\n                        // If we are falling back, make sure the panningModel is equalpower.\n                        sound._pannerAttr.panningModel = \"equalpower\";\n                        // Check if there is a panner setup and create a new one if not.\n                        if (!sound._panner || !sound._panner.pan) setupPanner(sound, pannerType);\n                        if (pannerType === \"spatial\") {\n                            if (typeof sound._panner.positionX !== \"undefined\") {\n                                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);\n                                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);\n                                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);\n                            } else sound._panner.setPosition(pan, 0, 0);\n                        } else sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);\n                    }\n                    self._emit(\"stereo\", sound._id);\n                } else return sound._stereo;\n            }\n        }\n        return self;\n    };\n    /**\n   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.\n   * @param  {Number} x  The x-position of the audio source.\n   * @param  {Number} y  The y-position of the audio source.\n   * @param  {Number} z  The z-position of the audio source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\n   */ Howl.prototype.pos = function(x, y, z, id) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self._webAudio) return self;\n        // If the sound hasn't loaded, add it to the load queue to change position when capable.\n        if (self._state !== \"loaded\") {\n            self._queue.push({\n                event: \"pos\",\n                action: function() {\n                    self.pos(x, y, z, id);\n                }\n            });\n            return self;\n        }\n        // Set the defaults for optional 'y' & 'z'.\n        y = typeof y !== \"number\" ? 0 : y;\n        z = typeof z !== \"number\" ? -0.5 : z;\n        // Setup the group's spatial position if no ID is passed.\n        if (typeof id === \"undefined\") {\n            // Return the group's spatial position if no parameters are passed.\n            if (typeof x === \"number\") self._pos = [\n                x,\n                y,\n                z\n            ];\n            else return self._pos;\n        }\n        // Change the spatial position of one or all sounds in group.\n        var ids = self._getSoundIds(id);\n        for(var i = 0; i < ids.length; i++){\n            // Get the sound.\n            var sound = self._soundById(ids[i]);\n            if (sound) {\n                if (typeof x === \"number\") {\n                    sound._pos = [\n                        x,\n                        y,\n                        z\n                    ];\n                    if (sound._node) {\n                        // Check if there is a panner setup and create a new one if not.\n                        if (!sound._panner || sound._panner.pan) setupPanner(sound, \"spatial\");\n                        if (typeof sound._panner.positionX !== \"undefined\") {\n                            sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);\n                            sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);\n                            sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);\n                        } else sound._panner.setPosition(x, y, z);\n                    }\n                    self._emit(\"pos\", sound._id);\n                } else return sound._pos;\n            }\n        }\n        return self;\n    };\n    /**\n   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\n   * space. Depending on how direction the sound is, based on the `cone` attributes,\n   * a sound pointing away from the listener can be quiet or silent.\n   * @param  {Number} x  The x-orientation of the source.\n   * @param  {Number} y  The y-orientation of the source.\n   * @param  {Number} z  The z-orientation of the source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\n   */ Howl.prototype.orientation = function(x, y, z, id) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self._webAudio) return self;\n        // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\n        if (self._state !== \"loaded\") {\n            self._queue.push({\n                event: \"orientation\",\n                action: function() {\n                    self.orientation(x, y, z, id);\n                }\n            });\n            return self;\n        }\n        // Set the defaults for optional 'y' & 'z'.\n        y = typeof y !== \"number\" ? self._orientation[1] : y;\n        z = typeof z !== \"number\" ? self._orientation[2] : z;\n        // Setup the group's spatial orientation if no ID is passed.\n        if (typeof id === \"undefined\") {\n            // Return the group's spatial orientation if no parameters are passed.\n            if (typeof x === \"number\") self._orientation = [\n                x,\n                y,\n                z\n            ];\n            else return self._orientation;\n        }\n        // Change the spatial orientation of one or all sounds in group.\n        var ids = self._getSoundIds(id);\n        for(var i = 0; i < ids.length; i++){\n            // Get the sound.\n            var sound = self._soundById(ids[i]);\n            if (sound) {\n                if (typeof x === \"number\") {\n                    sound._orientation = [\n                        x,\n                        y,\n                        z\n                    ];\n                    if (sound._node) {\n                        // Check if there is a panner setup and create a new one if not.\n                        if (!sound._panner) {\n                            // Make sure we have a position to setup the node with.\n                            if (!sound._pos) sound._pos = self._pos || [\n                                0,\n                                0,\n                                -0.5\n                            ];\n                            setupPanner(sound, \"spatial\");\n                        }\n                        if (typeof sound._panner.orientationX !== \"undefined\") {\n                            sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);\n                            sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);\n                            sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);\n                        } else sound._panner.setOrientation(x, y, z);\n                    }\n                    self._emit(\"orientation\", sound._id);\n                } else return sound._orientation;\n            }\n        }\n        return self;\n    };\n    /**\n   * Get/set the panner node's attributes for a sound or group of sounds.\n   * This method can optionall take 0, 1 or 2 arguments.\n   *   pannerAttr() -> Returns the group's values.\n   *   pannerAttr(id) -> Returns the sound id's values.\n   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\n   *   pannerAttr(o, id) -> Set's the values of passed sound id.\n   *\n   *   Attributes:\n   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      inside of which there will be no volume reduction.\n   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.\n   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the\n   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.\n   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from\n   *                     listener. Can be `linear`, `inverse` or `exponential.\n   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume\n   *                   will not be reduced any further.\n   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.\n   *                   This is simply a variable of the distance model and has a different effect depending on which model\n   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.\n   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a\n   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`\n   *                     with `inverse` and `exponential`.\n   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\n   *                     Can be `HRTF` or `equalpower`.\n   *\n   * @return {Howl/Object} Returns self or current panner attributes.\n   */ Howl.prototype.pannerAttr = function() {\n        var self = this;\n        var args = arguments;\n        var o, id, sound;\n        // Stop right here if not using Web Audio.\n        if (!self._webAudio) return self;\n        // Determine the values based on arguments.\n        if (args.length === 0) // Return the group's panner attribute values.\n        return self._pannerAttr;\n        else if (args.length === 1) {\n            if (typeof args[0] === \"object\") {\n                o = args[0];\n                // Set the grou's panner attribute values.\n                if (typeof id === \"undefined\") {\n                    if (!o.pannerAttr) o.pannerAttr = {\n                        coneInnerAngle: o.coneInnerAngle,\n                        coneOuterAngle: o.coneOuterAngle,\n                        coneOuterGain: o.coneOuterGain,\n                        distanceModel: o.distanceModel,\n                        maxDistance: o.maxDistance,\n                        refDistance: o.refDistance,\n                        rolloffFactor: o.rolloffFactor,\n                        panningModel: o.panningModel\n                    };\n                    self._pannerAttr = {\n                        coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== \"undefined\" ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,\n                        coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== \"undefined\" ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,\n                        coneOuterGain: typeof o.pannerAttr.coneOuterGain !== \"undefined\" ? o.pannerAttr.coneOuterGain : self._coneOuterGain,\n                        distanceModel: typeof o.pannerAttr.distanceModel !== \"undefined\" ? o.pannerAttr.distanceModel : self._distanceModel,\n                        maxDistance: typeof o.pannerAttr.maxDistance !== \"undefined\" ? o.pannerAttr.maxDistance : self._maxDistance,\n                        refDistance: typeof o.pannerAttr.refDistance !== \"undefined\" ? o.pannerAttr.refDistance : self._refDistance,\n                        rolloffFactor: typeof o.pannerAttr.rolloffFactor !== \"undefined\" ? o.pannerAttr.rolloffFactor : self._rolloffFactor,\n                        panningModel: typeof o.pannerAttr.panningModel !== \"undefined\" ? o.pannerAttr.panningModel : self._panningModel\n                    };\n                }\n            } else {\n                // Return this sound's panner attribute values.\n                sound = self._soundById(parseInt(args[0], 10));\n                return sound ? sound._pannerAttr : self._pannerAttr;\n            }\n        } else if (args.length === 2) {\n            o = args[0];\n            id = parseInt(args[1], 10);\n        }\n        // Update the values of the specified sounds.\n        var ids = self._getSoundIds(id);\n        for(var i = 0; i < ids.length; i++){\n            sound = self._soundById(ids[i]);\n            if (sound) {\n                // Merge the new values into the sound.\n                var pa = sound._pannerAttr;\n                pa = {\n                    coneInnerAngle: typeof o.coneInnerAngle !== \"undefined\" ? o.coneInnerAngle : pa.coneInnerAngle,\n                    coneOuterAngle: typeof o.coneOuterAngle !== \"undefined\" ? o.coneOuterAngle : pa.coneOuterAngle,\n                    coneOuterGain: typeof o.coneOuterGain !== \"undefined\" ? o.coneOuterGain : pa.coneOuterGain,\n                    distanceModel: typeof o.distanceModel !== \"undefined\" ? o.distanceModel : pa.distanceModel,\n                    maxDistance: typeof o.maxDistance !== \"undefined\" ? o.maxDistance : pa.maxDistance,\n                    refDistance: typeof o.refDistance !== \"undefined\" ? o.refDistance : pa.refDistance,\n                    rolloffFactor: typeof o.rolloffFactor !== \"undefined\" ? o.rolloffFactor : pa.rolloffFactor,\n                    panningModel: typeof o.panningModel !== \"undefined\" ? o.panningModel : pa.panningModel\n                };\n                // Create a new panner node if one doesn't already exist.\n                var panner = sound._panner;\n                if (!panner) {\n                    // Make sure we have a position to setup the node with.\n                    if (!sound._pos) sound._pos = self._pos || [\n                        0,\n                        0,\n                        -0.5\n                    ];\n                    // Create a new panner node.\n                    setupPanner(sound, \"spatial\");\n                    panner = sound._panner;\n                }\n                // Update the panner values or create a new panner if none exists.\n                panner.coneInnerAngle = pa.coneInnerAngle;\n                panner.coneOuterAngle = pa.coneOuterAngle;\n                panner.coneOuterGain = pa.coneOuterGain;\n                panner.distanceModel = pa.distanceModel;\n                panner.maxDistance = pa.maxDistance;\n                panner.refDistance = pa.refDistance;\n                panner.rolloffFactor = pa.rolloffFactor;\n                panner.panningModel = pa.panningModel;\n            }\n        }\n        return self;\n    };\n    /** Single Sound Methods **/ /***************************************************************************/ /**\n   * Add new properties to the core Sound init.\n   * @param  {Function} _super Core Sound init method.\n   * @return {Sound}\n   */ Sound.prototype.init = function(_super) {\n        return function() {\n            var self = this;\n            var parent = self._parent;\n            // Setup user-defined default properties.\n            self._orientation = parent._orientation;\n            self._stereo = parent._stereo;\n            self._pos = parent._pos;\n            self._pannerAttr = parent._pannerAttr;\n            // Complete initilization with howler.js core Sound's init function.\n            _super.call(this);\n            // If a stereo or position was specified, set it up.\n            if (self._stereo) parent.stereo(self._stereo);\n            else if (self._pos) parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n        };\n    }(Sound.prototype.init);\n    /**\n   * Override the Sound.reset method to clean up properties from the spatial plugin.\n   * @param  {Function} _super Sound reset method.\n   * @return {Sound}\n   */ Sound.prototype.reset = function(_super) {\n        return function() {\n            var self = this;\n            var parent = self._parent;\n            // Reset all spatial plugin properties on this sound.\n            self._orientation = parent._orientation;\n            self._stereo = parent._stereo;\n            self._pos = parent._pos;\n            self._pannerAttr = parent._pannerAttr;\n            // If a stereo or position was specified, set it up.\n            if (self._stereo) parent.stereo(self._stereo);\n            else if (self._pos) parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n            else if (self._panner) {\n                // Disconnect the panner.\n                self._panner.disconnect(0);\n                self._panner = undefined;\n                parent._refreshBuffer(self);\n            }\n            // Complete resetting of the sound.\n            return _super.call(this);\n        };\n    }(Sound.prototype.reset);\n    /** Helper Methods **/ /***************************************************************************/ /**\n   * Create a new panner node and save it on the sound.\n   * @param  {Sound} sound Specific sound to setup panning on.\n   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\n   */ var setupPanner = function(sound, type) {\n        type = type || \"spatial\";\n        // Create the new panner node.\n        if (type === \"spatial\") {\n            sound._panner = Howler.ctx.createPanner();\n            sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\n            sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\n            sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\n            sound._panner.distanceModel = sound._pannerAttr.distanceModel;\n            sound._panner.maxDistance = sound._pannerAttr.maxDistance;\n            sound._panner.refDistance = sound._pannerAttr.refDistance;\n            sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\n            sound._panner.panningModel = sound._pannerAttr.panningModel;\n            if (typeof sound._panner.positionX !== \"undefined\") {\n                sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);\n                sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);\n                sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);\n            } else sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\n            if (typeof sound._panner.orientationX !== \"undefined\") {\n                sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);\n                sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);\n                sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);\n            } else sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\n        } else {\n            sound._panner = Howler.ctx.createStereoPanner();\n            sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);\n        }\n        sound._panner.connect(sound._node);\n        // Update the connections.\n        if (!sound._paused) sound._parent.pause(sound._id, true).play(sound._id, true);\n    };\n})();\n\n\nclass $f761722007ed7192$export$5564cffdff00d859 {\n    preload() {\n        this.tracks.set(\"titleScreen\", new (0, $f89d8ffbdc18f2ab$export$b791fe48eec8032a)({\n            src: [\n                \"./assets/audio/titlescreen.mp3\"\n            ],\n            volume: 0.01\n        }));\n        const allTracks = Array.from(this.tracks.values());\n        return Promise.all(allTracks.map((howl)=>new Promise((resolve)=>howl.once(\"load\", resolve))));\n    }\n    playTitleScreenMusic() {\n        this.tracks.get(\"titleScreen\").play();\n    }\n    constructor(){\n        this.tracks = new Map();\n    }\n}\n\n\nclass $e46db5192eb49d53$var$Game {\n    constructor(){\n        // Keep this public as main menu needs to be able to play\n        // music before the game has started.\n        this.audioController = new (0, $f761722007ed7192$export$5564cffdff00d859)();\n        this.app = new (0, $2202931bfc9ee5c9$export$16975c34e60e1e61)();\n        this.controller = new (0, $a93d756e0c61289b$export$bd0bf19f25da8474)(this.app);\n    }\n    async start() {\n        const screenHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n        const screenWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n        const constrainByWidth = screenHeight * 16 / 9 > screenWidth;\n        await this.app.init({\n            width: constrainByWidth ? screenWidth : Math.floor(screenHeight * 16 / 9),\n            height: constrainByWidth ? Math.floor(screenWidth / 16 * 9) : screenHeight,\n            resolution: window.devicePixelRatio || 1,\n            antialias: true,\n            autoDensity: true\n        });\n        document.body.appendChild(this.app.canvas);\n        this.controller.start();\n    }\n    async preload() {\n        this.controller.preload();\n        await this.audioController.preload();\n    }\n}\nconst $e46db5192eb49d53$export$119d2a93e2780362 = new $e46db5192eb49d53$var$Game();\n\n\nclass $f2a3353d7c2e5cc3$export$4e08dcf990b776c0 extends (0, $fe586ba0757c37f7$export$3f2f9f5909897157) {\n    static{\n        this.styles = (0, $3233927aa82734f9$export$dbf350e5966cf602)`\n    :host {\n      width: 100%;\n      aspect-ratio: 16 / 9;\n      position: relative;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      flex-direction: column;\n      background: #f0cfbb;\n    }\n    .large-title {\n      font-family: \"Poppins\", sans-serif;\n      font-size: 12vw;\n      position: absolute;\n      margin: 0;\n      top: 5%;\n      color: #a0484c;\n    }\n    .text-button {\n      position: absolute;\n      background: none;\n      border: none;\n      font-size: 3vw;\n      font-weight: bold;\n      color: #a0484c;\n      cursor: pointer;\n      opacity: 60%;\n      transition: all 0.25s ease-in-out;\n    }\n    .text-button:hover {\n      opacity: 100%;\n    }\n    #play-button {\n      left: 50%;\n      top: 50%;\n      padding: 0 15vw 15vw 15vw;\n      transform: translate(-50%);\n    }\n    #settings-button {\n      right: 8%;\n      top: 35%;\n      padding-bottom: 25vw;\n    }\n    :host([play-hovered]) #play-button {\n      opacity: 100%;\n    }\n    :host([settings-hovered]) #settings-button {\n      opacity: 100%;\n    }\n    .bg {\n      width: 100%;\n      height: 100%;\n      position: absolute;\n      top: 0;\n      left: 0;\n    }\n    .bg svg {\n      width: 100%;\n      height: 100%;\n    }\n    #barbell {\n      transition: all 0.25s ease-in-out;\n    }\n    :host([play-hovered]) #barbell {\n      transform: translateY(-5%);\n    }\n    #mirror-sheen {\n      transform-origin: 0 0;\n      transition: all 0.25s ease-in-out;\n    }\n    :host([settings-hovered]) #mirror-sheen {\n      transform: translate(30px, -40px);\n    }\n\n    @media (min-aspect-ratio: 16/9) {\n      :host {\n        height: 100%;\n        width: unset;\n      }\n      .large-title {\n        font-size: calc(12vh * 16 / 9);\n      }\n      .text-button {\n        font-size: calc(3vh * 16 / 9);\n      }\n      #play-button {\n        padding: 0 calc(15vh * 16 / 9) calc(15vh * 16 / 9) calc(15vh * 16 / 9);\n      }\n      #settings-button {\n        padding-bottom: calc(25vh * 16 / 9);\n      }\n    }\n  `;\n    }\n    async firstUpdated() {\n        await (0, $e46db5192eb49d53$export$119d2a93e2780362).preload();\n        this.loadState = \"loaded\";\n    }\n    render() {\n        if (this.loadState === \"loading\") return this.renderLoadingScreen();\n        if (this.loadState === \"loaded\") return this.renderLoadedScreen();\n        if (this.settingsOpen) return this.renderSettings();\n        return (0, $e5ed8027d647799b$export$c0bb0b647f701bb5)`\n      <div class=\"bg\">\n        <svg\n          viewBox=\"0 0 1600 900\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n        >\n          <g clip-path=\"url(#clip0_61_2)\">\n            <rect width=\"1600\" height=\"900\" fill=\"#f0cfbb\" />\n            <rect\n              x=\"-28\"\n              y=\"653\"\n              width=\"1656\"\n              height=\"315\"\n              fill=\"#D3AE72\"\n              stroke=\"#B3935D\"\n              stroke-width=\"10\"\n            />\n            <rect\n              x=\"-4.71411\"\n              y=\"862\"\n              width=\"1632.71\"\n              height=\"106\"\n              fill=\"#C7A567\"\n              stroke=\"#B3935D\"\n              stroke-width=\"10\"\n            />\n            <rect\n              x=\"9.33789\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"73.3379\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"137.338\"\n              y=\"715\"\n              width=\"8\"\n              height=\"123\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"137.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"201.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"265.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"122\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"265.338\"\n              y=\"802\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"329.338\"\n              y=\"715\"\n              width=\"8\"\n              height=\"123\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"329.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"393.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"68\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"393.338\"\n              y=\"747\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"393.338\"\n              y=\"789\"\n              width=\"8\"\n              height=\"49\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"457.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"521.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"585.338\"\n              y=\"715\"\n              width=\"8\"\n              height=\"123\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"585.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"649.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"713.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"122\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"713.338\"\n              y=\"802\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"777.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"122\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"777.338\"\n              y=\"802\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"841.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"68\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"841.338\"\n              y=\"747\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"841.338\"\n              y=\"789\"\n              width=\"8\"\n              height=\"49\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"905.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"969.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1033.34\"\n              y=\"715\"\n              width=\"8\"\n              height=\"123\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1033.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1097.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1161.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"122\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1161.34\"\n              y=\"802\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1225.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"122\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1225.34\"\n              y=\"802\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1289.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"68\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1289.34\"\n              y=\"747\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1289.34\"\n              y=\"789\"\n              width=\"8\"\n              height=\"49\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1353.34\"\n              y=\"715\"\n              width=\"8\"\n              height=\"123\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1353.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1417.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"68\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1417.34\"\n              y=\"747\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1417.34\"\n              y=\"789\"\n              width=\"8\"\n              height=\"49\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1481.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1545.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"152.727\"\n              y=\"686.399\"\n              width=\"40.9657\"\n              height=\"39.3901\"\n              rx=\"7.87802\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n            />\n            <rect\n              x=\"250.414\"\n              y=\"686.399\"\n              width=\"40.9657\"\n              height=\"39.3901\"\n              rx=\"7.87802\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n            />\n            <rect\n              x=\"148\"\n              y=\"428\"\n              width=\"148.107\"\n              height=\"272.58\"\n              rx=\"12.6048\"\n              fill=\"#DFB97F\"\n            />\n            <path\n              d=\"M148 514.658V687.975C148 694.936 153.643 700.58 160.605 700.58H283.502C290.463 700.58 296.107 694.936 296.107 687.975V440.605C296.107 433.643 290.463 428 283.502 428H160.605C153.643 428 148 433.643 148 440.605V496.145\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n              stroke-linecap=\"round\"\n            />\n            <rect\n              x=\"153.563\"\n              y=\"447.447\"\n              width=\"145.764\"\n              height=\"27.9749\"\n              rx=\"13.9874\"\n              fill=\"#F4D776\"\n            />\n            <path\n              d=\"M179.329 459.436C182.274 458.437 190.814 457.038 201.415 459.436C212.016 461.834 218.101 460.435 219.819 459.436\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M225.708 468.754C228.653 467.755 237.193 466.356 247.794 468.754C258.395 471.152 264.481 469.753 266.198 468.754\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M276.505 460.55C273.56 459.551 265.02 458.152 254.419 460.55C243.818 462.948 237.733 461.549 236.015 460.55\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M178.593 447.447H167.55C159.825 447.447 153.563 453.709 153.563 461.434V461.434C153.563 469.159 159.825 475.422 167.55 475.422H285.339C293.064 475.422 299.327 469.159 299.327 461.434V461.434C299.327 453.709 293.064 447.447 285.339 447.447H190.372\"\n              stroke=\"#835243\"\n              stroke-width=\"8.83417\"\n              stroke-linecap=\"round\"\n            />\n            <circle\n              cx=\"120.435\"\n              cy=\"461.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <circle\n              cx=\"326.565\"\n              cy=\"461.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <mask id=\"path-57-inside-1_61_2\" fill=\"white\">\n              <rect x=\"207\" y=\"469\" width=\"29\" height=\"25\" rx=\"7\" />\n            </mask>\n            <rect\n              x=\"207\"\n              y=\"469\"\n              width=\"29\"\n              height=\"25\"\n              rx=\"7\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"16\"\n              mask=\"url(#path-57-inside-1_61_2)\"\n            />\n            <rect\n              x=\"153.563\"\n              y=\"542.447\"\n              width=\"145.764\"\n              height=\"27.9749\"\n              rx=\"13.9874\"\n              fill=\"#F4D776\"\n            />\n            <path\n              d=\"M179.329 554.436C182.274 553.437 190.814 552.038 201.415 554.436C212.016 556.834 218.101 555.435 219.819 554.436\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M225.708 563.754C228.653 562.755 237.193 561.356 247.794 563.754C258.395 566.152 264.481 564.753 266.198 563.754\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M276.505 555.55C273.56 554.551 265.02 553.152 254.419 555.55C243.818 557.948 237.733 556.549 236.015 555.55\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M178.593 542.447H167.55C159.825 542.447 153.563 548.709 153.563 556.434V556.434C153.563 564.159 159.825 570.422 167.55 570.422H285.339C293.064 570.422 299.327 564.159 299.327 556.434V556.434C299.327 548.709 293.064 542.447 285.339 542.447H190.372\"\n              stroke=\"#835243\"\n              stroke-width=\"8.83417\"\n              stroke-linecap=\"round\"\n            />\n            <circle\n              cx=\"120.435\"\n              cy=\"556.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <circle\n              cx=\"326.565\"\n              cy=\"556.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <mask id=\"path-65-inside-2_61_2\" fill=\"white\">\n              <rect x=\"207\" y=\"564\" width=\"29\" height=\"25\" rx=\"7\" />\n            </mask>\n            <rect\n              x=\"207\"\n              y=\"564\"\n              width=\"29\"\n              height=\"25\"\n              rx=\"7\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"16\"\n              mask=\"url(#path-65-inside-2_61_2)\"\n            />\n            <rect\n              x=\"153.563\"\n              y=\"637.447\"\n              width=\"145.764\"\n              height=\"27.9749\"\n              rx=\"13.9874\"\n              fill=\"#F4D776\"\n            />\n            <path\n              d=\"M179.329 649.436C182.274 648.437 190.814 647.038 201.415 649.436C212.016 651.834 218.101 650.435 219.819 649.436\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M225.708 658.754C228.653 657.755 237.193 656.356 247.794 658.754C258.395 661.152 264.481 659.753 266.198 658.754\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M276.505 650.55C273.56 649.551 265.02 648.152 254.419 650.55C243.818 652.948 237.733 651.549 236.015 650.55\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M178.593 637.447H167.55C159.825 637.447 153.563 643.709 153.563 651.434V651.434C153.563 659.159 159.825 665.422 167.55 665.422H285.339C293.064 665.422 299.327 659.159 299.327 651.434V651.434C299.327 643.709 293.064 637.447 285.339 637.447H190.372\"\n              stroke=\"#835243\"\n              stroke-width=\"8.83417\"\n              stroke-linecap=\"round\"\n            />\n            <circle\n              cx=\"120.435\"\n              cy=\"651.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <circle\n              cx=\"326.565\"\n              cy=\"651.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <mask id=\"path-73-inside-3_61_2\" fill=\"white\">\n              <rect x=\"207\" y=\"659\" width=\"29\" height=\"25\" rx=\"7\" />\n            </mask>\n            <rect\n              x=\"207\"\n              y=\"659\"\n              width=\"29\"\n              height=\"25\"\n              rx=\"7\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"16\"\n              mask=\"url(#path-73-inside-3_61_2)\"\n            />\n            <rect\n              x=\"535.727\"\n              y=\"667.727\"\n              width=\"530.546\"\n              height=\"61.5464\"\n              rx=\"7.87802\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n            />\n            <g id=\"barbell\">\n              <rect\n                x=\"728.563\"\n                y=\"620.447\"\n                width=\"145.764\"\n                height=\"27.9749\"\n                rx=\"13.9874\"\n                fill=\"#F4D776\"\n              />\n              <path\n                d=\"M754.329 632.436C757.274 631.437 765.814 630.038 776.415 632.436C787.016 634.834 793.101 633.435 794.819 632.436\"\n                stroke=\"#EDC76A\"\n                stroke-width=\"5.88945\"\n                stroke-linecap=\"round\"\n              />\n              <path\n                d=\"M800.708 641.754C803.653 640.755 812.193 639.356 822.794 641.754C833.395 644.152 839.481 642.753 841.198 641.754\"\n                stroke=\"#EDC76A\"\n                stroke-width=\"5.88945\"\n                stroke-linecap=\"round\"\n              />\n              <path\n                d=\"M851.505 633.55C848.56 632.551 840.02 631.152 829.419 633.55C818.818 635.948 812.733 634.549 811.015 633.55\"\n                stroke=\"#EDC76A\"\n                stroke-width=\"5.88945\"\n                stroke-linecap=\"round\"\n              />\n              <path\n                d=\"M753.593 620.447H742.55C734.825 620.447 728.563 626.709 728.563 634.434V634.434C728.563 642.159 734.825 648.422 742.55 648.422H860.339C868.064 648.422 874.327 642.159 874.327 634.434V634.434C874.327 626.709 868.064 620.447 860.339 620.447H765.372\"\n                stroke=\"#835243\"\n                stroke-width=\"8.83417\"\n                stroke-linecap=\"round\"\n              />\n              <circle\n                cx=\"695.435\"\n                cy=\"634.435\"\n                r=\"39.0176\"\n                fill=\"#C9BDA6\"\n                stroke=\"#7A4A3B\"\n                stroke-width=\"8.83417\"\n              />\n              <circle\n                cx=\"901.565\"\n                cy=\"634.435\"\n                r=\"39.0176\"\n                fill=\"#C9BDA6\"\n                stroke=\"#7A4A3B\"\n                stroke-width=\"8.83417\"\n              />\n            </g>\n            <rect\n              x=\"1296.73\"\n              y=\"679.399\"\n              width=\"40.9657\"\n              height=\"39.3901\"\n              rx=\"7.87802\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n            />\n            <rect\n              x=\"1394.41\"\n              y=\"679.399\"\n              width=\"40.9657\"\n              height=\"39.3901\"\n              rx=\"7.87802\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n            />\n            <rect\n              x=\"1292\"\n              y=\"421\"\n              width=\"148.107\"\n              height=\"272.58\"\n              rx=\"12.6048\"\n              fill=\"#C3D2D6\"\n            />\n            <path\n              d=\"M1292 507.658V680.975C1292 687.936 1297.64 693.58 1304.6 693.58H1427.5C1434.46 693.58 1440.11 687.936 1440.11 680.975V433.605C1440.11 426.643 1434.46 421 1427.5 421H1304.6C1297.64 421 1292 426.643 1292 433.605V489.145\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n              stroke-linecap=\"round\"\n            />\n            <mask\n              id=\"mask0_61_2\"\n              style=\"mask-type:alpha\"\n              maskUnits=\"userSpaceOnUse\"\n              x=\"1295\"\n              y=\"426\"\n              width=\"140\"\n              height=\"262\"\n            >\n              <rect\n                x=\"1295\"\n                y=\"426\"\n                width=\"140\"\n                height=\"262\"\n                rx=\"6\"\n                fill=\"#C3D2D6\"\n              />\n            </mask>\n            <g mask=\"url(#mask0_61_2)\">\n              <g id=\"mirror-sheen\">\n                <rect\n                  width=\"14.0505\"\n                  height=\"16.5682\"\n                  rx=\"7.02523\"\n                  transform=\"matrix(0.709637 0.704568 -0.709637 0.704568 1427.62 595)\"\n                  fill=\"white\"\n                  fill-opacity=\"0.68\"\n                />\n                <rect\n                  width=\"14.0505\"\n                  height=\"241.245\"\n                  rx=\"7.02523\"\n                  transform=\"matrix(0.709637 0.704568 -0.709637 0.704568 1412.1 610.635)\"\n                  fill=\"white\"\n                  fill-opacity=\"0.68\"\n                />\n                <rect\n                  width=\"160.272\"\n                  height=\"253.774\"\n                  rx=\"16\"\n                  transform=\"matrix(0.709637 0.704568 -0.709637 0.704568 1495.05 561.645)\"\n                  fill=\"white\"\n                  fill-opacity=\"0.68\"\n                />\n              </g>\n            </g>\n          </g>\n          <defs>\n            <clipPath id=\"clip0_61_2\">\n              <rect width=\"1600\" height=\"900\" fill=\"white\" />\n            </clipPath>\n          </defs>\n        </svg>\n      </div>\n      <h1 class=\"large-title\">Power Lifter</h1>\n      <button\n        @click=${this.startGame}\n        @mouseenter=${()=>this.playHovered = true}\n        @mouseleave=${()=>this.playHovered = false}\n        id=\"play-button\"\n        class=\"text-button\"\n      >\n        Play\n      </button>\n      <button\n        @mouseenter=${()=>this.settingsHovered = true}\n        @mouseleave=${()=>this.settingsHovered = false}\n        @click=${()=>this.settingsOpen = true}\n        id=\"settings-button\"\n        class=\"text-button\"\n      >\n        Settings\n      </button>\n    `;\n    }\n    renderLoadingScreen() {\n        return (0, $e5ed8027d647799b$export$c0bb0b647f701bb5)`<h1 class=\"large-title\">Loading...</h1> `;\n    }\n    renderLoadedScreen() {\n        return (0, $e5ed8027d647799b$export$c0bb0b647f701bb5)`\n      <h1 class=\"large-title\">Loaded.</h1>\n      <button class=\"text-button\" @click=${this.launch}>Start</button>\n    `;\n    }\n    renderSettings() {\n        return (0, $e5ed8027d647799b$export$c0bb0b647f701bb5)`\n      <h1 class=\"large-title\">Settings</h1>\n      <button class=\"text-button\" @click=${()=>this.settingsOpen = false}>\n        Back\n      </button>\n    `;\n    }\n    startGame() {\n        this.remove();\n        (0, $e46db5192eb49d53$export$119d2a93e2780362).start();\n    }\n    launch() {\n        // At this point we forced the user to interact with the page\n        // so we can now play music.\n        (0, $e46db5192eb49d53$export$119d2a93e2780362).audioController.playTitleScreenMusic();\n        this.loadState = \"done\";\n    }\n    constructor(...args){\n        super(...args);\n        this.playHovered = false;\n        this.settingsHovered = false;\n        this.settingsOpen = false;\n        /**\n   * If the game is currently loading or not. The \"loaded\" state\n   * accounts for the state when all assets are loaded but we are\n   * waiting on the user to click \"start\" to launch the main menu.\n   * Note that this state is needed so we can force a user\n   * interaction before showing the main menu which will\n   * attempt to play audio. Something we can not do before first\n   * user interaction.\n   * */ this.loadState = \"loading\";\n    }\n}\n(0, $5c96a02c592fcff1$export$29e00dfd3077644b)([\n    (0, $b2fdcbe153c88f81$export$d541bacb2bda4494)({\n        type: Boolean,\n        reflect: true,\n        attribute: \"play-hovered\"\n    })\n], $f2a3353d7c2e5cc3$export$4e08dcf990b776c0.prototype, \"playHovered\", void 0);\n(0, $5c96a02c592fcff1$export$29e00dfd3077644b)([\n    (0, $b2fdcbe153c88f81$export$d541bacb2bda4494)({\n        type: Boolean,\n        reflect: true,\n        attribute: \"settings-hovered\"\n    })\n], $f2a3353d7c2e5cc3$export$4e08dcf990b776c0.prototype, \"settingsHovered\", void 0);\n(0, $5c96a02c592fcff1$export$29e00dfd3077644b)([\n    (0, $7162e77b40ffab5c$export$ca000e230c0caa3e)()\n], $f2a3353d7c2e5cc3$export$4e08dcf990b776c0.prototype, \"settingsOpen\", void 0);\n(0, $5c96a02c592fcff1$export$29e00dfd3077644b)([\n    (0, $7162e77b40ffab5c$export$ca000e230c0caa3e)()\n], $f2a3353d7c2e5cc3$export$4e08dcf990b776c0.prototype, \"loadState\", void 0);\n$f2a3353d7c2e5cc3$export$4e08dcf990b776c0 = (0, $5c96a02c592fcff1$export$29e00dfd3077644b)([\n    (0, $07706bf0c990b886$export$da64fc29f17f9d0e)(\"main-menu\")\n], $f2a3353d7c2e5cc3$export$4e08dcf990b776c0);\n\n\n\n\n//# sourceMappingURL=index.60475b3b.js.map\n","\"use strict\";\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    /** Position of the point on the x axis */\n    this.x = 0;\n    /** Position of the point on the y axis */\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n  }\n  /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */\n  static get shared() {\n    tempPoint.x = 0;\n    tempPoint.y = 0;\n    return tempPoint;\n  }\n}\nconst tempPoint = new Point();\n\nexport { Point };\n//# sourceMappingURL=Point.mjs.map\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Point extends PixiMixins.Point { }\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n * <br/>\n * Many Pixi functions accept the `PointData` type as an alternative to `Point`,\n * which only requires `x` and `y` properties.\n * @class\n * @implements {PointLike}\n * @memberof maths\n */\nexport class Point implements PointLike\n{\n    /** Position of the point on the x axis */\n    public x = 0;\n    /** Position of the point on the y axis */\n    public y = 0;\n\n    /**\n     * Creates a new `Point`\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(x = 0, y = 0)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Creates a clone of this point\n     * @returns A clone of this point\n     */\n    public clone(): Point\n    {\n        return new Point(this.x, this.y);\n    }\n\n    /**\n     * Copies `x` and `y` from the given point into this point\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     */\n    public copyFrom(p: PointData): this\n    {\n        this.set(p.x, p.y);\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into the given point (`p`).\n     * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n     * @returns The point (`p`) with values updated\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this.x, this.y);\n\n        return p;\n    }\n\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this.x) && (p.y === this.y);\n    }\n\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the `x` axis\n     * @param {number} [y=x] - position of the point on the `y` axis\n     * @returns The point instance itself\n     */\n    public set(x = 0, y: number = x): this\n    {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n    }\n    // #endif\n\n    /**\n     * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n     * @readonly\n     */\n    static get shared(): Point\n    {\n        tempPoint.x = 0;\n        tempPoint.y = 0;\n\n        return tempPoint;\n    }\n}\n\nconst tempPoint = new Point();\n","import { Point } from '../point/Point.mjs';\n\n\"use strict\";\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    this.type = \"rectangle\";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth) {\n    const { width, height } = this;\n    if (width <= 0 || height <= 0)\n      return false;\n    const _x = this.x;\n    const _y = this.y;\n    const outerLeft = _x - strokeWidth / 2;\n    const outerRight = _x + width + strokeWidth / 2;\n    const outerTop = _y - strokeWidth / 2;\n    const outerBottom = _y + height + strokeWidth / 2;\n    const innerLeft = _x + strokeWidth / 2;\n    const innerRight = _x + width - strokeWidth / 2;\n    const innerTop = _y + strokeWidth / 2;\n    const innerBottom = _y + height - strokeWidth / 2;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.copyFrom(this);\n    return out;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\nexport { Rectangle };\n//# sourceMappingURL=Rectangle.mjs.map\n","// import { SHAPES } from '../const';\nimport { Point } from '../point/Point';\n\nimport type { Bounds } from '../../scene/container/bounds/Bounds';\nimport type { Matrix } from '../matrix/Matrix';\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Rectangle extends PixiMixins.Rectangle { }\n\n/**\n * The `Rectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`.\n *\n * It also provides convenience methods to get and set the position and size of the rectangle such as\n * {@link maths.Rectangle#bottom|bottom}, {@link maths.Rectangle#right|right} and {@link maths.Rectangle#isEmpty|isEmpty}.\n * @memberof maths\n */\nexport class Rectangle implements ShapePrimitive\n{\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'rectangle';\n\n    /**\n     * The X coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rectangle\n     *  @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     */\n    constructor(x: string | number = 0, y: string | number = 0, width: string | number = 0, height: string | number = 0)\n    {\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n\n    /** Returns the left edge of the rectangle. */\n    get left(): number\n    {\n        return this.x;\n    }\n\n    /** Returns the right edge of the rectangle. */\n    get right(): number\n    {\n        return this.x + this.width;\n    }\n\n    /** Returns the top edge of the rectangle. */\n    get top(): number\n    {\n        return this.y;\n    }\n\n    /** Returns the bottom edge of the rectangle. */\n    get bottom(): number\n    {\n        return this.y + this.height;\n    }\n\n    /** Determines whether the Rectangle is empty. */\n    public isEmpty(): boolean\n    {\n        return this.left === this.right || this.top === this.bottom;\n    }\n\n    /** A constant empty rectangle. This is a new object every time the property is accessed */\n    static get EMPTY(): Rectangle\n    {\n        return new Rectangle(0, 0, 0, 0);\n    }\n\n    /**\n     * Creates a clone of this Rectangle\n     * @returns a copy of the rectangle\n     */\n    public clone(): Rectangle\n    {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n\n    /**\n     * Converts a Bounds object to a Rectangle object.\n     * @param bounds - The bounds to copy and convert to a rectangle.\n     * @returns Returns itself.\n     */\n    public copyFromBounds(bounds: Bounds): this\n    {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n\n        return this;\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: Rectangle): Rectangle\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: Rectangle): Rectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        if (x >= this.x && x < this.x + this.width)\n        {\n            if (y >= this.y && y < this.y + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number): boolean\n    {\n        const { width, height } = this;\n\n        if (width <= 0 || height <= 0) return false;\n\n        const _x = this.x;\n        const _y = this.y;\n\n        const outerLeft = _x - (strokeWidth / 2);\n        const outerRight = _x + width + (strokeWidth / 2);\n        const outerTop = _y - (strokeWidth / 2);\n        const outerBottom = _y + height + (strokeWidth / 2);\n        const innerLeft = _x + (strokeWidth / 2);\n        const innerRight = _x + width - (strokeWidth / 2);\n        const innerTop = _y + (strokeWidth / 2);\n        const innerBottom = _y + height - (strokeWidth / 2);\n\n        return (x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom)\n        && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n     * (width or height equal to zero) can't intersect any other rectangle.\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Matrix} transform - The transformation matrix of `other`.\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n     */\n    public intersects(other: Rectangle, transform?: Matrix): boolean\n    {\n        if (!transform)\n        {\n            const x0 = this.x < other.x ? other.x : this.x;\n            const x1 = this.right > other.right ? other.right : this.right;\n\n            if (x1 <= x0)\n            {\n                return false;\n            }\n\n            const y0 = this.y < other.y ? other.y : this.y;\n            const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n            return y1 > y0;\n        }\n\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n\n        if (x1 <= x0 || y1 <= y0)\n        {\n            return false;\n        }\n\n        const lt = tempPoints[0].set(other.left, other.top);\n        const lb = tempPoints[1].set(other.left, other.bottom);\n        const rt = tempPoints[2].set(other.right, other.top);\n        const rb = tempPoints[3].set(other.right, other.bottom);\n\n        if (rt.x <= lt.x || lb.y <= lt.y)\n        {\n            return false;\n        }\n\n        const s = Math.sign((transform.a * transform.d) - (transform.b * transform.c));\n\n        if (s === 0)\n        {\n            return false;\n        }\n\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0\n            || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1\n            || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0\n            || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1)\n        {\n            return false;\n        }\n\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = (nx * x0) + (ny * y0);\n        const n10 = (nx * x1) + (ny * y0);\n        const n01 = (nx * x0) + (ny * y1);\n        const n11 = (nx * x1) + (ny * y1);\n\n        if (Math.max(n00, n10, n01, n11) <= (nx * lt.x) + (ny * lt.y)\n            || Math.min(n00, n10, n01, n11) >= (nx * rb.x) + (ny * rb.y))\n        {\n            return false;\n        }\n\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = (mx * x0) + (my * y0);\n        const m10 = (mx * x1) + (my * y0);\n        const m01 = (mx * x0) + (my * y1);\n        const m11 = (mx * x1) + (my * y1);\n\n        if (Math.max(m00, m10, m01, m11) <= (mx * lt.x) + (my * lt.y)\n            || Math.min(m00, m10, m01, m11) >= (mx * rb.x) + (my * rb.y))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Pads the rectangle making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     * @returns Returns itself.\n     */\n    public pad(paddingX = 0, paddingY = paddingX): this\n    {\n        this.x -= paddingX;\n        this.y -= paddingY;\n\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n\n        return this;\n    }\n\n    /**\n     * Fits this rectangle around the passed one.\n     * @param rectangle - The rectangle to fit.\n     * @returns Returns itself.\n     */\n    public fit(rectangle: Rectangle): this\n    {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n\n        return this;\n    }\n\n    /**\n     * Enlarges rectangle that way its corners lie on grid\n     * @param resolution - resolution\n     * @param eps - precision\n     * @returns Returns itself.\n     */\n    public ceil(resolution = 1, eps = 0.001): this\n    {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n\n        return this;\n    }\n\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     * @param rectangle - The rectangle to include.\n     * @returns Returns itself.\n     */\n    public enlarge(rectangle: Rectangle): this\n    {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n\n        return this;\n    }\n\n    /**\n     * Returns the framing rectangle of the rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n        out.copyFrom(this);\n\n        return out;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n    // #endif\n}\n","\"use strict\";\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2[\"Application\"] = \"application\";\n  ExtensionType2[\"WebGLPipes\"] = \"webgl-pipes\";\n  ExtensionType2[\"WebGLPipesAdaptor\"] = \"webgl-pipes-adaptor\";\n  ExtensionType2[\"WebGLSystem\"] = \"webgl-system\";\n  ExtensionType2[\"WebGPUPipes\"] = \"webgpu-pipes\";\n  ExtensionType2[\"WebGPUPipesAdaptor\"] = \"webgpu-pipes-adaptor\";\n  ExtensionType2[\"WebGPUSystem\"] = \"webgpu-system\";\n  ExtensionType2[\"CanvasSystem\"] = \"canvas-system\";\n  ExtensionType2[\"CanvasPipesAdaptor\"] = \"canvas-pipes-adaptor\";\n  ExtensionType2[\"CanvasPipes\"] = \"canvas-pipes\";\n  ExtensionType2[\"Asset\"] = \"asset\";\n  ExtensionType2[\"LoadParser\"] = \"load-parser\";\n  ExtensionType2[\"ResolveParser\"] = \"resolve-parser\";\n  ExtensionType2[\"CacheParser\"] = \"cache-parser\";\n  ExtensionType2[\"DetectionParser\"] = \"detection-parser\";\n  ExtensionType2[\"MaskEffect\"] = \"mask-effect\";\n  ExtensionType2[\"BlendMode\"] = \"blend-mode\";\n  ExtensionType2[\"TextureSource\"] = \"texture-source\";\n  ExtensionType2[\"Environment\"] = \"environment\";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === \"function\" || typeof ext === \"object\" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error(\"Extension class must have an extension object\");\n    }\n    const metadata = typeof ext.extension !== \"object\" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === \"object\") {\n    ext = { ...ext };\n  } else {\n    throw new Error(\"Invalid extension type\");\n  }\n  if (typeof ext.type === \"string\") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type]?.push(ext);\n        } else {\n          handlers[type]?.(ext);\n        }\n      });\n    });\n    return this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type]?.forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (extension.name) {\n          map[extension.name] = extension.ref;\n        }\n      },\n      (extension) => {\n        if (extension.name) {\n          delete map[extension.name];\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */\n  handleByNamedList(type, map, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index >= 0)\n          return;\n        map.push({ name: extension.name, value: extension.ref });\n        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));\n      },\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index !== -1) {\n          map.splice(index, 1);\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (list.includes(extension.ref)) {\n          return;\n        }\n        list.push(extension.ref);\n        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        if (index !== -1) {\n          list.splice(index, 1);\n        }\n      }\n    );\n  }\n};\n\nexport { ExtensionType, extensions, normalizeExtensionPriority };\n//# sourceMappingURL=Extensions.mjs.map\n","/**\n * `extensions` is a global object that holds all the extensions registered with PixiJS.\n * PixiJS uses a this extensions architecture a lot to make the library more modular and\n * flexible.\n *\n * For example, if you want to add load a new type of asset, you can register a new\n * {@link assets.LoaderParser} with the `extensions` object.\n *\n * ```js\n * import { extensions, ExtensionType } from 'pixi.js';\n *\n * // create a custom asset loader\n * const customAssetLoader = {\n *    extension: {\n *        type: ExtensionType.LoadParser,\n *        name: 'custom-asset-loader',\n *    },\n *    test(url) {\n *       // check if this new loader should be used...\n *    },\n *    load(url) {\n *        // load the asset...\n *    },\n * };\n *\n * // add the custom asset loader to pixi\n * extensions.add(customAssetLoader);\n * ```\n *\n * This would add the `customAssetLoader` to the list of available loaders that PixiJS can use.\n *\n * There are many different types of extensions, which are listed in {@link extensions.ExtensionType}.\n * @namespace extensions\n */\n\n/**\n * Collection of valid extension types.\n * @memberof extensions\n */\nenum ExtensionType\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /** extensions that are registered as Application plugins */\n    Application = 'application',\n\n    /** extensions that are registered as WebGL render pipes */\n    WebGLPipes = 'webgl-pipes',\n    /** extensions that are registered as WebGL render pipes adaptors */\n    WebGLPipesAdaptor = 'webgl-pipes-adaptor',\n    /** extensions that are registered as WebGL render systems */\n    WebGLSystem = 'webgl-system',\n\n    /** extensions that are registered as WebGPU render pipes */\n    WebGPUPipes = 'webgpu-pipes',\n    /** extensions that are registered as WebGPU render pipes adaptors */\n    WebGPUPipesAdaptor = 'webgpu-pipes-adaptor',\n    /** extensions that are registered as WebGPU render systems */\n    WebGPUSystem = 'webgpu-system',\n\n    /** extensions that are registered as Canvas render pipes */\n    CanvasSystem = 'canvas-system',\n    /** extensions that are registered as Canvas render pipes adaptors */\n    CanvasPipesAdaptor = 'canvas-pipes-adaptor',\n    /** extensions that are registered as Canvas render systems */\n    CanvasPipes = 'canvas-pipes',\n\n    /** extensions that combine the other Asset extensions */\n    Asset = 'asset',\n    /** extensions that are used to load assets through Assets */\n    LoadParser = 'load-parser',\n    /** extensions that are used to resolve asset urls through Assets */\n    ResolveParser = 'resolve-parser',\n    /** extensions that are used to handle how urls are cached by Assets */\n    CacheParser = 'cache-parser',\n    /** extensions that are used to add/remove available resources from Assets */\n    DetectionParser = 'detection-parser',\n\n    /** extensions that are registered with the MaskEffectManager */\n    MaskEffect = 'mask-effect',\n\n    /** A type of extension for creating a new advanced blend mode */\n    BlendMode = 'blend-mode',\n\n    /** A type of extension that will be used to auto detect a resource type */\n    TextureSource = 'texture-source',\n\n    /** A type of extension that will be used to auto detect an environment */\n    Environment = 'environment',\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n * @ignore\n */\ninterface ExtensionMetadataDetails\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, to make them more easily accessible */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n */\ntype ExtensionMetadata = ExtensionType | ExtensionMetadataDetails;\n\n/**\n * Format when registering an extension. Generally, the extension\n * should have these values as `extension` static property,\n * but you can override name or type by providing an object.\n * @memberof extensions\n */\ninterface ExtensionFormat\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, such as Renderer plugins */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n    /** Reference to the plugin object/class */\n    ref: any;\n}\n\n/**\n * Extension format that is used internally for registrations.\n * @memberof extensions\n * @ignore\n */\ninterface StrictExtensionFormat extends ExtensionFormat\n{\n    /** The extension type, always expressed as multiple, even if a single */\n    type: ExtensionType[];\n}\n\ntype ExtensionHandler = (extension: StrictExtensionFormat) => void;\n\n/**\n * Convert input into extension format data.\n * @ignore\n */\nconst normalizeExtension = (ext: ExtensionFormat | any): StrictExtensionFormat =>\n{\n    // Class/Object submission, use extension object\n    if (typeof ext === 'function' || (typeof ext === 'object' && ext.extension))\n    {\n        // #if _DEBUG\n        if (!ext.extension)\n        {\n            throw new Error('Extension class must have an extension object');\n        }\n        // #endif\n        const metadata: ExtensionMetadataDetails = (typeof ext.extension !== 'object')\n            ? { type: ext.extension }\n            : ext.extension;\n\n        ext = { ...metadata, ref: ext };\n    }\n    if (typeof ext === 'object')\n    {\n        ext = { ...ext };\n    }\n    else\n    {\n        throw new Error('Invalid extension type');\n    }\n\n    if (typeof ext.type === 'string')\n    {\n        ext.type = [ext.type];\n    }\n\n    return ext;\n};\n\n/**\n * Get the priority for an extension.\n * @ignore\n * @param ext - Any extension\n * @param defaultPriority - Fallback priority if none is defined.\n * @returns The priority for the extension.\n * @memberof extensions\n */\nexport const normalizeExtensionPriority = (ext: ExtensionFormat | any, defaultPriority: number): number =>\n    normalizeExtension(ext).priority ?? defaultPriority;\n\n/**\n * Global registration of all PixiJS extensions. One-stop-shop for extensibility.\n *\n * Import the `extensions` object and use it to register new functionality via the described methods below.\n * ```js\n * import { extensions } from 'pixi.js';\n *\n * // register a new extension\n * extensions.add(myExtension);\n * ```\n * @property {Function} remove - Remove extensions from PixiJS.\n * @property {Function} add - Register new extensions with PixiJS.\n * @property {Function} handle - Internal method to handle extensions by name.\n * @property {Function} handleByMap - Handle a type, but using a map by `name` property.\n * @property {Function} handleByNamedList - Handle a type, but using a list of extensions with a `name` property.\n * @property {Function} handleByList - Handle a type, but using a list of extensions.\n * @memberof extensions\n */\nconst extensions = {\n\n    /** @ignore */\n    _addHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _removeHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _queue: {} as Partial<Record<ExtensionType, StrictExtensionFormat[]>>,\n\n    /**\n     * Remove extensions from PixiJS.\n     * @param extensions - Extensions to be removed.\n     * @returns {extensions} For chaining.\n     */\n    remove(...extensions: Array<ExtensionFormat | any>)\n    {\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n        });\n\n        return this;\n    },\n\n    /**\n     * Register new extensions with PixiJS.\n     * @param extensions - The spread of extensions to add to PixiJS.\n     * @returns {extensions} For chaining.\n     */\n    add(...extensions: Array<ExtensionFormat | any>)\n    {\n        // Handle any extensions either passed as class w/ data or as data\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) =>\n            {\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n\n                if (!handlers[type])\n                {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                }\n                else\n                {\n                    handlers[type]?.(ext);\n                }\n            });\n        });\n\n        return this;\n    },\n\n    /**\n     * Internal method to handle extensions by name.\n     * @param type - The extension type.\n     * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n     * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n     * @returns {extensions} For chaining.\n     */\n    handle(type: ExtensionType, onAdd: ExtensionHandler, onRemove: ExtensionHandler)\n    {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n\n        // #if _DEBUG\n        if (addHandlers[type] || removeHandlers[type])\n        {\n            throw new Error(`Extension type ${type} already has a handler`);\n        }\n        // #endif\n\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n\n        // Process the queue\n        const queue = this._queue;\n\n        // Process any plugins that have been registered before the handler\n        if (queue[type])\n        {\n            queue[type]?.forEach((ext) => onAdd(ext));\n            delete queue[type];\n        }\n\n        return this;\n    },\n\n    /**\n     * Handle a type, but using a map by `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The object map of named extensions.\n     * @returns {extensions} For chaining.\n     */\n    handleByMap(type: ExtensionType, map: Record<string, any>)\n    {\n        return this.handle(type,\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    map[extension.name] = extension.ref;\n                }\n            },\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    delete map[extension.name];\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions with a `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The array of named extensions.\n     * @param defaultPriority - Fallback priority if none is defined.\n     * @returns {extensions} For chaining.\n     */\n    handleByNamedList(type: ExtensionType, map: {name: string, value: any}[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index >= 0) return;\n\n                map.push({ name: extension.name, value: extension.ref });\n                map.sort((a, b) =>\n                    normalizeExtensionPriority(b.value, defaultPriority)\n                    - normalizeExtensionPriority(a.value, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index !== -1)\n                {\n                    map.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions.\n     * @param type - Type of extension to handle.\n     * @param list - The list of extensions.\n     * @param defaultPriority - The default priority to use if none is specified.\n     * @returns {extensions} For chaining.\n     */\n    handleByList(type: ExtensionType, list: any[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                if (list.includes(extension.ref))\n                {\n                    return;\n                }\n\n                list.push(extension.ref);\n                list.sort((a, b) =>\n                    normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = list.indexOf(extension.ref);\n\n                if (index !== -1)\n                {\n                    list.splice(index, 1);\n                }\n            }\n        );\n    },\n};\n\nexport {\n    extensions,\n    ExtensionType,\n};\nexport type {\n    StrictExtensionFormat as ExtensionFormat,\n    ExtensionFormat as ExtensionFormatLoose,\n    ExtensionHandler,\n    ExtensionMetadata,\n};\n","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = Promise.all([load(\"7OvPL\"), load(\"78TkE\"), load(\"dCEEN\")]).then(() => parcelRequire('gFyHJ'));","\"use strict\";\n\nfunction load(id) {\n  // eslint-disable-next-line no-undef\n  return __parcel__import__(require('../bundle-manifest').resolve(id));\n}\nmodule.exports = load;","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = Promise.all([load(\"7OvPL\"), load(\"78TkE\"), load(\"5zD7l\")]).then(() => parcelRequire('danRq'));","import { extensions } from '../extensions/Extensions.mjs';\nimport { AlphaMask } from './mask/alpha/AlphaMask.mjs';\nimport { ColorMask } from './mask/color/ColorMask.mjs';\nimport { StencilMask } from './mask/stencil/StencilMask.mjs';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferSource.mjs';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource.mjs';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource.mjs';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource.mjs';\nimport './renderers/shared/texture/utils/textureFrom.mjs';\nimport './mask/MaskEffectManager.mjs';\n\n\"use strict\";\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { AlphaMask } from './mask/alpha/AlphaMask';\nimport { ColorMask } from './mask/color/ColorMask';\nimport { StencilMask } from './mask/stencil/StencilMask';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferSource';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource';\nimport './renderers/shared/texture/utils/textureFrom';\nimport './mask/MaskEffectManager';\n\n/**\n * The rendering namespace contains all the classes used for core rendering in PixiJS\n * this includes all the lower level resources such as Textures, Shaders, State, Buffers,\n * Geometry and the systems required to use them. This covers WebGL and WebGPU and their shared classes.\n *\n * To automatically create a renderer based on available resources, see the {@link rendering.autoDetectRenderer} function.\n * @namespace rendering\n */\n\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { addMaskBounds } from '../utils/addMaskBounds.mjs';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds.mjs';\n\n\"use strict\";\nclass AlphaMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"alphaMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.renderMaskToTexture = !(mask instanceof Sprite);\n    this.mask.renderable = this.renderMaskToTexture;\n    this.mask.includeInBuild = !this.renderMaskToTexture;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Sprite;\n  }\n}\nAlphaMask.extension = ExtensionType.MaskEffect;\n\nexport { AlphaMask };\n//# sourceMappingURL=AlphaMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class AlphaMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'alphaMask';\n    public renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n","import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds.mjs';\nimport { Container } from '../container/Container.mjs';\n\n\"use strict\";\nclass Sprite extends Container {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = Texture.EMPTY) {\n    if (options instanceof Texture) {\n      options = { texture: options };\n    }\n    const { texture, anchor, roundPixels, width, height, ...rest } = options;\n    super({\n      label: \"Sprite\",\n      ...rest\n    });\n    this.renderPipeId = \"sprite\";\n    this.batched = true;\n    this._didSpriteUpdate = false;\n    this._bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._boundsDirty = true;\n    this._sourceBoundsDirty = true;\n    this._roundPixels = 0;\n    this._anchor = new ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor) {\n      this.anchor = anchor;\n    } else if (texture.defaultAnchor) {\n      this.anchor = texture.defaultAnchor;\n    }\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width)\n      this.width = width;\n    if (height)\n      this.height = height;\n  }\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof Texture) {\n      return new Sprite(source);\n    }\n    return new Sprite(Texture.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /**\n   * The bounds of the sprite, taking the texture's trim into account.\n   * @type {rendering.Bounds}\n   */\n  get sourceBounds() {\n    if (this._sourceBoundsDirty) {\n      this._updateSourceBounds();\n      this._sourceBoundsDirty = false;\n    }\n    return this._sourceBounds;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.sourceBounds;\n    if (point.x >= bounds.maxX && point.x <= bounds.minX) {\n      if (point.y >= bounds.maxY && point.y <= bounds.minY) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didSpriteUpdate = true;\n    this._sourceBoundsDirty = this._boundsDirty = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    if (this.renderGroup) {\n      this.renderGroup.onChildViewUpdate(this);\n    }\n  }\n  _updateBounds() {\n    updateQuadBounds(this._bounds, this._anchor, this._texture, 0);\n  }\n  _updateSourceBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const sourceBounds = this._sourceBounds;\n    const { width, height } = texture.orig;\n    sourceBounds.maxX = -anchor._x * width;\n    sourceBounds.minX = sourceBounds.maxX + width;\n    sourceBounds.maxY = -anchor._y * height;\n    sourceBounds.minY = sourceBounds.maxY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._bounds = null;\n    this._sourceBounds = null;\n    this._anchor = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from 'pixi.js';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   *  Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== \"object\") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, this._texture.orig.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, this._texture.orig.height);\n    }\n  }\n}\n\nexport { Sprite };\n//# sourceMappingURL=Sprite.mjs.map\n","import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { Container } from '../container/Container';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { TextureSourceLike } from '../../rendering/renderers/shared/texture/Texture';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds, BoundsData } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Options for the {@link scene.Sprite} constructor.\n * @memberof scene\n */\nexport interface SpriteOptions extends ContainerOptions\n{\n    /** The texture to use for the sprite. */\n    texture?: Texture;\n    /** The anchor point of the sprite. */\n    anchor?: PointData | number;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('assets/image.png');\n * ```\n *\n * The more efficient way to create sprites is using a {@link assets.Spritesheet},\n * as swapping base textures when rendering to the screen is inefficient.\n *\n * ```js\n * import { Assets, Sprite } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n * ```\n * @memberof scene\n * @extends scene.Container\n */\nexport class Sprite extends Container implements View\n{\n    /**\n     * Helper function that creates a new sprite based on the source you provide.\n     * The source can be - frame id, image, video, canvas element, video element, texture\n     * @param source - Source to create texture from\n     * @param [skipCache] - Whether to skip the cache or not\n     * @returns The newly created sprite\n     */\n    public static from(source: Texture | TextureSourceLike, skipCache = false): Sprite\n    {\n        if (source instanceof Texture)\n        {\n            return new Sprite(source);\n        }\n\n        return new Sprite(Texture.from(source, skipCache));\n    }\n\n    public readonly renderPipeId = 'sprite';\n\n    public batched = true;\n    public readonly _anchor: ObservablePoint;\n\n    // sprite specific..\n    public _texture: Texture;\n    public _didSpriteUpdate = false;\n\n    private readonly _bounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private readonly _sourceBounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private _boundsDirty = true;\n    private _sourceBoundsDirty = true;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: SpriteOptions | Texture = Texture.EMPTY)\n    {\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        // split out\n        const { texture, anchor, roundPixels, width, height, ...rest } = options;\n\n        super({\n            label: 'Sprite',\n            ...rest\n        });\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        if (anchor)\n        {\n            this.anchor = anchor;\n        }\n        else if (texture.defaultAnchor)\n        {\n            this.anchor = texture.defaultAnchor;\n        }\n\n        this.texture = texture;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width) this.width = width;\n        if (height) this.height = height;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The local bounds of the sprite.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * The bounds of the sprite, taking the texture's trim into account.\n     * @type {rendering.Bounds}\n     */\n    get sourceBounds()\n    {\n        if (this._sourceBoundsDirty)\n        {\n            this._updateSourceBounds();\n            this._sourceBoundsDirty = false;\n        }\n\n        return this._sourceBounds;\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.sourceBounds;\n\n        if (point.x >= bounds.maxX && point.x <= bounds.minX)\n        {\n            if (point.y >= bounds.maxY && point.y <= bounds.minY)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n\n    public onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n        this._didSpriteUpdate = true;\n        this._sourceBoundsDirty = this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    private _updateBounds()\n    {\n        updateQuadBounds(this._bounds, this._anchor, this._texture, 0);\n    }\n\n    private _updateSourceBounds()\n    {\n        const anchor = this._anchor;\n        const texture = this._texture;\n\n        const sourceBounds = this._sourceBounds;\n\n        const { width, height } = texture.orig;\n\n        sourceBounds.maxX = -anchor._x * width;\n        sourceBounds.minX = sourceBounds.maxX + width;\n\n        sourceBounds.maxY = -anchor._y * height;\n        sourceBounds.minY = sourceBounds.maxY + height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this._bounds as null) = null;\n        (this._sourceBounds as null) = null;\n        (this._anchor as null) = null;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this._texture.orig.width);\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this._texture.orig.height);\n    }\n\n    /**\n     * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Sprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Sprite to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        let convertedWidth: number;\n        let convertedHeight: number;\n\n        if (typeof value !== 'object')\n        {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        }\n        else\n        {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n\n        if (convertedWidth !== undefined)\n        {\n            this._setWidth(convertedWidth, this._texture.orig.width);\n        }\n\n        if (convertedHeight !== undefined)\n        {\n            this._setHeight(convertedHeight, this._texture.orig.height);\n        }\n    }\n}\n","\"use strict\";\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(observer, x, y) {\n    this._x = x || 0;\n    this._y = y || 0;\n    this._observer = observer;\n  }\n  /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */\n  clone(observer) {\n    return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n  }\n  /** Position of the observable point on the x axis. */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this._observer._onUpdate(this);\n    }\n  }\n  /** Position of the observable point on the y axis. */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this._observer._onUpdate(this);\n    }\n  }\n}\n\nexport { ObservablePoint };\n//# sourceMappingURL=ObservablePoint.mjs.map\n","import type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ObservablePoint extends PixiMixins.ObservablePoint { }\n\n/**\n * Observer used to listen for observable point changes.\n * @memberof maths\n */\nexport interface Observer<T>\n{\n    /** Callback to call when the point has updated. */\n    _onUpdate: (point?: T) => void;\n}\n\n/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n *\n * An `ObservablePoint` is a point that triggers the `onUpdate` method on an observer when the point's position is changed.\n * @memberof maths\n */\nexport class ObservablePoint implements PointLike\n{\n    /** @ignore */\n    public _x: number;\n    /** @ignore */\n    public _y: number;\n\n    /** This object used to call the `onUpdate` callback when the point changes. */\n    private readonly _observer: Observer<ObservablePoint>;\n\n    /**\n     * Creates a new `ObservablePoint`\n     * @param observer - Observer to pass to listen for change events.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(observer: Observer<ObservablePoint>, x?: number, y?: number)\n    {\n        this._x = x || 0;\n        this._y = y || 0;\n\n        this._observer = observer;\n    }\n\n    /**\n     * Creates a clone of this point.\n     * @param observer - Optional observer to pass to the new observable point.\n     * @returns a copy of this observable point\n     */\n    public clone(observer?: Observer<ObservablePoint>): ObservablePoint\n    {\n        return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n    }\n\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=x] - position of the point on the y axis\n     * @returns The observable point instance itself\n     */\n    public set(x = 0, y = x): this\n    {\n        if (this._x !== x || this._y !== y)\n        {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies x and y from the given point (`p`)\n     * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n     * @returns The observable point instance itself\n     */\n    public copyFrom(p: PointData): this\n    {\n        if (this._x !== p.x || this._y !== p.y)\n        {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into that of the given point (`p`)\n     * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n     * @returns The point (`p`) with values updated\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this._x, this._y);\n\n        return p;\n    }\n\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this._x) && (p.y === this._y);\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n    }\n    // #endif\n\n    /** Position of the observable point on the x axis. */\n    get x(): number\n    {\n        return this._x;\n    }\n\n    set x(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n\n    /** Position of the observable point on the y axis. */\n    get y(): number\n    {\n        return this._y;\n    }\n\n    set y(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { NOOP } from '../../../../utils/misc/NOOP.mjs';\nimport { BufferImageSource } from './sources/BufferSource.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { TextureMatrix } from './TextureMatrix.mjs';\n\n\"use strict\";\nclass Texture extends EventEmitter {\n  /**\n   * @param {TextureOptions} param0 - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate,\n    dynamic\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = uid(\"texture\");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    this.noFrame = false;\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    this.dynamic = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const { width, height } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.dynamic = dynamic || false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off(\"resize\", this.update, this);\n    }\n    this._source = value;\n    value.on(\"resize\", this.update, this);\n    this.emit(\"update\", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const { uvs, frame } = this;\n    const { width, height } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n  }\n  /** call this if you have modified the `texture outside` of the constructor */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit(\"update\", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    deprecation(v8_0_0, \"Texture.baseTexture is now Texture.source\");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: \"EMPTY\",\n  source: new TextureSource({\n    label: \"EMPTY\"\n  })\n});\nTexture.EMPTY.destroy = NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferImageSource({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    label: \"WHITE\"\n  }),\n  label: \"WHITE\"\n});\nTexture.WHITE.destroy = NOOP;\n\nexport { Texture };\n//# sourceMappingURL=Texture.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { NOOP } from '../../../../utils/misc/NOOP';\nimport { BufferImageSource } from './sources/BufferSource';\nimport { TextureSource } from './sources/TextureSource';\nimport { TextureMatrix } from './TextureMatrix';\n\nimport type { TextureResourceOrOptions } from './utils/textureFrom';\n\n/**\n * Stores the width of the non-scalable borders, for example when used with {@link scene.NineSlicePlane} texture.\n * @memberof rendering\n */\nexport interface TextureBorders\n{\n    /** left border in pixels */\n    left: number;\n    /** top border in pixels */\n    top: number;\n    /** right border in pixels */\n    right: number;\n    /** bottom border in pixels */\n    bottom: number;\n}\n\n/**\n * The UVs data structure for a texture.\n * @memberof rendering\n */\nexport type UVs = {\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    x3: number;\n    y3: number;\n};\n\n/**\n * The options that can be passed to a new Texture\n * @memberof rendering\n */\nexport interface TextureOptions\n{\n    /** the underlying texture data that this texture will use  */\n    source?: TextureSource;\n    /** optional label, for debugging */\n    label?: string;\n    /** The rectangle frame of the texture to show */\n    frame?: Rectangle;\n    /** The area of original texture */\n    orig?: Rectangle;\n    /** Trimmed rectangle of original texture */\n    trim?: Rectangle;\n    /** Default anchor point used for sprite placement / rotation */\n    defaultAnchor?: { x: number; y: number };\n    /** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n    defaultBorders?: TextureBorders;\n    /** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n    rotate?: number;\n    /** set to true if you plan on modifying the uvs of this texture - can affect performance with high numbers of sprites*/\n    dynamic?: boolean;\n}\n\nexport interface BindableTexture\n{\n    source: TextureSource;\n}\n\nexport type TextureSourceLike = TextureSource | TextureResourceOrOptions | string;\n\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load an texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n * ```js\n *\n * const texture = await Asset.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to acces the texture once loaded\n * const sameAgainTexture = Asset.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * ```\n *\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Asset.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ```\n *\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n * @memberof rendering\n * @class\n */\nexport class Texture extends EventEmitter<{\n    update: Texture\n    destroy: Texture\n}> implements BindableTexture\n{\n    /**\n     * Helper function that creates a returns Texture based on the source you provide.\n     * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n     * @param id - String or Source to create texture from\n     * @param skipCache - Skip adding the texture to the cache\n     * @returns The texture based on the Id provided\n     */\n    public static from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\n    /** label used for debugging */\n    public label?: string;\n    /** unique id for this texture */\n    public uid = uid('texture');\n    /**\n     * Has the texture been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    public _source: TextureSource;\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link maths.groupD8} for explanation\n     */\n    public readonly rotate: number;\n    /** A uvs object based on the given frame and the texture source */\n    public readonly uvs: UVs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @default {0,0}\n     */\n    public readonly defaultAnchor?: { x: number; y: number };\n    /**\n     * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n     * @since 7.2.0\n     * @see scene.NineSliceSprite\n     */\n    public readonly defaultBorders?: TextureBorders;\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    public readonly frame = new Rectangle();\n    /** This is the area of original texture, before it was put in atlas. */\n    public readonly orig: Rectangle;\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `updateUvs()` after you change coordinates of `trim` manually.\n     */\n    public readonly trim: Rectangle;\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    public noFrame = false;\n\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    public dynamic = false;\n\n    private _textureMatrix: TextureMatrix;\n\n    /** is it a texture? yes! used for type checking */\n    public readonly isTexture = true;\n\n    /**\n     * @param {TextureOptions} param0 - Options for the texture\n     */\n    constructor({\n        source,\n        label,\n        frame,\n        orig,\n        trim,\n        defaultAnchor,\n        defaultBorders,\n        rotate,\n        dynamic\n    }: TextureOptions = {})\n    {\n        super();\n\n        this.label = label;\n        this.source = source?.source ?? new TextureSource();\n\n        this.noFrame = !frame;\n\n        if (frame)\n        {\n            this.frame.copyFrom(frame);\n        }\n        else\n        {\n            const { width, height } = this._source;\n\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n\n        this.orig = orig || this.frame;\n        this.trim = trim;\n\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n\n        this.updateUvs();\n    }\n\n    set source(value: TextureSource)\n    {\n        if (this._source)\n        {\n            this._source.off('resize', this.update, this);\n        }\n\n        this._source = value;\n\n        value.on('resize', this.update, this);\n\n        this.emit('update', this);\n    }\n\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */\n    get source(): TextureSource\n    {\n        return this._source;\n    }\n\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n    get textureMatrix()\n    {\n        if (!this._textureMatrix)\n        {\n            this._textureMatrix = new TextureMatrix(this);\n        }\n\n        return this._textureMatrix;\n    }\n\n    /** The width of the Texture in pixels. */\n    get width(): number\n    {\n        return this.orig.width;\n    }\n\n    /** The height of the Texture in pixels. */\n    get height(): number\n    {\n        return this.orig.height;\n    }\n\n    /** Call this function when you have modified the frame of this texture. */\n    public updateUvs()\n    {\n        const { uvs, frame } = this;\n        const { width, height } = this._source;\n\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n\n        let rotate = this.rotate;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n\n            // coordinates of center\n            const cX = nX + w2;\n            const cY = nY + h2;\n\n            rotate = groupD8.add(rotate, groupD8.NW); // NW is top-left corner\n            uvs.x0 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y0 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            uvs.x1 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y1 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x2 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y2 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x3 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y3 = cY + (h2 * groupD8.uY(rotate));\n        }\n\n        else\n        {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n\n    /**\n     * Destroys this texture\n     * @param destroySource - Destroy the source when the texture is destroyed.\n     */\n    public destroy(destroySource = false)\n    {\n        if (this._source)\n        {\n            if (destroySource)\n            {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.removeAllListeners();\n    }\n\n    /** call this if you have modified the `texture outside` of the constructor */\n    public update(): void\n    {\n        if (this.noFrame)\n        {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n\n        this.updateUvs();\n        this.emit('update', this);\n    }\n\n    /** @deprecated since 8.0.0 */\n    get baseTexture(): TextureSource\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Texture.baseTexture is now Texture.source');\n        // #endif\n\n        return this._source;\n    }\n\n    /** an Empty Texture used internally by the engine */\n    public static EMPTY: Texture;\n    /** a White texture used internally by the engine */\n    public static WHITE: Texture;\n}\n\nTexture.EMPTY = new Texture({\n    label: 'EMPTY',\n    source: new TextureSource({\n        label: 'EMPTY',\n    })\n});\n\nTexture.EMPTY.destroy = NOOP;\n\nTexture.WHITE = new Texture({\n    source: new BufferImageSource({\n        resource: new Uint8Array([255, 255, 255, 255]),\n        width: 1,\n        height: 1,\n        alphaMode: 'premultiply-alpha-on-upload',\n        label: 'WHITE',\n    }),\n    label: 'WHITE',\n});\n\nTexture.WHITE.destroy = NOOP;\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","import { Matrix } from './Matrix.mjs';\n\n\"use strict\";\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\nexport { groupD8 };\n//# sourceMappingURL=groupD8.mjs.map\n","// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group\n//\n// This file implements the dihedral group of order 16, also called\n// of degree 8. That's why its called groupD8.\n\nimport { Matrix } from './Matrix';\n\n/*\n * Transform matrix for operation n is:\n * | ux | vx |\n * | uy | vy |\n */\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\n\n/**\n * [Cayley Table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n * for the composition of each rotation in the dihederal group D8.\n * @type {number[][]}\n * @private\n */\nconst rotationCayley: number[][] = [];\n\n/**\n * Matrices for each `GD8Symmetry` rotation.\n * @type {Matrix[]}\n * @private\n */\nconst rotationMatrices: Matrix[] = [];\n\n/*\n * Alias for {@code Math.sign}.\n */\nconst signum = Math.sign;\n\n/*\n * Initializes `rotationCayley` and `rotationMatrices`. It is called\n * only once below.\n */\nfunction init(): void\n{\n    for (let i = 0; i < 16; i++)\n    {\n        const row: number[] = [];\n\n        rotationCayley.push(row);\n\n        for (let j = 0; j < 16; j++)\n        {\n            /* Multiplies rotation matrices i and j. */\n            const _ux = signum((ux[i] * ux[j]) + (vx[i] * uy[j]));\n            const _uy = signum((uy[i] * ux[j]) + (vy[i] * uy[j]));\n            const _vx = signum((ux[i] * vx[j]) + (vx[i] * vy[j]));\n            const _vy = signum((uy[i] * vx[j]) + (vy[i] * vy[j]));\n\n            /* Finds rotation matrix matching the product and pushes it. */\n            for (let k = 0; k < 16; k++)\n            {\n                if (ux[k] === _ux && uy[k] === _uy\n                      && vx[k] === _vx && vy[k] === _vy)\n                {\n                    row.push(k);\n                    break;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < 16; i++)\n    {\n        const mat = new Matrix();\n\n        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n        rotationMatrices.push(mat);\n    }\n}\n\ninit();\n\ntype GD8Symmetry = number;\n/**\n * @typedef {number} GD8Symmetry\n * @see groupD8\n */\n\n/**\n * Implements the dihedral group D8, which is similar to\n * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};\n * D8 is the same but with diagonals, and it is used for texture\n * rotations.\n *\n * The directions the U- and V- axes after rotation\n * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`\n * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.\n *\n * **Origin:**<br>\n *  This is the small part of gameofbombs.com portal system. It works.\n * @see maths.groupD8.E\n * @see maths.groupD8.SE\n * @see maths.groupD8.S\n * @see maths.groupD8.SW\n * @see maths.groupD8.W\n * @see maths.groupD8.NW\n * @see maths.groupD8.N\n * @see maths.groupD8.NE\n * @author Ivan @ivanpopelyshev\n * @namespace maths.groupD8\n */\nexport const groupD8 = {\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 0°       | East      |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    E: 0,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 45°↻     | Southeast |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    SE: 1,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 90°↻     | South     |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    S: 2,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 135°↻    | Southwest |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    SW: 3,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 180°     | West      |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    W: 4,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -135°/225°↻ | Northwest    |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    NW: 5,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -90°/270°↻  | North        |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    N: 6,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -45°/315°↻  | Northeast    |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    NE: 7,\n\n    /**\n     * Reflection about Y-axis.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MIRROR_VERTICAL: 8,\n\n    /**\n     * Reflection about the main diagonal.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MAIN_DIAGONAL: 10,\n\n    /**\n     * Reflection about X-axis.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MIRROR_HORIZONTAL: 12,\n\n    /**\n     * Reflection about reverse diagonal.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    REVERSE_DIAGONAL: 14,\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the U-axis\n     *    after rotating the axes.\n     */\n    uX: (ind: GD8Symmetry): GD8Symmetry => ux[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the U-axis\n     *    after rotating the axes.\n     */\n    uY: (ind: GD8Symmetry): GD8Symmetry => uy[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the V-axis\n     *    after rotating the axes.\n     */\n    vX: (ind: GD8Symmetry): GD8Symmetry => vx[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the V-axis\n     *    after rotating the axes.\n     */\n    vY: (ind: GD8Symmetry): GD8Symmetry => vy[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotation - symmetry whose opposite\n     *   is needed. Only rotations have opposite symmetries while\n     *   reflections don't.\n     * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n     */\n    inv: (rotation: GD8Symmetry): GD8Symmetry =>\n    {\n        if (rotation & 8)// true only if between 8 & 15 (reflections)\n        {\n            return rotation & 15;// or rotation % 16\n        }\n\n        return (-rotation) & 7;// or (8 - rotation) % 8\n    },\n\n    /**\n     * Composes the two D8 operations.\n     *\n     * Taking `^` as reflection:\n     *\n     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n     * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n     *\n     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation, which\n     *   is the row in the above cayley table.\n     * @param {GD8Symmetry} rotationFirst - First operation, which\n     *   is the column in the above cayley table.\n     * @returns {GD8Symmetry} Composed operation\n     */\n    add: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][rotationFirst]\n    ),\n\n    /**\n     * Reverse of `add`.\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation\n     * @param {GD8Symmetry} rotationFirst - First operation\n     * @returns {GD8Symmetry} Result\n     */\n    sub: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][groupD8.inv(rotationFirst)]\n    ),\n\n    /**\n     * Adds 180 degrees to rotation, which is a commutative\n     * operation.\n     * @memberof maths.groupD8\n     * @param {number} rotation - The number to rotate.\n     * @returns {number} Rotated number\n     */\n    rotate180: (rotation: number): number => rotation ^ 4,\n\n    /**\n     * Checks if the rotation angle is vertical, i.e. south\n     * or north. It doesn't work for reflections.\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotation - The number to check.\n     * @returns {boolean} Whether or not the direction is vertical\n     */\n    isVertical: (rotation: GD8Symmetry): boolean => (rotation & 3) === 2, // rotation % 4 === 2\n\n    /**\n     * Approximates the vector `V(dx,dy)` into one of the\n     * eight directions provided by `groupD8`.\n     * @memberof maths.groupD8\n     * @param {number} dx - X-component of the vector\n     * @param {number} dy - Y-component of the vector\n     * @returns {GD8Symmetry} Approximation of the vector into\n     *  one of the eight symmetries.\n     */\n    byDirection: (dx: number, dy: number): GD8Symmetry =>\n    {\n        if (Math.abs(dx) * 2 <= Math.abs(dy))\n        {\n            if (dy >= 0)\n            {\n                return groupD8.S;\n            }\n\n            return groupD8.N;\n        }\n        else if (Math.abs(dy) * 2 <= Math.abs(dx))\n        {\n            if (dx > 0)\n            {\n                return groupD8.E;\n            }\n\n            return groupD8.W;\n        }\n        else if (dy > 0)\n        {\n            if (dx > 0)\n            {\n                return groupD8.SE;\n            }\n\n            return groupD8.SW;\n        }\n        else if (dx > 0)\n        {\n            return groupD8.NE;\n        }\n\n        return groupD8.NW;\n    },\n\n    /**\n     * Helps sprite to compensate texture packer rotation.\n     * @memberof maths.groupD8\n     * @param {Matrix} matrix - sprite world matrix\n     * @param {GD8Symmetry} rotation - The rotation factor to use.\n     * @param {number} tx - sprite anchoring\n     * @param {number} ty - sprite anchoring\n     */\n    matrixAppendRotationInv: (matrix: Matrix, rotation: GD8Symmetry, tx = 0, ty = 0): void =>\n    {\n        // Packer used \"rotation\", we use \"inv(rotation)\"\n        const mat: Matrix = rotationMatrices[groupD8.inv(rotation)];\n\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    },\n};\n","import { PI_2 } from '../misc/const.mjs';\nimport { Point } from '../point/Point.mjs';\n\n\"use strict\";\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new Point();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new Point();\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const tx = this.tx;\n    const ty = this.ty;\n    const id = 1 / (a * d + c * -b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n    return newPos;\n  }\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  appendFrom(a, b) {\n    const a1 = a.a;\n    const b1 = a.b;\n    const c1 = a.c;\n    const d1 = a.d;\n    const tx = a.tx;\n    const ty = a.ty;\n    const a2 = b.a;\n    const b2 = b.b;\n    const c2 = b.c;\n    const d2 = b.d;\n    this.a = a1 * a2 + b1 * c2;\n    this.b = a1 * b2 + b1 * d2;\n    this.c = c1 * a2 + d1 * c2;\n    this.d = c1 * b2 + d1 * d2;\n    this.tx = tx * a2 + ty * c2 + b.tx;\n    this.ty = tx * b2 + ty * d2 + b.ty;\n    return this;\n  }\n  /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  /** Checks if this matrix is an identity matrix */\n  isIdentity() {\n    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */\n  equals(matrix) {\n    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n  }\n  toString() {\n    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */\n  static get IDENTITY() {\n    return identityMatrix.identity();\n  }\n  /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */\n  static get shared() {\n    return tempMatrix.identity();\n  }\n}\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n\nexport { Matrix };\n//# sourceMappingURL=Matrix.mjs.map\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { PI_2 } from '../misc/const';\nimport { Point } from '../point/Point';\n\nimport type { PointData } from '../point/PointData';\n\ninterface TransformableObject\n{\n    position: PointData;\n    scale: PointData;\n    pivot: PointData;\n    skew: PointData;\n    rotation: number;\n}\n\n/**\n * A fast matrix for 2D transformations.\n * ```js\n * | a | c | tx|\n * | b | d | ty|\n * | 0 | 0 | 1 |\n * ```\n * @memberof maths\n */\nexport class Matrix\n{\n    /** @default 1 */\n    public a: number;\n\n    /** @default 0 */\n    public b: number;\n\n    /** @default 0 */\n    public c: number;\n\n    /** @default 1 */\n    public d: number;\n\n    /** @default 0 */\n    public tx: number;\n\n    /** @default 0 */\n    public ty: number;\n\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    public array: Float32Array | null = null;\n\n    /**\n     * @param a - x scale\n     * @param b - y skew\n     * @param c - x skew\n     * @param d - y scale\n     * @param tx - x translation\n     * @param ty - y translation\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n     *\n     * a = array[0]\n     * b = array[1]\n     * c = array[3]\n     * d = array[4]\n     * tx = array[2]\n     * ty = array[5]\n     * @param array - The array that the matrix will be populated from.\n     */\n    public fromArray(array: number[]): void\n    {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n\n    /**\n     * Sets the matrix properties.\n     * @param a - Matrix component\n     * @param b - Matrix component\n     * @param c - Matrix component\n     * @param d - Matrix component\n     * @param tx - Matrix component\n     * @param ty - Matrix component\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n\n        return this;\n    }\n\n    /**\n     * Creates an array from the current Matrix object.\n     * @param transpose - Whether we need to transpose the matrix or not\n     * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n     * @returns The newly created array which contains the matrix\n     */\n    public toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.array)\n        {\n            this.array = new Float32Array(9);\n        }\n\n        const array = out || this.array;\n\n        if (transpose)\n        {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        }\n        else\n        {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n\n        return array;\n    }\n\n    /**\n     * Get a new position with the current transformation applied.\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n     * @param pos - The origin\n     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {Point} The new point, transformed through this matrix\n     */\n    public apply<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (this.a * x) + (this.c * y) + this.tx;\n        newPos.y = (this.b * x) + (this.d * y) + this.ty;\n\n        return newPos;\n    }\n\n    /**\n     * Get a new position with the inverse of the current transformation applied.\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n     * @param pos - The origin\n     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {Point} The new point, inverse-transformed through this matrix\n     */\n    public applyInverse<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n\n        const id = 1 / ((a * d) + (c * -b));\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\n        newPos.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\n\n        return newPos;\n    }\n\n    /**\n     * Translates the matrix on the x and y.\n     * @param x - How much to translate x by\n     * @param y - How much to translate y by\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public translate(x: number, y: number): this\n    {\n        this.tx += x;\n        this.ty += y;\n\n        return this;\n    }\n\n    /**\n     * Applies a scale transformation to the matrix.\n     * @param x - The amount to scale horizontally\n     * @param y - The amount to scale vertically\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public scale(x: number, y: number): this\n    {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the matrix.\n     * @param angle - The angle in radians.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public rotate(angle: number): this\n    {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n\n        this.a = (a1 * cos) - (this.b * sin);\n        this.b = (a1 * sin) + (this.b * cos);\n        this.c = (c1 * cos) - (this.d * sin);\n        this.d = (c1 * sin) + (this.d * cos);\n        this.tx = (tx1 * cos) - (this.ty * sin);\n        this.ty = (tx1 * sin) + (this.ty * cos);\n\n        return this;\n    }\n\n    /**\n     * Appends the given Matrix to this Matrix.\n     * @param matrix - The matrix to append.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public append(matrix: Matrix): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n\n        this.a = (matrix.a * a1) + (matrix.b * c1);\n        this.b = (matrix.a * b1) + (matrix.b * d1);\n        this.c = (matrix.c * a1) + (matrix.d * c1);\n        this.d = (matrix.c * b1) + (matrix.d * d1);\n\n        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;\n        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;\n\n        return this;\n    }\n\n    /**\n     * Appends two matrix's and sets the result to this matrix. AB = A * B\n     * @param a - The matrix to append.\n     * @param b - The matrix to append.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public appendFrom(a: Matrix, b: Matrix): this\n    {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n\n        this.a = (a1 * a2) + (b1 * c2);\n        this.b = (a1 * b2) + (b1 * d2);\n        this.c = (c1 * a2) + (d1 * c2);\n        this.d = (c1 * b2) + (d1 * d2);\n        this.tx = (tx * a2) + (ty * c2) + b.tx;\n        this.ty = (tx * b2) + (ty * d2) + b.ty;\n\n        return this;\n    }\n\n    /**\n     * Sets the matrix based on all the available properties\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis\n     * @param pivotX - Pivot on the x axis\n     * @param pivotY - Pivot on the y axis\n     * @param scaleX - Scale on the x axis\n     * @param scaleY - Scale on the y axis\n     * @param rotation - Rotation in radians\n     * @param skewX - Skew on the x axis\n     * @param skewY - Skew on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public setTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number,\n        scaleY: number, rotation: number, skewX: number, skewY: number): this\n    {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n\n        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));\n        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));\n\n        return this;\n    }\n\n    /**\n     * Prepends the given Matrix to this Matrix.\n     * @param matrix - The matrix to prepend\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public prepend(matrix: Matrix): this\n    {\n        const tx1 = this.tx;\n\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)\n        {\n            const a1 = this.a;\n            const c1 = this.c;\n\n            this.a = (a1 * matrix.a) + (this.b * matrix.c);\n            this.b = (a1 * matrix.b) + (this.b * matrix.d);\n            this.c = (c1 * matrix.a) + (this.d * matrix.c);\n            this.d = (c1 * matrix.b) + (this.d * matrix.d);\n        }\n\n        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;\n        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n     * @param transform - The transform to apply the properties to.\n     * @returns The transform with the newly applied properties\n     */\n    public decompose(transform: TransformableObject): TransformableObject\n    {\n        // sort out rotation / skew..\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n\n        const delta = Math.abs(skewX + skewY);\n\n        if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001)\n        {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        }\n        else\n        {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n\n        // next set scale\n        transform.scale.x = Math.sqrt((a * a) + (b * b));\n        transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n        // next set position\n        transform.position.x = this.tx + ((pivot.x * a) + (pivot.y * c));\n        transform.position.y = this.ty + ((pivot.x * b) + (pivot.y * d));\n\n        return transform;\n    }\n\n    /**\n     * Inverts this matrix\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public invert(): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = (a1 * d1) - (b1 * c1);\n\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;\n        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;\n\n        return this;\n    }\n\n    /** Checks if this matrix is an identity matrix */\n    public isIdentity(): boolean\n    {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n\n    /**\n     * Resets this Matrix to an identity (default) matrix.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public identity(): this\n    {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n\n        return this;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @returns A copy of this matrix. Good for chaining method calls.\n     */\n    public clone(): Matrix\n    {\n        const matrix = new Matrix();\n\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the given matrix to be the same as the ones in this matrix\n     * @param matrix - The matrix to copy to.\n     * @returns The matrix given in parameter with its values updated.\n     */\n    public copyTo(matrix: Matrix): Matrix\n    {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the matrix to be the same as the ones in given matrix\n     * @param matrix - The matrix to copy from.\n     * @returns this\n     */\n    public copyFrom(matrix: Matrix): this\n    {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * check to see if two matrices are the same\n     * @param matrix - The matrix to compare to.\n     */\n    public equals(matrix: Matrix)\n    {\n        return matrix.a === this.a && matrix.b === this.b\n            && matrix.c === this.c && matrix.d === this.d\n            && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    // #endif\n\n    /**\n     * A default (identity) matrix.\n     *\n     * This is a shared object, if you want to modify it consider creating a new `Matrix`\n     * @readonly\n     */\n    static get IDENTITY(): Readonly<Matrix>\n    {\n        return identityMatrix.identity();\n    }\n\n    /**\n     * A static Matrix that can be used to avoid creating new objects.\n     * Will always ensure the matrix is reset to identity when requested.\n     * Use this object for fast but temporary calculations, as it may be mutated later on.\n     * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n     * @readonly\n     */\n    static get shared(): Matrix\n    {\n        return tempMatrix.identity();\n    }\n}\n\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n","\"use strict\";\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\n\nexport { DEG_TO_RAD, PI_2, RAD_TO_DEG };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Two Pi.\n * @static\n * @member {number}\n * @memberof maths\n */\nexport const PI_2 = Math.PI * 2;\n\n/**\n * Conversion factor for converting radians to degrees.\n * @static\n * @member {number} RAD_TO_DEG\n * @memberof maths\n */\nexport const RAD_TO_DEG = 180 / Math.PI;\n\n/**\n * Conversion factor for converting degrees to radians.\n * @static\n * @member {number}\n * @memberof maths\n */\nexport const DEG_TO_RAD = Math.PI / 180;\n\n/**\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\n * @memberof maths\n */\nexport type SHAPE_PRIMITIVE =\n    | 'polygon'\n    | 'rectangle'\n    | 'circle'\n    | 'ellipse'\n    | 'triangle'\n    | 'roundedRectangle';\n\n/**\n * The `maths` folder contains utility classes and functions for mathematical operations used throughout the project.\n * This includes constants such as conversion factors for radians and degrees, as well as shapes such as polygons,\n * rectangles, circles, ellipses, triangles, and rounded rectangles.\n * ```js\n * import { RAD_TO_DEG, Circle } from 'pixi.js';\n *\n * // Convert 180 degrees to radians\n * const radians = 180 * RAD_TO_DEG;\n *\n * // test if a point is inside a circle\n * const isPointInCircle = new Circle(0, 0, 10).contains(0, 0); // true\n * ```\n * @namespace maths\n */\n","\"use strict\";\nconst uidCache = {\n  default: -1\n};\nfunction uid(name = \"default\") {\n  if (uidCache[name] === void 0) {\n    uidCache[name] = -1;\n  }\n  return ++uidCache[name];\n}\nfunction resetUids() {\n  for (const key in uidCache) {\n    delete uidCache[key];\n  }\n}\n\nexport { resetUids, uid };\n//# sourceMappingURL=uid.mjs.map\n","const uidCache: Record<string, number> = {\n    default: -1,\n};\n\ntype UIDNames =\n    | 'default'\n    | 'resource'\n    | 'texture'\n    | 'textureSource'\n    | 'textureResource'\n    | 'batcher' //\n    | 'graphicsContext' //\n    | 'graphicsView' //\n    | 'graphicsPath' //\n    | 'fillGradient' //\n    | 'fillPattern' //\n    | 'meshView' //\n    | 'renderable' //\n    | 'buffer' //\n    | 'bufferResource' //\n    | 'geometry'\n    | 'instructionSet' //\n    | 'renderTarget' //\n    | 'uniform' //\n    | 'spriteView' //\n    | 'textView' //\n    | 'tilingSpriteView'; // ;\n\n/**\n * Gets the next unique identifier\n * @param name - The name of the identifier.\n * @function uid\n * @returns {number} The next unique identifier to use.\n * @memberof utils\n */\nexport function uid(name: UIDNames = 'default'): number\n{\n    if (uidCache[name] === undefined)\n    {\n        uidCache[name] = -1;\n    }\n\n    return ++uidCache[name];\n}\n\n/** Resets the next unique identifier to 0. This is used for some tests, dont touch or things WILL explode :) */\nexport function resetUids(): void\n{\n    for (const key in uidCache)\n    {\n        delete uidCache[key];\n    }\n}\n","\"use strict\";\nconst warnings = {};\nconst v8_0_0 = \"8.0.0\";\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === \"undefined\") {\n    console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split(\"\\n\").splice(ignoreDepth).join(\"\\n\");\n    if (console.groupCollapsed) {\n      console.groupCollapsed(\n        \"%cPixiJS Deprecation Warning: %c%s\",\n        \"color:#614108;background:#fffbe6\",\n        \"font-weight:normal;color:#614108;background:#fffbe6\",\n        `${message}\nDeprecated since v${version}`\n      );\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\nexport { deprecation, v8_0_0 };\n//# sourceMappingURL=deprecation.mjs.map\n","import type { Dict } from '../types';\n\n// A map of warning messages already fired\nconst warnings: Dict<boolean> = {};\n\n/**\n * deprecation name for version 8.0.0\n * @ignore\n */\nexport const v8_0_0 = '8.0.0';\n\n/**\n * Helper for warning developers about deprecated features & settings.\n * A stack track for warnings is given; useful for tracking-down where\n * deprecated methods/properties/classes are being used within the code.\n * @memberof utils\n * @ignore\n * @function deprecation\n * @param {string} version - The version where the feature became deprecated\n * @param {string} message - Message should include what is deprecated, where, and the new solution\n * @param {number} [ignoreDepth=3] - The number of steps to ignore at the top of the error stack\n *        this is mostly to ignore internal deprecation calls.\n */\nexport function deprecation(version: string, message: string, ignoreDepth = 3): void\n{\n    // Ignore duplicat\n    if (warnings[message])\n    {\n        return;\n    }\n\n    /* eslint-disable no-console */\n    let stack = new Error().stack;\n\n    // Handle IE < 10 and Safari < 6\n    if (typeof stack === 'undefined')\n    {\n        console.warn('PixiJS Deprecation Warning: ', `${message}\\nDeprecated since v${version}`);\n    }\n    else\n    {\n        // chop off the stack trace which includes PixiJS internal calls\n        stack = stack.split('\\n').splice(ignoreDepth).join('\\n');\n\n        if (console.groupCollapsed)\n        {\n            console.groupCollapsed(\n                '%cPixiJS Deprecation Warning: %c%s',\n                'color:#614108;background:#fffbe6',\n                'font-weight:normal;color:#614108;background:#fffbe6',\n                `${message}\\nDeprecated since v${version}`\n            );\n            console.warn(stack);\n            console.groupEnd();\n        }\n        else\n        {\n            console.warn('PixiJS Deprecation Warning: ', `${message}\\nDeprecated since v${version}`);\n            console.warn(stack);\n        }\n    }\n    /* eslint-enable no-console */\n\n    warnings[message] = true;\n}\n","\"use strict\";\nconst NOOP = () => {\n};\n\nexport { NOOP };\n//# sourceMappingURL=NOOP.mjs.map\n","export const NOOP = () =>\n{\n    // empty!\n};\n","import { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass BufferImageSource extends TextureSource {\n  constructor(options) {\n    const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n    let format = options.format;\n    if (!format) {\n      if (buffer instanceof Float32Array) {\n        format = \"rgba32float\";\n      } else if (buffer instanceof Int32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Uint32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Int16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Uint16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Int8Array) {\n        format = \"bgra8unorm\";\n      } else {\n        format = \"bgra8unorm\";\n      }\n    }\n    super({\n      ...options,\n      resource: buffer,\n      format\n    });\n    this.uploadMethodId = \"buffer\";\n  }\n  static test(resource) {\n    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n  }\n}\nBufferImageSource.extension = ExtensionType.TextureSource;\n\nexport { BufferImageSource };\n//# sourceMappingURL=BufferSource.mjs.map\n","import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface BufferSourceOptions extends TextureSourceOptions<TypedArray | ArrayBuffer>\n{\n    width: number;\n    height: number;\n}\n\nexport class BufferImageSource extends TextureSource<TypedArray | ArrayBuffer>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'buffer';\n\n    constructor(options: BufferSourceOptions)\n    {\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n\n        if (!format)\n        {\n            if (buffer instanceof Float32Array)\n            {\n                format = 'rgba32float';\n            }\n            else if (buffer instanceof Int32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Uint32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Int16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Uint16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Int8Array)\n            {\n                format = 'bgra8unorm';\n            }\n            else\n            {\n                format = 'bgra8unorm';\n            }\n        }\n\n        super({\n            ...options,\n            resource: buffer,\n            format,\n        });\n    }\n\n    public static test(resource: any): resource is TypedArray | ArrayBuffer\n    {\n        return resource instanceof Int8Array\n        || resource instanceof Uint8Array\n        || resource instanceof Uint8ClampedArray\n        || resource instanceof Int16Array\n        || resource instanceof Uint16Array\n        || resource instanceof Int32Array\n        || resource instanceof Uint32Array\n        || resource instanceof Float32Array;\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2.mjs';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps.mjs';\nimport { uid } from '../../../../../utils/data/uid.mjs';\nimport { TextureStyle } from '../TextureStyle.mjs';\n\n\"use strict\";\nconst _TextureSource = class _TextureSource extends EventEmitter {\n  /**\n   * @param options - options for creating a new TextureSource\n   */\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    /** unique id for this Texture source */\n    this.uid = uid(\"textureSource\");\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    this._resourceType = \"textureSource\";\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    this.uploadMethodId = \"unknown\";\n    // dimensions\n    this._resolution = 1;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelHeight = 1;\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    this.width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    this.height = 1;\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    this.sampleCount = 1;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    this.mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    this.autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    this.format = \"rgba8unorm\";\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    this.dimension = \"2d\";\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    this.antialias = false;\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    this._touched = 0;\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    this._batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    this._textureBindLocation = -1;\n    options = { ..._TextureSource.defaultOptions, ...options };\n    this.label = options.label ?? \"\";\n    this.resource = options.resource;\n    this.autoGarbageCollect = options.autoGarbageCollect;\n    this._resolution = options.resolution;\n    if (options.width) {\n      this.pixelWidth = options.width * this._resolution;\n    } else {\n      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n    }\n    if (options.height) {\n      this.pixelHeight = options.height * this._resolution;\n    } else {\n      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n    }\n    this.width = this.pixelWidth / this._resolution;\n    this.height = this.pixelHeight / this._resolution;\n    this.format = options.format;\n    this.dimension = options.dimensions;\n    this.mipLevelCount = options.mipLevelCount;\n    this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n    this.sampleCount = options.sampleCount;\n    this.antialias = options.antialias;\n    this.alphaMode = options.alphaMode;\n    this.style = new TextureStyle(definedProps(options));\n    this.destroyed = false;\n    this._refreshPOT();\n  }\n  /** returns itself */\n  get source() {\n    return this;\n  }\n  /** the style of the texture */\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (this.style === value)\n      return;\n    this._style?.off(\"change\", this._onStyleChange, this);\n    this._style = value;\n    this._style?.on(\"change\", this._onStyleChange, this);\n    this._onStyleChange();\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this._style.addressMode;\n  }\n  set addressMode(value) {\n    this._style.addressMode = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get repeatMode() {\n    return this._style.addressMode;\n  }\n  set repeatMode(value) {\n    this._style.addressMode = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n  get magFilter() {\n    return this._style.magFilter;\n  }\n  set magFilter(value) {\n    this._style.magFilter = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n  get minFilter() {\n    return this._style.minFilter;\n  }\n  set minFilter(value) {\n    this._style.minFilter = value;\n  }\n  /** Specifies behavior for sampling between mipmap levels. */\n  get mipmapFilter() {\n    return this._style.mipmapFilter;\n  }\n  set mipmapFilter(value) {\n    this._style.mipmapFilter = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMinClamp() {\n    return this._style.lodMinClamp;\n  }\n  set lodMinClamp(value) {\n    this._style.lodMinClamp = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMaxClamp() {\n    return this._style.lodMaxClamp;\n  }\n  set lodMaxClamp(value) {\n    this._style.lodMaxClamp = value;\n  }\n  _onStyleChange() {\n    this.emit(\"styleChange\", this);\n  }\n  /** call this if you have modified the texture outside of the constructor */\n  update() {\n    if (this.resource) {\n      const resolution = this._resolution;\n      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n      if (didResize)\n        return;\n    }\n    this.emit(\"update\", this);\n  }\n  /** Destroys this texture source */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    if (this._style) {\n      this._style.destroy();\n      this._style = null;\n    }\n    this.uploadMethodId = null;\n    this.resource = null;\n    this.removeAllListeners();\n  }\n  /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */\n  unload() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    this.emit(\"unload\", this);\n  }\n  /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n  get resourceWidth() {\n    const { resource } = this;\n    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n  }\n  /** the height of the resource. This is the REAL pure number, not accounting resolution */\n  get resourceHeight() {\n    const { resource } = this;\n    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n  }\n  /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(resolution) {\n    if (this._resolution === resolution)\n      return;\n    this._resolution = resolution;\n    this.width = this.pixelWidth / resolution;\n    this.height = this.pixelHeight / resolution;\n  }\n  /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */\n  resize(width, height, resolution) {\n    resolution = resolution || this._resolution;\n    width = width || this.width;\n    height = height || this.height;\n    const newPixelWidth = Math.round(width * resolution);\n    const newPixelHeight = Math.round(height * resolution);\n    this.width = newPixelWidth / resolution;\n    this.height = newPixelHeight / resolution;\n    this._resolution = resolution;\n    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {\n      return false;\n    }\n    this._refreshPOT();\n    this.pixelWidth = newPixelWidth;\n    this.pixelHeight = newPixelHeight;\n    this.emit(\"resize\", this);\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    return true;\n  }\n  /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n   */\n  updateMipmaps() {\n    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {\n      this.emit(\"updateMipmaps\", this);\n    }\n  }\n  set wrapMode(value) {\n    this._style.wrapMode = value;\n  }\n  get wrapMode() {\n    return this._style.wrapMode;\n  }\n  set scaleMode(value) {\n    this._style.scaleMode = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this._style.scaleMode;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n  }\n  static test(_resource) {\n    throw new Error(\"Unimplemented\");\n  }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */\n_TextureSource.defaultOptions = {\n  resolution: 1,\n  format: \"bgra8unorm\",\n  alphaMode: \"premultiply-alpha-on-upload\",\n  dimensions: \"2d\",\n  mipLevelCount: 1,\n  autoGenerateMipmaps: false,\n  sampleCount: 1,\n  antialias: false,\n  autoGarbageCollect: false\n};\nlet TextureSource = _TextureSource;\n\nexport { TextureSource };\n//# sourceMappingURL=TextureSource.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps';\nimport { uid } from '../../../../../utils/data/uid';\nimport { TextureStyle } from '../TextureStyle';\n\nimport type { BindResource } from '../../../gpu/shader/BindResource';\nimport type { ALPHA_MODES, SCALE_MODE, TEXTURE_DIMENSIONS, TEXTURE_FORMATS, WRAP_MODE } from '../const';\nimport type { TextureStyleOptions } from '../TextureStyle';\n\n/**\n * options for creating a new TextureSource\n * @memberof rendering\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions\n{\n    /**\n     * the resource that will be upladed to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    resource?: T;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    width?: number;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    height?: number;\n    /** the resolution of the texture. */\n    resolution?: number;\n    /** the format that the texture data has */\n    format?: TEXTURE_FORMATS;\n    /**\n     * Used by internal textures\n     * @ignore\n     */\n    sampleCount?: number;\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    antialias?: boolean;\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    dimensions?: TEXTURE_DIMENSIONS;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    mipLevelCount?: number;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    autoGenerateMipmaps?: boolean;\n    /** the alpha mode of the texture */\n    alphaMode?: ALPHA_MODES;\n    /** optional label, can be used for debugging */\n    label?: string;\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    autoGarbageCollect?: boolean;\n}\n\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @memberof rendering\n * @typeParam T - The TextureSource's Resource type.\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n    change: BindResource;\n    update: TextureSource;\n    unload: TextureSource;\n    destroy: TextureSource;\n    resize: TextureSource;\n    styleChange: TextureSource;\n    updateMipmaps: TextureSource;\n    error: Error;\n}> implements BindResource\n{\n    /** The default options used when creating a new TextureSource. override these to add your own defaults */\n    public static defaultOptions: TextureSourceOptions = {\n        resolution: 1,\n        format: 'bgra8unorm',\n        alphaMode: 'premultiply-alpha-on-upload',\n        dimensions: '2d',\n        mipLevelCount: 1,\n        autoGenerateMipmaps: false,\n        sampleCount: 1,\n        antialias: false,\n        autoGarbageCollect: false,\n    };\n\n    /** unique id for this Texture source */\n    public readonly uid = uid('textureSource');\n    /** optional label, can be used for debugging */\n    public label: string;\n\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    public readonly _resourceType = 'textureSource';\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    public _resourceId = uid('resource');\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    public uploadMethodId = 'unknown';\n\n    // dimensions\n    public _resolution = 1;\n\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelHeight = 1;\n\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    public width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    public height = 1;\n\n    /**\n     * the resource that will be upladed to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    public resource: T;\n\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    public sampleCount = 1;\n\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    public mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    public autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    public format: TEXTURE_FORMATS = 'rgba8unorm';\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    public dimension: TEXTURE_DIMENSIONS = '2d';\n    /** the alpha mode of the texture */\n    public alphaMode: ALPHA_MODES;\n    private _style: TextureStyle;\n\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    public antialias = false;\n\n    /**\n     * Has the source been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    public _touched = 0;\n\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    public _batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    public _textureBindLocation = -1;\n\n    public isPowerOfTwo: boolean;\n\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    public autoGarbageCollect: boolean;\n\n    /**\n     * used internally to know where a texture came from. Usually assigned by the asset loader!\n     * @ignore\n     */\n    public _sourceOrigin: string;\n\n    /**\n     * @param options - options for creating a new TextureSource\n     */\n    constructor(protected readonly options: TextureSourceOptions<T> = {})\n    {\n        super();\n\n        options = { ...TextureSource.defaultOptions, ...options };\n\n        this.label = options.label ?? '';\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n\n        if (options.width)\n        {\n            this.pixelWidth = options.width * this._resolution;\n        }\n        else\n        {\n            this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1;\n        }\n\n        if (options.height)\n        {\n            this.pixelHeight = options.height * this._resolution;\n        }\n        else\n        {\n            this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1;\n        }\n\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n\n        this.style = new TextureStyle(definedProps(options));\n\n        this.destroyed = false;\n\n        this._refreshPOT();\n    }\n\n    /** returns itself */\n    get source(): TextureSource\n    {\n        return this;\n    }\n\n    /** the style of the texture */\n    get style(): TextureStyle\n    {\n        return this._style;\n    }\n\n    set style(value: TextureStyle)\n    {\n        if (this.style === value) return;\n\n        this._style?.off('change', this._onStyleChange, this);\n        this._style = value;\n        this._style?.on('change', this._onStyleChange, this);\n\n        this._onStyleChange();\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get repeatMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set repeatMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    get magFilter(): SCALE_MODE\n    {\n        return this._style.magFilter;\n    }\n\n    set magFilter(value: SCALE_MODE)\n    {\n        this._style.magFilter = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    get minFilter(): SCALE_MODE\n    {\n        return this._style.minFilter;\n    }\n\n    set minFilter(value: SCALE_MODE)\n    {\n        this._style.minFilter = value;\n    }\n\n    /** Specifies behavior for sampling between mipmap levels. */\n    get mipmapFilter(): SCALE_MODE\n    {\n        return this._style.mipmapFilter;\n    }\n\n    set mipmapFilter(value: SCALE_MODE)\n    {\n        this._style.mipmapFilter = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMinClamp(): number\n    {\n        return this._style.lodMinClamp;\n    }\n\n    set lodMinClamp(value: number)\n    {\n        this._style.lodMinClamp = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMaxClamp(): number\n    {\n        return this._style.lodMaxClamp;\n    }\n\n    set lodMaxClamp(value: number)\n    {\n        this._style.lodMaxClamp = value;\n    }\n\n    private _onStyleChange()\n    {\n        this.emit('styleChange', this);\n    }\n\n    /** call this if you have modified the texture outside of the constructor */\n    public update()\n    {\n        // update resource...\n        if (this.resource)\n        {\n            const resolution = this._resolution;\n\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n\n            // no ned to dispatch the update we resized as that will\n            // notify the texture systems anyway\n            if (didResize) return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /** Destroys this texture source */\n    public destroy()\n    {\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        if (this._style)\n        {\n            this._style.destroy();\n            this._style = null;\n        }\n\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n\n    /**\n     * This will unload the Texture source from the GPU. This will free up the GPU memory\n     * As soon as it is required fore rendering, it will be re-uploaded.\n     */\n    public unload()\n    {\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n        this.emit('unload', this);\n    }\n\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n    public get resourceWidth(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */\n    public get resourceHeight(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n\n    /**\n     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n     * but will the size of the texture when rendered.\n     *\n     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n     * density will have increased)\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number)\n    {\n        if (this._resolution === resolution) return;\n\n        this._resolution = resolution;\n\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n\n    /**\n     * Resize the texture, this is handy if you want to use the texture as a render texture\n     * @param width - the new width of the texture\n     * @param height - the new height of the texture\n     * @param resolution - the new resolution of the texture\n     * @returns - if the texture was resized\n     */\n    public resize(width?: number, height?: number, resolution?: number): boolean\n    {\n        resolution = resolution || this._resolution;\n        width = width || this.width;\n        height = height || this.height;\n\n        // make sure we work with rounded pixels\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n\n        this._resolution = resolution;\n\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight)\n        {\n            return false;\n        }\n\n        this._refreshPOT();\n\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n\n        this.emit('resize', this);\n\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        return true;\n    }\n\n    /**\n     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n     * This is only important for RenderTexture instances, as standard Texture instances will have their\n     * mipmaps generated on upload. You should call this method after you make any change to the texture\n     *\n     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n     * We want you, the developer to specify when this action should happen.\n     *\n     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n     */\n    public updateMipmaps()\n    {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1)\n        {\n            this.emit('updateMipmaps', this);\n        }\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        this._style.wrapMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this._style.wrapMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this._style.scaleMode = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this._style.scaleMode;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n    }\n\n    public static test(_resource: any): any\n    {\n        // this should be overridden by other sources..\n        throw new Error('Unimplemented');\n    }\n}\n","\"use strict\";\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\nexport { isPow2, log2, nextPow2 };\n//# sourceMappingURL=pow2.mjs.map\n","// Taken from the bit-twiddle package\n\n/**\n * Rounds to next power of two.\n * @function nextPow2\n * @param {number} v - input value\n * @returns {number} - next rounded power of two\n * @memberof maths\n */\nexport function nextPow2(v: number): number\n{\n    v += v === 0 ? 1 : 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n\n    return v + 1;\n}\n\n/**\n * Checks if a number is a power of two.\n * @function isPow2\n * @param {number} v - input value\n * @returns {boolean} `true` if value is power of two\n * @memberof maths\n */\nexport function isPow2(v: number): boolean\n{\n    return !(v & (v - 1)) && (!!v);\n}\n\n/**\n * Computes ceil of log base 2\n * @function log2\n * @param {number} v - input value\n * @returns {number} logarithm base 2\n * @memberof maths\n */\nexport function log2(v: number): number\n{\n    let r = (v > 0xFFFF ? 1 : 0) << 4;\n\n    v >>>= r;\n\n    let shift = (v > 0xFF ? 1 : 0) << 3;\n\n    v >>>= shift; r |= shift;\n    shift = (v > 0xF ? 1 : 0) << 2;\n    v >>>= shift; r |= shift;\n    shift = (v > 0x3 ? 1 : 0) << 1;\n    v >>>= shift; r |= shift;\n\n    return r | (v >> 1);\n}\n","\"use strict\";\nfunction definedProps(obj) {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] !== void 0) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\nexport { definedProps };\n//# sourceMappingURL=definedProps.mjs.map\n","/**\n * Returns a new object with all properties from the input object that have defined values.\n * @template T - The type of the input object.\n * @param {T} obj - The input object.\n * @returns {T} - A new object with only the defined properties from the input object.\n * @memberof utils\n * @ignore\n */\nexport function definedProps<T extends Record<string, any>>(obj: T): T\n{\n    const result: Partial<T> = {};\n\n    for (const key in obj)\n    {\n        if (obj[key] !== undefined)\n        {\n            result[key] = obj[key];\n        }\n    }\n\n    return result as T;\n}\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createResourceIdFromString(value) {\n  const id = idHash[value];\n  if (id === void 0) {\n    idHash[value] = uid(\"resource\");\n  }\n  return id;\n}\nconst _TextureStyle = class _TextureStyle extends EventEmitter {\n  /**\n   * @param options - options for the style\n   */\n  constructor(options = {}) {\n    super();\n    this._resourceType = \"textureSampler\";\n    this._touched = 0;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    this._maxAnisotropy = 1;\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    options = { ..._TextureStyle.defaultOptions, ...options };\n    this.addressMode = options.addressMode;\n    this.addressModeU = options.addressModeU ?? this.addressModeU;\n    this.addressModeV = options.addressModeV ?? this.addressModeV;\n    this.addressModeW = options.addressModeW ?? this.addressModeW;\n    this.scaleMode = options.scaleMode;\n    this.magFilter = options.magFilter ?? this.magFilter;\n    this.minFilter = options.minFilter ?? this.minFilter;\n    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n    this.lodMinClamp = options.lodMinClamp;\n    this.lodMaxClamp = options.lodMaxClamp;\n    this.compare = options.compare;\n    this.maxAnisotropy = options.maxAnisotropy ?? 1;\n  }\n  set addressMode(value) {\n    this.addressModeU = value;\n    this.addressModeV = value;\n    this.addressModeW = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this.addressModeU;\n  }\n  set wrapMode(value) {\n    deprecation(v8_0_0, \"TextureStyle.wrapMode is now TextureStyle.addressMode\");\n    this.addressMode = value;\n  }\n  get wrapMode() {\n    return this.addressMode;\n  }\n  set scaleMode(value) {\n    this.magFilter = value;\n    this.minFilter = value;\n    this.mipmapFilter = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this.magFilter;\n  }\n  /** Specifies the maximum anisotropy value clamp used by the sampler. */\n  set maxAnisotropy(value) {\n    this._maxAnisotropy = Math.min(value, 16);\n    if (this._maxAnisotropy > 1) {\n      this.scaleMode = \"linear\";\n    }\n  }\n  get maxAnisotropy() {\n    return this._maxAnisotropy;\n  }\n  // TODO - move this to WebGL?\n  get _resourceId() {\n    return this._sharedResourceId || this._generateResourceId();\n  }\n  update() {\n    this.emit(\"change\", this);\n    this._sharedResourceId = null;\n  }\n  _generateResourceId() {\n    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n    this._sharedResourceId = createResourceIdFromString(bigKey);\n    return this._resourceId;\n  }\n  /** Destroys the style */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this.removeAllListeners();\n  }\n};\n/** default options for the style */\n_TextureStyle.defaultOptions = {\n  addressMode: \"clamp-to-edge\",\n  scaleMode: \"linear\"\n};\nlet TextureStyle = _TextureStyle;\n\nexport { TextureStyle };\n//# sourceMappingURL=TextureStyle.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { COMPARE_FUNCTION, SCALE_MODE, WRAP_MODE } from './const';\n\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * This takes a shader string and maps it to a resource id.\n * This is a little different than regular resource ids as these ids\n * are not unique to the resource. But must not overlap with other (non sampler) resources Ids.\n * @param value - the string to turn into a resource id\n * @returns a unique resource id\n */\nfunction createResourceIdFromString(value: string): number\n{\n    const id = idHash[value];\n\n    if (id === undefined)\n    {\n        idHash[value] = uid('resource');\n    }\n\n    return id;\n}\n\nexport interface TextureStyleOptions extends Partial<TextureStyle>\n{\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    addressMode?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeU?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeW?: WRAP_MODE;\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    scaleMode?: SCALE_MODE;\n\n    /** specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    magFilter?: SCALE_MODE;\n    /** specifies the sampling behavior when the sample footprint is larger than one texel. */\n    minFilter?: SCALE_MODE;\n    /** specifies behavior for sampling between mipmap levels. */\n    mipmapFilter?: SCALE_MODE;\n\n    /** specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     *\n     * setting this to anything higher than 1 will set scale modes to 'linear'\n     */\n    maxAnisotropy?: number;\n}\n\n/**\n * A texture style describes how a texture should be sampled by a shader.\n * @memberof rendering\n */\nexport class TextureStyle extends EventEmitter<{\n    change: TextureStyle,\n    destroy: TextureStyle,\n}> implements BindResource\n{\n    public _resourceType = 'textureSampler';\n    public _touched = 0;\n    private _sharedResourceId: number;\n\n    /** default options for the style */\n    public static readonly defaultOptions: TextureStyleOptions = {\n        addressMode: 'clamp-to-edge',\n        scaleMode: 'linear'\n    };\n\n    /** */\n    public addressModeU?: WRAP_MODE;\n    /** */\n    public addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    public addressModeW?: WRAP_MODE;\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    public magFilter?: SCALE_MODE;\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    public minFilter?: SCALE_MODE;\n    /** Specifies behavior for sampling between mipmap levels. */\n    public mipmapFilter?: SCALE_MODE;\n    /** */\n    public lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    public lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    public compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    public _maxAnisotropy?: number = 1;\n\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * @param options - options for the style\n     */\n    constructor(options: TextureStyleOptions = {})\n    {\n        super();\n\n        options = { ...TextureStyle.defaultOptions, ...options };\n\n        this.addressMode = options.addressMode;\n\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n\n        this.scaleMode = options.scaleMode;\n\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n\n        this.compare = options.compare;\n\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this.addressModeU;\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'TextureStyle.wrapMode is now TextureStyle.addressMode');\n        // #endif\n\n        this.addressMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this.addressMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this.magFilter;\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._maxAnisotropy = Math.min(value, 16);\n\n        if (this._maxAnisotropy > 1)\n        {\n            this.scaleMode = 'linear';\n        }\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._maxAnisotropy;\n    }\n\n    // TODO - move this to WebGL?\n    get _resourceId(): number\n    {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n\n    public update()\n    {\n        // manage the resource..\n        this.emit('change', this);\n        this._sharedResourceId = null;\n    }\n\n    private _generateResourceId(): number\n    {\n        // eslint-disable-next-line max-len\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n\n        this._sharedResourceId = createResourceIdFromString(bigKey);\n\n        return this._resourceId;\n    }\n\n    /** Destroys the style */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this.removeAllListeners();\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\n\n\"use strict\";\nconst tempMat = new Matrix();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this.mapCoord = new Matrix();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    if (typeof clampMargin === \"undefined\") {\n      this.clampMargin = texture.width < 10 ? 0 : 0.5;\n    } else {\n      this.clampMargin = clampMargin;\n    }\n    this.isSimple = false;\n    this.texture = texture;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this.texture === value)\n      return;\n    this._texture?.removeListener(\"update\", this.update, this);\n    this._texture = value;\n    this._texture.addListener(\"update\", this.update, this);\n    this.update();\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */\n  update() {\n    const tex = this._texture;\n    this._updateID++;\n    const uvs = tex.uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(\n        orig.width / trim.width,\n        0,\n        0,\n        orig.height / trim.height,\n        -trim.x / trim.width,\n        -trim.y / trim.height\n      );\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.source;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase._resolution;\n    const offset = this.clampOffset;\n    frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = offset / texBase.pixelWidth;\n    this.uClampOffset[1] = offset / texBase.pixelHeight;\n    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\nexport { TextureMatrix };\n//# sourceMappingURL=TextureMatrix.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\n\nimport type { Texture } from './Texture';\n\nconst tempMat = new Matrix();\n\n/**\n * Class controls uv mapping from Texture normal space to BaseTexture normal space.\n *\n * Takes `trim` and `rotate` into account. May contain clamp settings for Meshes and TilingSprite.\n *\n * Can be used in Texture `uvMatrix` field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * Takes track of Texture changes through `_lastTextureID` private field.\n * Use `update()` method call to track it from outside.\n * @see Texture\n * @see Mesh\n * @see TilingSprite\n * @memberof rendering\n */\nexport class TextureMatrix\n{\n    /**\n     * Matrix operation that converts texture region coords to texture coords\n     * @readonly\n     */\n    public mapCoord: Matrix;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n     * @default 0\n     */\n    public clampOffset: number;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     */\n    public clampMargin: number;\n\n    /**\n     * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.\n     * Calculated based on clampOffset.\n     */\n    public readonly uClampFrame: Float32Array;\n\n    /** Normalized clamp offset. Calculated based on clampOffset. */\n    public readonly uClampOffset: Float32Array;\n\n    /**\n     * Tracks Texture frame changes.\n     * @ignore\n     */\n    public _updateID: number;\n\n    /**\n     * Tracks Texture frame changes.\n     * @protected\n     */\n    protected _textureID: number;\n\n    protected _texture: Texture;\n\n    /**\n     * If texture size is the same as baseTexture.\n     * @default false\n     * @readonly\n     */\n    public isSimple: boolean;\n\n    /**\n     * @param texture - observed texture\n     * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     */\n    constructor(texture: Texture, clampMargin?: number)\n    {\n        this.mapCoord = new Matrix();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n\n        this.clampOffset = 0;\n\n        if ((typeof clampMargin === 'undefined'))\n        {\n            this.clampMargin = (texture.width < 10) ? 0 : 0.5;\n        }\n        else\n        {\n            this.clampMargin = clampMargin;\n        }\n\n        this.isSimple = false;\n\n        this.texture = texture;\n    }\n\n    /** Texture property. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this._texture?.removeListener('update', this.update, this);\n        this._texture = value;\n        this._texture.addListener('update', this.update, this);\n\n        this.update();\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param uvs - mesh uvs\n     * @param [out=uvs] - output\n     * @returns - output\n     */\n    public multiplyUvs(uvs: Float32Array, out?: Float32Array): Float32Array\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * Updates matrices if texture was changed\n     * @returns - whether or not it was updated\n     */\n    public update(): boolean\n    {\n        const tex = this._texture;\n\n        this._updateID++;\n\n        const uvs = tex.uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(\n                orig.width / trim.width,\n                0, 0, orig.height / trim.height,\n                -trim.x / trim.width,\n                -trim.y / trim.height\n            );\n\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset;\n\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n\n        this.uClampOffset[0] = offset / texBase.pixelWidth;\n        this.uClampOffset[1] = offset / texBase.pixelHeight;\n\n        this.isSimple = tex.frame.width === texBase.width\n            && tex.frame.height === texBase.height\n            && tex.rotate === 0;\n\n        return true;\n    }\n}\n","\"use strict\";\nfunction updateQuadBounds(bounds, anchor, texture, padding) {\n  const { width, height } = texture.orig;\n  const trim = texture.trim;\n  if (trim) {\n    const sourceWidth = trim.width;\n    const sourceHeight = trim.height;\n    bounds.minX = trim.x - anchor._x * width - padding;\n    bounds.maxX = bounds.minX + sourceWidth;\n    bounds.minY = trim.y - anchor._y * height - padding;\n    bounds.maxY = bounds.minY + sourceHeight;\n  } else {\n    bounds.minX = -anchor._x * width - padding;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height - padding;\n    bounds.maxY = bounds.minY + height;\n  }\n  return;\n}\n\nexport { updateQuadBounds };\n//# sourceMappingURL=updateQuadBounds.mjs.map\n","import type { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../../scene/container/bounds/Bounds';\n\nexport function updateQuadBounds(\n    bounds: BoundsData,\n    anchor: ObservablePoint,\n    texture: Texture,\n    padding: number\n)\n{\n    const { width, height } = texture.orig;\n    const trim = texture.trim;\n\n    if (trim)\n    {\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n\n        bounds.minX = (trim.x) - (anchor._x * width) - padding;\n        bounds.maxX = bounds.minX + sourceWidth;\n\n        bounds.minY = (trim.y) - (anchor._y * height) - padding;\n        bounds.maxY = bounds.minY + sourceHeight;\n    }\n\n    else\n    {\n        bounds.minX = (-anchor._x * width) - padding;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = (-anchor._y * height) - padding;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    return;\n}\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../color/Color.mjs';\nimport { cullingMixin } from '../../culling/cullingMixin.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { RAD_TO_DEG, DEG_TO_RAD } from '../../maths/misc/const.mjs';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { uid } from '../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin.mjs';\nimport { effectsMixin } from './container-mixins/effectsMixin.mjs';\nimport { findMixin } from './container-mixins/findMixin.mjs';\nimport { measureMixin } from './container-mixins/measureMixin.mjs';\nimport { onRenderMixin } from './container-mixins/onRenderMixin.mjs';\nimport { sortMixin } from './container-mixins/sortMixin.mjs';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin.mjs';\nimport { RenderGroup } from './RenderGroup.mjs';\nimport { assignWithIgnore } from './utils/assignWithIgnore.mjs';\n\n\"use strict\";\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\nconst UPDATE_COLOR = 1;\nconst UPDATE_BLEND = 2;\nconst UPDATE_VISIBLE = 4;\nconst UPDATE_TRANSFORM = 8;\nclass Container extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    /** @private */\n    this.uid = uid(\"renderable\");\n    /** @private */\n    this._updateFlags = 15;\n    // is this container the root of a renderGroup?\n    // TODO implement this in a few more places\n    /** @private */\n    this.isRenderGroupRoot = false;\n    // the render group this container belongs to OR owns\n    /** @private */\n    this.renderGroup = null;\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    this.didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    this.didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    this.relativeRenderGroupDepth = 0;\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    this.children = [];\n    /** The display object container that contains this display object. */\n    this.parent = null;\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    this.includeInBuild = true;\n    /** @private */\n    this.measurable = true;\n    /** @private */\n    this.isSimple = true;\n    // / /////////////Transform related props//////////////\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    this.updateTick = -1;\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    this.localTransform = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    this.relativeGroupTransform = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    this.groupTransform = this.relativeGroupTransform;\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    this.destroyed = false;\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    this._position = new ObservablePoint(this, 0, 0);\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    this._scale = defaultScale;\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    this._pivot = defaultPivot;\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    this._skew = defaultSkew;\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cx = 1;\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sx = 0;\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cy = 0;\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sy = 1;\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    this._rotation = 0;\n    // / COLOR related props //////////////\n    // color stored as ABGR\n    this.localColor = 16777215;\n    this.localAlpha = 1;\n    this.groupAlpha = 1;\n    // A\n    this.groupColor = 16777215;\n    // BGR\n    this.groupColorAlpha = 4294967295;\n    // ABGR\n    // / BLEND related props //////////////\n    /**\n     * @internal\n     * @ignore\n     */\n    this.localBlendMode = \"inherit\";\n    /**\n     * @internal\n     * @ignore\n     */\n    this.groupBlendMode = \"normal\";\n    // / VISIBILITY related props //////////////\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = renderable, 1 = not renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    this.localDisplayStatus = 7;\n    // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    this.globalDisplayStatus = 7;\n    /**\n     * A value that increments each time the container is modified\n     * the first 12 bits represent the container changes (eg transform, alpha, visible etc)\n     * the second 12 bits represent the view changes (eg texture swap, geometry change etc)\n     *\n     *  view          container\n     * [000000000000][00000000000]\n     * @ignore\n     */\n    this._didChangeId = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    this._didLocalTransformChangeId = -1;\n    assignWithIgnore(this, options, {\n      children: true,\n      parent: true,\n      effects: true\n    });\n    options.children?.forEach((child) => this.addChild(child));\n    this.effects = [];\n    options.parent?.addChild(this);\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */\n  static mixin(source) {\n    Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n  }\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */\n  addChild(...children) {\n    if (!this.allowChildren) {\n      deprecation(v8_0_0, \"addChild: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    if (child.parent === this) {\n      this.children.splice(this.children.indexOf(child), 1);\n      this.children.push(child);\n      if (this.renderGroup && !this.isRenderGroupRoot) {\n        this.renderGroup.structureDidChange = true;\n      }\n      return child;\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    this.children.push(child);\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    if (this.renderGroup) {\n      this.renderGroup.addChild(child);\n    }\n    this.emit(\"childAdded\", child, this, this.children.length - 1);\n    child.emit(\"added\", this);\n    if (child._zIndex !== 0) {\n      child.depthOfChildModified();\n    }\n    return child;\n  }\n  /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const index = this.children.indexOf(child);\n    if (index > -1) {\n      this.children.splice(index, 1);\n      if (this.renderGroup) {\n        this.renderGroup.removeChild(child);\n      }\n      child.parent = null;\n      this.emit(\"childRemoved\", child, this, index);\n      child.emit(\"removed\", this);\n    }\n    return child;\n  }\n  /** @ignore */\n  _onUpdate(point) {\n    if (point) {\n      if (point === this._skew) {\n        this._updateSkew();\n      }\n    }\n    this._didChangeId++;\n    if (this.didChange)\n      return;\n    this.didChange = true;\n    if (this.isRenderGroupRoot) {\n      const renderGroupParent = this.renderGroup.renderGroupParent;\n      if (renderGroupParent) {\n        renderGroupParent.onChildUpdate(this);\n      }\n    } else if (this.renderGroup) {\n      this.renderGroup.onChildUpdate(this);\n    }\n  }\n  set isRenderGroup(value) {\n    if (this.isRenderGroupRoot && value === false) {\n      throw new Error(\"[Pixi] cannot undo a render group just yet\");\n    }\n    if (value) {\n      this.enableRenderGroup();\n    }\n  }\n  /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */\n  get isRenderGroup() {\n    return this.isRenderGroupRoot;\n  }\n  /** This enables the container to be rendered as a render group. */\n  enableRenderGroup() {\n    if (this.renderGroup && this.renderGroup.root === this)\n      return;\n    this.isRenderGroupRoot = true;\n    const parentRenderGroup = this.renderGroup;\n    if (parentRenderGroup) {\n      parentRenderGroup.removeChild(this);\n    }\n    this.renderGroup = new RenderGroup(this);\n    if (parentRenderGroup) {\n      for (let i = 0; i < parentRenderGroup.renderGroupChildren.length; i++) {\n        const childRenderGroup = parentRenderGroup.renderGroupChildren[i];\n        let parent = childRenderGroup.root;\n        while (parent) {\n          if (parent === this) {\n            this.renderGroup.addRenderGroupChild(childRenderGroup);\n            break;\n          }\n          parent = parent.parent;\n        }\n      }\n      parentRenderGroup.addRenderGroupChild(this.renderGroup);\n    }\n    this._updateIsSimple();\n    this.groupTransform = Matrix.IDENTITY;\n  }\n  /** @ignore */\n  _updateIsSimple() {\n    this.isSimple = !this.isRenderGroupRoot && this.effects.length === 0;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */\n  get worldTransform() {\n    this._worldTransform || (this._worldTransform = new Matrix());\n    if (this.renderGroup) {\n      if (this.isRenderGroupRoot) {\n        this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n      } else {\n        this._worldTransform.appendFrom(this.relativeGroupTransform, this.renderGroup.worldTransform);\n      }\n    }\n    return this._worldTransform;\n  }\n  // / ////// transform related stuff\n  /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */\n  get x() {\n    return this._position.x;\n  }\n  set x(value) {\n    this._position.x = value;\n  }\n  /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */\n  get y() {\n    return this._position.y;\n  }\n  set y(value) {\n    this._position.y = value;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this._skew);\n    }\n  }\n  /**\n   * The angle of the object in degrees.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get angle() {\n    return this.rotation * RAD_TO_DEG;\n  }\n  set angle(value) {\n    this.rotation = value * DEG_TO_RAD;\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent's local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */\n  get pivot() {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    return this._pivot;\n  }\n  set pivot(value) {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */\n  get skew() {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    return this._skew;\n  }\n  set skew(value) {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    this._skew.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */\n  get scale() {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 1, 1);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._scale.set(value) : this._scale.copyFrom(value);\n  }\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get width() {\n    return Math.abs(this.scale.x * this.getLocalBounds().width);\n  }\n  set width(value) {\n    const localWidth = this.getLocalBounds().width;\n    this._setWidth(value, localWidth);\n  }\n  /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get height() {\n    return Math.abs(this.scale.y * this.getLocalBounds().height);\n  }\n  set height(value) {\n    const localHeight = this.getLocalBounds().height;\n    this._setHeight(value, localHeight);\n  }\n  /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    const bounds = this.getLocalBounds();\n    out.width = Math.abs(this.scale.x * bounds.width);\n    out.height = Math.abs(this.scale.y * bounds.height);\n    return out;\n  }\n  /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */\n  setSize(value, height) {\n    const size = this.getLocalBounds();\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== \"object\") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, size.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, size.height);\n    }\n  }\n  /** Called when the skew or the rotation changes. */\n  _updateSkew() {\n    const rotation = this._rotation;\n    const skew = this._skew;\n    this._cx = Math.cos(rotation + skew._y);\n    this._sx = Math.sin(rotation + skew._y);\n    this._cy = -Math.sin(rotation - skew._x);\n    this._sy = Math.cos(rotation - skew._x);\n  }\n  /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */\n  updateTransform(opts) {\n    this.position.set(\n      typeof opts.x === \"number\" ? opts.x : this.position.x,\n      typeof opts.y === \"number\" ? opts.y : this.position.y\n    );\n    this.scale.set(\n      typeof opts.scaleX === \"number\" ? opts.scaleX || 1 : this.scale.x,\n      typeof opts.scaleY === \"number\" ? opts.scaleY || 1 : this.scale.y\n    );\n    this.rotation = typeof opts.rotation === \"number\" ? opts.rotation : this.rotation;\n    this.skew.set(\n      typeof opts.skewX === \"number\" ? opts.skewX : this.skew.x,\n      typeof opts.skewY === \"number\" ? opts.skewY : this.skew.y\n    );\n    this.pivot.set(\n      typeof opts.pivotX === \"number\" ? opts.pivotX : this.pivot.x,\n      typeof opts.pivotY === \"number\" ? opts.pivotY : this.pivot.y\n    );\n    return this;\n  }\n  /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n  }\n  /** Updates the local transform. */\n  updateLocalTransform() {\n    if ((this._didLocalTransformChangeId & 15) === this._didChangeId)\n      return;\n    this._didLocalTransformChangeId = this._didChangeId;\n    const lt = this.localTransform;\n    const scale = this._scale;\n    const pivot = this._pivot;\n    const position = this._position;\n    const sx = scale._x;\n    const sy = scale._y;\n    const px = pivot._x;\n    const py = pivot._y;\n    lt.a = this._cx * sx;\n    lt.b = this._sx * sx;\n    lt.c = this._cy * sy;\n    lt.d = this._sy * sy;\n    lt.tx = position._x - (px * lt.a + py * lt.c);\n    lt.ty = position._y - (px * lt.b + py * lt.d);\n  }\n  // / ///// color related stuff\n  set alpha(value) {\n    if (value === this.localAlpha)\n      return;\n    this.localAlpha = value;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /** The opacity of the object. */\n  get alpha() {\n    return this.localAlpha;\n  }\n  set tint(value) {\n    const tempColor = Color.shared.setValue(value ?? 16777215);\n    const bgr = tempColor.toBgrNumber();\n    if (bgr === this.localColor)\n      return;\n    this.localColor = bgr;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    const bgr = this.localColor;\n    return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);\n  }\n  // / //////////////// blend related stuff\n  set blendMode(value) {\n    if (this.localBlendMode === value)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_BLEND;\n    this.localBlendMode = value;\n    this._onUpdate();\n  }\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this.localBlendMode;\n  }\n  // / ///////// VISIBILITY / RENDERABLE /////////////////\n  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n  get visible() {\n    return !!(this.localDisplayStatus & 2);\n  }\n  set visible(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 2) >> 1 === valueNumber)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 2;\n    this._onUpdate();\n  }\n  /** @ignore */\n  get culled() {\n    return !(this.localDisplayStatus & 4);\n  }\n  /** @ignore */\n  set culled(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 4) >> 2 === valueNumber)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 4;\n    this._onUpdate();\n  }\n  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n  get renderable() {\n    return !!(this.localDisplayStatus & 1);\n  }\n  set renderable(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 1) === valueNumber)\n      return;\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 1;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._onUpdate();\n  }\n  /** Whether or not the object should be rendered. */\n  get isRenderable() {\n    return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */\n  destroy(options = false) {\n    if (this.destroyed)\n      return;\n    this.destroyed = true;\n    this.removeFromParent();\n    this.parent = null;\n    this._mask = null;\n    this._filters = null;\n    this.effects = null;\n    this._position = null;\n    this._scale = null;\n    this._pivot = null;\n    this._skew = null;\n    this.emit(\"destroyed\", this);\n    this.removeAllListeners();\n    const destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n    const oldChildren = this.removeChildren(0, this.children.length);\n    if (destroyChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  }\n}\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\n\nexport { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_TRANSFORM, UPDATE_VISIBLE };\n//# sourceMappingURL=Container.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { cullingMixin } from '../../culling/cullingMixin';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { DEG_TO_RAD, RAD_TO_DEG } from '../../maths/misc/const';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin';\nimport { effectsMixin } from './container-mixins/effectsMixin';\nimport { findMixin } from './container-mixins/findMixin';\nimport { measureMixin } from './container-mixins/measureMixin';\nimport { onRenderMixin } from './container-mixins/onRenderMixin';\nimport { sortMixin } from './container-mixins/sortMixin';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin';\nimport { RenderGroup } from './RenderGroup';\nimport { assignWithIgnore } from './utils/assignWithIgnore';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Rectangle } from '../../maths/shapes/Rectangle';\nimport type { BLEND_MODES } from '../../rendering/renderers/shared/state/const';\nimport type { Dict } from '../../utils/types';\nimport type { Optional } from './container-mixins/measureMixin';\nimport type { DestroyOptions } from './destroyTypes';\n\nexport type ContainerChild = Container;\n\n/**\n * This is where you'll find all the display objects available in Pixi.\n *\n * All display objects inherit from the {@link scene.Container} class. You can use a `Container` for simple grouping of\n * other display objects. Here's all the available display object classes.\n *\n * - {@link scene.Container} is the base class for all display objects that act as a container for other objects.\n *   - {@link scene.Sprite} is a display object that uses a texture\n *      - {@link scene.AnimatedSprite} is a sprite that can play animations\n *   - {@link scene.TilingSprite} a fast way of rendering a tiling image\n *   - {@link scene.NineSliceSprite} allows you to stretch a texture using 9-slice scaling\n *   - {@link scene.Graphics} is a graphic object that can be drawn to the screen.\n *   - {@link scene.Mesh} empowers you to have maximum flexibility to render any kind of visuals you can think of\n *      - {@link scene.MeshSimple} mimics Mesh, providing easy-to-use constructor arguments\n *      - {@link scene.MeshPlane} allows you to draw a texture across several points and then manipulate these points\n *      - {@link scene.MeshRope} allows you to draw a texture across several points and then manipulate these points\n *   - {@link scene.Text} render text using custom fonts\n *      - {@link scene.BitmapText} render text using a bitmap font\n *      - {@link scene.HTMLText} render text using HTML and CSS\n * @namespace scene\n */\n\n// as pivot and skew are the least used properties of a container, we can use this optimisation\n// to avoid allocating lots of unnecessary objects for them.\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\n\nexport interface ContainerEvents<C extends ContainerChild> extends PixiMixins.ContainerEvents\n{\n    added: [container: Container];\n    childAdded: [child: C, container: Container, index: number];\n    removed: [container: Container];\n    childRemoved: [child: C, container: Container, index: number];\n    destroyed: [container: Container];\n}\n\ntype AnyEvent = {\n    // The following is a hack to allow any custom event while maintaining type safety.\n    // For some reason, the tsc compiler gets angry about error TS1023\n    // \"An index signature parameter type must be either 'string' or 'number'.\"\n    // This is really odd since ({}&string) should interpret as string, but then again\n    // there is some black magic behind why this works in the first place.\n    // Closest thing to an explanation:\n    // https://stackoverflow.com/questions/70144348/why-does-a-union-of-type-literals-and-string-cause-ide-code-completion-wh\n    //\n    // Side note, we disable @typescript-eslint/ban-types since {}&string is the only syntax that works.\n    // Nor of the Record/unknown/never alternatives work.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    [K: ({} & string) | ({} & symbol)]: any;\n};\n\nexport const UPDATE_COLOR = 0b0001;\nexport const UPDATE_BLEND = 0b0010;\nexport const UPDATE_VISIBLE = 0b0100;\nexport const UPDATE_TRANSFORM = 0b1000;\n\nexport interface UpdateTransformOptions\n{\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n    rotation: number;\n    skewX: number;\n    skewY: number;\n    pivotX: number;\n    pivotY: number;\n}\n\n/**\n * Constructor options used for `Container` instances.\n * ```js\n * const container = new Container({\n *    position: new Point(100, 200),\n *    scale: new Point(2, 2),\n *    rotation: Math.PI / 2,\n * });\n * ```\n * @memberof scene\n * @see scene.Container\n */\nexport interface ContainerOptions<C extends ContainerChild = ContainerChild> extends PixiMixins.ContainerOptions\n{\n    /** @see scene.Container#isRenderGroup */\n    isRenderGroup?: boolean;\n\n    /** @see scene.Container#blendMode */\n    blendMode?: BLEND_MODES;\n    /** @see scene.Container#tint */\n    tint?: ColorSource;\n\n    /** @see scene.Container#alpha */\n    alpha?: number;\n    /** @see scene.Container#angle */\n    angle?: number;\n    /** @see scene.Container#children */\n    children?: C[];\n    /** @see scene.Container#parent */\n    parent?: Container;\n    /** @see scene.Container#renderable */\n    renderable?: boolean;\n    /** @see scene.Container#rotation */\n    rotation?: number;\n    /** @see scene.Container#scale */\n    scale?: PointData | number;\n    /** @see scene.Container#pivot */\n    pivot?: PointData | number;\n    /** @see scene.Container#position */\n    position?: PointData;\n    /** @see scene.Container#skew */\n    skew?: PointData;\n    /** @see scene.Container#visible */\n    visible?: boolean;\n    /** @see scene.Container#culled */\n    culled?: boolean;\n    /** @see scene.Container#x */\n    x?: number;\n    /** @see scene.Container#y */\n    y?: number;\n    /** @see scene.Container#boundArea */\n    boundsArea?: Rectangle;\n}\n\nexport interface Container<C extends ContainerChild>\n    extends Omit<PixiMixins.Container<C>, keyof EventEmitter<ContainerEvents<C> & AnyEvent>>,\n    EventEmitter<ContainerEvents<C> & AnyEvent> { }\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * <details id=\"transforms\">\n *\n * <summary>Transforms</summary>\n *\n * The [transform]{@link scene.Container#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link scene.Container#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link scene.Container#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link scene.Container#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link scene.Container#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link scene.Container#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link scene.Container#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link scene.Container#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[angle]{@link scene.Container#angle}</td>\n *       <td>Rotation. This is an alias for [rotation]{@link scene.Container#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>[x]{@link scene.Container#x}</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>[y]{@link scene.Container#y}</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>[width]{@link scene.Container#width}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[height]{@link scene.Container#height}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n * </details>\n *\n * <details id=\"alpha\">\n * <summary>Alpha</summary>\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n * </details>\n *\n * <details id=\"visible\">\n * <summary>Renderable vs Visible</summary>\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n * ```ts\n * import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n * ```\n *\n * </details>\n *\n * <details id=\"renderGroup\">\n * <summary>RenderGroup</summary>\n *\n * In PixiJS v8, containers can be set to operate in 'render group mode',\n * transforming them into entities akin to a stage in traditional rendering paradigms.\n * A render group is a root renderable entity, similar to a container,\n * but it's rendered in a separate pass with its own unique set of rendering instructions.\n * This approach enhances rendering efficiency and organization, particularly in complex scenes.\n *\n * You can enable render group mode on any container using container.enableRenderGroup()\n * or by initializing a new container with the render group property set to true (new Container({isRenderGroup: true})).\n *  The method you choose depends on your specific use case and setup requirements.\n *\n * An important aspect of PixiJS’s rendering process is the automatic treatment of rendered scenes as render groups.\n * This conversion streamlines the rendering process, but understanding when and how this happens is crucial\n * to fully leverage its benefits.\n *\n * One of the key advantages of using render groups is the performance efficiency in moving them. Since transformations\n *  are applied at the GPU level, moving a render group, even one with complex and numerous children,\n * doesn't require recalculating the rendering instructions or performing transformations on each child.\n * This makes operations like panning a large game world incredibly efficient.\n *\n * However, it's crucial to note that render groups do not batch together.\n * This means that turning every container into a render group could actually slow things down,\n * as each render group is processed separately. It's best to use render groups judiciously, at a broader level,\n * rather than on a per-child basis.\n * This approach ensures you get the performance benefits without overburdening the rendering process.\n *\n * RenderGroups maintain their own set of rendering instructions,\n * ensuring that changes or updates within a render group don't affect the rendering\n * instructions of its parent or other render groups.\n *  This isolation ensures more stable and predictable rendering behavior.\n *\n * Additionally, renderGroups can be nested, allowing for powerful options in organizing different aspects of your scene.\n * This feature is particularly beneficial for separating complex game graphics from UI elements,\n * enabling intricate and efficient scene management in complex applications.\n *\n * This means that Containers have 3 levels of matrix to be mindful of:\n *\n * 1. localTransform, this is the transform of the container based on its own properties\n * 2. groupTransform, this it the transform of the container relative to the renderGroup it belongs too\n * 3. worldTransform, this is the transform of the container relative to the Scene being rendered\n * </details>\n * @memberof scene\n */\nexport class Container<C extends ContainerChild = ContainerChild> extends EventEmitter<ContainerEvents<C> & AnyEvent>\n{\n    /**\n     * Mixes all enumerable properties and methods from a source object to Container.\n     * @param source - The source of properties and methods to mix in.\n     */\n    public static mixin(source: Dict<any>): void\n    {\n        Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n    }\n\n    /** @private */\n    public uid: number = uid('renderable');\n\n    /** @private */\n    public _updateFlags = 0b1111;\n\n    // is this container the root of a renderGroup?\n    // TODO implement this in a few more places\n    /** @private */\n    public isRenderGroupRoot = false;\n    // the render group this container belongs to OR owns\n    /** @private */\n    public renderGroup: RenderGroup = null;\n\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    public didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    public didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    public relativeRenderGroupDepth = 0;\n\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    public children: C[] = [];\n    /** The display object container that contains this display object. */\n    public parent: Container = null;\n\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    public includeInBuild = true;\n    /** @private */\n    public measurable = true;\n    /** @private */\n    public isSimple = true;\n\n    // / /////////////Transform related props//////////////\n\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    public updateTick = -1;\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    public localTransform: Matrix = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    public relativeGroupTransform: Matrix = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    public groupTransform: Matrix = this.relativeGroupTransform;\n\n    // the global transform taking into account the render group and all parents\n    private _worldTransform: Matrix;\n\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    public destroyed = false;\n\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    public _position: ObservablePoint = new ObservablePoint(this, 0, 0);\n\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    public _scale: ObservablePoint = defaultScale;\n\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    public _pivot: ObservablePoint = defaultPivot;\n\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    public _skew: ObservablePoint = defaultSkew;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cx = 1;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sx = 0;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cy = 0;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sy = 1;\n\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    private _rotation = 0;\n\n    // / COLOR related props //////////////\n\n    // color stored as ABGR\n    public localColor = 0xFFFFFF;\n    public localAlpha = 1;\n\n    public groupAlpha = 1; // A\n    public groupColor = 0xFFFFFF; // BGR\n    public groupColorAlpha = 0xFFFFFFFF; // ABGR\n\n    // / BLEND related props //////////////\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public localBlendMode: BLEND_MODES = 'inherit';\n    /**\n     * @internal\n     * @ignore\n     */\n    public groupBlendMode: BLEND_MODES = 'normal';\n\n    // / VISIBILITY related props //////////////\n\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = renderable, 1 = not renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    public localDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    public globalDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n\n    public renderPipeId: string;\n\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     * This is great for optimisation! If for example you have a 1000 spinning particles and you know they all sit\n     * within a specific bounds, then setting it will mean the renderer will not need to measure the\n     * 1000 children to find the bounds. Instead it will just use the bounds you set.\n     */\n    public boundsArea: Rectangle;\n\n    /**\n     * A value that increments each time the container is modified\n     * the first 12 bits represent the container changes (eg transform, alpha, visible etc)\n     * the second 12 bits represent the view changes (eg texture swap, geometry change etc)\n     *\n     *  view          container\n     * [000000000000][00000000000]\n     * @ignore\n     */\n    public _didChangeId = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    private _didLocalTransformChangeId = -1;\n\n    constructor(options: ContainerOptions<C> = {})\n    {\n        super();\n\n        assignWithIgnore(this, options, {\n            children: true,\n            parent: true,\n            effects: true,\n        });\n\n        options.children?.forEach((child) => this.addChild(child));\n        this.effects = [];\n        options.parent?.addChild(this);\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     * @param {...Container} children - The Container(s) to add to the container\n     * @returns {Container} - The first child that was added.\n     */\n    public addChild<U extends C[]>(...children: U): U[0]\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChild: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.addChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        if (child.parent === this)\n        {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n\n            if (this.renderGroup && !this.isRenderGroupRoot)\n            {\n                this.renderGroup.structureDidChange = true;\n            }\n\n            return child;\n        }\n\n        if (child.parent)\n        {\n            // TODO Optimisation...if the parent has the same render group, this does not need to change!\n            child.parent.removeChild(child);\n        }\n\n        this.children.push(child);\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        child.parent = this;\n\n        child.didChange = true;\n        child.didViewUpdate = false;\n\n        // TODO - OPtimise this? could check what the parent has set?\n        child._updateFlags = 0b1111;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.addChild(child);\n        }\n\n        this.emit('childAdded', child, this, this.children.length - 1);\n        child.emit('added', this);\n\n        if (child._zIndex !== 0)\n        {\n            child.depthOfChildModified();\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes one or more children from the container.\n     * @param {...Container} children - The Container(s) to remove\n     * @returns {Container} The first child that was removed.\n     */\n    public removeChild<U extends C[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        const index = this.children.indexOf(child);\n\n        if (index > -1)\n        {\n            this.children.splice(index, 1);\n\n            if (this.renderGroup)\n            {\n                this.renderGroup.removeChild(child);\n            }\n\n            child.parent = null;\n            this.emit('childRemoved', child, this, index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /** @ignore */\n    public _onUpdate(point?: ObservablePoint)\n    {\n        if (point)\n        {\n            //   this.updateFlags |= UPDATE_TRANSFORM;\n\n            if (point === this._skew)\n            {\n                this._updateSkew();\n            }\n        }\n\n        this._didChangeId++;\n\n        if (this.didChange) return;\n        this.didChange = true;\n\n        if (this.isRenderGroupRoot)\n        {\n            const renderGroupParent = this.renderGroup.renderGroupParent;\n            // lets update its parent..\n\n            if (renderGroupParent)\n            {\n                renderGroupParent.onChildUpdate(this);\n            }\n        }\n        else if (this.renderGroup)\n        {\n            this.renderGroup.onChildUpdate(this);\n        }\n    }\n\n    set isRenderGroup(value: boolean)\n    {\n        if (this.isRenderGroupRoot && value === false)\n        {\n            throw new Error('[Pixi] cannot undo a render group just yet');\n        }\n\n        if (value)\n        {\n            this.enableRenderGroup();\n        }\n    }\n\n    /**\n     * Returns true if this container is a render group.\n     * This means that it will be rendered as a separate pass, with its own set of instructions\n     */\n    get isRenderGroup(): boolean\n    {\n        return this.isRenderGroupRoot;\n    }\n\n    /** This enables the container to be rendered as a render group. */\n    public enableRenderGroup()\n    {\n        // does it OWN the render group..\n        if (this.renderGroup && this.renderGroup.root === this) return;\n\n        this.isRenderGroupRoot = true;\n\n        const parentRenderGroup = this.renderGroup;\n\n        if (parentRenderGroup)\n        {\n            parentRenderGroup.removeChild(this);\n        }\n\n        this.renderGroup = new RenderGroup(this);\n\n        // find children render groups and move them out..\n        if (parentRenderGroup)\n        {\n            for (let i = 0; i < parentRenderGroup.renderGroupChildren.length; i++)\n            {\n                const childRenderGroup = parentRenderGroup.renderGroupChildren[i];\n                let parent = childRenderGroup.root;\n\n                while (parent)\n                {\n                    if (parent === this)\n                    {\n                        this.renderGroup.addRenderGroupChild(childRenderGroup);\n\n                        break;\n                    }\n                    parent = parent.parent;\n                }\n            }\n\n            parentRenderGroup.addRenderGroupChild(this.renderGroup);\n        }\n\n        this._updateIsSimple();\n\n        // this group matrix will now forever be an identity matrix,\n        // as its own transform will be passed to the GPU\n        this.groupTransform = Matrix.IDENTITY;\n    }\n\n    /** @ignore */\n    public _updateIsSimple()\n    {\n        this.isSimple = !(this.isRenderGroupRoot) && (this.effects.length === 0);\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     * @readonly\n     */\n    get worldTransform()\n    {\n        this._worldTransform ||= new Matrix();\n\n        if (this.renderGroup)\n        {\n            if (this.isRenderGroupRoot)\n            {\n                this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n            }\n            else\n            {\n                this._worldTransform.appendFrom(this.relativeGroupTransform, this.renderGroup.worldTransform);\n            }\n        }\n\n        return this._worldTransform;\n    }\n\n    // / ////// transform related stuff\n\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get x(): number\n    {\n        return this._position.x;\n    }\n\n    set x(value: number)\n    {\n        this._position.x = value;\n    }\n\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get y(): number\n    {\n        return this._position.y;\n    }\n\n    set y(value: number)\n    {\n        this._position.y = value;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this._position;\n    }\n\n    set position(value: PointData)\n    {\n        this._position.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get angle(): number\n    {\n        return this.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._pivot;\n    }\n\n    set pivot(value: PointData | number)\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * @since 4.0.0\n     */\n    get skew(): ObservablePoint\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._skew;\n    }\n\n    set skew(value: PointData)\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        this._skew.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 1, 1);\n        }\n\n        return this._scale;\n    }\n\n    set scale(value: PointData | number)\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get width(): number\n    {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n\n    set width(value: number)\n    {\n        const localWidth = this.getLocalBounds().width;\n\n        this._setWidth(value, localWidth);\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get height(): number\n    {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n\n    set height(value: number)\n    {\n        const localHeight = this.getLocalBounds().height;\n\n        this._setHeight(value, localHeight);\n    }\n\n    /**\n     * Retrieves the size of the container as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the container.\n     * @memberof scene.Container#\n     */\n    public getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        const bounds = this.getLocalBounds();\n\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the container to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     * @memberof scene.Container#\n     */\n    public setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        const size = this.getLocalBounds();\n        let convertedWidth: number;\n        let convertedHeight: number;\n\n        if (typeof value !== 'object')\n        {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        }\n        else\n        {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n\n        if (convertedWidth !== undefined)\n        {\n            this._setWidth(convertedWidth, size.width);\n        }\n\n        if (convertedHeight !== undefined)\n        {\n            this._setHeight(convertedHeight, size.height);\n        }\n    }\n\n    /** Called when the skew or the rotation changes. */\n    private _updateSkew(): void\n    {\n        const rotation = this._rotation;\n        const skew = this._skew;\n\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x); // cos, added PI/2\n        this._sy = Math.cos(rotation - skew._x); // sin, added PI/2\n    }\n\n    /**\n     * Updates the transform properties of the container (accepts partial values).\n     * @param {object} opts - The options for updating the transform.\n     * @param {number} opts.x - The x position of the container.\n     * @param {number} opts.y - The y position of the container.\n     * @param {number} opts.scaleX - The scale factor on the x-axis.\n     * @param {number} opts.scaleY - The scale factor on the y-axis.\n     * @param {number} opts.rotation - The rotation of the container, in radians.\n     * @param {number} opts.skewX - The skew factor on the x-axis.\n     * @param {number} opts.skewY - The skew factor on the y-axis.\n     * @param {number} opts.pivotX - The x coordinate of the pivot point.\n     * @param {number} opts.pivotY - The y coordinate of the pivot point.\n     */\n    public updateTransform(opts: Partial<UpdateTransformOptions>): this\n    {\n        this.position.set(\n            typeof opts.x === 'number' ? opts.x : this.position.x,\n            typeof opts.y === 'number' ? opts.y : this.position.y\n        );\n        this.scale.set(\n            typeof opts.scaleX === 'number' ? opts.scaleX || 1 : this.scale.x,\n            typeof opts.scaleY === 'number' ? opts.scaleY || 1 : this.scale.y\n        );\n        this.rotation = typeof opts.rotation === 'number' ? opts.rotation : this.rotation;\n        this.skew.set(\n            typeof opts.skewX === 'number' ? opts.skewX : this.skew.x,\n            typeof opts.skewY === 'number' ? opts.skewY : this.skew.y\n        );\n        this.pivot.set(\n            typeof opts.pivotX === 'number' ? opts.pivotX : this.pivot.x,\n            typeof opts.pivotY === 'number' ? opts.pivotY : this.pivot.y\n        );\n\n        return this;\n    }\n\n    /**\n     * Updates the local transform using the given matrix.\n     * @param matrix - The matrix to use for updating the transform.\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n    }\n\n    /** Updates the local transform. */\n    public updateLocalTransform(): void\n    {\n        if ((this._didLocalTransformChangeId & 0b1111) === this._didChangeId) return;\n\n        this._didLocalTransformChangeId = this._didChangeId;\n        //   this.didChange = false;\n\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const position = this._position;\n\n        const sx = scale._x;\n        const sy = scale._y;\n\n        const px = pivot._x;\n        const py = pivot._y;\n\n        // get the matrix values of the container based on its this properties..\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n\n        lt.tx = position._x - ((px * lt.a) + (py * lt.c));\n        lt.ty = position._y - ((px * lt.b) + (py * lt.d));\n    }\n\n    // / ///// color related stuff\n\n    set alpha(value: number)\n    {\n        if (value === this.localAlpha) return;\n\n        this.localAlpha = value;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /** The opacity of the object. */\n    get alpha(): number\n    {\n        return this.localAlpha;\n    }\n\n    set tint(value: ColorSource)\n    {\n        const tempColor = Color.shared.setValue(value ?? 0xFFFFFF);\n        const bgr = tempColor.toBgrNumber();\n\n        if (bgr === this.localColor) return;\n\n        this.localColor = bgr;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The tint applied to the sprite. This is a hex value.\n     *\n     * A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    get tint(): number\n    {\n        const bgr = this.localColor;\n        // convert bgr to rgb..\n\n        return ((bgr & 0xFF) << 16) + (bgr & 0xFF00) + ((bgr >> 16) & 0xFF);\n    }\n\n    // / //////////////// blend related stuff\n\n    set blendMode(value: BLEND_MODES)\n    {\n        if (this.localBlendMode === value) return;\n        if (this.renderGroup && !this.isRenderGroupRoot)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_BLEND;\n\n        this.localBlendMode = value;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this.localBlendMode;\n    }\n\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n\n    /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n    get visible()\n    {\n        return !!(this.localDisplayStatus & 0b010);\n    }\n\n    set visible(value: boolean)\n    {\n        const valueNumber = value ? 1 : 0;\n\n        if ((this.localDisplayStatus & 0b010) >> 1 === valueNumber) return;\n\n        if (this.renderGroup && !this.isRenderGroupRoot)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n\n        this.localDisplayStatus ^= 0b010;\n\n        this._onUpdate();\n    }\n\n    /** @ignore */\n    get culled()\n    {\n        return !(this.localDisplayStatus & 0b100);\n    }\n\n    /** @ignore */\n    set culled(value: boolean)\n    {\n        const valueNumber = value ? 1 : 0;\n\n        if ((this.localDisplayStatus & 0b100) >> 2 === valueNumber) return;\n\n        if (this.renderGroup && !this.isRenderGroupRoot)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b100;\n\n        this._onUpdate();\n    }\n\n    /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n    get renderable()\n    {\n        return !!(this.localDisplayStatus & 0b001);\n    }\n\n    set renderable(value: boolean)\n    {\n        const valueNumber = value ? 1 : 0;\n\n        if ((this.localDisplayStatus & 0b001) === valueNumber) return;\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b001;\n\n        if (this.renderGroup && !this.isRenderGroupRoot)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._onUpdate();\n    }\n\n    /** Whether or not the object should be rendered. */\n    get isRenderable(): boolean\n    {\n        return (this.localDisplayStatus === 0b111 && this.groupAlpha > 0);\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n     * is set to true it should destroy the texture of the child sprite\n     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n     * If options.children is set to true it should destroy the texture source of the child sprite\n     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n     * If options.children is set to true it should destroy the context of the child graphics\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        if (this.destroyed) return;\n        this.destroyed = true;\n\n        this.removeFromParent();\n        this.parent = null;\n        this._mask = null;\n        this._filters = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._skew = null;\n\n        this.emit('destroyed', this);\n\n        this.removeAllListeners();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options?.children;\n\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n    }\n}\n\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\n","import { extend, colord } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\n\"use strict\";\nextend([namesPlugin]);\nconst _Color = class _Color {\n  /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  /** Get red component (0 - 1) */\n  get red() {\n    return this._components[0];\n  }\n  /** Get green component (0 - 1) */\n  get green() {\n    return this._components[1];\n  }\n  /** Get blue component (0 - 1) */\n  get blue() {\n    return this._components[2];\n  }\n  /** Get alpha component (0 - 1) */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this._cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error(\"Cannot set Color#value to null\");\n    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n      this._normalize(value);\n      this._value = this._cloneSource(value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  _cloneSource(value) {\n    if (typeof value === \"string\" || typeof value === \"number\" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === \"object\" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  _isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === \"number\" || type1 === \"string\" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  toArray(out) {\n    if (!this._arrayRgba) {\n      this._arrayRgba = [];\n    }\n    out = out || this._arrayRgba;\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  toRgbArray(out) {\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toNumber(); // returns 16777215\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */\n  toBgrNumber() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return (b << 16) + (g << 8) + r;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color._temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */\n  toPremultiplied(alpha, applyToRGB = true) {\n    if (alpha === 1) {\n      return (255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return applyToRGB ? 0 : this._int;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    if (applyToRGB) {\n      r = r * alpha + 0.5 | 0;\n      g = g * alpha + 0.5 | 0;\n      b = b * alpha + 0.5 | 0;\n    }\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexidecimal string.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHex(); // returns \"#ffffff\"\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${\"000000\".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexidecimal string with alpha.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHexa(); // returns \"#ffffffff\"\n   */\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + \"00\".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  _normalize(value) {\n    let r;\n    let g;\n    let b;\n    let a;\n    if ((typeof value === \"number\" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255;\n      g = (int >> 8 & 255) / 255;\n      b = (int & 255) / 255;\n      a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      [r, g, b, a = 1] = value;\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      [r, g, b, a = 255] = value;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      a /= 255;\n    } else if (typeof value === \"string\" || typeof value === \"object\") {\n      if (typeof value === \"string\") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = colord(value);\n      if (color.isValid()) {\n        ({ r, g, b, a } = color.rgba);\n        r /= 255;\n        g /= 255;\n        b /= 255;\n      }\n    }\n    if (r !== void 0) {\n      this._components[0] = r;\n      this._components[1] = g;\n      this._components[2] = b;\n      this._components[3] = a;\n      this._refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  /** Refresh the internal color rgb number */\n  _refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === \"number\") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n  /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from 'pixi.js';\n   * Color.isColorLike('white'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */\n  static isColorLike(value) {\n    return typeof value === \"number\" || typeof value === \"string\" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n  }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from 'pixi.js';\n * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n */\n_Color.shared = new _Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */\n_Color._temp = new _Color();\n/** Pattern for hex strings */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color = _Color;\n\nexport { Color };\n//# sourceMappingURL=Color.mjs.map\n","import { colord, extend } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\nimport type { AnyColor, HslaColor, HslColor, HsvaColor, HsvColor, RgbaColor, RgbColor } from '@pixi/colord';\n\nextend([namesPlugin]);\n\n/**\n * Pixi supports multiple color formats, including CSS color strings, hex, numbers, and arrays.\n *\n * When providing values for any of the color properties, you can use any of the {@link color.ColorSource} formats.\n * ```typescript\n * import { Color } from 'pixi.js';\n *\n * // All of these are valid:\n * sprite.tint = 'red';\n * sprite.tint = 0xff0000;\n * sprite.tint = '#ff0000';\n * sprite.tint = new Color('red');\n *\n * // Same for graphics fill/stroke colors and other  color values:\n * graphics.fill({ color: 'red' });\n * graphics.fill({ color: 0xff0000 });\n * graphics.stroke({ color: '#ff0000' });\n * graphics.stroke({ color: new Color('red')};\n * ```\n * @namespace color\n */\n\n/**\n * RGBA color array.\n *\n * `[number, number, number, number]`\n * @memberof color\n */\nexport type RgbaArray = [number, number, number, number];\n\n/**\n * Valid formats to use when defining any color properties, also valid for the {@link color.Color} constructor.\n *\n * These types are extended from [colord](https://www.npmjs.com/package/colord) with some PixiJS-specific extensions.\n *\n * Possible value types are:\n * - [Color names](https://www.w3.org/TR/css-color-4/#named-colors):\n *   `'red'`, `'green'`, `'blue'`, `'white'`, etc.\n * - RGB hex integers (`0xRRGGBB`):\n *   `0xff0000`, `0x00ff00`, `0x0000ff`, etc.\n * - [RGB(A) hex strings](https://www.w3.org/TR/css-color-4/#hex-notation):\n *   - 6 digits (`RRGGBB`): `'ff0000'`, `'#00ff00'`, `'0x0000ff'`, etc.\n *   - 3 digits (`RGB`): `'f00'`, `'#0f0'`, `'0x00f'`, etc.\n *   - 8 digits (`RRGGBBAA`): `'ff000080'`, `'#00ff0080'`, `'0x0000ff80'`, etc.\n *   - 4 digits (`RGBA`): `'f008'`, `'#0f08'`, `'0x00f8'`, etc.\n * - RGB(A) objects:\n *   `{ r: 255, g: 0, b: 0 }`, `{ r: 255, g: 0, b: 0, a: 0.5 }`, etc.\n * - [RGB(A) strings](https://www.w3.org/TR/css-color-4/#rgb-functions):\n *   `'rgb(255, 0, 0)'`, `'rgb(100% 0% 0%)'`, `'rgba(255, 0, 0, 0.5)'`, `'rgba(100% 0% 0% / 50%)'`, etc.\n * - RGB(A) arrays:\n *   `[1, 0, 0]`, `[1, 0, 0, 0.5]`, etc.\n * - RGB(A) Float32Array:\n *   `new Float32Array([1, 0, 0])`, `new Float32Array([1, 0, 0, 0.5])`, etc.\n * - RGB(A) Uint8Array:\n *   `new Uint8Array([255, 0, 0])`, `new Uint8Array([255, 0, 0, 128])`, etc.\n * - RGB(A) Uint8ClampedArray:\n *   `new Uint8ClampedArray([255, 0, 0])`, `new Uint8ClampedArray([255, 0, 0, 128])`, etc.\n * - HSL(A) objects:\n *   `{ h: 0, s: 100, l: 50 }`, `{ h: 0, s: 100, l: 50, a: 0.5 }`, etc.\n * - [HSL(A) strings](https://www.w3.org/TR/css-color-4/#the-hsl-notation):\n *   `'hsl(0, 100%, 50%)'`, `'hsl(0deg 100% 50%)'`, `'hsla(0, 100%, 50%, 0.5)'`, `'hsla(0deg 100% 50% / 50%)'`, etc.\n * - HSV(A) objects:\n *   `{ h: 0, s: 100, v: 100 }`, `{ h: 0, s: 100, v: 100, a: 0.5 }`, etc.\n * - {@link color.Color} objects.\n * @since 7.2.0\n * @memberof color\n */\nexport type ColorSource =\n    | string\n    | number\n    | number[]\n    | Float32Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | HslColor\n    | HslaColor\n    | HsvColor\n    | HsvaColor\n    | RgbColor\n    | RgbaColor\n    | Color\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    | Number;\n\ntype ColorSourceTypedArray = Float32Array | Uint8Array | Uint8ClampedArray;\n\n/**\n * Color utility class. Can accept any {@link color.ColorSource} format in its constructor.\n * ```js\n * import { Color } from 'pixi.js';\n *\n * new Color('red').toArray(); // [1, 0, 0, 1]\n * new Color(0xff0000).toArray(); // [1, 0, 0, 1]\n * new Color('ff0000').toArray(); // [1, 0, 0, 1]\n * new Color('#f00').toArray(); // [1, 0, 0, 1]\n * new Color('0xff0000ff').toArray(); // [1, 0, 0, 1]\n * new Color('#f00f').toArray(); // [1, 0, 0, 1]\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('rgb(255, 0, 0, 0.5)').toArray(); // [1, 0, 0, 0.5]\n * new Color([1, 1, 1]).toArray(); // [1, 1, 1, 1]\n * new Color([1, 0, 0, 0.5]).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Float32Array([1, 0, 0, 0.5])).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Uint8Array([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color(new Uint8ClampedArray([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('hsl(0, 100%, 50%, 50%)').toArray(); // [1, 0, 0, 0.5]\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * ```\n * @since 7.2.0\n * @memberof color\n */\nexport class Color\n{\n    /**\n     * Default Color object for static uses\n     * @example\n     * import { Color } from 'pixi.js';\n     * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n     */\n    public static readonly shared = new Color();\n\n    /**\n     * Temporary Color object for static uses internally.\n     * As to not conflict with Color.shared.\n     * @ignore\n     */\n    private static readonly _temp = new Color();\n\n    /** Pattern for hex strings */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static readonly HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\n\n    /** Internal color source, from constructor or set value */\n    private _value: Exclude<ColorSource, Color> | null;\n\n    /** Normalized rgba component, floats from 0-1 */\n    private _components: Float32Array;\n\n    /** Cache color as number */\n    private _int: number;\n\n    /** An array of the current Color. Only populated when `toArray` functions are called */\n    private _arrayRgba: number[] | null;\n    private _arrayRgb: number[] | null;\n\n    /**\n     * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n     */\n    constructor(value: ColorSource = 0xffffff)\n    {\n        this._value = null;\n        this._components = new Float32Array(4);\n        this._components.fill(1);\n        this._int = 0xffffff;\n        this.value = value;\n    }\n\n    /** Get red component (0 - 1) */\n    get red(): number\n    {\n        return this._components[0];\n    }\n\n    /** Get green component (0 - 1) */\n    get green(): number\n    {\n        return this._components[1];\n    }\n\n    /** Get blue component (0 - 1) */\n    get blue(): number\n    {\n        return this._components[2];\n    }\n\n    /** Get alpha component (0 - 1) */\n    get alpha(): number\n    {\n        return this._components[3];\n    }\n\n    /**\n     * Set the value, suitable for chaining\n     * @param value\n     * @see Color.value\n     */\n    public setValue(value: ColorSource): this\n    {\n        this.value = value;\n\n        return this;\n    }\n\n    /**\n     * The current color source.\n     *\n     * When setting:\n     * - Setting to an instance of `Color` will copy its color source and components.\n     * - Otherwise, `Color` will try to normalize the color source and set the components.\n     *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n     *\n     * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n     * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n     *\n     * When getting:\n     * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n     *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n     * - Otherwise, the color source used when setting is returned.\n     */\n    set value(value: ColorSource | null)\n    {\n        // Support copying from other Color objects\n        if (value instanceof Color)\n        {\n            this._value = this._cloneSource(value._value);\n            this._int = value._int;\n            this._components.set(value._components);\n        }\n        else if (value === null)\n        {\n            throw new Error('Cannot set Color#value to null');\n        }\n        else if (this._value === null || !this._isSourceEqual(this._value, value))\n        {\n            this._normalize(value);\n            this._value = this._cloneSource(value);\n        }\n    }\n    get value(): Exclude<ColorSource, Color> | null\n    {\n        return this._value;\n    }\n\n    /**\n     * Copy a color source internally.\n     * @param value - Color source\n     */\n    private _cloneSource(value: Exclude<ColorSource, Color> | null): Exclude<ColorSource, Color> | null\n    {\n        if (typeof value === 'string' || typeof value === 'number' || value instanceof Number || value === null)\n        {\n            return value;\n        }\n        else if (Array.isArray(value) || ArrayBuffer.isView(value))\n        {\n            return value.slice(0);\n        }\n        else if (typeof value === 'object' && value !== null)\n        {\n            return { ...value };\n        }\n\n        return value;\n    }\n\n    /**\n     * Equality check for color sources.\n     * @param value1 - First color source\n     * @param value2 - Second color source\n     * @returns `true` if the color sources are equal, `false` otherwise.\n     */\n    private _isSourceEqual(value1: Exclude<ColorSource, Color>, value2: Exclude<ColorSource, Color>): boolean\n    {\n        const type1 = typeof value1;\n        const type2 = typeof value2;\n\n        // Mismatched types\n        if (type1 !== type2)\n        {\n            return false;\n        }\n        // Handle numbers/strings and things that extend Number\n        // important to do the instanceof Number first, as this is \"object\" type\n        else if (type1 === 'number' || type1 === 'string' || value1 instanceof Number)\n        {\n            return value1 === value2;\n        }\n        // Handle Arrays and TypedArrays\n        else if (\n            (Array.isArray(value1) && Array.isArray(value2))\n            || (ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))\n        )\n        {\n            if (value1.length !== value2.length)\n            {\n                return false;\n            }\n\n            return value1.every((v, i) => v === value2[i]);\n        }\n        // Handle Objects\n        else if (value1 !== null && value2 !== null)\n        {\n            const keys1 = Object.keys(value1) as (keyof typeof value1)[];\n            const keys2 = Object.keys(value2) as (keyof typeof value2)[];\n\n            if (keys1.length !== keys2.length)\n            {\n                return false;\n            }\n\n            return keys1.every((key) => value1[key] === value2[key]);\n        }\n\n        return value1 === value2;\n    }\n\n    /**\n     * Convert to a RGBA color object.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n     */\n    public toRgba(): RgbaColor\n    {\n        const [r, g, b, a] = this._components;\n\n        return { r, g, b, a };\n    }\n\n    /**\n     * Convert to a RGB color object.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n     */\n    public toRgb(): RgbColor\n    {\n        const [r, g, b] = this._components;\n\n        return { r, g, b };\n    }\n\n    /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n    public toRgbaString(): string\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return `rgba(${r},${g},${b},${this.alpha})`;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]\n     * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Output array\n     */\n    public toUint8RgbArray(): number[];\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray>(out: T): T;\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray>(out?: T): T\n    {\n        const [r, g, b] = this._components;\n\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out = out || this._arrayRgb as T;\n\n        out[0] = Math.round(r * 255);\n        out[1] = Math.round(g * 255);\n        out[2] = Math.round(b * 255);\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toArray(); // returns [1, 1, 1, 1]\n     * @param {number[]|Float32Array} [out] - Output array\n     */\n    public toArray(): number[];\n    public toArray<T extends number[] | Float32Array>(out: T): T;\n    public toArray<T extends number[] | Float32Array>(out?: T): T\n    {\n        if (!this._arrayRgba)\n        {\n            this._arrayRgba = [];\n        }\n\n        out = out || this._arrayRgba as T;\n        const [r, g, b, a] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgbArray(); // returns [1, 1, 1]\n     * @param {number[]|Float32Array} [out] - Output array\n     */\n    public toRgbArray(): number[];\n    public toRgbArray<T extends number[] | Float32Array>(out: T): T;\n    public toRgbArray<T extends number[] | Float32Array>(out?: T): T\n    {\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out = out || this._arrayRgb as T;\n        const [r, g, b] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n\n        return out;\n    }\n\n    /**\n     * Convert to a hexadecimal number.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toNumber(); // returns 16777215\n     */\n    public toNumber(): number\n    {\n        return this._int;\n    }\n\n    /**\n     * Convert to a BGR number\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n     */\n    public toBgrNumber(): number\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return (b << 16) + (g << 8) + r;\n    }\n\n    /**\n     * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n     * @returns {number} - The color as a number in little endian format.\n     */\n    public toLittleEndianNumber(): number\n    {\n        const value = this._int;\n\n        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n    }\n\n    /**\n     * Multiply with another color. This action is destructive, and will\n     * override the previous `value` property to be `null`.\n     * @param {ColorSource} value - The color to multiply by.\n     */\n    public multiply(value: ColorSource): this\n    {\n        const [r, g, b, a] = Color._temp.setValue(value)._components;\n\n        this._components[0] *= r;\n        this._components[1] *= g;\n        this._components[2] *= b;\n        this._components[3] *= a;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Converts color to a premultiplied alpha format. This action is destructive, and will\n     * override the previous `value` property to be `null`.\n     * @param alpha - The alpha to multiply by.\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n     * @returns {Color} - Itself.\n     */\n    public premultiply(alpha: number, applyToRGB = true): this\n    {\n        if (applyToRGB)\n        {\n            this._components[0] *= alpha;\n            this._components[1] *= alpha;\n            this._components[2] *= alpha;\n        }\n        this._components[3] = alpha;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Premultiplies alpha with current color.\n     * @param {number} alpha - The alpha to multiply by.\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n     * @returns {number} tint multiplied by alpha\n     */\n    public toPremultiplied(alpha: number, applyToRGB = true): number\n    {\n        if (alpha === 1.0)\n        {\n            return (0xff << 24) + this._int;\n        }\n        if (alpha === 0.0)\n        {\n            return applyToRGB ? 0 : this._int;\n        }\n        let r = (this._int >> 16) & 0xff;\n        let g = (this._int >> 8) & 0xff;\n        let b = this._int & 0xff;\n\n        if (applyToRGB)\n        {\n            r = ((r * alpha) + 0.5) | 0;\n            g = ((g * alpha) + 0.5) | 0;\n            b = ((b * alpha) + 0.5) | 0;\n        }\n\n        return ((alpha * 255) << 24) + (r << 16) + (g << 8) + b;\n    }\n\n    /**\n     * Convert to a hexidecimal string.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toHex(); // returns \"#ffffff\"\n     */\n    public toHex(): string\n    {\n        const hexString = this._int.toString(16);\n\n        return `#${'000000'.substring(0, 6 - hexString.length) + hexString}`;\n    }\n\n    /**\n     * Convert to a hexidecimal string with alpha.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toHexa(); // returns \"#ffffffff\"\n     */\n    public toHexa(): string\n    {\n        const alphaValue = Math.round(this._components[3] * 255);\n        const alphaString = alphaValue.toString(16);\n\n        return this.toHex() + '00'.substring(0, 2 - alphaString.length) + alphaString;\n    }\n\n    /**\n     * Set alpha, suitable for chaining.\n     * @param alpha\n     */\n    public setAlpha(alpha: number): this\n    {\n        this._components[3] = this._clamp(alpha);\n\n        return this;\n    }\n\n    /**\n     * Normalize the input value into rgba\n     * @param value - Input value\n     */\n    private _normalize(value: Exclude<ColorSource, Color>): void\n    {\n        let r: number | undefined;\n        let g: number | undefined;\n        let b: number | undefined;\n        let a: number | undefined;\n\n        // Number is a primative so typeof works fine, but in the case\n        // that someone creates a class that extends Number, we also\n        // need to check for instanceof Number\n        if (\n            (typeof value === 'number' || value instanceof Number)\n            && (value as number) >= 0\n            && (value as number) <= 0xffffff\n        )\n        {\n            const int = value as number; // cast required because instanceof Number is ambiguous for TS\n\n            r = ((int >> 16) & 0xff) / 255;\n            g = ((int >> 8) & 0xff) / 255;\n            b = (int & 0xff) / 255;\n            a = 1.0;\n        }\n        else if (\n            (Array.isArray(value) || value instanceof Float32Array)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 1\n            value = this._clamp(value);\n            [r, g, b, a = 1.0] = value;\n        }\n        else if (\n            (value instanceof Uint8Array || value instanceof Uint8ClampedArray)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 255\n            value = this._clamp(value, 0, 255);\n            [r, g, b, a = 255] = value;\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            a /= 255;\n        }\n        else if (typeof value === 'string' || typeof value === 'object')\n        {\n            if (typeof value === 'string')\n            {\n                const match = Color.HEX_PATTERN.exec(value);\n\n                if (match)\n                {\n                    // Normalize hex string, remove 0x or # prefix\n                    value = `#${match[2]}`;\n                }\n            }\n\n            const color = colord(value as AnyColor);\n\n            if (color.isValid())\n            {\n                ({ r, g, b, a } = color.rgba);\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n        }\n\n        // Cache normalized values for rgba and hex integer\n        if (r !== undefined)\n        {\n            this._components[0] = r as number;\n            this._components[1] = g as number;\n            this._components[2] = b as number;\n            this._components[3] = a as number;\n            this._refreshInt();\n        }\n        else\n        {\n            throw new Error(`Unable to convert color ${value}`);\n        }\n    }\n\n    /** Refresh the internal color rgb number */\n    private _refreshInt(): void\n    {\n        // Clamp values to 0 - 1\n        this._clamp(this._components);\n\n        const [r, g, b] = this._components;\n\n        this._int = ((r * 255) << 16) + ((g * 255) << 8) + ((b * 255) | 0);\n    }\n\n    /**\n     * Clamps values to a range. Will override original values\n     * @param value - Value(s) to clamp\n     * @param min - Minimum value\n     * @param max - Maximum value\n     */\n    private _clamp<T extends number | number[] | ColorSourceTypedArray>(value: T, min = 0, max = 1): T\n    {\n        if (typeof value === 'number')\n        {\n            return Math.min(Math.max(value, min), max) as T;\n        }\n\n        value.forEach((v, i) =>\n        {\n            value[i] = Math.min(Math.max(v, min), max);\n        });\n\n        return value;\n    }\n\n    /**\n     * Check if the value is a color-like object\n     * @param value - Value to check\n     * @returns True if the value is a color-like object\n     * @static\n     * @example\n     * import { Color } from 'pixi.js';\n     * Color.isColorLike('white'); // returns true\n     * Color.isColorLike(0xffffff); // returns true\n     * Color.isColorLike([1, 1, 1]); // returns true\n     */\n    public static isColorLike(value: ColorSource): value is ColorSource\n    {\n        return (\n            typeof value === 'number'\n            || typeof value === 'string'\n            || value instanceof Number\n            || value instanceof Color\n            || Array.isArray(value)\n            || value instanceof Uint8Array\n            || value instanceof Uint8ClampedArray\n            || value instanceof Float32Array\n            || ((value as RgbColor).r !== undefined\n                && (value as RgbColor).g !== undefined\n                && (value as RgbColor).b !== undefined)\n            || ((value as RgbaColor).r !== undefined\n                && (value as RgbaColor).g !== undefined\n                && (value as RgbaColor).b !== undefined\n                && (value as RgbaColor).a !== undefined)\n            || ((value as HslColor).h !== undefined\n                && (value as HslColor).s !== undefined\n                && (value as HslColor).l !== undefined)\n            || ((value as HslaColor).h !== undefined\n                && (value as HslaColor).s !== undefined\n                && (value as HslaColor).l !== undefined\n                && (value as HslaColor).a !== undefined)\n            || ((value as HsvColor).h !== undefined\n                && (value as HsvColor).s !== undefined\n                && (value as HsvColor).v !== undefined)\n            || ((value as HsvaColor).h !== undefined\n                && (value as HsvaColor).s !== undefined\n                && (value as HsvaColor).v !== undefined\n                && (value as HsvaColor).a !== undefined)\n        );\n    }\n}\n","var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},\"hsl\"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):\"\",\"#\"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return\"number\"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};export{j as Colord,w as colord,k as extend,I as getFormat,E as random};\n","export default function(e,f){var a={white:\"#ffffff\",bisque:\"#ffe4c4\",blue:\"#0000ff\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",azure:\"#f0ffff\",whitesmoke:\"#f5f5f5\",papayawhip:\"#ffefd5\",plum:\"#dda0dd\",blanchedalmond:\"#ffebcd\",black:\"#000000\",gold:\"#ffd700\",goldenrod:\"#daa520\",gainsboro:\"#dcdcdc\",cornsilk:\"#fff8dc\",cornflowerblue:\"#6495ed\",burlywood:\"#deb887\",aquamarine:\"#7fffd4\",beige:\"#f5f5dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkkhaki:\"#bdb76b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",darkgrey:\"#a9a9a9\",peachpuff:\"#ffdab9\",darkmagenta:\"#8b008b\",darkred:\"#8b0000\",darkorchid:\"#9932cc\",darkorange:\"#ff8c00\",darkslateblue:\"#483d8b\",gray:\"#808080\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",wheat:\"#f5deb3\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",ghostwhite:\"#f8f8ff\",darkviolet:\"#9400d3\",magenta:\"#ff00ff\",green:\"#008000\",dodgerblue:\"#1e90ff\",grey:\"#808080\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",blueviolet:\"#8a2be2\",forestgreen:\"#228b22\",lawngreen:\"#7cfc00\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",fuchsia:\"#ff00ff\",brown:\"#a52a2a\",maroon:\"#800000\",mediumblue:\"#0000cd\",lightcoral:\"#f08080\",darkturquoise:\"#00ced1\",lightcyan:\"#e0ffff\",ivory:\"#fffff0\",lightyellow:\"#ffffe0\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",linen:\"#faf0e6\",mediumaquamarine:\"#66cdaa\",lemonchiffon:\"#fffacd\",lime:\"#00ff00\",khaki:\"#f0e68c\",mediumseagreen:\"#3cb371\",limegreen:\"#32cd32\",mediumspringgreen:\"#00fa9a\",lightskyblue:\"#87cefa\",lightblue:\"#add8e6\",midnightblue:\"#191970\",lightpink:\"#ffb6c1\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",mintcream:\"#f5fffa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",navajowhite:\"#ffdead\",navy:\"#000080\",mediumvioletred:\"#c71585\",powderblue:\"#b0e0e6\",palegoldenrod:\"#eee8aa\",oldlace:\"#fdf5e6\",paleturquoise:\"#afeeee\",mediumturquoise:\"#48d1cc\",mediumorchid:\"#ba55d3\",rebeccapurple:\"#663399\",lightsteelblue:\"#b0c4de\",mediumslateblue:\"#7b68ee\",thistle:\"#d8bfd8\",tan:\"#d2b48c\",orchid:\"#da70d6\",mediumpurple:\"#9370db\",purple:\"#800080\",pink:\"#ffc0cb\",skyblue:\"#87ceeb\",springgreen:\"#00ff7f\",palegreen:\"#98fb98\",red:\"#ff0000\",yellow:\"#ffff00\",slateblue:\"#6a5acd\",lavenderblush:\"#fff0f5\",peru:\"#cd853f\",palevioletred:\"#db7093\",violet:\"#ee82ee\",teal:\"#008080\",slategray:\"#708090\",slategrey:\"#708090\",aliceblue:\"#f0f8ff\",darkseagreen:\"#8fbc8f\",darkolivegreen:\"#556b2f\",greenyellow:\"#adff2f\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",tomato:\"#ff6347\",silver:\"#c0c0c0\",sienna:\"#a0522d\",lavender:\"#e6e6fa\",lightgreen:\"#90ee90\",orange:\"#ffa500\",orangered:\"#ff4500\",steelblue:\"#4682b4\",royalblue:\"#4169e1\",turquoise:\"#40e0d0\",yellowgreen:\"#9acd32\",salmon:\"#fa8072\",saddlebrown:\"#8b4513\",sandybrown:\"#f4a460\",rosybrown:\"#bc8f8f\",darksalmon:\"#e9967a\",lightgoldenrodyellow:\"#fafad2\",snow:\"#fffafa\",lightgrey:\"#d3d3d3\",lightgray:\"#d3d3d3\",dimgray:\"#696969\",dimgrey:\"#696969\",olivedrab:\"#6b8e23\",olive:\"#808000\"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return\"transparent\";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b=\"black\";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d=\"transparent\"===r?\"#0000\":a[r];return d?new e(d).toRgb():null},\"name\"])}\n","\"use strict\";\nconst cullingMixin = {\n  cullArea: null,\n  cullable: false,\n  cullableChildren: true\n};\n\nexport { cullingMixin };\n//# sourceMappingURL=cullingMixin.mjs.map\n","import type { Rectangle } from '../maths/shapes/Rectangle';\n\nexport interface CullingMixinConstructor\n{\n    /**\n     * If set, this shape is used for culling instead of the bounds of this object.\n     * It can improve the culling performance of objects with many children.\n     * The culling area is defined in local space.\n     * @memberof scene.Container#\n     */\n    cullArea: Rectangle,\n    /**\n     * Should this object be rendered if the bounds of this object are out of frame?\n     *\n     * Culling has no effect on whether updateTransform is called.\n     * @default false\n     * @memberof scene.Container#\n     */\n    cullable: boolean,\n    /**\n     * Determines if the children to the container can be culled\n     * Setting this to false allows PixiJS to bypass a recursive culling function\n     * Which can help to optimize very complex scenes\n     * @default true\n     * @memberof scene.Container#\n     */\n    cullableChildren: boolean,\n}\n\nexport const cullingMixin: CullingMixinConstructor = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true,\n};\n","import { removeItems } from '../../../utils/data/removeItems.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst childrenHelperMixin = {\n  allowChildren: true,\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */\n  removeChildren(beginIndex = 0, endIndex) {\n    const end = endIndex ?? this.children.length;\n    const range = end - beginIndex;\n    const removed = [];\n    if (range > 0 && range <= end) {\n      for (let i = end - 1; i >= beginIndex; i--) {\n        const child = this.children[i];\n        if (!child)\n          continue;\n        if (this.renderGroup) {\n          this.renderGroup.removeChild(child);\n        }\n        removed.push(child);\n        child.parent = null;\n      }\n      removeItems(this.children, beginIndex, end);\n      for (let i = 0; i < removed.length; ++i) {\n        this.emit(\"childRemoved\", removed[i], this, i);\n        removed[i].emit(\"removed\", this);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return removed;\n    }\n    throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n  },\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return this.removeChild(child);\n  },\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  },\n  /**\n   * Changes the position of an existing child in the container container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    this.getChildIndex(child);\n    this.addChildAt(child, index);\n  },\n  /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error(\"The supplied Container must be a child of the caller\");\n    }\n    return index;\n  },\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */\n  addChildAt(child, index) {\n    if (!this.allowChildren) {\n      deprecation(v8_0_0, \"addChildAt: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    const { children } = this;\n    if (index < 0 || index > children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n    }\n    if (child.parent) {\n      const currentIndex = child.parent.children.indexOf(child);\n      if (child.parent === this && currentIndex === index) {\n        return child;\n      }\n      if (currentIndex !== -1) {\n        child.parent.children.splice(currentIndex, 1);\n      }\n    }\n    if (index === children.length) {\n      children.push(child);\n    } else {\n      children.splice(index, 0, child);\n    }\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    if (this.renderGroup) {\n      this.renderGroup.addChild(child);\n    }\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    this.emit(\"childAdded\", child, this, index);\n    child.emit(\"added\", this);\n    return child;\n  },\n  /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   */\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n  },\n  /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  }\n};\n\nexport { childrenHelperMixin };\n//# sourceMappingURL=childrenHelperMixin.mjs.map\n","import { removeItems } from '../../../utils/data/removeItems';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container, ContainerChild } from '../Container';\n\nexport interface ChildrenHelperMixin<C = ContainerChild>\n{\n    allowChildren: boolean;\n    addChild<U extends C[]>(...children: U): U[0];\n    removeChild<U extends C[]>(...children: U): U[0];\n    removeChildren(beginIndex?: number, endIndex?: number): C[];\n    removeChildAt<U extends C>(index: number): U;\n    getChildAt<U extends C>(index: number): U;\n    setChildIndex(child: C, index: number): void;\n    getChildIndex(child: C): number;\n    addChildAt<U extends C>(child: U, index: number): U;\n    swapChildren<U extends C>(child: U, child2: U): void;\n    removeFromParent(): void;\n}\n\nexport const childrenHelperMixin: Partial<Container> = {\n\n    allowChildren: true,\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     * @param beginIndex - The beginning position.\n     * @param endIndex - The ending position. Default value is size of the container.\n     * @returns - List of removed children\n     * @memberof scene.Container#\n     */\n    removeChildren(beginIndex = 0, endIndex?: number): ContainerChild[]\n    {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed: ContainerChild[] = [];\n\n        if (range > 0 && range <= end)\n        {\n            for (let i = end - 1; i >= beginIndex; i--)\n            {\n                const child = this.children[i];\n\n                if (!child) continue;\n\n                if (this.renderGroup)\n                {\n                    this.renderGroup.removeChild(child);\n                }\n\n                removed.push(child);\n                child.parent = null;\n            }\n\n            removeItems(this.children, beginIndex, end);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                this.emit('childRemoved', removed[i], this, i);\n                removed[i].emit('removed', this);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return removed;\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    },\n\n    /**\n     * Removes a child from the specified index position.\n     * @param index - The index to get the child from\n     * @returns The child that was removed.\n     * @memberof scene.Container#\n     */\n    removeChildAt<U extends ContainerChild>(index: number): U\n    {\n        const child = this.getChildAt<U>(index);\n\n        return this.removeChild(child);\n    },\n\n    /**\n     * Returns the child at the specified index\n     * @param index - The index to get the child at\n     * @returns - The child at the given index, if any.\n     * @memberof scene.Container#\n     */\n    getChildAt<U extends ContainerChild>(index: number): U\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index] as U;\n    },\n\n    /**\n     * Changes the position of an existing child in the container container\n     * @param child - The child Container instance for which you want to change the index number\n     * @param index - The resulting index number for the child container\n     * @memberof scene.Container#\n     */\n    setChildIndex(child: ContainerChild, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        this.getChildIndex(child); // check if child exists\n        this.addChildAt(child, index);\n    },\n\n    /**\n     * Returns the index position of a child Container instance\n     * @param child - The Container instance to identify\n     * @returns - The index position of the child container to identify\n     * @memberof scene.Container#\n     */\n    getChildIndex(child: ContainerChild): number\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied Container must be a child of the caller');\n        }\n\n        return index;\n    },\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n     * If the child is already in this container, it will be moved to the specified index.\n     * @param {Container} child - The child to add.\n     * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n     * @returns {Container} The child that was added.\n     * @memberof scene.Container#\n     */\n    addChildAt<U extends ContainerChild>(child: U, index: number): U\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChildAt: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        const { children } = this;\n\n        if (index < 0 || index > children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        }\n\n        // TODO - check if child is already in the list?\n        // we should be able to optimise this!\n\n        if (child.parent)\n        {\n            const currentIndex = child.parent.children.indexOf(child);\n\n            // If this child is in the container and in the same position, do nothing\n            if (child.parent === this && currentIndex === index)\n            {\n                return child;\n            }\n\n            if (currentIndex !== -1)\n            {\n                child.parent.children.splice(currentIndex, 1);\n            }\n        }\n\n        if (index === children.length)\n        {\n            children.push(child);\n        }\n        else\n        {\n            children.splice(index, 0, child);\n        }\n\n        child.parent = this;\n        child.didChange = true;\n        child.didViewUpdate = false;\n        child._updateFlags = 0b1111;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.addChild(child);\n        }\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        this.emit('childAdded', child, this, index);\n        child.emit('added', this);\n\n        return child;\n    },\n    /**\n     * Swaps the position of 2 Containers within this container.\n     * @param child - First container to swap\n     * @param child2 - Second container to swap\n     */\n    swapChildren<U extends ContainerChild>(child: U, child2: U): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n    },\n    /**\n     * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n     * @memberof scene.Container#\n     */\n    removeFromParent()\n    {\n        this.parent?.removeChild(this);\n    }\n} as Container;\n","\"use strict\";\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\nexport { removeItems };\n//# sourceMappingURL=removeItems.mjs.map\n","/**\n * Remove items from a javascript array without generating garbage\n * @function removeItems\n * @memberof utils\n * @param {Array<any>} arr - Array to remove elements from\n * @param {number} startIdx - starting index\n * @param {number} removeCount - how many to remove\n */\nexport function removeItems(arr: any[], startIdx: number, removeCount: number): void\n{\n    const length = arr.length;\n    let i;\n\n    if (startIdx >= length || removeCount === 0)\n    {\n        return;\n    }\n\n    removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);\n\n    const len = length - removeCount;\n\n    for (i = startIdx; i < len; ++i)\n    {\n        arr[i] = arr[i + removeCount];\n    }\n\n    arr.length = len;\n}\n","import { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\n\n\"use strict\";\nconst effectsMixin = {\n  _mask: null,\n  _filters: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1)\n      return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    if (this.renderGroup) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1)\n      return;\n    this.effects.splice(index, 1);\n    if (!this.isRenderGroupRoot && this.renderGroup) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    this._mask || (this._mask = { mask: null, effect: null });\n    if (this._mask.mask === value)\n      return;\n    if (this._mask.effect) {\n      this.removeEffect(this._mask.effect);\n      MaskEffectManager.returnMaskEffect(this._mask.effect);\n      this._mask.effect = null;\n    }\n    this._mask.mask = value;\n    if (value === null || value === void 0)\n      return;\n    const effect = MaskEffectManager.getMaskEffect(value);\n    this._mask.effect = effect;\n    this.addEffect(effect);\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    return this._mask?.mask;\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value)\n      value = [value];\n    value = value;\n    this._filters || (this._filters = { filters: null, effect: null, filterArea: null });\n    const hasFilters = value?.length > 0;\n    const didChange = this._filters.effect && !hasFilters || !this._filters.effect && hasFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    this._filters.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        const effect = BigPool.get(FilterEffect);\n        this._filters.effect = effect;\n        this.addEffect(effect);\n      } else {\n        const effect = this._filters.effect;\n        this.removeEffect(effect);\n        effect.filterArea = null;\n        effect.filters = null;\n        this._filters.effect = null;\n        BigPool.return(effect);\n      }\n    }\n    if (hasFilters) {\n      this._filters.effect.filters = value;\n      this._filters.effect.filterArea = this.filterArea;\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    return this._filters?.filters;\n  },\n  set filterArea(value) {\n    this._filters || (this._filters = { filters: null, effect: null, filterArea: null });\n    this._filters.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    return this._filters?.filterArea;\n  }\n};\n\nexport { effectsMixin };\n//# sourceMappingURL=effectsMixin.mjs.map\n","import { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\n\nimport type { Filter } from '../../../filters/Filter';\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../Container';\nimport type { Effect } from '../Effect';\n\nexport interface EffectsMixinConstructor\n{\n    mask?: number | Container | null;\n    filters?: Filter | Filter[];\n}\nexport interface EffectsMixin extends Required<EffectsMixinConstructor>\n{\n    _mask?: {mask: unknown, effect: Effect};\n    _filters?: {\n        filters: readonly Filter[],\n        effect: FilterEffect\n        filterArea?: Rectangle,\n    },\n    filterArea?: Rectangle,\n    effects?: Effect[];\n    addEffect(effect: Effect): void;\n    removeEffect(effect: Effect): void;\n}\n\nexport const effectsMixin: Partial<Container> = {\n    _mask: null,\n    _filters: null,\n\n    /**\n     * @todo Needs docs.\n     * @memberof scene.Container#\n     * @type {Array<Effect>}\n     */\n    effects: [],\n\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to add.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    addEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index !== -1) return; // already exists!\n\n        this.effects.push(effect);\n\n        this.effects.sort((a, b) => a.priority - b.priority);\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateIsSimple();\n    },\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to remove.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    removeEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index === -1) return; // already exists!\n\n        this.effects.splice(index, 1);\n\n        if (!this.isRenderGroupRoot && this.renderGroup)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateIsSimple();\n    },\n\n    set mask(value: number | Container | null)\n    {\n        this._mask ||= { mask: null, effect: null };\n\n        if (this._mask.mask === value) return;\n\n        if (this._mask.effect)\n        {\n            this.removeEffect(this._mask.effect);\n\n            MaskEffectManager.returnMaskEffect(this._mask.effect);\n\n            this._mask.effect = null;\n        }\n\n        this._mask.mask = value;\n\n        if (value === null || value === undefined) return;\n\n        const effect = MaskEffectManager.getMaskEffect(value);\n\n        this._mask.effect = effect;\n\n        this.addEffect(effect);\n    },\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     * @memberof scene.Container#\n     */\n    get mask(): unknown\n    {\n        return this._mask?.mask;\n    },\n\n    set filters(value: Filter | Filter[] | null | undefined)\n    {\n        if (!Array.isArray(value) && value) value = [value];\n\n        // Ignore the Filter type\n        value = value as Filter[] | null | undefined;\n\n        // by reusing the same effect.. rather than adding and removing from the pool!\n        this._filters ||= { filters: null, effect: null, filterArea: null };\n\n        const hasFilters = value?.length > 0;\n        const didChange = (this._filters.effect && !hasFilters) || (!this._filters.effect && hasFilters);\n\n        // Clone the filters array so we don't freeze the user-input\n        value = Array.isArray(value) ? value.slice(0) : value;\n\n        // Ensure filters are immutable via filters getter\n        this._filters.filters = Object.freeze(value);\n\n        if (didChange)\n        {\n            if (hasFilters)\n            {\n                const effect = BigPool.get(FilterEffect);\n\n                this._filters.effect = effect;\n                this.addEffect(effect);\n            }\n            else\n            {\n                const effect = this._filters.effect;\n\n                this.removeEffect(effect);\n\n                effect.filterArea = null;\n                effect.filters = null;\n\n                this._filters.effect = null;\n                BigPool.return(effect as PoolItem);\n            }\n        }\n\n        if (hasFilters)\n        {\n            this._filters.effect.filters = value as Filter[];\n            this._filters.effect.filterArea = this.filterArea;\n        }\n    },\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     * @memberof scene.Container#\n     */\n    get filters(): readonly Filter[]\n    {\n        return this._filters?.filters;\n    },\n\n    set filterArea(value: Rectangle)\n    {\n        this._filters ||= { filters: null, effect: null, filterArea: null };\n\n        this._filters.filterArea = value;\n    },\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     * @memberof scene.Container#\n     */\n    get filterArea(): Rectangle\n    {\n        return this._filters?.filterArea;\n    },\n\n} as Container;\n","\"use strict\";\nclass FilterEffect {\n  constructor(options) {\n    this.pipe = \"filter\";\n    this.priority = 1;\n    this.filters = options?.filters;\n    this.filterArea = options?.filterArea;\n  }\n  destroy() {\n    for (let i = 0; i < this.filters.length; i++) {\n      this.filters[i].destroy();\n    }\n    this.filters = null;\n    this.filterArea = null;\n  }\n}\n\nexport { FilterEffect };\n//# sourceMappingURL=FilterEffect.mjs.map\n","import type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { Effect } from '../scene/container/Effect';\nimport type { Filter } from './Filter';\n\nexport class FilterEffect implements Effect\n{\n    public filters: Filter[];\n    public filterArea?: Rectangle;\n\n    public pipe = 'filter';\n    public priority = 1;\n\n    constructor(options?: {filters: Filter[], filterArea?: Rectangle})\n    {\n        this.filters = options?.filters;\n        this.filterArea = options?.filterArea;\n    }\n\n    public destroy(): void\n    {\n        for (let i = 0; i < this.filters.length; i++)\n        {\n            this.filters[i].destroy();\n        }\n\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n","import { extensions, ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\n\n\"use strict\";\nclass MaskEffectManagerClass {\n  constructor() {\n    /**\n     * @private\n     */\n    this._effectClasses = [];\n    this._tests = [];\n    this._initialized = false;\n  }\n  init() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n    this._effectClasses.forEach((test) => {\n      this.add({\n        test: test.test,\n        maskClass: test\n      });\n    });\n  }\n  add(test) {\n    this._tests.push(test);\n  }\n  getMaskEffect(item) {\n    if (!this._initialized)\n      this.init();\n    for (let i = 0; i < this._tests.length; i++) {\n      const test = this._tests[i];\n      if (test.test(item)) {\n        return BigPool.get(test.maskClass, item);\n      }\n    }\n    return item;\n  }\n  returnMaskEffect(effect) {\n    BigPool.return(effect);\n  }\n}\nconst MaskEffectManager = new MaskEffectManagerClass();\nextensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n\nexport { MaskEffectManager, MaskEffectManagerClass };\n//# sourceMappingURL=MaskEffectManager.mjs.map\n","import { extensions, ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\n\nimport type { Effect, EffectConstructor } from '../../scene/container/Effect';\nimport type { PoolItem, PoolItemConstructor } from '../../utils/pool/Pool';\n\ninterface MaskConversionTest\n{\n    test: (item: any) => boolean;\n    maskClass: new (item: any) => Effect & PoolItem;\n}\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @memberof rendering\n * @ignore\n */\nexport class MaskEffectManagerClass\n{\n    /**\n     * @private\n     */\n    public readonly _effectClasses: EffectConstructor[] = [];\n    private readonly _tests: MaskConversionTest[] = [];\n    private _initialized = false;\n\n    public init()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n\n        this._effectClasses.forEach((test) =>\n        {\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n\n    public add(test: MaskConversionTest)\n    {\n        this._tests.push(test);\n    }\n\n    public getMaskEffect(item: any): Effect\n    {\n        if (!this._initialized) this.init();\n\n        for (let i = 0; i < this._tests.length; i++)\n        {\n            const test = this._tests[i];\n\n            if (test.test(item))\n            {\n                return BigPool.get(test.maskClass as PoolItemConstructor<Effect & PoolItem>, item);\n            }\n        }\n\n        return item;\n    }\n\n    public returnMaskEffect(effect: Effect & PoolItem)\n    {\n        BigPool.return(effect);\n    }\n}\n\nexport const MaskEffectManager = new MaskEffectManagerClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n","import { Pool } from './Pool.mjs';\n\n\"use strict\";\nclass PoolGroupClass {\n  constructor() {\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    this._poolsByClass = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */\n  prepopulate(Class, total) {\n    const classPool = this.getPool(Class);\n    classPool.prepopulate(total);\n  }\n  /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(Class, data) {\n    const pool = this.getPool(Class);\n    return pool.get(data);\n  }\n  /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */\n  return(item) {\n    const pool = this.getPool(item.constructor);\n    pool.return(item);\n  }\n  /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */\n  getPool(ClassType) {\n    if (!this._poolsByClass.has(ClassType)) {\n      this._poolsByClass.set(ClassType, new Pool(ClassType));\n    }\n    return this._poolsByClass.get(ClassType);\n  }\n  /** gets the usage stats of each pool in the system */\n  stats() {\n    const stats = {};\n    this._poolsByClass.forEach((pool) => {\n      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n      stats[name] = {\n        free: pool.totalFree,\n        used: pool.totalUsed,\n        size: pool.totalSize\n      };\n    });\n    return stats;\n  }\n}\nconst BigPool = new PoolGroupClass();\n\nexport { BigPool, PoolGroupClass };\n//# sourceMappingURL=PoolGroup.mjs.map\n","import { Pool } from './Pool';\n\nimport type { PoolItem, PoolItemConstructor } from './Pool';\n\n/**\n * A type alias for a constructor of a Pool.\n * @template T The type of items in the pool. Must extend PoolItem.\n * @memberof utils\n */\nexport type PoolConstructor<T extends PoolItem> = new () => Pool<T>;\n\n/**\n * A group of pools that can be used to store objects of different types.\n * @memberof utils\n */\nexport class PoolGroupClass\n{\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    private readonly _poolsByClass: Map<PoolItemConstructor<PoolItem>, Pool<PoolItem>> = new Map();\n\n    /**\n     * Prepopulates a specific pool with a given number of items.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {number} total - The number of items to add to the pool.\n     */\n    public prepopulate<T extends PoolItem>(Class: PoolItemConstructor<T>, total: number): void\n    {\n        const classPool = this.getPool(Class);\n\n        classPool.prepopulate(total);\n    }\n\n    /**\n     * Gets an item from a specific pool.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get<T extends PoolItem>(Class: PoolItemConstructor<T>, data?: unknown): T\n    {\n        const pool = this.getPool(Class);\n\n        return pool.get(data) as T;\n    }\n\n    /**\n     * Returns an item to its respective pool.\n     * @param {PoolItem} item - The item to return to the pool.\n     */\n    public return(item: PoolItem): void\n    {\n        const pool = this.getPool(item.constructor as PoolItemConstructor<PoolItem>);\n\n        pool.return(item);\n    }\n\n    /**\n     * Gets a specific pool based on the class type.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n     * @returns {Pool<T>} The pool of the given class type.\n     */\n    public getPool<T extends PoolItem>(ClassType: PoolItemConstructor<T>): Pool<T>\n    {\n        if (!this._poolsByClass.has(ClassType))\n        {\n            this._poolsByClass.set(ClassType, new Pool(ClassType));\n        }\n\n        return this._poolsByClass.get(ClassType) as Pool<T>;\n    }\n\n    /** gets the usage stats of each pool in the system */\n    public stats(): Record<string, {free: number; used: number; size: number}>\n    {\n        const stats = {} as Record<string, {free: number; used: number; size: number}>;\n\n        this._poolsByClass.forEach((pool) =>\n        {\n            // TODO: maybe we should allow the name to be set when `createEntity` is called\n            const name = stats[pool._classType.name]\n                ? pool._classType.name + (pool._classType as any).ID : pool._classType.name;\n\n            stats[name] = {\n                free: pool.totalFree,\n                used: pool.totalUsed,\n                size: pool.totalSize,\n            };\n        });\n\n        return stats;\n    }\n}\n\nexport const BigPool = new PoolGroupClass();\n","\"use strict\";\nclass Pool {\n  /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */\n  constructor(ClassType, initialSize) {\n    this._pool = [];\n    this._count = 0;\n    this._index = 0;\n    this._classType = ClassType;\n    if (initialSize) {\n      this.prepopulate(initialSize);\n    }\n  }\n  /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */\n  prepopulate(total) {\n    for (let i = 0; i < total; i++) {\n      this._pool[this._index++] = new this._classType();\n    }\n    this._count += total;\n  }\n  /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(data) {\n    let item;\n    if (this._index > 0) {\n      item = this._pool[--this._index];\n    } else {\n      item = new this._classType();\n    }\n    item.init?.(data);\n    return item;\n  }\n  /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */\n  return(item) {\n    item.reset?.();\n    this._pool[this._index++] = item;\n  }\n  /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */\n  get totalSize() {\n    return this._count;\n  }\n  /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */\n  get totalFree() {\n    return this._index;\n  }\n  /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */\n  get totalUsed() {\n    return this._count - this._index;\n  }\n}\n\nexport { Pool };\n//# sourceMappingURL=Pool.mjs.map\n","/**\n * A generic class for managing a pool of items.\n * @template T The type of items in the pool. Must implement {@link utils.PoolItem}.\n * @memberof utils\n */\nexport class Pool<T extends PoolItem>\n{\n    public readonly _classType: PoolItemConstructor<T>;\n    private readonly _pool: T[] = [];\n    private _count = 0;\n    private _index = 0;\n\n    /**\n     * Constructs a new Pool.\n     * @param ClassType - The constructor of the items in the pool.\n     * @param {number} [initialSize] - The initial size of the pool.\n     */\n    constructor(ClassType: PoolItemConstructor<T>, initialSize?: number)\n    {\n        this._classType = ClassType;\n\n        if (initialSize)\n        {\n            this.prepopulate(initialSize);\n        }\n    }\n\n    /**\n     * Prepopulates the pool with a given number of items.\n     * @param total - The number of items to add to the pool.\n     */\n    public prepopulate(total: number): void\n    {\n        for (let i = 0; i < total; i++)\n        {\n            this._pool[this._index++] = new this._classType();\n        }\n\n        this._count += total;\n    }\n\n    /**\n     * Gets an item from the pool. Calls the item's `init` method if it exists.\n     * If there are no items left in the pool, a new one will be created.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get(data?: unknown): T\n    {\n        let item;\n\n        if (this._index > 0)\n        {\n            item = this._pool[--this._index];\n        }\n        else\n        {\n            item = new this._classType();\n        }\n\n        item.init?.(data);\n\n        return item;\n    }\n\n    /**\n     * Returns an item to the pool. Calls the item's `reset` method if it exists.\n     * @param {T} item - The item to return to the pool.\n     */\n    public return(item: T): void\n    {\n        item.reset?.();\n\n        this._pool[this._index++] = item;\n    }\n\n    /**\n     * Gets the number of items in the pool.\n     * @readonly\n     * @member {number}\n     */\n    get totalSize(): number\n    {\n        return this._count;\n    }\n\n    /**\n     * Gets the number of items in the pool that are free to use without needing to create more.\n     * @readonly\n     * @member {number}\n     */\n    get totalFree(): number\n    {\n        return this._index;\n    }\n\n    /**\n     * Gets the number of items in the pool that are currently in use.\n     * @readonly\n     * @member {number}\n     */\n    get totalUsed(): number\n    {\n        return this._count - this._index;\n    }\n}\n\n/**\n * An object that can be stored in a {@link utils.Pool}.\n * @memberof utils\n */\nexport type PoolItem = {\n    init?: (data?: any) => void;\n    reset?: () => void;\n    [key: string]: any;\n};\n\n/**\n * The constructor of an object that can be stored in a {@link utils.Pool}.\n * @typeParam K - The type of the object that can be stored in a {@link utils.Pool}.\n * @memberof utils\n */\nexport type PoolItemConstructor<K extends PoolItem> = new () => K;\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst findMixin = {\n  /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */\n  label: null,\n  /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */\n  get name() {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    return this.label;\n  },\n  set name(value) {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    this.label = value;\n  },\n  /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */\n  getChildByName(name, deep = false) {\n    return this.getChildByLabel(name, deep);\n  },\n  /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */\n  getChildByLabel(label, deep = false) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label))\n        return child;\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const found = child.getChildByLabel(label, true);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */\n  getChildrenByLabel(label, deep = false, out = []) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) {\n        out.push(child);\n      }\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        children[i].getChildrenByLabel(label, true, out);\n      }\n    }\n    return out;\n  }\n};\n\nexport { findMixin };\n//# sourceMappingURL=findMixin.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\n\nexport interface FindMixinConstructor\n{\n    label?: string;\n}\nexport interface FindMixin extends Required<FindMixinConstructor>\n{\n    /**\n     * @deprecated since 8.0.0\n     * @see Container#label\n     */\n    name: string;\n    getChildByName(label: RegExp | string, deep?: boolean): Container | null;\n    getChildByLabel(label: RegExp | string, deep?: boolean): Container | null;\n    getChildrenByLabel(label: RegExp | string, deep?: boolean, out?: Container[]): Container[];\n}\n\nexport const findMixin: Partial<Container> = {\n    /**\n     * The instance label of the object.\n     * @memberof scene.Container#\n     * @member {string} label\n     */\n    label: null,\n\n    /**\n     * The instance name of the object.\n     * @deprecated since 8.0.0\n     * @see scene.Container#label\n     * @member {string} name\n     * @memberof scene.Container#\n     */\n    get name(): string\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        return this.label;\n    },\n    set name(value: string)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        this.label = value;\n    },\n\n    /**\n     * @method getChildByName\n     * @deprecated since 8.0.0\n     * @param {string} name - Instance name.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified name.\n     * @see scene.Container#getChildByLabel\n     * @memberof scene.Container#\n     */\n    getChildByName(name: string, deep = false): Container | null\n    {\n        return this.getChildByLabel(name, deep);\n    },\n    /**\n     * Returns the first child in the container with the specified label.\n     *\n     * Recursive searches are done in a pre-order traversal.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified label.\n     */\n    getChildByLabel(label: string | RegExp, deep = false): Container | null\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label))) return child;\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i];\n                const found = child.getChildByLabel(label, true);\n\n                if (found)\n                {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    },\n\n    /**\n     * Returns all children in the container with the specified label.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @param {Container[]} [out=[]] - The array to store matching children in.\n     * @returns {Container[]} An array of children with the specified label.\n     */\n    getChildrenByLabel(label: string | RegExp, deep = false, out = []): Container[]\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label)))\n            {\n                out.push(child);\n            }\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i].getChildrenByLabel(label, true, out);\n            }\n        }\n\n        return out;\n    },\n} as Container;\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Bounds } from '../bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds.mjs';\nimport { getLocalBounds } from '../bounds/getLocalBounds.mjs';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nconst measureMixin = {\n  _localBoundsCacheId: -1,\n  _localBoundsCacheData: null,\n  _setWidth(value, localWidth) {\n    const sign = Math.sign(this.scale.x) || 1;\n    if (localWidth !== 0) {\n      this.scale.x = value / localWidth * sign;\n    } else {\n      this.scale.x = sign;\n    }\n  },\n  _setHeight(value, localHeight) {\n    const sign = Math.sign(this.scale.y) || 1;\n    if (localHeight !== 0) {\n      this.scale.y = value / localHeight * sign;\n    } else {\n      this.scale.y = sign;\n    }\n  },\n  /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */\n  getLocalBounds() {\n    if (!this._localBoundsCacheData) {\n      this._localBoundsCacheData = {\n        data: [],\n        index: 1,\n        didChange: false,\n        localBounds: new Bounds()\n      };\n    }\n    const localBoundsCacheData = this._localBoundsCacheData;\n    localBoundsCacheData.index = 1;\n    localBoundsCacheData.didChange = false;\n    if (localBoundsCacheData.data[0] !== this._didChangeId >> 12) {\n      localBoundsCacheData.didChange = true;\n      localBoundsCacheData.data[0] = this._didChangeId >> 12;\n    }\n    checkChildrenDidChange(this, localBoundsCacheData);\n    if (localBoundsCacheData.didChange) {\n      getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n    }\n    return localBoundsCacheData.localBounds;\n  },\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */\n  getBounds(skipUpdate, bounds) {\n    return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n  }\n};\n\nexport { measureMixin };\n//# sourceMappingURL=measureMixin.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Bounds } from '../bounds/Bounds';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds';\nimport { getLocalBounds } from '../bounds/getLocalBounds';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { Container } from '../Container';\n\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport interface MeasureMixinConstructor\n{\n    width?: number;\n    height?: number;\n}\nexport interface MeasureMixin extends Required<MeasureMixinConstructor>\n{\n    getSize(out?: Size): Size;\n    setSize(width: number, height?: number): void;\n    setSize(value: Optional<Size, 'height'>): void;\n    getLocalBounds(bounds?: Bounds): Bounds;\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds;\n    _localBoundsCacheData: LocalBoundsCacheData;\n    _localBoundsCacheId: number;\n    _setWidth(width: number, localWidth: number): void;\n    _setHeight(height: number, localHeight: number): void;\n}\n\ninterface LocalBoundsCacheData\n{\n    data: number[];\n    index: number;\n    didChange: boolean;\n    localBounds: Bounds;\n}\n\nconst tempMatrix = new Matrix();\n\nexport const measureMixin: Partial<Container> = {\n\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n\n    _setWidth(value: number, localWidth: number)\n    {\n        const sign = Math.sign(this.scale.x) || 1;\n\n        if (localWidth !== 0)\n        {\n            this.scale.x = (value / localWidth) * sign;\n        }\n        else\n        {\n            this.scale.x = sign;\n        }\n    },\n\n    _setHeight(value: number, localHeight: number)\n    {\n        const sign = Math.sign(this.scale.y) || 1;\n\n        if (localHeight !== 0)\n        {\n            this.scale.y = (value / localHeight) * sign;\n        }\n        else\n        {\n            this.scale.y = sign;\n        }\n    },\n\n    /**\n     * Retrieves the local bounds of the container as a Bounds object.\n     * @returns - The bounding area.\n     * @memberof scene.Container#\n     */\n    getLocalBounds(): Bounds\n    {\n        if (!this._localBoundsCacheData)\n        {\n            this._localBoundsCacheData = {\n                data: [],\n                index: 1,\n                didChange: false,\n                localBounds: new Bounds()\n            };\n        }\n\n        const localBoundsCacheData = this._localBoundsCacheData;\n\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n\n        if (localBoundsCacheData.data[0] !== this._didChangeId >> 12)\n        {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didChangeId >> 12;\n        }\n\n        checkChildrenDidChange(this, localBoundsCacheData);\n\n        if (localBoundsCacheData.didChange)\n        {\n            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n        }\n\n        return localBoundsCacheData.localBounds;\n    },\n\n    /**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param bounds - Optional bounds to store the result of the bounds calculation.\n     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n     * @memberof scene.Container#\n     */\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds\n    {\n        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n    },\n} as Container;\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../maths/shapes/Rectangle.mjs';\n\n\"use strict\";\nconst defaultMatrix = new Matrix();\nclass Bounds {\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /** @default Infinity */\n    this.minX = Infinity;\n    /** @default Infinity */\n    this.minY = Infinity;\n    /** @default -Infinity */\n    this.maxX = -Infinity;\n    /** @default -Infinity */\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  /** The bounding rectangle of the bounds. */\n  get rectangle() {\n    if (!this._rectangle) {\n      this._rectangle = new Rectangle();\n    }\n    const rectangle = this._rectangle;\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      rectangle.x = 0;\n      rectangle.y = 0;\n      rectangle.width = 0;\n      rectangle.height = 0;\n    } else {\n      rectangle.copyFromBounds(this);\n    }\n    return rectangle;\n  }\n  /** Clears the bounds and resets. */\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    return this;\n  }\n  /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  set(x0, y0, x1, y1) {\n    this.minX = x0;\n    this.minY = y0;\n    this.maxX = x1;\n    this.maxY = y1;\n  }\n  /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */\n  addFrame(x0, y0, x1, y1, matrix) {\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  addRect(rect, matrix) {\n    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n  }\n  /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */\n  addBounds(bounds, matrix) {\n    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n  }\n  /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */\n  addBoundsMask(mask) {\n    this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n    this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n  }\n  /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  applyMatrix(matrix) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    const { a, b, c, d, tx, ty } = matrix;\n    let x = a * minX + c * minY + tx;\n    let y = b * minX + d * minY + ty;\n    this.minX = x;\n    this.minY = y;\n    this.maxX = x;\n    this.maxY = y;\n    x = a * maxX + c * minY + tx;\n    y = b * maxX + d * minY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * minX + c * maxY + tx;\n    y = b * minX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * maxX + c * maxY + tx;\n    y = b * maxX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n  }\n  /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */\n  fit(rect) {\n    if (this.minX < rect.left)\n      this.minX = rect.left;\n    if (this.maxX > rect.right)\n      this.maxX = rect.right;\n    if (this.minY < rect.top)\n      this.minY = rect.top;\n    if (this.maxY > rect.bottom)\n      this.maxY = rect.bottom;\n    return this;\n  }\n  /**\n   * Resizes the bounds object to include the given bounds.\n   * @param left - The left value of the bounds.\n   * @param right - The right value of the bounds.\n   * @param top - The top value of the bounds.\n   * @param bottom - The bottom value of the bounds.\n   */\n  fitBounds(left, right, top, bottom) {\n    if (this.minX < left)\n      this.minX = left;\n    if (this.maxX > right)\n      this.maxX = right;\n    if (this.minY < top)\n      this.minY = top;\n    if (this.maxY > bottom)\n      this.maxY = bottom;\n    return this;\n  }\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */\n  pad(paddingX, paddingY = paddingX) {\n    this.minX -= paddingX;\n    this.maxX += paddingX;\n    this.minY -= paddingY;\n    this.maxY += paddingY;\n    return this;\n  }\n  /** Ceils the bounds. */\n  ceil() {\n    this.minX = Math.floor(this.minX);\n    this.minY = Math.floor(this.minY);\n    this.maxX = Math.ceil(this.maxX);\n    this.maxY = Math.ceil(this.maxY);\n    return this;\n  }\n  /** Clones the bounds. */\n  clone() {\n    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n  }\n  /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */\n  scale(x, y = x) {\n    this.minX *= x;\n    this.minY *= y;\n    this.maxX *= x;\n    this.maxY *= y;\n    return this;\n  }\n  /** the x value of the bounds. */\n  get x() {\n    return this.minX;\n  }\n  set x(value) {\n    const width = this.maxX - this.minX;\n    this.minX = value;\n    this.maxX = value + width;\n  }\n  /** the y value of the bounds. */\n  get y() {\n    return this.minY;\n  }\n  set y(value) {\n    const height = this.maxY - this.minY;\n    this.minY = value;\n    this.maxY = value + height;\n  }\n  /** the width value of the bounds. */\n  get width() {\n    return this.maxX - this.minX;\n  }\n  set width(value) {\n    this.maxX = this.minX + value;\n  }\n  /** the height value of the bounds. */\n  get height() {\n    return this.maxY - this.minY;\n  }\n  set height(value) {\n    this.maxY = this.minY + value;\n  }\n  /** the left value of the bounds. */\n  get left() {\n    return this.minX;\n  }\n  /** the right value of the bounds. */\n  get right() {\n    return this.maxX;\n  }\n  /** the top value of the bounds. */\n  get top() {\n    return this.minY;\n  }\n  /** the bottom value of the bounds. */\n  get bottom() {\n    return this.maxY;\n  }\n  /** Is the bounds positive. */\n  get isPositive() {\n    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n  }\n  get isValid() {\n    return this.minX + this.minY !== Infinity;\n  }\n  /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */\n  addVertexData(vertexData, beginOffset, endOffset, matrix) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const localX = vertexData[i];\n      const localY = vertexData[i + 1];\n      const x = a * localX + c * localY + tx;\n      const y = b * localX + d * localY + ty;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */\n  containsPoint(x, y) {\n    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {\n      return true;\n    }\n    return false;\n  }\n  toString() {\n    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n  }\n}\n\nexport { Bounds };\n//# sourceMappingURL=Bounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\n\n/**\n * Simple bounds implementation instead of more ambiguous [number, number, number, number]\n * @memberof rendering\n */\nexport interface BoundsData\n{\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n}\n\nconst defaultMatrix = new Matrix();\n\n// TODO optimisations\n// 1 - get rectangle could use a dirty flag, rather than setting the data each time is called\n// 2- getFrame ALWAYS assumes a matrix, could be optimised to avoid the matrix calculation if not needed\n\n/**\n * A representation of an AABB bounding box.\n * @memberof rendering\n */\nexport class Bounds\n{\n    /** @default Infinity */\n    public minX = Infinity;\n\n    /** @default Infinity */\n    public minY = Infinity;\n\n    /** @default -Infinity */\n    public maxX = -Infinity;\n\n    /** @default -Infinity */\n    public maxY = -Infinity;\n\n    public matrix = defaultMatrix;\n\n    private _rectangle: Rectangle;\n\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity)\n    {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if bounds are empty.\n     * @returns - True if empty.\n     */\n    public isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /** The bounding rectangle of the bounds. */\n    get rectangle(): Rectangle\n    {\n        if (!this._rectangle)\n        {\n            this._rectangle = new Rectangle();\n        }\n\n        const rectangle = this._rectangle;\n\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        }\n        else\n        {\n            rectangle.copyFromBounds(this);\n        }\n\n        return rectangle;\n    }\n\n    /** Clears the bounds and resets. */\n    public clear(): this\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.matrix = defaultMatrix;\n\n        return this;\n    }\n\n    /**\n     * Sets the bounds.\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    public set(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n\n    /**\n     * Adds sprite frame\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     * @param matrix\n     */\n    public addFrame(x0: number, y0: number, x1: number, y1: number, matrix?: Matrix): void\n    {\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds a rectangle to the bounds.\n     * @param rect - The rectangle to be added.\n     * @param matrix - The matrix to apply to the bounds.\n     */\n    public addRect(rect: Rectangle, matrix?: Matrix)\n    {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n\n    /**\n     * Adds other {@link Bounds}.\n     * @param bounds - The Bounds to be added\n     * @param matrix\n     */\n    public addBounds(bounds: BoundsData, matrix?: Matrix)\n    {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n\n    /**\n     * Adds other Bounds, masked with Bounds.\n     * @param mask - The Bounds to be added.\n     */\n    public addBoundsMask(mask: Bounds): void\n    {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n\n    /**\n     * Adds other Bounds, multiplied with matrix.\n     * @param matrix - The matrix to apply to the bounds.\n     */\n    public applyMatrix(matrix: Matrix): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        // multiple bounds by matrix\n        const { a, b, c, d, tx, ty } = matrix;\n\n        let x = (a * minX) + (c * minY) + tx;\n        let y = (b * minX) + (d * minY) + ty;\n\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n\n        x = (a * maxX) + (c * minY) + tx;\n        y = (b * maxX) + (d * minY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * minX) + (c * maxY) + tx;\n        y = (b * minX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * maxX) + (c * maxY) + tx;\n        y = (b * maxX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n\n    /**\n     * Resizes the bounds object to include the given rectangle.\n     * @param rect - The rectangle to be included.\n     */\n    public fit(rect: Rectangle): this\n    {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n\n        return this;\n    }\n\n    /**\n     * Resizes the bounds object to include the given bounds.\n     * @param left - The left value of the bounds.\n     * @param right - The right value of the bounds.\n     * @param top - The top value of the bounds.\n     * @param bottom - The bottom value of the bounds.\n     */\n    public fitBounds(left: number, right: number, top: number, bottom: number): this\n    {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n\n        return this;\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     */\n    public pad(paddingX: number, paddingY: number = paddingX): this\n    {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n\n        return this;\n    }\n\n    /** Ceils the bounds. */\n    public ceil(): this\n    {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n\n        return this;\n    }\n\n    /** Clones the bounds. */\n    public clone(): Bounds\n    {\n        return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n    }\n\n    /**\n     * Scales the bounds by the given values\n     * @param x - The X value to scale by.\n     * @param y - The Y value to scale by.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n\n        return this;\n    }\n\n    /** the x value of the bounds. */\n    get x(): number\n    {\n        return this.minX;\n    }\n    set x(value: number)\n    {\n        const width = this.maxX - this.minX;\n\n        this.minX = value;\n        this.maxX = value + width;\n    }\n\n    /** the y value of the bounds. */\n    get y(): number\n    {\n        return this.minY;\n    }\n\n    set y(value: number)\n    {\n        const height = this.maxY - this.minY;\n\n        this.minY = value;\n        this.maxY = value + height;\n    }\n\n    /** the width value of the bounds. */\n    get width(): number\n    {\n        return this.maxX - this.minX;\n    }\n\n    set width(value: number)\n    {\n        this.maxX = this.minX + value;\n    }\n\n    /** the height value of the bounds. */\n    get height(): number\n    {\n        return this.maxY - this.minY;\n    }\n\n    set height(value: number)\n    {\n        this.maxY = this.minY + value;\n    }\n\n    /** the left value of the bounds. */\n    get left(): number\n    {\n        return this.minX;\n    }\n\n    /** the right value of the bounds. */\n    get right(): number\n    {\n        return this.maxX;\n    }\n\n    /** the top value of the bounds. */\n    get top(): number\n    {\n        return this.minY;\n    }\n\n    /** the bottom value of the bounds. */\n    get bottom(): number\n    {\n        return this.maxY;\n    }\n\n    /** Is the bounds positive. */\n    get isPositive(): boolean\n    {\n        return (this.maxX - this.minX > 0) && (this.maxY - this.minY > 0);\n    }\n\n    get isValid(): boolean\n    {\n        return (this.minX + this.minY !== Infinity);\n    }\n\n    /**\n     * Adds screen vertices from array\n     * @param vertexData - calculated vertices\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     * @param matrix\n     */\n    public addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number, matrix?: Matrix): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n\n            const x = (a * localX) + (c * localY) + tx;\n            const y = (b * localX) + (d * localY) + ty;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if the point is contained within the bounds.\n     * @param x - x coordinate\n     * @param y - y coordinate\n     */\n    public containsPoint(x: number, y: number): boolean\n    {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public toString(): string\n    {\n        // eslint-disable-next-line max-len\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { matrixPool, boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nfunction getGlobalBounds(target, skipUpdateTransform, bounds) {\n  bounds.clear();\n  let parentTransform;\n  let pooledMatrix;\n  if (target.parent) {\n    if (!skipUpdateTransform) {\n      pooledMatrix = matrixPool.get().identity();\n      parentTransform = updateTransformBackwards(target, pooledMatrix);\n    } else {\n      parentTransform = target.parent.worldTransform;\n    }\n  } else {\n    parentTransform = Matrix.IDENTITY;\n  }\n  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n  if (pooledMatrix) {\n    matrixPool.return(pooledMatrix);\n  }\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {\n  if (!target.visible || !target.measurable)\n    return;\n  let worldTransform;\n  if (!skipUpdateTransform) {\n    target.updateLocalTransform();\n    worldTransform = matrixPool.get();\n    worldTransform.appendFrom(target.localTransform, parentTransform);\n  } else {\n    worldTransform = target.worldTransform;\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, worldTransform);\n  } else {\n    if (target.addBounds) {\n      bounds.matrix = worldTransform;\n      target.addBounds(bounds);\n    }\n    for (let i = 0; i < target.children.length; i++) {\n      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addBounds?.(bounds);\n    }\n    parentBounds.addBounds(bounds, Matrix.IDENTITY);\n    boundsPool.return(bounds);\n  }\n  if (!skipUpdateTransform) {\n    matrixPool.return(worldTransform);\n  }\n}\nfunction updateTransformBackwards(target, parentTransform) {\n  const parent = target.parent;\n  if (parent) {\n    updateTransformBackwards(parent, parentTransform);\n    parent.updateLocalTransform();\n    parentTransform.append(parent.localTransform);\n  }\n  return parentTransform;\n}\n\nexport { _getGlobalBounds, getGlobalBounds, updateTransformBackwards };\n//# sourceMappingURL=getGlobalBounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalBounds(target: Container, skipUpdateTransform: boolean, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    let parentTransform;\n    let pooledMatrix;\n\n    if (target.parent)\n    {\n        if (!skipUpdateTransform)\n        {\n            pooledMatrix = matrixPool.get().identity();\n            parentTransform = updateTransformBackwards(target, pooledMatrix);\n        }\n        else\n        {\n            parentTransform = target.parent.worldTransform;\n        }\n    }\n    else\n    {\n        parentTransform = Matrix.IDENTITY;\n    }\n\n    // then collect them...\n\n    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n\n    if (pooledMatrix)\n    {\n        matrixPool.return(pooledMatrix);\n    }\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    skipUpdateTransform: boolean,\n): void\n{\n    if (!target.visible || !target.measurable) return;\n\n    let worldTransform: Matrix;\n\n    if (!skipUpdateTransform)\n    {\n        target.updateLocalTransform();\n\n        worldTransform = matrixPool.get();\n\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    }\n    else\n    {\n        worldTransform = target.worldTransform;\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, worldTransform);\n    }\n    else\n    {\n        if ((target as Renderable).addBounds)\n        {\n            // save a copy\n            bounds.matrix = worldTransform;\n\n            (target as Renderable).addBounds(bounds);\n        }\n\n        for (let i = 0; i < target.children.length; i++)\n        {\n            _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addBounds?.(bounds);\n        }\n\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    if (!skipUpdateTransform)\n    {\n        matrixPool.return(worldTransform);\n    }\n}\n\nexport function updateTransformBackwards(target: Container, parentTransform: Matrix)\n{\n    const parent = target.parent;\n\n    if (parent)\n    {\n        updateTransformBackwards(parent, parentTransform);\n\n        parent.updateLocalTransform();\n\n        parentTransform.append(parent.localTransform);\n    }\n\n    return parentTransform;\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Pool } from '../../../../utils/pool/Pool.mjs';\nimport { Bounds } from '../Bounds.mjs';\n\n\"use strict\";\nconst matrixPool = new Pool(Matrix);\nconst boundsPool = new Pool(Bounds);\n\nexport { boundsPool, matrixPool };\n//# sourceMappingURL=matrixAndBoundsPool.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Pool } from '../../../../utils/pool/Pool';\nimport { Bounds } from '../Bounds';\n\nimport type { PoolItem } from '../../../../utils/pool/Pool';\n\ntype MatrixPoolItem = Matrix & PoolItem;\ntype BoundsPoolItem = Bounds & PoolItem;\nexport const matrixPool = new Pool<MatrixPoolItem>(Matrix);\nexport const boundsPool = new Pool<BoundsPoolItem>(Bounds);\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\nimport { matrixPool, boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nfunction getLocalBounds(target, bounds, relativeMatrix) {\n  bounds.clear();\n  relativeMatrix || (relativeMatrix = Matrix.IDENTITY);\n  _getLocalBounds(target, bounds, relativeMatrix, target, true);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n  let relativeTransform;\n  if (!isRoot) {\n    if (!target.visible || !target.measurable)\n      return;\n    target.updateLocalTransform();\n    const localTransform = target.localTransform;\n    relativeTransform = matrixPool.get();\n    relativeTransform.appendFrom(localTransform, parentTransform);\n  } else {\n    relativeTransform = matrixPool.get();\n    relativeTransform = parentTransform.copyTo(relativeTransform);\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, relativeTransform);\n  } else {\n    if (target.renderPipeId) {\n      bounds.matrix = relativeTransform;\n      target.addBounds(bounds);\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addLocalBounds?.(bounds, rootContainer);\n    }\n    parentBounds.addBounds(bounds, Matrix.IDENTITY);\n    boundsPool.return(bounds);\n  }\n  matrixPool.return(relativeTransform);\n}\nfunction getParent(target, root, matrix) {\n  const parent = target.parent;\n  if (!parent) {\n    warn(\"Item is not inside the root container\");\n    return;\n  }\n  if (parent !== root) {\n    getParent(parent, root, matrix);\n    parent.updateLocalTransform();\n    matrix.append(parent.localTransform);\n  }\n}\n\nexport { getLocalBounds, getParent };\n//# sourceMappingURL=getLocalBounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { warn } from '../../../utils/logging/warn';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\nexport function getLocalBounds(target: Container, bounds: Bounds, relativeMatrix?: Matrix): Bounds\n{\n    bounds.clear();\n\n    relativeMatrix ||= Matrix.IDENTITY;\n\n    _getLocalBounds(target, bounds, relativeMatrix, target, true);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nfunction _getLocalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    rootContainer: Container,\n    isRoot: boolean\n): void\n{\n    let relativeTransform: Matrix;\n\n    if (!isRoot)\n    {\n        if (!target.visible || !target.measurable) return;\n\n        target.updateLocalTransform();\n\n        const localTransform = target.localTransform;\n\n        relativeTransform = matrixPool.get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    }\n    else\n    {\n        relativeTransform = matrixPool.get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, relativeTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            bounds.matrix = relativeTransform;\n            (target as Renderable).addBounds(bounds);\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        }\n\n        // TODO - make a add transformed bounds?\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    matrixPool.return(relativeTransform);\n}\n\nexport function getParent(target: Container, root: Container, matrix: Matrix)\n{\n    const parent = target.parent;\n\n    if (!parent)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Item is not inside the root container');\n        // #endif\n\n        return;\n    }\n\n    if (parent !== root)\n    {\n        getParent(parent, root, matrix);\n\n        parent.updateLocalTransform();\n        matrix.append(parent.localTransform);\n    }\n}\n\n","\"use strict\";\nlet warnCount = 0;\nconst maxWarnings = 500;\nfunction warn(...args) {\n  if (warnCount === maxWarnings)\n    return;\n  warnCount++;\n  if (warnCount === maxWarnings) {\n    console.warn(\"PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.\");\n  } else {\n    console.warn(\"PixiJS Warning: \", ...args);\n  }\n}\n\nexport { warn };\n//# sourceMappingURL=warn.mjs.map\n","let warnCount = 0;\nconst maxWarnings = 500;\n\n/**\n * Logs a PixiJS warning message to the console. Stops logging after 500 warnings have been logged.\n * @param args - The warning message(s) to log\n * @returns {void}\n * @memberof utils\n * @ignore\n */\nexport function warn(...args: any[])\n{\n    if (warnCount === maxWarnings) return;\n\n    warnCount++;\n\n    if (warnCount === maxWarnings)\n    {\n        console.warn('PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.');\n    }\n    else\n    {\n        console.warn('PixiJS Warning: ', ...args);\n    }\n}\n","\"use strict\";\nfunction checkChildrenDidChange(container, previousData) {\n  const children = container.children;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    const changeId = (child.uid & 255) << 24 | child._didChangeId & 16777215;\n    if (previousData.data[previousData.index] !== changeId) {\n      previousData.data[previousData.index] = changeId;\n      previousData.didChange = true;\n    }\n    previousData.index++;\n    if (child.children.length) {\n      checkChildrenDidChange(child, previousData);\n    }\n  }\n  return previousData.didChange;\n}\n\nexport { checkChildrenDidChange };\n//# sourceMappingURL=checkChildrenDidChange.mjs.map\n","import type { Container } from '../Container';\n\n/**\n * This function will crawl through the container essentially check if the children have changed.\n *\n * This function checkChildrenDidChange recursively checks if any child in a Container\n * or its children has changed. It does this by comparing a generated changeId for each\n * child against a stored value in previousData.\n * The changeId is a combination of the child's uid and _didChangeId, bitwise manipulated for uniqueness.\n * If a change is detected, it updates previousData and sets didChange to true.\n * The function returns a boolean indicating if any change was detected in the entire hierarchy of children.\n * @param container - the container to check for changes\n * @param previousData - the previous data from the last check made\n * @param previousData.data - the data array\n * @param previousData.index - the index of the data array\n * @param previousData.didChange - did the data change\n */\nexport function checkChildrenDidChange(\n    container: Container,\n    previousData: {\n        data: number[];\n        index: number;\n        didChange: boolean;\n    })\n{\n    const children = container.children;\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i];\n\n        const changeId = ((child.uid & 255) << 24)\n            | (child._didChangeId & 16777215);\n\n        if (previousData.data[previousData.index] !== changeId)\n        {\n            previousData.data[previousData.index] = changeId;\n\n            previousData.didChange = true;\n        }\n\n        previousData.index++;\n\n        if (child.children.length)\n        {\n            checkChildrenDidChange(child, previousData);\n        }\n    }\n\n    return previousData.didChange;\n}\n","\"use strict\";\nconst onRenderMixin = {\n  _onRender: null,\n  set onRender(func) {\n    const renderGroup = this.renderGroup;\n    if (!func) {\n      if (this._onRender) {\n        renderGroup?.removeOnRender(this);\n      }\n      this._onRender = null;\n      return;\n    }\n    if (!this._onRender) {\n      renderGroup?.addOnRender(this);\n    }\n    this._onRender = func;\n  },\n  /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and \"updateTransform\" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */\n  get onRender() {\n    return this._onRender;\n  }\n};\n\nexport { onRenderMixin };\n//# sourceMappingURL=onRenderMixin.mjs.map\n","import type { Container } from '../Container';\n\nexport interface OnRenderMixinConstructor\n{\n    onRender?: (() => void | null);\n}\nexport interface OnRenderMixin extends Required<OnRenderMixinConstructor>\n{\n    _onRender: (() => void) | null;\n}\n\nexport const onRenderMixin: Partial<Container> = {\n    _onRender: null,\n\n    set onRender(func: () => void)\n    {\n        const renderGroup = this.renderGroup;\n\n        if (!func)\n        {\n            if (this._onRender)\n            {\n                renderGroup?.removeOnRender(this);\n            }\n\n            this._onRender = null;\n\n            return;\n        }\n\n        if (!this._onRender)\n        {\n            renderGroup?.addOnRender(this);\n        }\n\n        this._onRender = func;\n    },\n\n    /**\n     * This callback is used when the container is rendered. This is where you should add your custom\n     * logic that is needed to be run every frame.\n     *\n     * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n     * and \"updateTransform\" is no longer called every frame\n     * @example\n     * const container = new Container();\n     * container.onRender = () => {\n     *    container.rotation += 0.01;\n     * };\n     * @memberof scene.Container#\n     */\n    get onRender(): () => void\n    {\n        return this._onRender;\n    }\n} as Container;\n","\"use strict\";\nconst sortMixin = {\n  _zIndex: 0,\n  /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortDirty: false,\n  /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortableChildren: false,\n  /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */\n  get zIndex() {\n    return this._zIndex;\n  },\n  set zIndex(value) {\n    if (this._zIndex === value)\n      return;\n    this._zIndex = value;\n    this.depthOfChildModified();\n  },\n  depthOfChildModified() {\n    if (this.parent) {\n      this.parent.sortableChildren = true;\n      this.parent.sortDirty = true;\n    }\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */\n  sortChildren() {\n    if (!this.sortDirty)\n      return;\n    this.sortDirty = false;\n    this.children.sort(sortChildren);\n  }\n};\nfunction sortChildren(a, b) {\n  return a._zIndex - b._zIndex;\n}\n\nexport { sortMixin };\n//# sourceMappingURL=sortMixin.mjs.map\n","import type { Container } from '../Container';\n\nexport interface SortMixinConstructor\n{\n    zIndex?: number;\n    sortDirty?: boolean;\n    sortableChildren?: boolean;\n}\nexport interface SortMixin extends Required<SortMixinConstructor>\n{\n    _zIndex: number;\n\n    sortChildren: () => void;\n    depthOfChildModified: () => void;\n}\n\nexport const sortMixin: Partial<Container> = {\n    _zIndex: 0,\n    /**\n     * Should children be sorted by zIndex at the next render call.\n     *\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    sortDirty: false,\n    /**\n     * If set to true, the container will sort its children by `zIndex` value\n     * when the next render is called, or manually if `sortChildren()` is called.\n     *\n     * This actually changes the order of elements in the array, so should be treated\n     * as a basic solution that is not performant compared to other solutions,\n     * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n     *\n     * Also be aware of that this may not work nicely with the `addChildAt()` function,\n     * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    sortableChildren: false,\n\n    /**\n     * The zIndex of the container.\n     *\n     * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other display objects within the same container.\n     * @see scene.Container#sortableChildren\n     * @memberof scene.Container#\n     */\n    get zIndex()\n    {\n        return this._zIndex;\n    },\n\n    set zIndex(value: number)\n    {\n        if (this._zIndex === value) return;\n\n        this._zIndex = value;\n\n        this.depthOfChildModified();\n    },\n\n    depthOfChildModified()\n    {\n        if (this.parent)\n        {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n\n        if (this.renderGroup && !this.isRenderGroupRoot)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n    },\n\n    /**\n     * Sorts children by zIndex.\n     * @memberof scene.Container#\n     */\n    sortChildren()\n    {\n        if (!this.sortDirty) return;\n\n        this.sortDirty = false;\n\n        this.children.sort(sortChildren);\n    },\n} as Container;\n\nfunction sortChildren(a: Container, b: Container): number\n{\n    return a._zIndex - b._zIndex;\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds.mjs';\n\n\"use strict\";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = updateTransformBackwards(this, new Matrix());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.apply(position, point);\n    }\n    return this.worldTransform.apply(position, point);\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = updateTransformBackwards(this, new Matrix());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.applyInverse(position, point);\n    }\n    return this.worldTransform.applyInverse(position, point);\n  }\n};\n\nexport { toLocalGlobalMixin };\n//# sourceMappingURL=toLocalGlobalMixin.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Container } from '../Container';\n\nexport interface ToLocalGlobalMixin\n{\n    getGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n\nexport const toLocalGlobalMixin: Partial<Container> = {\n    /**\n     * Returns the global position of the container.\n     * @param point - The optional point to write the global value to.\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - The updated point.\n     * @memberof scene.Container#\n     */\n    getGlobalPosition(point: Point = new Point(), skipUpdate = false): Point\n    {\n        if (this.parent)\n        {\n            this.parent.toGlobal(this._position, point, skipUpdate);\n        }\n        else\n        {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n\n        return point;\n    },\n\n    /**\n     * Calculates the global position of the container.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     * @memberof scene.Container#\n     */\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate = false): P\n    {\n        if (!skipUpdate)\n        {\n            this.updateLocalTransform();\n\n            const globalMatrix = updateTransformBackwards(this, new Matrix());\n\n            globalMatrix.append(this.localTransform);\n\n            return globalMatrix.apply<P>(position, point);\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.apply<P>(position, point);\n    },\n\n    /**\n     * Calculates the local position of the container relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The Container to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     * @memberof scene.Container#\n     */\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this.updateLocalTransform();\n\n            const globalMatrix = updateTransformBackwards(this, new Matrix());\n\n            globalMatrix.append(this.localTransform);\n\n            return globalMatrix.applyInverse<P>(position, point);\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse<P>(position, point);\n    }\n} as Container;\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet.mjs';\n\n\"use strict\";\nclass RenderGroup {\n  constructor(root) {\n    this.renderPipeId = \"renderGroup\";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this._children = [];\n    this.worldTransform = new Matrix();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n    this.updateTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = { list: [], index: 0 };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet();\n    this._onRenderContainers = [];\n    this.root = root;\n    this.addChild(root);\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.onChildUpdate(renderGroupChild.root);\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.root.didChange) {\n      this._removeChildFromUpdate(renderGroupChild.root);\n    }\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    if (child !== this.root) {\n      this._children.push(child);\n      child.updateTick = -1;\n      if (child.parent === this.root) {\n        child.relativeRenderGroupDepth = 1;\n      } else {\n        child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n      }\n      if (child._onRender) {\n        this.addOnRender(child);\n      }\n    }\n    if (child.renderGroup) {\n      if (child.renderGroup.root === child) {\n        this.addRenderGroupChild(child.renderGroup);\n        return;\n      }\n    } else {\n      child.renderGroup = this;\n      child.didChange = true;\n    }\n    const children = child.children;\n    if (!child.isRenderGroupRoot) {\n      this.onChildUpdate(child);\n    }\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      this.removeOnRender(child);\n    }\n    if (child.renderGroup.root !== child) {\n      const children = child.children;\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      if (child.didChange) {\n        child.renderGroup._removeChildFromUpdate(child);\n      }\n      child.renderGroup = null;\n    } else {\n      this._removeRenderGroupChild(child.renderGroup);\n    }\n    const index = this._children.indexOf(child);\n    if (index > -1) {\n      this._children.splice(index, 1);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  // SHOULD THIS BE HERE?\n  updateRenderable(container) {\n    if (container.globalDisplayStatus < 7)\n      return;\n    container.didViewUpdate = false;\n    this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  _removeChildFromUpdate(child) {\n    const childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      return;\n    }\n    const index = childrenToUpdate.list.indexOf(child);\n    if (index > -1) {\n      childrenToUpdate.list.splice(index, 1);\n    }\n    childrenToUpdate.index--;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender() {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender();\n    }\n  }\n}\n\nexport { RenderGroup };\n//# sourceMappingURL=RenderGroup.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Container } from './Container';\n\n/**\n * The render group is the base class for all render groups\n * It is used to render a group of containers together\n * @memberof rendering\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    private readonly _children: Container[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    constructor(root: Container)\n    {\n        this.root = root;\n\n        this.addChild(root);\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.onChildUpdate(renderGroupChild.root);\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.root.didChange)\n        {\n            this._removeChildFromUpdate(renderGroupChild.root);\n        }\n\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        // TODO this can be optimized..\n        if (child !== this.root)\n        {\n            this._children.push(child);\n\n            child.updateTick = -1;\n\n            if (child.parent === this.root)\n            {\n                child.relativeRenderGroupDepth = 1;\n            }\n\n            else\n            {\n                child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n            }\n\n            if (child._onRender)\n            {\n                this.addOnRender(child);\n            }\n        }\n\n        if (child.renderGroup)\n        {\n            if (child.renderGroup.root === child)\n            {\n                // its already its own render group..\n                this.addRenderGroupChild(child.renderGroup);\n\n                return;\n            }\n        }\n        else\n        {\n            child.renderGroup = this;\n            child.didChange = true;\n        }\n\n        const children = child.children;\n\n        if (!child.isRenderGroupRoot)\n        {\n            this.onChildUpdate(child);\n        }\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            this.removeOnRender(child);\n        }\n\n        if (child.renderGroup.root !== child)\n        {\n            const children = child.children;\n\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            if (child.didChange)\n            {\n                child.renderGroup._removeChildFromUpdate(child);\n            }\n\n            child.renderGroup = null;\n        }\n\n        else\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n        }\n\n        const index = this._children.indexOf(child);\n\n        if (index > -1)\n        {\n            this._children.splice(index, 1);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    // SHOULD THIS BE HERE?\n    public updateRenderable(container: Container)\n    {\n        // only update if its visible!\n        if (container.globalDisplayStatus < 0b111) return;\n\n        container.didViewUpdate = false;\n        // actually updates the renderable..\n        this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    private _removeChildFromUpdate(child: Container)\n    {\n        const childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        { return; }\n\n        const index = childrenToUpdate.list.indexOf(child);\n\n        // TODO this should be optimized - don't really want to change array size on the fly if we can avoid!\n        if (index > -1)\n        {\n            childrenToUpdate.list.splice(index, 1);\n        }\n\n        childrenToUpdate.index--;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender()\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender();\n        }\n    }\n}\n","import { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass InstructionSet {\n  constructor() {\n    /** a unique id for this instruction set used through the renderer */\n    this.uid = uid(\"instructionSet\");\n    /** the array of instructions */\n    this.instructions = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    this.instructionSize = 0;\n  }\n  /** reset the instruction set so it can be reused set size back to 0 */\n  reset() {\n    this.instructionSize = 0;\n  }\n  /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */\n  add(instruction) {\n    this.instructions[this.instructionSize++] = instruction;\n  }\n  /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */\n  log() {\n    this.instructions.length = this.instructionSize;\n    console.table(this.instructions, [\"type\", \"action\"]);\n  }\n}\n\nexport { InstructionSet };\n//# sourceMappingURL=InstructionSet.mjs.map\n","import { uid } from '../../../../utils/data/uid';\n\nimport type { Instruction } from './Instruction';\n\n/**\n * A set of instructions that can be executed by the renderer.\n * Basically wraps an array, but with some extra properties that help the renderer\n * to keep things nice and optimised.\n *\n * Note:\n * InstructionSet.instructions contains all the instructions, but does not resize (for performance).\n * So for the true length of the instructions you need to use InstructionSet.instructionSize\n * @memberof rendering\n */\nexport class InstructionSet\n{\n    /** a unique id for this instruction set used through the renderer */\n    public readonly uid = uid('instructionSet');\n    /** the array of instructions */\n    public readonly instructions: Instruction[] = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    public instructionSize = 0;\n    /** allows for access to the render pipes of the renderer */\n    public renderPipes: any;\n\n    /** reset the instruction set so it can be reused set size back to 0 */\n    public reset()\n    {\n        this.instructionSize = 0;\n    }\n\n    /**\n     * Add an instruction to the set\n     * @param instruction - add an instruction to the set\n     */\n    public add(instruction: Instruction)\n    {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n\n    /**\n     * Log the instructions to the console (for debugging)\n     * @internal\n     * @ignore\n     */\n    public log()\n    {\n        this.instructions.length = this.instructionSize;\n        // eslint-disable-next-line no-console\n        console.table(this.instructions, ['type', 'action']);\n    }\n}\n","\"use strict\";\nfunction assignWithIgnore(target, options, ignore = {}) {\n  for (const key in options) {\n    if (!ignore[key] && options[key] !== void 0) {\n      target[key] = options[key];\n    }\n  }\n}\n\nexport { assignWithIgnore };\n//# sourceMappingURL=assignWithIgnore.mjs.map\n","/**\n * Assigns properties from one object to another, using an optional array of property names to ignore.\n * @param target - The target object to assign properties to.\n * @param options - The object to assign properties from.\n * @param ignore - An object of property names to ignore ({ propToIgnore: true }).\n */\nexport function assignWithIgnore<T extends Record<string, any>>(\n    target: T,\n    options: T,\n    ignore: Record<string, boolean> = {}\n)\n{\n    for (const key in options)\n    {\n        if (!ignore[key] && options[key] !== undefined)\n        {\n            target[key] = options[key];\n        }\n    }\n}\n","import { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction addMaskBounds(mask, bounds, skipUpdateTransform) {\n  const boundsToMask = tempBounds;\n  mask.measurable = true;\n  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n  bounds.addBoundsMask(boundsToMask);\n  mask.measurable = false;\n}\n\nexport { addMaskBounds };\n//# sourceMappingURL=addMaskBounds.mjs.map\n","import { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../../../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\nexport function addMaskBounds(mask: Container, bounds: Bounds, skipUpdateTransform: boolean): void\n{\n    const boundsToMask = tempBounds;\n\n    mask.measurable = true;\n\n    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n\n    bounds.addBoundsMask(boundsToMask);\n\n    mask.measurable = false;\n}\n\n","import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds.mjs';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addMaskLocalBounds(mask, bounds, localRoot) {\n  const boundsToMask = boundsPool.get();\n  mask.measurable = true;\n  const tempMatrix = matrixPool.get().identity();\n  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n  getLocalBounds(mask, boundsToMask, relativeMask);\n  mask.measurable = false;\n  bounds.addBoundsMask(boundsToMask);\n  matrixPool.return(tempMatrix);\n  boundsPool.return(boundsToMask);\n}\nfunction getMatrixRelativeToParent(target, root, matrix) {\n  if (!target) {\n    warn(\"Mask bounds, renderable is not inside the root container\");\n    return matrix;\n  }\n  if (target !== root) {\n    getMatrixRelativeToParent(target.parent, root, matrix);\n    target.updateLocalTransform();\n    matrix.append(target.localTransform);\n  }\n  return matrix;\n}\n\nexport { addMaskLocalBounds, getMatrixRelativeToParent };\n//# sourceMappingURL=addMaskLocalBounds.mjs.map\n","import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\n\nexport function addMaskLocalBounds(mask: Container, bounds: Bounds, localRoot: Container): void\n{\n    const boundsToMask = boundsPool.get();\n\n    mask.measurable = true;\n\n    const tempMatrix = matrixPool.get().identity();\n\n    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n\n    getLocalBounds(mask, boundsToMask, relativeMask);\n\n    mask.measurable = false;\n\n    bounds.addBoundsMask(boundsToMask);\n\n    matrixPool.return(tempMatrix);\n    boundsPool.return(boundsToMask);\n}\n\nexport function getMatrixRelativeToParent(target: Container, root: Container, matrix: Matrix): Matrix\n{\n    if (!target)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Mask bounds, renderable is not inside the root container');\n        // #endif\n\n        return matrix;\n    }\n\n    if (target !== root)\n    {\n        getMatrixRelativeToParent(target.parent, root, matrix);\n\n        target.updateLocalTransform();\n\n        matrix.append(target.localTransform);\n    }\n\n    return matrix;\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"colorMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n  }\n  destroy() {\n  }\n  static test(mask) {\n    return typeof mask === \"number\";\n  }\n}\nColorMask.extension = ExtensionType.MaskEffect;\n\nexport { ColorMask };\n//# sourceMappingURL=ColorMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class ColorMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: number;\n    public pipe = 'colorMask';\n\n    constructor(options: {mask: number})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: number): void\n    {\n        this.mask = mask;\n    }\n\n    public destroy(): void\n    {\n        // nothing to destroy\n    }\n\n    public static test(mask: any): boolean\n    {\n        return typeof mask === 'number';\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Container } from '../../../scene/container/Container.mjs';\nimport { addMaskBounds } from '../utils/addMaskBounds.mjs';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds.mjs';\n\n\"use strict\";\nclass StencilMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"stencilMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.mask.includeInBuild = false;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask.includeInBuild = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Container;\n  }\n}\nStencilMask.extension = ExtensionType.MaskEffect;\n\nexport { StencilMask };\n//# sourceMappingURL=StencilMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Container } from '../../../scene/container/Container';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class StencilMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'stencilMask';\n\n    constructor(options: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Container;\n    }\n}\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass CanvasSource extends TextureSource {\n  constructor(options) {\n    if (!options.resource) {\n      options.resource = DOMAdapter.get().createCanvas();\n    }\n    if (!options.width) {\n      options.width = options.resource.width;\n      if (!options.autoDensity) {\n        options.width /= options.resolution;\n      }\n    }\n    if (!options.height) {\n      options.height = options.resource.height;\n      if (!options.autoDensity) {\n        options.height /= options.resolution;\n      }\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoDensity = options.autoDensity;\n    const canvas = options.resource;\n    if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) {\n      this.resizeCanvas();\n    }\n    this.transparent = !!options.transparent;\n  }\n  resizeCanvas() {\n    if (this.autoDensity) {\n      this.resource.style.width = `${this.width}px`;\n      this.resource.style.height = `${this.height}px`;\n    }\n    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n      this.resource.width = this.pixelWidth;\n      this.resource.height = this.pixelHeight;\n    }\n  }\n  resize(width = this.width, height = this.height, resolution = this._resolution) {\n    const didResize = super.resize(width, height, resolution);\n    if (didResize) {\n      this.resizeCanvas();\n    }\n    return didResize;\n  }\n  static test(resource) {\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n  }\n}\nCanvasSource.extension = ExtensionType.TextureSource;\n\nexport { CanvasSource };\n//# sourceMappingURL=CanvasSource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas>\n{\n    /** should the canvas be resized to preserve its screen width and height regardless of the resolution of the renderer */\n    autoDensity?: boolean;\n    /** if true, this canvas will be set up to be transparent where possible */\n    transparent?: boolean;\n}\n\nexport class CanvasSource extends TextureSource<ICanvas>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'image';\n    public autoDensity: boolean;\n    public transparent: boolean;\n\n    constructor(options: CanvasSourceOptions)\n    {\n        if (!options.resource)\n        {\n            options.resource = DOMAdapter.get().createCanvas();\n        }\n\n        if (!options.width)\n        {\n            options.width = options.resource.width;\n\n            if (!options.autoDensity)\n            {\n                options.width /= options.resolution;\n            }\n        }\n\n        if (!options.height)\n        {\n            options.height = options.resource.height;\n\n            if (!options.autoDensity)\n            {\n                options.height /= options.resolution;\n            }\n        }\n\n        super(options);\n\n        this.autoDensity = options.autoDensity;\n\n        const canvas = options.resource;\n\n        if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height)\n        {\n            this.resizeCanvas();\n        }\n\n        this.transparent = !!options.transparent;\n    }\n\n    public resizeCanvas()\n    {\n        if (this.autoDensity)\n        {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n\n        // only resize if wee need to, as this clears the canvas (even if values are set to the same)\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight)\n        {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n\n    public resize(width = this.width, height = this.height, resolution = this._resolution): boolean\n    {\n        const didResize = super.resize(width, height, resolution);\n\n        if (didResize)\n        {\n            this.resizeCanvas();\n        }\n\n        return didResize;\n    }\n\n    public static test(resource: any): resource is ICanvas\n    {\n        return (globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement)\n        || (globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas);\n    }\n}\n","import { BrowserAdapter } from '../environment-browser/BrowserAdapter.mjs';\n\n\"use strict\";\nlet currentAdapter = BrowserAdapter;\nconst DOMAdapter = {\n  /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */\n  get() {\n    return currentAdapter;\n  },\n  /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */\n  set(adapter) {\n    currentAdapter = adapter;\n  }\n};\n\nexport { DOMAdapter };\n//# sourceMappingURL=adapter.mjs.map\n","import { BrowserAdapter } from '../environment-browser/BrowserAdapter';\n\nimport type { ICanvas } from './canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from './canvas/ICanvasRenderingContext2D';\n\n/**\n * PixiJS supports multiple environments including browsers, Web Workers, and Node.js.\n * The environment is auto-detected by default using the {@link environment.autoDetectEnvironment} function.\n *\n * The {@link environment.Adapter} interface provides a way to abstract away the differences between\n * these environments. PixiJS uses the {@link environment.BrowserAdapter} by default.\n *\n * However you can manually set the environment using the {@link environment.DOMAdapter} singleton, for example to\n * use Pixi within a WebWorker.\n * ```js\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * ```\n * @namespace environment\n */\n\n/**\n * This interface describes all the DOM dependent calls that Pixi makes throughout its codebase.\n * Implementations of this interface can be used to make sure Pixi will work in any environment,\n * such as browser, Web Workers, and Node.js.\n * @memberof environment\n */\nexport interface Adapter\n{\n    /** Returns a canvas object that can be used to create a webgl context. */\n    createCanvas: (width?: number, height?: number) => ICanvas;\n    /** Returns a 2D rendering context. */\n    getCanvasRenderingContext2D: () => { prototype: ICanvasRenderingContext2D; };\n    /** Returns a WebGL rendering context. */\n    getWebGLRenderingContext: () => typeof WebGLRenderingContext;\n    /** Returns a partial implementation of the browsers window.navigator */\n    getNavigator: () => { userAgent: string, gpu: GPU | null };\n    /** Returns the current base URL For browser environments this is either the document.baseURI or window.location.href */\n    getBaseUrl: () => string;\n    /** Return the font face set if available */\n    getFontFaceSet: () => FontFaceSet | null;\n    /** Returns a Response object that has been fetched from the given URL. */\n    fetch: (url: RequestInfo, options?: RequestInit) => Promise<Response>;\n    /** Returns Document object that has been parsed from the given XML string. */\n    parseXML: (xml: string) => Document;\n}\n\nlet currentAdapter: Adapter = BrowserAdapter;\n\n/**\n * The DOMAdapter is a singleton that allows PixiJS to perform DOM operations, such as creating a canvas.\n * This allows PixiJS to be used in any environment, such as a web browser, Web Worker, or Node.js.\n * It uses the {@link environment.Adapter} interface to abstract away the differences between these environments\n * and uses the {@link environment.BrowserAdapter} by default.\n *\n * It has two methods: `get():Adapter` and `set(adapter: Adapter)`.\n *\n * Defaults to the {@link environment.BrowserAdapter}.\n * @example\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * @memberof environment\n */\nexport const DOMAdapter = {\n    /**\n     * Returns the current adapter.\n     * @returns {environment.Adapter} The current adapter.\n     */\n    get(): Adapter\n    {\n        return currentAdapter;\n    },\n    /**\n     * Sets the current adapter.\n     * @param adapter - The new adapter.\n     */\n    set(adapter: Adapter): void\n    {\n        currentAdapter = adapter;\n    },\n};\n","\"use strict\";\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, \"text/xml\");\n  }\n};\n\nexport { BrowserAdapter };\n//# sourceMappingURL=BrowserAdapter.mjs.map\n","import { type Adapter } from '../environment/adapter';\n\n/**\n * This is an implementation of the {@link environment.Adapter} interface.\n * It can be used to make Pixi work in the browser.\n * @memberof environment\n * @property {Function} createCanvas - Creates a canvas element of the given size.\n * This canvas is created using the browser's native canvas element.\n * @property {Function} getCanvasRenderingContext2D - Returns a 2D rendering context.\n * @property {Function} getWebGLRenderingContext - Returns a WebGL rendering context.\n * @property {Function} getNavigator - Returns browsers window.navigator\n * @property {Function} getBaseUrl - Returns the current base URL for browser environments this is either\n * the document.baseURI or window.location.href\n * @property {Function} getFontFaceSet - Return the font face set if available\n * @property {Function} fetch - Returns a Response object that has been fetched from the given URL.\n * @property {Function} parseXML - Returns Document object that has been parsed from the given XML string.\n */\nexport const BrowserAdapter = {\n    createCanvas: (width: number, height: number): HTMLCanvasElement =>\n    {\n        const canvas = document.createElement('canvas');\n\n        canvas.width = width;\n        canvas.height = height;\n\n        return canvas;\n    },\n    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n    getWebGLRenderingContext: () => WebGLRenderingContext,\n    getNavigator: () => navigator,\n    getBaseUrl: () => (document.baseURI ?? window.location.href),\n    getFontFaceSet: () => document.fonts,\n    fetch: (url: RequestInfo, options?: RequestInit) => fetch(url, options),\n    parseXML: (xml: string) =>\n    {\n        const parser = new DOMParser();\n\n        return parser.parseFromString(xml, 'text/xml');\n    },\n} as Adapter;\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass ImageSource extends TextureSource {\n  constructor(options) {\n    if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {\n      const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(options.resource, 0, 0);\n      options.resource = canvas;\n      warn(\"ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.\");\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoGarbageCollect = true;\n  }\n  static test(resource) {\n    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== \"undefined\" && resource instanceof ImageBitmap;\n  }\n}\nImageSource.extension = ExtensionType.TextureSource;\n\nexport { ImageSource };\n//# sourceMappingURL=ImageSource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport type ImageResource =\nImageBitmap\n| HTMLCanvasElement\n| OffscreenCanvas\n| ICanvas\n| VideoFrame\n| HTMLImageElement\n| HTMLVideoElement;\n\nexport class ImageSource extends TextureSource<ImageResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n    public uploadMethodId = 'image';\n\n    constructor(options: TextureSourceOptions<ImageResource>)\n    {\n        if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement))\n        {\n            const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);\n            const context = canvas.getContext('2d');\n\n            context.drawImage(options.resource, 0, 0);\n            options.resource = canvas;\n\n            // #if _DEBUG\n            warn('ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.');\n            // #endif\n        }\n\n        super(options);\n\n        this.autoGarbageCollect = true;\n    }\n\n    public static test(resource: any): resource is ImageResource\n    {\n        return (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        || (typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap);\n    }\n}\n","import { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../../../ticker/Ticker.mjs';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nconst _VideoSource = class _VideoSource extends TextureSource {\n  constructor(options) {\n    super(options);\n    // Public\n    /** Whether or not the video is ready to play. */\n    this.isReady = false;\n    /** The upload method for this texture. */\n    this.uploadMethodId = \"video\";\n    options = {\n      ..._VideoSource.defaultOptions,\n      ...options\n    };\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this.alphaMode = options.alphaMode ?? \"premultiply-alpha-on-upload\";\n    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n    this._videoFrameRequestCallbackHandle = null;\n    this._load = null;\n    this._resolve = null;\n    this._reject = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onError = this._onError.bind(this);\n    this._onPlayStart = this._onPlayStart.bind(this);\n    this._onPlayStop = this._onPlayStop.bind(this);\n    this._onSeeked = this._onSeeked.bind(this);\n    if (options.autoLoad !== false) {\n      void this.load();\n    }\n  }\n  /** Update the video frame if the source is not destroyed and meets certain conditions. */\n  updateFrame() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._updateFPS) {\n      const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n    }\n    if (!this._updateFPS || this._msToNextUpdate <= 0) {\n      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n    }\n    if (this.isValid) {\n      this.update();\n    }\n  }\n  /** Callback to update the video frame and potentially request the next frame update. */\n  _videoFrameRequestCallback() {\n    this.updateFrame();\n    if (this.destroyed) {\n      this._videoFrameRequestCallbackHandle = null;\n    } else {\n      this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n        this._videoFrameRequestCallback\n      );\n    }\n  }\n  /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */\n  get isValid() {\n    return !!this.resource.videoWidth && !!this.resource.videoHeight;\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */\n  async load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.resource;\n    const options = this.options;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener(\"play\", this._onPlayStart);\n    source.addEventListener(\"pause\", this._onPlayStop);\n    source.addEventListener(\"seeked\", this._onSeeked);\n    if (!this._isSourceReady()) {\n      if (!options.preload) {\n        source.addEventListener(\"canplay\", this._onCanPlay);\n      }\n      source.addEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.addEventListener(\"error\", this._onError, true);\n    } else {\n      this._mediaReady();\n    }\n    this.alphaMode = await detectVideoAlphaMode();\n    this._load = new Promise((resolve, reject) => {\n      if (this.isValid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        this._reject = reject;\n        if (options.preloadTimeoutMs !== void 0) {\n          this._preloadTimeout = setTimeout(() => {\n            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n          });\n        }\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event - The error event\n   */\n  _onError(event) {\n    this.resource.removeEventListener(\"error\", this._onError, true);\n    this.emit(\"error\", event);\n    if (this._reject) {\n      this._reject(event);\n      this._reject = null;\n      this._resolve = null;\n    }\n  }\n  /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.resource;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */\n  _isSourceReady() {\n    const source = this.resource;\n    return source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    if (!this.isValid) {\n      this._mediaReady();\n    }\n    this._configureAutoUpdate();\n  }\n  /** Stops the update loop when a pause event is triggered. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Handles behavior when the video completes seeking to the current playback position. */\n  _onSeeked() {\n    if (this._autoUpdate && !this._isSourcePlaying()) {\n      this._msToNextUpdate = 0;\n      this.updateFrame();\n      this._msToNextUpdate = 0;\n    }\n  }\n  _onCanPlay() {\n    const source = this.resource;\n    source.removeEventListener(\"canplay\", this._onCanPlay);\n    this._mediaReady();\n  }\n  _onCanPlayThrough() {\n    const source = this.resource;\n    source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    if (this._preloadTimeout) {\n      clearTimeout(this._preloadTimeout);\n      this._preloadTimeout = void 0;\n    }\n    this._mediaReady();\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _mediaReady() {\n    const source = this.resource;\n    if (this.isValid) {\n      this.isReady = true;\n      this.resize(source.videoWidth, source.videoHeight);\n    }\n    this._msToNextUpdate = 0;\n    this.updateFrame();\n    this._msToNextUpdate = 0;\n    if (this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n      this._reject = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      void this.resource.play();\n    }\n  }\n  /** Cleans up resources and event listeners associated with this texture. */\n  destroy() {\n    this._configureAutoUpdate();\n    const source = this.resource;\n    if (source) {\n      source.removeEventListener(\"play\", this._onPlayStart);\n      source.removeEventListener(\"pause\", this._onPlayStop);\n      source.removeEventListener(\"seeked\", this._onSeeked);\n      source.removeEventListener(\"canplay\", this._onCanPlay);\n      source.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.removeEventListener(\"error\", this._onError, true);\n      source.pause();\n      source.src = \"\";\n      source.load();\n    }\n    super.destroy();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser's native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video's state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n   */\n  _configureAutoUpdate() {\n    if (this._autoUpdate && this._isSourcePlaying()) {\n      if (!this._updateFPS && this.resource.requestVideoFrameCallback) {\n        if (this._isConnectedToTicker) {\n          Ticker.shared.remove(this.updateFrame, this);\n          this._isConnectedToTicker = false;\n          this._msToNextUpdate = 0;\n        }\n        if (this._videoFrameRequestCallbackHandle === null) {\n          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n            this._videoFrameRequestCallback\n          );\n        }\n      } else {\n        if (this._videoFrameRequestCallbackHandle !== null) {\n          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n          this._videoFrameRequestCallbackHandle = null;\n        }\n        if (!this._isConnectedToTicker) {\n          Ticker.shared.add(this.updateFrame, this);\n          this._isConnectedToTicker = true;\n          this._msToNextUpdate = 0;\n        }\n      }\n    } else {\n      if (this._videoFrameRequestCallbackHandle !== null) {\n        this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n        this._videoFrameRequestCallbackHandle = null;\n      }\n      if (this._isConnectedToTicker) {\n        Ticker.shared.remove(this.updateFrame, this);\n        this._isConnectedToTicker = false;\n        this._msToNextUpdate = 0;\n      }\n    }\n  }\n  static test(resource) {\n    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement || globalThis.VideoFrame && resource instanceof VideoFrame;\n  }\n};\n_VideoSource.extension = ExtensionType.TextureSource;\n/** The default options for video sources. */\n_VideoSource.defaultOptions = {\n  ...TextureSource.defaultOptions,\n  /** If true, the video will start loading immediately. */\n  autoLoad: true,\n  /** If true, the video will start playing as soon as it is loaded. */\n  autoPlay: true,\n  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n  updateFPS: 0,\n  /** If true, the video will be loaded with the `crossorigin` attribute. */\n  crossorigin: true,\n  /** If true, the video will loop when it ends. */\n  loop: false,\n  /** If true, the video will be muted. */\n  muted: true,\n  /** If true, the video will play inline. */\n  playsinline: true,\n  /** If true, the video will be preloaded. */\n  preload: false\n};\n/**\n * Map of video MIME types that can't be directly derived from file extensions.\n * @readonly\n */\n_VideoSource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nlet VideoSource = _VideoSource;\n\nexport { VideoSource };\n//# sourceMappingURL=VideoSource.mjs.map\n","// VideoSource.ts\n\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { Ticker } from '../../../../../ticker/Ticker';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { Dict } from '../../../../../utils/types';\nimport type { ALPHA_MODES } from '../const';\nimport type { TextureSourceOptions } from './TextureSource';\n\ntype VideoResource = HTMLVideoElement;\n\n/**\n * Options for video sources.\n * @memberof rendering\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource>\n{\n    /** If true, the video will start loading immediately. */\n    autoLoad?: boolean;\n    /** If true, the video will start playing as soon as it is loaded. */\n    autoPlay?: boolean;\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n    updateFPS?: number;\n    /** If true, the video will be loaded with the `crossorigin` attribute. */\n    crossorigin?: boolean | string;\n    /** If true, the video will loop when it ends. */\n    loop?: boolean;\n    /** If true, the video will be muted. */\n    muted?: boolean;\n    /** If true, the video will play inline. */\n    playsinline?: boolean;\n    /** If true, the video will be preloaded. */\n    preload?: boolean;\n    /** The time in milliseconds to wait for the video to preload before timing out. */\n    preloadTimeoutMs?: number;\n    /** The alpha mode of the video. */\n    alphaMode?: ALPHA_MODES;\n}\n\nexport interface VideoResourceOptionsElement\n{\n    src: string;\n    mime: string;\n}\n\n/**\n * A source for video-based textures.\n * @memberof rendering\n */\nexport class VideoSource extends TextureSource<VideoResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    /** The default options for video sources. */\n    public static defaultOptions: VideoSourceOptions = {\n        ...TextureSource.defaultOptions,\n        /** If true, the video will start loading immediately. */\n        autoLoad: true,\n        /** If true, the video will start playing as soon as it is loaded. */\n        autoPlay: true,\n        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n        updateFPS: 0,\n        /** If true, the video will be loaded with the `crossorigin` attribute. */\n        crossorigin: true,\n        /** If true, the video will loop when it ends. */\n        loop: false,\n        /** If true, the video will be muted. */\n        muted: true,\n        /** If true, the video will play inline. */\n        playsinline: true,\n        /** If true, the video will be preloaded. */\n        preload: false,\n    };\n\n    // Public\n    /** Whether or not the video is ready to play. */\n    public isReady = false;\n    /** The upload method for this texture. */\n    public uploadMethodId = 'video';\n\n    // Protected\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    // Private\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    private _msToNextUpdate: number;\n    private _preloadTimeout: number;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n    private _reject: (error: ErrorEvent) => void;\n\n    private _updateFPS: number;\n    private _videoFrameRequestCallbackHandle: number | null;\n\n    constructor(\n        options: VideoSourceOptions\n    )\n    {\n        super(options);\n\n        // Merge provided options with default ones\n        options = {\n            ...VideoSource.defaultOptions,\n            ...options\n        };\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? 'premultiply-alpha-on-upload';\n\n        // Binding for frame updates\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            void this.load();\n        }\n    }\n\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */\n    protected updateFrame(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        if (this._updateFPS)\n        {\n            // Account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n\n        if (!this._updateFPS || this._msToNextUpdate <= 0)\n        {\n            this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n        }\n\n        if (this.isValid)\n        {\n            this.update();\n        }\n    }\n\n    /** Callback to update the video frame and potentially request the next frame update. */\n    private _videoFrameRequestCallback(): void\n    {\n        this.updateFrame();\n\n        if (this.destroyed)\n        {\n            this._videoFrameRequestCallbackHandle = null;\n        }\n        else\n        {\n            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                this._videoFrameRequestCallback\n            );\n        }\n    }\n\n    /**\n     * Checks if the resource has valid dimensions.\n     * @returns {boolean} True if width and height are set, otherwise false.\n     */\n    public get isValid(): boolean\n    {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<this>} Handle the validate event\n     */\n    public async load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.resource;\n        const options = this.options as VideoSourceOptions;\n\n        // Check if source data is enough and set it to complete if needed\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        // Add event listeners related to playback and seeking\n        source.addEventListener('play', this._onPlayStart);\n        source.addEventListener('pause', this._onPlayStop);\n        source.addEventListener('seeked', this._onSeeked);\n\n        // Add or handle source readiness event listeners\n        if (!this._isSourceReady())\n        {\n            if (!options.preload)\n            {\n                // since this event fires early, only bind if not waiting for a preload event\n                source.addEventListener('canplay', this._onCanPlay);\n            }\n            source.addEventListener('canplaythrough', this._onCanPlayThrough);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            // Source is already ready, so handle it immediately\n            this._mediaReady();\n        }\n\n        this.alphaMode = await detectVideoAlphaMode();\n\n        // Create and return the loading promise\n        this._load = new Promise((resolve, reject): void =>\n        {\n            if (this.isValid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n                this._reject = reject;\n\n                if (options.preloadTimeoutMs !== undefined)\n                {\n                    this._preloadTimeout = setTimeout(() =>\n                    {\n                        this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                    }) as unknown as number;\n                }\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event - The error event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        this.resource.removeEventListener('error', this._onError, true);\n        this.emit('error', event);\n\n        if (this._reject)\n        {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n\n    /**\n     * Checks if the underlying source is playing.\n     * @returns True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.resource;\n\n        return (!source.paused && !source.ended);\n    }\n\n    /**\n     * Checks if the underlying source is ready for playing.\n     * @returns True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.resource;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Handle edge case where video might not have received its \"can play\" event yet\n        if (!this.isValid)\n        {\n            this._mediaReady();\n        }\n\n        this._configureAutoUpdate();\n    }\n\n    /** Stops the update loop when a pause event is triggered. */\n    private _onPlayStop(): void\n    {\n        this._configureAutoUpdate();\n    }\n\n    /** Handles behavior when the video completes seeking to the current playback position. */\n    private _onSeeked(): void\n    {\n        if (this._autoUpdate && !this._isSourcePlaying())\n        {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n\n    private _onCanPlay(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplay', this._onCanPlay);\n\n        this._mediaReady();\n    }\n\n    private _onCanPlayThrough(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        if (this._preloadTimeout)\n        {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = undefined;\n        }\n\n        this._mediaReady();\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _mediaReady(): void\n    {\n        const source = this.resource;\n\n        if (this.isValid)\n        {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n\n        // Reset update timers and perform a frame update\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n\n        // Resolve the loading promise if it exists\n        if (this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n\n        // Handle play behavior based on current source status\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            void this.resource.play();\n        }\n    }\n\n    /** Cleans up resources and event listeners associated with this texture. */\n    public destroy()\n    {\n        this._configureAutoUpdate();\n\n        const source = this.resource;\n\n        if (source)\n        {\n            // Remove event listeners\n            source.removeEventListener('play', this._onPlayStart);\n            source.removeEventListener('pause', this._onPlayStop);\n            source.removeEventListener('seeked', this._onSeeked);\n            source.removeEventListener('canplay', this._onCanPlay);\n            source.removeEventListener('canplaythrough', this._onCanPlayThrough);\n            source.removeEventListener('error', this._onError, true);\n\n            // Clear the video source and pause\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n\n        super.destroy();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * Configures the updating mechanism based on the current state and settings.\n     *\n     * This method decides between using the browser's native video frame callback or a custom ticker\n     * for updating the video frame. It ensures optimal performance and responsiveness\n     * based on the video's state, playback status, and the desired frames-per-second setting.\n     *\n     * - If `_autoUpdate` is enabled and the video source is playing:\n     *   - It will prefer the native video frame callback if available and no specific FPS is set.\n     *   - Otherwise, it will use a custom ticker for manual updates.\n     * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n     */\n    private _configureAutoUpdate(): void\n    {\n        // Check if automatic updating is enabled and if the source is currently playing\n        if (this._autoUpdate && this._isSourcePlaying())\n        {\n            // Determine if we should use the browser's native video frame callback (generally for better performance)\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback)\n            {\n                // If connected to a custom ticker, remove the update frame function from it\n                if (this._isConnectedToTicker)\n                {\n                    Ticker.shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n\n                // Check if we haven't already requested a video frame callback, and if not, request one\n                if (this._videoFrameRequestCallbackHandle === null)\n                {\n                    this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                        this._videoFrameRequestCallback\n                    );\n                }\n            }\n            else\n            {\n                // If a video frame request callback exists, cancel it, as we are switching to manual ticker-based updates\n                if (this._videoFrameRequestCallbackHandle !== null)\n                {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n\n                // If not connected to the custom ticker, add the update frame function to it\n                if (!this._isConnectedToTicker)\n                {\n                    Ticker.shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n            }\n        }\n        else\n        {\n            // If automatic updating is disabled or the source isn't playing, perform cleanup\n\n            // Cancel any existing video frame callback request\n            if (this._videoFrameRequestCallbackHandle !== null)\n            {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n\n            // Remove the update frame function from the custom ticker\n            if (this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                // Reset the time until the next update\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    public static MIME_TYPES: Dict<string>\n        = {\n            ogv: 'video/ogg',\n            mov: 'video/quicktime',\n            m4v: 'video/mp4',\n        };\n\n    public static test(resource: any): resource is VideoResource\n    {\n        return (globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement)\n            || (globalThis.VideoFrame && resource instanceof VideoFrame);\n    }\n}\n","import { UPDATE_PRIORITY } from './const.mjs';\nimport { TickerListener } from './TickerListener.mjs';\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frames per millisecond.\n * @static\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\nexport { Ticker };\n//# sourceMappingURL=Ticker.mjs.map\n","import { UPDATE_PRIORITY } from './const';\nimport { TickerListener } from './TickerListener';\n\n/**\n * A callback which can be added to a ticker.\n * ```js\n * ticker.add(() => {\n *    // do something every frame\n * });\n * ```\n * @memberof ticker\n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n\n/**\n * {@link ticker.Ticker|Tickers} provide periodic callbacks based on the system clock.\n * Your game update logic will generally be run in response to a tick once per frame.\n * You can have multiple tickers in use at one time.\n * ```js\n * import { Ticker } from 'pixi.js';\n *\n * const callback = (ticker: Ticker) => {\n *    // do something on the next animation frame\n * };\n *\n * // create a ticker\n * const ticker = new Ticker();\n *\n * // register the callback and start the ticker\n * ticker.add(callback);\n * ticker.start();\n * ```\n *\n * You can always use the {@link ticker.Ticker.shared|shared} ticker that Pixi renders with by default.\n * ```js\n * Ticker.shared.add(callback);\n * ```\n * @namespace ticker\n */\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n *\n * This class is composed around listeners meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary, e.g. When the ticker is started and the emitter has listeners.\n * @class\n * @memberof ticker\n */\nexport class Ticker\n{\n    /**\n     * Target frames per millisecond.\n     * @static\n     */\n    public static targetFPMS = 0.06;\n\n    /** The private shared ticker instance */\n    private static _shared: Ticker;\n    /** The private system ticker instance  */\n    private static _system: Ticker;\n\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    public autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    public deltaTime = 1;\n    /**\n     * Scaler time elapsed in milliseconds from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public deltaMS: number;\n    /**\n     * Time elapsed in milliseconds from last frame to this frame.\n     * Opposed to what the scalar {@link ticker.Ticker#deltaTime|deltaTime}\n     * is based, this value is neither capped nor scaled.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public elapsedMS: number;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     */\n    public lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    public speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    public started = false;\n\n    /** The first listener. All new listeners added are chained on this. */\n    private _head: TickerListener;\n    /** Internal current frame request ID */\n    private _requestId: number = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    private _maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    private _minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    private _protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    private _lastFrame = -1;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     * @param time - Time since last tick.\n     */\n    private readonly _tick: (time: number) => any;\n\n    constructor()\n    {\n        this._head = new TickerListener(null, null, Infinity);\n        this.deltaMS = 1 / Ticker.targetFPMS;\n        this.elapsedMS = 1 / Ticker.targetFPMS;\n\n        this._tick = (time: number): void =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     * @private\n     */\n    private _requestIfNeeded(): void\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /**\n     * Conditionally cancels a pending animation frame.\n     * @private\n     */\n    private _cancelIfNeeded(): void\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     * @private\n     */\n    private _startIfPossible(): void\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events. Calls continuously unless\n     * it is removed or the ticker is stopped.\n     * @param fn - The listener function to be added for updates\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public add<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only execute once.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public addOnce<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     * @private\n     * @param listener - Current listener being added.\n     * @returns This instance of a ticker\n     */\n    private _addListener(listener: TickerListener): this\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     * @param fn - The listener function to be removed\n     * @param context - The listener context to be removed\n     * @returns This instance of a ticker\n     */\n    public remove<T = any>(fn: TickerCallback<T>, context?: T): this\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of listeners on this ticker, calculated by walking through linked list\n     * @readonly\n     * @member {number}\n     */\n    get count(): number\n    {\n        if (!this._head)\n        {\n            return 0;\n        }\n\n        let count = 0;\n        let current = this._head;\n\n        while ((current = current.next))\n        {\n            count++;\n        }\n\n        return count;\n    }\n\n    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n    public start(): void\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n    public stop(): void\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n    public destroy(): void\n    {\n        if (!this._protected)\n        {\n            this.stop();\n\n            let listener = this._head.next;\n\n            while (listener)\n            {\n                listener = listener.destroy(true);\n            }\n\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n\n    /**\n     * Triggers an update. An update entails setting the\n     * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n     * the current {@link ticker.Ticker#deltaTime|deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n     * with the value of currentTime that was provided.\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     * @param {number} [currentTime=performance.now()] - the current time of execution\n     */\n    public update(currentTime: number = performance.now()): void\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            elapsedMS *= this.speed;\n\n            // If not enough time has passed, exit the function.\n            // Get ready for next frame by setting _lastFrame, but based on _minElapsedMS\n            // adjustment to ensure a relatively stable interval.\n            if (this._minElapsedMS)\n            {\n                const delta = currentTime - this._lastFrame | 0;\n\n                if (delta < this._minElapsedMS)\n                {\n                    return;\n                }\n\n                this._lastFrame = currentTime - (delta % this._minElapsedMS);\n            }\n\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * Ticker.targetFPMS;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link ticker.Ticker#speed|speed}, which is specific\n     * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @member {number}\n     * @readonly\n     */\n    get FPS(): number\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n     * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `Ticker.targetFPMS * 1000`.\n     * @member {number}\n     * @default 10\n     */\n    get minFPS(): number\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps: number)\n    {\n        // Minimum must be below the maxFPS\n        const minFPS = Math.min(this.maxFPS, fps);\n\n        // Must be at least 0, but below 1 / Ticker.targetFPMS\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1000, Ticker.targetFPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n\n    /**\n     * Manages the minimum amount of milliseconds required to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n     * Otherwise it will be at least `minFPS`\n     * @member {number}\n     * @default 0\n     */\n    get maxFPS(): number\n    {\n        if (this._minElapsedMS)\n        {\n            return Math.round(1000 / this._minElapsedMS);\n        }\n\n        return 0;\n    }\n\n    set maxFPS(fps: number)\n    {\n        if (fps === 0)\n        {\n            this._minElapsedMS = 0;\n        }\n        else\n        {\n            // Max must be at least the minFPS\n            const maxFPS = Math.max(this.minFPS, fps);\n\n            this._minElapsedMS = 1 / (maxFPS / 1000);\n        }\n    }\n\n    /**\n     * The shared ticker instance used by {@link AnimatedSprite} and by\n     * {@link VideoResource} to update animation frames / video textures.\n     *\n     * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n     * @example\n     * import { Ticker } from 'pixi.js';\n     *\n     * const ticker = Ticker.shared;\n     * // Set this to prevent starting this ticker when listeners are added.\n     * // By default this is true only for the Ticker.shared instance.\n     * ticker.autoStart = false;\n     *\n     * // FYI, call this to ensure the ticker is stopped. It should be stopped\n     * // if you have not attempted to render anything yet.\n     * ticker.stop();\n     *\n     * // Call this when you are ready for a running shared ticker.\n     * ticker.start();\n     * @example\n     * import { autoDetectRenderer, Container } from 'pixi.js';\n     *\n     * // You may use the shared ticker to render...\n     * const renderer = autoDetectRenderer();\n     * const stage = new Container();\n     * document.body.appendChild(renderer.view);\n     * ticker.add((time) => renderer.render(stage));\n     *\n     * // Or you can just update it manually.\n     * ticker.autoStart = false;\n     * ticker.stop();\n     * const animate = (time) => {\n     *     ticker.update(time);\n     *     renderer.render(stage);\n     *     requestAnimationFrame(animate);\n     * };\n     * animate(performance.now());\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get shared(): Ticker\n    {\n        if (!Ticker._shared)\n        {\n            const shared = Ticker._shared = new Ticker();\n\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n\n        return Ticker._shared;\n    }\n\n    /**\n     * The system ticker instance used by {@link BasePrepare} for core timing\n     * functionality that shouldn't usually need to be paused, unlike the `shared`\n     * ticker which drives visual animations and rendering which may want to be paused.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get system(): Ticker\n    {\n        if (!Ticker._system)\n        {\n            const system = Ticker._system = new Ticker();\n\n            system.autoStart = true;\n            system._protected = true;\n        }\n\n        return Ticker._system;\n    }\n}\n","\"use strict\";\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"INTERACTION\"] = 50] = \"INTERACTION\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"HIGH\"] = 25] = \"HIGH\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"NORMAL\"] = 0] = \"NORMAL\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"LOW\"] = -25] = \"LOW\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"UTILITY\"] = -50] = \"UTILITY\";\n  return UPDATE_PRIORITY2;\n})(UPDATE_PRIORITY || {});\n\nexport { UPDATE_PRIORITY };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link ticker.Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @static\n * @enum {number}\n * @memberof ticker\n */\nexport enum UPDATE_PRIORITY\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * Highest priority used for interaction events in {@link EventSystem}\n     * @default 50\n     */\n    INTERACTION = 50,\n    /**\n     * High priority updating, used by {@link AnimatedSprite}\n     * @default 25\n     */\n    HIGH = 25,\n    /**\n     * Default priority for ticker events, see {@link Ticker#add}.\n     * @default 0\n     */\n    NORMAL = 0,\n    /**\n     * Low priority used for {@link Application} rendering.\n     * @default -25\n     */\n    LOW = -25,\n    /**\n     * Lowest priority used for {@link BasePrepare} utility.\n     * @default -50\n     */\n    UTILITY = -50,\n}\n","\"use strict\";\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = false) {\n    /** The next item in chain. */\n    this.next = null;\n    /** The previous item in chain. */\n    this.previous = null;\n    /** `true` if this listener has been destroyed already. */\n    this._destroyed = false;\n    this._fn = fn;\n    this._context = context;\n    this.priority = priority;\n    this._once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this._fn === fn && this._context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */\n  emit(ticker) {\n    if (this._fn) {\n      if (this._context) {\n        this._fn.call(this._context, ticker);\n      } else {\n        this._fn(ticker);\n      }\n    }\n    const redirect = this.next;\n    if (this._once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = false) {\n    this._destroyed = true;\n    this._fn = null;\n    this._context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\nexport { TickerListener };\n//# sourceMappingURL=TickerListener.mjs.map\n","import type { Ticker, TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private _fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private _context: T;\n    /** If this should only execute once. */\n    private readonly _once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    public match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this._fn === fn && this._context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param ticker - The ticker emitting.\n     * @returns Next ticker\n     */\n    public emit(ticker: Ticker): TickerListener\n    {\n        if (this._fn)\n        {\n            if (this._context)\n            {\n                this._fn.call(this._context, ticker);\n            }\n            else\n            {\n                (this as TickerListener<any>)._fn(ticker);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this._once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param previous - Input node, previous listener\n     */\n    public connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    public destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n","\"use strict\";\nlet promise;\nasync function detectVideoAlphaMode() {\n  promise ?? (promise = (async () => {\n    const canvas = document.createElement(\"canvas\");\n    const gl = canvas.getContext(\"webgl\");\n    if (!gl) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement(\"video\");\n      video2.onloadeddata = () => resolve(video2);\n      video2.onerror = () => resolve(null);\n      video2.autoplay = false;\n      video2.crossOrigin = \"anonymous\";\n      video2.preload = \"auto\";\n      video2.src = \"data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=\";\n      video2.load();\n    });\n    if (!video) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n    gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    return pixel[0] <= pixel[3] ? \"premultiplied-alpha\" : \"premultiply-alpha-on-upload\";\n  })());\n  return promise;\n}\n\nexport { detectVideoAlphaMode };\n//# sourceMappingURL=detectVideoAlphaMode.mjs.map\n","import type { ALPHA_MODES } from '../../rendering/renderers/shared/texture/const';\n\nlet promise: Promise<ALPHA_MODES> | undefined;\n\n/**\n * Helper for detecting the correct alpha mode for video textures.\n * For some reason, some browsers/devices/WebGL implementations premultiply the alpha\n * of a video before and then a second time if `UNPACK_PREMULTIPLY_ALPHA_WEBGL`\n * is true. So the video is premultiplied twice if the alpha mode is `UNPACK`.\n * In this case we need the alpha mode to be `PMA`. This function detects\n * the upload behavior by uploading a white 2x2 webm with 50% alpha\n * without `UNPACK_PREMULTIPLY_ALPHA_WEBGL` and then checking whether\n * the uploaded pixels are premultiplied.\n * @memberof utils\n * @function detectVideoAlphaMode\n * @returns {Promise<ALPHA_MODES>} The correct alpha mode for video textures.\n */\nexport async function detectVideoAlphaMode(): Promise<ALPHA_MODES>\n{\n    promise ??= (async () =>\n    {\n        const canvas = document.createElement('canvas');\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const video = await new Promise<HTMLVideoElement | null>((resolve) =>\n        {\n            const video = document.createElement('video');\n\n            video.onloadeddata = () => resolve(video);\n            video.onerror = () => resolve(null);\n            video.autoplay = false;\n            video.crossOrigin = 'anonymous';\n            video.preload = 'auto';\n            // eslint-disable-next-line max-len\n            video.src = 'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=';\n            video.load();\n        });\n\n        if (!video)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const texture = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        const framebuffer = gl.createFramebuffer();\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.COLOR_ATTACHMENT0,\n            gl.TEXTURE_2D,\n            texture,\n            0\n        );\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n\n        const pixel = new Uint8Array(4);\n\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n        return pixel[0] <= pixel[3] ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload';\n    })();\n\n    return promise;\n}\n","import { Cache } from '../../../../../assets/cache/Cache.mjs';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from '../sources/TextureSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst sources = [];\nextensions.handleByList(ExtensionType.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  if (!skipCache && Cache.has(resource)) {\n    return Cache.get(resource);\n  }\n  const texture = new Texture({ source: autoDetectSource(opts) });\n  texture.on(\"destroy\", () => {\n    if (Cache.has(resource)) {\n      Cache.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    Cache.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === \"string\") {\n    return Cache.get(id);\n  } else if (id instanceof TextureSource) {\n    return new Texture({ source: id });\n  }\n  return resourceToTexture(id, skipCache);\n}\nTexture.from = textureFrom;\n\nexport { autoDetectSource, resourceToTexture, textureFrom };\n//# sourceMappingURL=textureFrom.mjs.map\n","import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions;\n\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: autoDetectSource(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\n\n\"use strict\";\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n    if (!cacheableAssets) {\n      keys.forEach((key2) => {\n        cacheableMap.set(key2, value);\n      });\n    }\n    const cacheKeys = [...cacheableMap.keys()];\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      const val = cacheableAssets ? cacheableAssets[key2] : value;\n      if (this._cache.has(key2) && this._cache.get(key2) !== val) {\n        warn(\"[Cache] already has key:\", key2);\n      }\n      this._cache.set(key2, cacheableMap.get(key2));\n    });\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\nexport { Cache };\n//# sourceMappingURL=Cache.mjs.map\n","import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSpritesheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @example\n * import { Cache } from 'pixi.js';\n *\n * Cache.set('bunny', bunnyTexture);\n * @class Cache\n * @memberof assets\n */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: any | any[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n","\"use strict\";\nconst convertToList = (input, transform, forceTransform = false) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === \"string\" || forceTransform) {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\nexport { convertToList };\n//# sourceMappingURL=convertToList.mjs.map\n","export const convertToList = <T>(\n    input: string | T | (string | T)[],\n    transform?: (input: string) => T,\n    forceTransform = false\n): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string' || forceTransform)\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { spritesheetAsset } from './spritesheetAsset.mjs';\n\n\"use strict\";\nextensions.add(spritesheetAsset);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { spritesheetAsset } from './spritesheetAsset';\n\nextensions.add(spritesheetAsset);\n","import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser.mjs';\nimport { Resolver } from '../assets/resolver/Resolver.mjs';\nimport { copySearchParams } from '../assets/utils/copySearchParams.mjs';\nimport { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { path } from '../utils/path.mjs';\nimport { Spritesheet } from './Spritesheet.mjs';\n\n\"use strict\";\nconst validImages = [\n  \"jpg\",\n  \"png\",\n  \"jpeg\",\n  \"avif\",\n  \"webp\",\n  \"basis\",\n  \"etc2\",\n  \"bc7\",\n  \"bc6h\",\n  \"bc5\",\n  \"bc4\",\n  \"bc3\",\n  \"bc2\",\n  \"bc1\",\n  \"eac\",\n  \"astc\"\n];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = path.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: ExtensionType.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  /** Resolve the resolution of the asset. */\n  resolver: {\n    test: (value) => {\n      const tempURL = value.split(\"?\")[0];\n      const split = tempURL.split(\".\");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === \"json\" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(\".\");\n      return {\n        resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */\n  loader: {\n    name: \"spritesheetLoader\",\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.Normal\n    },\n    async testParse(asset, options) {\n      return path.extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      const {\n        texture: imageTexture,\n        // if user need to use preloaded texture\n        imageFilename\n        // if user need to use custom filename (not from jsonFile.meta.image)\n      } = options?.data ?? {};\n      let basePath = path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) {\n        basePath += \"/\";\n      }\n      let texture;\n      if (imageTexture instanceof Texture) {\n        texture = imageTexture;\n      } else {\n        const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n        const assets = await loader.load([imagePath]);\n        texture = assets[imagePath];\n      }\n      const spritesheet = new Spritesheet(\n        texture.source,\n        asset\n      );\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== \"string\") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = copySearchParams(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    async unload(spritesheet, _resolvedAsset, loader) {\n      await loader.unload(spritesheet.textureSource._sourceOrigin);\n      spritesheet.destroy(false);\n    }\n  }\n};\n\nexport { spritesheetAsset };\n//# sourceMappingURL=spritesheetAsset.mjs.map\n","import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser';\nimport { Resolver } from '../assets/resolver/Resolver';\nimport { copySearchParams } from '../assets/utils/copySearchParams';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { path } from '../utils/path';\nimport { Spritesheet } from './Spritesheet';\n\nimport type { AssetExtension } from '../assets/AssetExtension';\nimport type { Loader } from '../assets/loader/Loader';\nimport type { ResolvedAsset, UnresolvedAsset } from '../assets/types';\nimport type { SpritesheetData } from './Spritesheet';\n\nexport interface SpriteSheetJson extends SpritesheetData\n{\n    meta: {\n        image: string;\n        scale: string;\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n    };\n}\n\nconst validImages = ['jpg', 'png', 'jpeg', 'avif', 'webp',\n    'basis', 'etc2', 'bc7', 'bc6h', 'bc5', 'bc4', 'bc3', 'bc2', 'bc1', 'eac', 'astc'];\n\nfunction getCacheableAssets(keys: string[], asset: Spritesheet, ignoreMultiPack: boolean)\n{\n    const out: Record<string, any> = {};\n\n    keys.forEach((key: string) =>\n    {\n        out[key] = asset;\n    });\n\n    Object.keys(asset.textures).forEach((key) =>\n    {\n        out[key] = asset.textures[key];\n    });\n\n    if (!ignoreMultiPack)\n    {\n        const basePath = path.dirname(keys[0]);\n\n        asset.linkedSheets.forEach((item: Spritesheet, i) =>\n        {\n            const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n\n            Object.assign(out, out2);\n        });\n    }\n\n    return out;\n}\n\n/**\n * Asset extension for loading spritesheets\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *     alias: 'spritesheet',\n *     src: 'path/to/spritesheet.json',\n *     data: {\n *         ignoreMultiPack: true,\n *     }\n * })\n * @type {AssetExtension}\n * @memberof assets\n */\nexport const spritesheetAsset = {\n    extension: ExtensionType.Asset,\n    /** Handle the caching of the related Spritesheet Textures */\n    cache: {\n        test: (asset: Spritesheet) => asset instanceof Spritesheet,\n        getCacheableAssets: (keys: string[], asset: Spritesheet) => getCacheableAssets(keys, asset, false),\n    },\n    /** Resolve the resolution of the asset. */\n    resolver: {\n        test: (value: string): boolean =>\n        {\n            const tempURL = value.split('?')[0];\n            const split = tempURL.split('.');\n            const extension = split.pop();\n            const format = split.pop();\n\n            return extension === 'json' && validImages.includes(format);\n        },\n        parse: (value: string): UnresolvedAsset =>\n        {\n            const split = value.split('.');\n\n            return {\n                resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n                format: split[split.length - 2],\n                src: value,\n            };\n        },\n    },\n    /**\n     * Loader plugin that parses sprite sheets!\n     * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n     * If it is, we load the spritesheets image and parse the data into Spritesheet\n     * All textures in the sprite sheet are then added to the cache\n     */\n    loader: {\n        name: 'spritesheetLoader',\n\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n        },\n\n        async testParse(asset: SpriteSheetJson, options: ResolvedAsset): Promise<boolean>\n        {\n            return (path.extname(options.src).toLowerCase() === '.json' && !!asset.frames);\n        },\n\n        async parse(\n            asset: SpriteSheetJson,\n            options: ResolvedAsset<{texture: Texture, imageFilename: string, ignoreMultiPack: boolean}>,\n            loader: Loader\n        ): Promise<Spritesheet>\n        {\n            const {\n                texture: imageTexture, // if user need to use preloaded texture\n                imageFilename // if user need to use custom filename (not from jsonFile.meta.image)\n            } = options?.data ?? {};\n\n            let basePath = path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== (basePath.length - 1))\n            {\n                basePath += '/';\n            }\n\n            let texture: Texture;\n\n            if (imageTexture instanceof Texture)\n            {\n                texture = imageTexture;\n            }\n            else\n            {\n                const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n\n                const assets = await loader.load<Texture>([imagePath]);\n\n                texture = assets[imagePath];\n            }\n\n            const spritesheet = new Spritesheet(\n                texture.source,\n                asset,\n            );\n\n            await spritesheet.parse();\n\n            // Check and add the multi atlas\n            // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n            // eslint-disable-next-line camelcase\n            const multiPacks = asset?.meta?.related_multi_packs;\n\n            if (Array.isArray(multiPacks))\n            {\n                const promises: Promise<Spritesheet<SpriteSheetJson>>[] = [];\n\n                for (const item of multiPacks)\n                {\n                    if (typeof item !== 'string')\n                    {\n                        continue;\n                    }\n\n                    let itemUrl = basePath + item;\n\n                    // Check if the file wasn't already added as multipack\n                    if (options.data?.ignoreMultiPack)\n                    {\n                        continue;\n                    }\n\n                    itemUrl = copySearchParams(itemUrl, options.src);\n\n                    promises.push(loader.load<Spritesheet<SpriteSheetJson>>({\n                        src: itemUrl,\n                        data: {\n                            ignoreMultiPack: true,\n                        }\n                    }));\n                }\n\n                const res = await Promise.all(promises);\n\n                spritesheet.linkedSheets = res;\n                res.forEach((item) =>\n                {\n                    item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => (sp !== item)));\n                });\n            }\n\n            return spritesheet;\n        },\n\n        async unload(spritesheet: Spritesheet, _resolvedAsset, loader)\n        {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n\n            spritesheet.destroy(false);\n        },\n    },\n} as AssetExtension<Spritesheet | SpriteSheetJson>;\n","\"use strict\";\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2[\"Low\"] = 0] = \"Low\";\n  LoaderParserPriority2[LoaderParserPriority2[\"Normal\"] = 1] = \"Normal\";\n  LoaderParserPriority2[LoaderParserPriority2[\"High\"] = 2] = \"High\";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\nexport { LoaderParserPriority };\n//# sourceMappingURL=LoaderParser.mjs.map\n","import type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { ResolvedAsset } from '../../types';\nimport type { Loader } from '../Loader';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @enum {number}\n */\nexport enum LoaderParserPriority\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @memberof assets\n */\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n{\n    /** Should be ExtensionType.LoaderParser */\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /** The name of the parser (this can be used when specifying loadParser in a ResolvedAsset) */\n    name: string;\n\n    /**\n     * Each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void>;\n}\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { createStringVariations } from '../utils/createStringVariations.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = convertToList(\n      alias || src,\n      (value) => {\n        if (typeof value === \"string\")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      warn(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        warn(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = convertToList(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = convertToList(src).map((src2) => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\nexport { Resolver, getUrlExtension };\n//# sourceMappingURL=Resolver.mjs.map\n","import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @memberof assets\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @static\n     * @name RETINA_PREFIX\n     * @type {RegExp}\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let { data, format, loadParser } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        formattedAsset.src = src;\n                        // first see if it contains any {} tags...\n                        for (let i = 0; i < this._parsers.length; i++)\n                        {\n                            const parser = this._parsers[i];\n\n                            if (parser.test(src))\n                            {\n                                formattedAsset = parser.parse(src);\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        loadParser = src.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        format?: string,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, format } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n\n        return formattedAsset;\n    }\n}\n\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n","import { DOMAdapter } from '../environment/adapter.mjs';\n\n\"use strict\";\nfunction assertPath(path2) {\n  if (typeof path2 !== \"string\") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split(\"?\")[0];\n  return re.split(\"#\")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), \"g\"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = \"\";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += \"/..\";\n          } else {\n            res = \"..\";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, \"\\\\\", \"/\");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith(\"blob:\");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile) {\n      return matchFile[0];\n    }\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    if (matchProtocol) {\n      return matchProtocol[0];\n    }\n    return \"\";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    assertPath(url);\n    if (this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    url = this.toPosix(url);\n    if (url.startsWith(\"/\")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = \"\";\n    const isAbsolute = path2.startsWith(\"/\");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith(\"/\");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += \"/\";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith(\"/\");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0) {\n      return \".\";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? \"\";\n          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return \".\";\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return \"//\";\n    return proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = \"\";\n    if (path2.startsWith(\"/\"))\n      root = \"/\";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf(\"/\", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith(\"/\"))\n        root += \"/\";\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return \"\";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return \"\";\n    return path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return \"\";\n    }\n    return path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = \"\";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: \"/\",\n  delimiter: \":\",\n  joinExtensions: [\".html\"]\n};\n\nexport { path };\n//# sourceMappingURL=path.mjs.map\n","import { DOMAdapter } from '../environment/adapter';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @memberof utils\n */\nexport interface Path\n{\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix: (path: string) => string;\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl: (path: string) => boolean;\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol: (path: string) => boolean;\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol: (path: string) => string;\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize: (path: string) => string;\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute: (path: string) => boolean;\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join: (...paths: string[]) => string;\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname: (path: string) => string;\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname: (path: string) => string;\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename: (path: string, ext?: string) => string;\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname: (path: string) => string;\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @see {@link utils.Path}\n * @memberof utils\n */\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators, no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators, no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n","\"use strict\";\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(\",\");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\nexport { createStringVariations };\n//# sourceMappingURL=createStringVariations.mjs.map\n","function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n","\"use strict\";\nconst isSingleItem = (item) => !Array.isArray(item);\n\nexport { isSingleItem };\n//# sourceMappingURL=isSingleItem.mjs.map\n","/**\n * Checks if the given value is an array.\n * @param item - The item to test\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n","\"use strict\";\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split(\"?\")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\nexport { copySearchParams };\n//# sourceMappingURL=copySearchParams.mjs.map\n","/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n","import { Rectangle } from '../maths/shapes/Rectangle.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\n\n\"use strict\";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\nexport { Spritesheet };\n//# sourceMappingURL=Spritesheet.mjs.map\n","import { Rectangle } from '../maths/shapes/Rectangle';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { BindableTexture, TextureBorders } from '../rendering/renderers/shared/texture/Texture';\nimport type { Dict } from '../utils/types';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @memberof assets\n */\nexport interface SpritesheetFrameData\n{\n    /** The frame rectangle of the texture. */\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    /** Whether the texture is trimmed. */\n    trimmed?: boolean;\n    /** Whether the texture is rotated. */\n    rotated?: boolean;\n    /** The source size of the texture. */\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    /** The sprite source size. */\n    spriteSourceSize?: {\n        h?: number;\n        w?: number;\n        x: number;\n        y: number;\n    };\n    /** The anchor point of the texture. */\n    anchor?: PointData;\n    /** The 9-slice borders of the texture. */\n    borders?: TextureBorders\n}\n\n/**\n * Atlas format.\n * @memberof assets\n */\nexport interface SpritesheetData\n{\n    /** The frames of the atlas. */\n    frames: Dict<SpritesheetFrameData>;\n    /** The animations of the atlas. */\n    animations?: Dict<string[]>;\n    /** The meta data of the atlas. */\n    meta: {\n        app?: string;\n        format?: string;\n        frameTags?: {\n            from: number;\n            name: string;\n            to: number;\n            direction: string;\n        }[];\n        image?: string;\n        layers?: {\n            blendMode: string;\n            name: string;\n            opacity: number;\n        }[];\n        scale: number | string;\n        size?: {\n            h: number;\n            w: number;\n        };\n        slices?: {\n            color: string;\n            name: string;\n            keys: {\n                frame: number,\n                bounds: {\n                    x: number;\n                    y: number;\n                    w: number;\n                    h: number;\n                };\n            }[];\n        }[];\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n        version?: string;\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json'\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n *\n * or:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json'\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n * @memberof assets\n */\nexport class Spritesheet<S extends SpritesheetData = SpritesheetData>\n{\n    /** The maximum number of Textures to build per process. */\n    public static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet<S>[] = [];\n\n    /** Reference to ths source texture. */\n    public textureSource: TextureSource;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link Sprite|Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: Record<keyof S['frames'], Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link AnimatedSprite|AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: Record<keyof NonNullable<S['animations']>, Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: S;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: S['frames'];\n\n    /** Collection of frame names. */\n    private _frameKeys: (keyof S['frames'])[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     */\n    constructor(texture: BindableTexture, data: S)\n    {\n        this._texture = texture instanceof Texture ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {} as Record<keyof S['frames'], Texture>;\n        this.animations = {} as Record<keyof NonNullable<S['animations']>, Texture[]>;\n        this.data = data;\n\n        const metaResolution = parseFloat(data.meta.scale as string);\n\n        if (metaResolution)\n        {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        }\n        else\n        {\n            this.resolution = texture.source._resolution;\n        }\n\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     */\n    public parse(): Promise<Record<string, Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture({\n                    source: this.textureSource,\n\n                    frame,\n                    orig,\n                    trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n\n                    label: i.toString(),\n                });\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName as keyof S['animations']] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport '../../../../utils/utils.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { SystemRunner } from './SystemRunner.mjs';\nimport EventEmitter from 'eventemitter3';\n\n\"use strict\";\nconst defaultRunners = [\n  \"init\",\n  \"destroy\",\n  \"contextChange\",\n  \"resolutionChange\",\n  \"reset\",\n  \"renderEnd\",\n  \"renderStart\",\n  \"render\",\n  \"update\",\n  \"postrender\",\n  \"prerender\"\n];\nconst _AbstractRenderer = class _AbstractRenderer extends EventEmitter {\n  /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */\n  constructor(config) {\n    super();\n    this.runners = /* @__PURE__ */ Object.create(null);\n    this.renderPipes = /* @__PURE__ */ Object.create(null);\n    this._initOptions = {};\n    this._systemsHash = /* @__PURE__ */ Object.create(null);\n    this.type = config.type;\n    this.name = config.name;\n    const combinedRunners = [...defaultRunners, ...config.runners ?? []];\n    this._addRunners(...combinedRunners);\n    this._addSystems(config.systems);\n    this._addPipes(config.renderPipes, config.renderPipeAdaptors);\n    this._unsafeEvalCheck();\n  }\n  /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */\n  async init(options = {}) {\n    for (const systemName in this._systemsHash) {\n      const system = this._systemsHash[systemName];\n      const defaultSystemOptions = system.constructor.defaultOptions;\n      options = { ...defaultSystemOptions, ...options };\n    }\n    options = { ..._AbstractRenderer.defaultOptions, ...options };\n    this._roundPixels = options.roundPixels ? 1 : 0;\n    for (let i = 0; i < this.runners.init.items.length; i++) {\n      await this.runners.init.items[i].init(options);\n    }\n    this._initOptions = options;\n  }\n  render(args, deprecated) {\n    let options = args;\n    if (options instanceof Container) {\n      options = { container: options };\n      if (deprecated) {\n        deprecation(v8_0_0, \"passing a second argument is deprecated, please use render options instead\");\n        options.target = deprecated.renderTexture;\n      }\n    }\n    options.target || (options.target = this.view.renderTarget);\n    if (options.target === this.view.renderTarget) {\n      this._lastObjectRendered = options.container;\n      options.clearColor = this.background.colorRgba;\n    }\n    if (options.clearColor) {\n      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n      options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n    }\n    if (!options.transform) {\n      options.container.updateLocalTransform();\n      options.transform = options.container.localTransform;\n    }\n    this.runners.prerender.emit(options);\n    this.runners.renderStart.emit(options);\n    this.runners.render.emit(options);\n    this.runners.renderEnd.emit(options);\n    this.runners.postrender.emit(options);\n  }\n  /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.emit(\"resize\", this.view.screen.width, this.view.screen.height);\n  }\n  clear(options = {}) {\n    const renderer = this;\n    options.target || (options.target = renderer.renderTarget.renderTarget);\n    options.clearColor || (options.clearColor = this.background.colorRgba);\n    options.clear ?? (options.clear = CLEAR.ALL);\n    const { clear, clearColor, target } = options;\n    Color.shared.setValue(clearColor ?? this.background.colorRgba);\n    renderer.renderTarget.clear(target, clear, Color.shared.toArray());\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.view.resolution;\n  }\n  set resolution(value) {\n    this.view.resolution = value;\n    this.runners.resolutionChange.emit(value);\n  }\n  /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */\n  get width() {\n    return this.view.texture.frame.width;\n  }\n  /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */\n  get height() {\n    return this.view.texture.frame.height;\n  }\n  // NOTE: this was `view` in v7\n  /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */\n  get canvas() {\n    return this.view.canvas;\n  }\n  /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */\n  get lastObjectRendered() {\n    return this._lastObjectRendered;\n  }\n  /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */\n  get renderingToScreen() {\n    const renderer = this;\n    return renderer.renderTarget.renderingToScreen;\n  }\n  /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */\n  get screen() {\n    return this.view.screen;\n  }\n  /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */\n  _addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new SystemRunner(runnerId);\n    });\n  }\n  _addSystems(systems) {\n    let i;\n    for (i in systems) {\n      const val = systems[i];\n      this._addSystem(val.value, val.name);\n    }\n  }\n  /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn't collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */\n  _addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error(`Whoops! The name \"${name}\" is already in use`);\n    }\n    this[name] = system;\n    this._systemsHash[name] = system;\n    for (const i in this.runners) {\n      this.runners[i].add(system);\n    }\n    return this;\n  }\n  _addPipes(pipes, pipeAdaptors) {\n    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {\n      acc[adaptor.name] = adaptor.value;\n      return acc;\n    }, {});\n    pipes.forEach((pipe) => {\n      const PipeClass = pipe.value;\n      const name = pipe.name;\n      const Adaptor = adaptors[name];\n      this.renderPipes[name] = new PipeClass(\n        this,\n        Adaptor ? new Adaptor() : null\n      );\n    });\n  }\n  destroy(options = false) {\n    this.runners.destroy.items.reverse();\n    this.runners.destroy.emit(options);\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    });\n    this._systemsHash = null;\n    this.renderPipes = null;\n  }\n  /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */\n  generateTexture(options) {\n    return this.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  /**\n   * Overrideable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   * @ignore\n   */\n  _unsafeEvalCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n};\n/** The default options for the renderer. */\n_AbstractRenderer.defaultOptions = {\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */\n  resolution: 1,\n  /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */\n  failIfMajorPerformanceCaveat: false,\n  /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */\n  roundPixels: false\n};\nlet AbstractRenderer = _AbstractRenderer;\n\nexport { AbstractRenderer };\n//# sourceMappingURL=AbstractRenderer.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { Container } from '../../../../scene/container/Container';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { EventEmitter } from '../../../../utils/utils';\nimport { CLEAR } from '../../gl/const';\nimport { SystemRunner } from './SystemRunner';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { Renderer } from '../../types';\nimport type { BackgroundSystem } from '../background/BackgroundSystem';\nimport type { GenerateTextureOptions, GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport type { PipeConstructor } from '../instructions/RenderPipe';\nimport type { RenderSurface } from '../renderTarget/RenderTargetSystem';\nimport type { Texture } from '../texture/Texture';\nimport type { ViewSystem, ViewSystemDestroyOptions } from '../view/ViewSystem';\nimport type { System, SystemConstructor } from './System';\n\ninterface RendererConfig\n{\n    type: number;\n    name: string;\n    runners?: string[];\n    systems: {name: string, value: SystemConstructor}[];\n    renderPipes: {name: string, value: PipeConstructor}[];\n    renderPipeAdaptors: {name: string, value: any}[];\n}\n\n/**\n * The options for rendering a view.\n * @memberof rendering\n */\nexport interface RenderOptions extends ClearOptions\n{\n    /** The container to render. */\n    container: Container;\n    /** the transform to apply to the container. */\n    transform?: Matrix;\n}\n\n/**\n * The options for clearing the render target.\n * @memberof rendering\n */\nexport interface ClearOptions\n{\n    /** The render target to render. */\n    target?: RenderSurface;\n    /** The color to clear with. */\n    clearColor?: ColorSource;\n    /** The clear mode to use. */\n    clear?: CLEAR_OR_BOOL\n}\n\nexport type RendererDestroyOptions = TypeOrBool<ViewSystemDestroyOptions>;\n\nconst defaultRunners = [\n    'init',\n    'destroy',\n    'contextChange',\n    'resolutionChange',\n    'reset',\n    'renderEnd',\n    'renderStart',\n    'render',\n    'update',\n    'postrender',\n    'prerender'\n] as const;\n\ntype DefaultRunners = typeof defaultRunners[number];\ntype Runners = {[key in DefaultRunners]: SystemRunner} & {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    [K: ({} & string) | ({} & symbol)]: SystemRunner;\n};\n\n/* eslint-disable max-len */\n/**\n * The base class for a PixiJS Renderer. It contains the shared logic for all renderers.\n *\n * You should not use this class directly, but instead use {@linkrendering.WebGLRenderer}\n * or {@link rendering.WebGPURenderer}.\n * Alternatively, you can also use {@link rendering.autoDetectRenderer} if you want us to\n * determine the best renderer for you.\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a renderer:\n *\n *\n * | Generic Systems                      | Systems that manage functionality that all renderer types share               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.ViewSystem}              | This manages the main view of the renderer usually a Canvas              |\n * | {@link rendering.BackgroundSystem}        | This manages the main views background color and alpha                   |\n * | {@link events.EventSystem}           | This manages UI events.                                                       |\n * | {@link accessibility.AccessibilitySystem} | This manages accessibility features. Requires `import 'pixi.js/accessibility'`|\n *\n * | Core Systems                   | Provide an optimised, easy to use API to work with WebGL/WebGPU               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.RenderGroupSystem} | This manages the what what we are rendering to (eg - canvas or texture)   |\n * | {@link rendering.GlobalUniformSystem} | This manages shaders, programs that run on the GPU to calculate 'em pixels.   |\n * | {@link rendering.TextureGCSystem}     | This will automatically remove textures from the GPU if they are not used.    |\n *\n * | PixiJS High-Level Systems            | Set of specific systems designed to work with PixiJS objects                  |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.HelloSystem}               | Says hello, buy printing out the pixi version into the console log (along with the renderer type)       |\n * | {@link rendering.GenerateTextureSystem} | This adds the ability to generate textures from any Container       |\n * | {@link rendering.FilterSystem}          | This manages the filtering pipeline for post-processing effects.             |\n * | {@link rendering.PrepareSystem}               | This manages uploading assets to the GPU. Requires `import 'pixi.js/prepare'`|\n * | {@link rendering.ExtractSystem}               | This extracts image data from display objects.                               |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @abstract\n * @memberof rendering\n * @property {rendering.HelloSystem} hello - HelloSystem instance.\n * @property {rendering.RenderGroupSystem} renderGroup - RenderGroupSystem instance.\n * @property {rendering.TextureGCSystem} textureGC - TextureGCSystem instance.\n * @property {rendering.FilterSystem} filter - FilterSystem instance.\n * @property {rendering.GlobalUniformSystem} globalUniforms - GlobalUniformSystem instance.\n * @property {rendering.TextureSystem} texture - TextureSystem instance.\n * @property {rendering.EventSystem} events - EventSystem instance.\n * @property {rendering.ExtractSystem} extract - ExtractSystem instance. Requires `import 'pixi.js/extract'`.\n * @property {rendering.PrepareSystem} prepare - PrepareSystem instance. Requires `import 'pixi.js/prepare'`.\n * @property {rendering.AccessibilitySystem} accessibility - AccessibilitySystem instance. Requires `import 'pixi.js/accessibility'`.\n */\n/* eslint-enable max-len */\nexport class AbstractRenderer<\n    PIPES, OPTIONS extends PixiMixins.RendererOptions, CANVAS extends ICanvas = HTMLCanvasElement\n> extends EventEmitter<{resize: [number, number]}>\n{\n    /** The default options for the renderer. */\n    public static defaultOptions = {\n        /**\n         * Default resolution / device pixel ratio of the renderer.\n         * @default 1\n         */\n        resolution: 1,\n        /**\n         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n         * performance issues when using WebGL.\n         *\n         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n         * driver version blacklisted by the\n         * browser.\n         *\n         * If your application requires high performance rendering, you may wish to set this to false.\n         * We recommend one of two options if you decide to set this flag to false:\n         *\n         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n         *    not supported.\n         *\n         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n         *    device & browser combination does not support high performance WebGL.\n         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n         * @default false\n         */\n        failIfMajorPerformanceCaveat: false,\n        /**\n         * Should round pixels be forced when rendering?\n         * @default false\n         */\n        roundPixels: false\n    };\n\n    public readonly type: number;\n    /** The name of the renderer. */\n    public readonly name: string;\n\n    public _roundPixels: 0 | 1;\n\n    public readonly runners: Runners = Object.create(null) as Runners;\n    public readonly renderPipes = Object.create(null) as PIPES;\n    /** The view system manages the main canvas that is attached to the DOM */\n    public view!: ViewSystem;\n    /** The background system manages the background color and alpha of the main view. */\n    public background: BackgroundSystem;\n    /** System that manages the generation of textures from the renderer */\n    public textureGenerator: GenerateTextureSystem;\n\n    protected _initOptions: OPTIONS = {} as OPTIONS;\n\n    private _systemsHash: Record<string, System> = Object.create(null);\n    private _lastObjectRendered: Container;\n\n    /**\n     * Set up a system with a collection of SystemClasses and runners.\n     * Systems are attached dynamically to this class when added.\n     * @param config - the config for the system manager\n     */\n    constructor(config: RendererConfig)\n    {\n        super();\n        this.type = config.type;\n        this.name = config.name;\n\n        const combinedRunners = [...defaultRunners, ...(config.runners ?? [])];\n\n        this._addRunners(...combinedRunners);\n        this._addSystems(config.systems);\n        this._addPipes(config.renderPipes, config.renderPipeAdaptors);\n\n        // Validation check that this environment support `new Function`\n        this._unsafeEvalCheck();\n    }\n\n    /**\n     * Initialize the renderer.\n     * @param options - The options to use to create the renderer.\n     */\n    public async init(options: Partial<OPTIONS> = {})\n    {\n        // loop through all systems...\n        for (const systemName in this._systemsHash)\n        {\n            const system = this._systemsHash[systemName];\n\n            const defaultSystemOptions = (system.constructor as any).defaultOptions;\n\n            options = { ...defaultSystemOptions, ...options };\n        }\n\n        options = { ...AbstractRenderer.defaultOptions, ...options };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n\n        // await emits..\n        for (let i = 0; i < this.runners.init.items.length; i++)\n        {\n            await this.runners.init.items[i].init(options);\n        }\n\n        // store options\n        this._initOptions = options as OPTIONS;\n    }\n\n    /**\n     * Renders the object to its view.\n     * @param options - The options to render with.\n     * @param options.container - The container to render.\n     * @param [options.target] - The target to render to.\n     */\n    public render(options: RenderOptions | Container): void;\n    /** @deprecated since 8.0.0 */\n    public render(container: Container, options: {renderTexture: any}): void;\n    public render(args: RenderOptions | Container, deprecated?: {renderTexture: any}): void\n    {\n        let options = args;\n\n        if (options instanceof Container)\n        {\n            options = { container: options };\n\n            if (deprecated)\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                deprecation(v8_0_0, 'passing a second argument is deprecated, please use render options instead');\n                // #endif\n\n                options.target = deprecated.renderTexture;\n            }\n        }\n\n        options.target ||= this.view.renderTarget;\n\n        // TODO: we should eventually fix events so that it can handle multiple canvas elements\n        if (options.target === this.view.renderTarget)\n        {\n            // TODO get rid of this\n            this._lastObjectRendered = options.container;\n            options.clearColor = this.background.colorRgba;\n        }\n\n        if (options.clearColor)\n        {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n\n            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n        }\n\n        if (!options.transform)\n        {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n\n    /**\n     * Resizes the WebGL view to the specified width and height.\n     * @param desiredScreenWidth - The desired width of the screen.\n     * @param desiredScreenHeight - The desired height of the screen.\n     * @param resolution - The resolution / device pixel ratio of the renderer.\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution?: number): void\n    {\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit('resize', this.view.screen.width, this.view.screen.height);\n    }\n\n    public clear(options: ClearOptions = {}): void\n    {\n        // override!\n        const renderer = this as unknown as Renderer;\n\n        options.target ||= renderer.renderTarget.renderTarget;\n        options.clearColor ||= this.background.colorRgba;\n        options.clear ??= CLEAR.ALL;\n\n        const { clear, clearColor, target } = options;\n\n        Color.shared.setValue(clearColor ?? this.background.colorRgba);\n\n        renderer.renderTarget.clear(target, clear, Color.shared.toArray() as RgbaArray);\n    }\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.view.resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n\n    /**\n     * Same as view.width, actual number of pixels in the canvas by horizontal.\n     * @member {number}\n     * @readonly\n     * @default 800\n     */\n    get width(): number\n    {\n        return this.view.texture.frame.width;\n    }\n\n    /**\n     * Same as view.height, actual number of pixels in the canvas by vertical.\n     * @default 600\n     */\n    get height(): number\n    {\n        return this.view.texture.frame.height;\n    }\n\n    // NOTE: this was `view` in v7\n    /**\n     * The canvas element that everything is drawn to.\n     * @type {environment.ICanvas}\n     */\n    get canvas(): CANVAS\n    {\n        return this.view.canvas as CANVAS;\n    }\n\n    /**\n     * the last object rendered by the renderer. Useful for other plugins like interaction managers\n     * @readonly\n     */\n    get lastObjectRendered(): Container\n    {\n        return this._lastObjectRendered;\n    }\n\n    /**\n     * Flag if we are rendering to the screen vs renderTexture\n     * @readonly\n     * @default true\n     */\n    get renderingToScreen(): boolean\n    {\n        const renderer = this as unknown as Renderer;\n\n        return renderer.renderTarget.renderingToScreen;\n    }\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    get screen(): Rectangle\n    {\n        return this.view.screen;\n    }\n\n    /**\n     * Create a bunch of runners based of a collection of ids\n     * @param runnerIds - the runner ids to add\n     */\n    private _addRunners(...runnerIds: string[]): void\n    {\n        runnerIds.forEach((runnerId) =>\n        {\n            this.runners[runnerId] = new SystemRunner(runnerId);\n        });\n    }\n\n    private _addSystems(systems: RendererConfig['systems']): void\n    {\n        let i: keyof typeof systems;\n\n        for (i in systems)\n        {\n            const val = systems[i];\n\n            this._addSystem(val.value, val.name);\n        }\n    }\n\n    /**\n     * Add a new system to the renderer.\n     * @param ClassRef - Class reference\n     * @param name - Property name for system, if not specified\n     *        will use a static `name` property on the class itself. This\n     *        name will be assigned as s property on the Renderer so make\n     *        sure it doesn't collide with properties on Renderer.\n     * @returns Return instance of renderer\n     */\n    private _addSystem(ClassRef: SystemConstructor, name: string): this\n    {\n        const system = new ClassRef(this as unknown as Renderer);\n\n        if ((this as any)[name])\n        {\n            throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        }\n\n        (this as any)[name] = system;\n\n        this._systemsHash[name] = system;\n\n        for (const i in this.runners)\n        {\n            this.runners[i].add(system);\n        }\n\n        return this;\n    }\n\n    private _addPipes(pipes: RendererConfig['renderPipes'], pipeAdaptors: RendererConfig['renderPipeAdaptors']): void\n    {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor) =>\n        {\n            acc[adaptor.name] = adaptor.value;\n\n            return acc;\n        }, {} as Record<string, any>);\n\n        pipes.forEach((pipe) =>\n        {\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n\n            const Adaptor = adaptors[name];\n\n            // sorry typescript..\n            (this.renderPipes as any)[name] = new PipeClass(\n                this as unknown as Renderer,\n                Adaptor ? new Adaptor() : null\n            );\n        });\n    }\n\n    public destroy(options: RendererDestroyOptions = false): void\n    {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n\n        // destroy all runners\n        Object.values(this.runners).forEach((runner) =>\n        {\n            runner.destroy();\n        });\n\n        this._systemsHash = null;\n\n        // destroy all pipes\n        (this.renderPipes as null) = null;\n    }\n\n    /**\n     * Generate a texture from a container.\n     * @param options - options or container target to use when generating the texture\n     * @returns a texture\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        return this.textureGenerator.generateTexture(options);\n    }\n\n    /**\n     * Whether the renderer will round coordinates to whole pixels when rendering.\n     * Can be overridden on a per scene item basis.\n     */\n    get roundPixels(): boolean\n    {\n        return !!this._roundPixels;\n    }\n\n    /**\n     * Overrideable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     * @ignore\n     */\n    public _unsafeEvalCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n               + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n}\n","\"use strict\";\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === \"boolean\") {\n    return unsafeEval;\n  }\n  try {\n    const func = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n    unsafeEval = func({ a: \"b\" }, \"a\", \"b\") === true;\n  } catch (e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\n\nexport { unsafeEvalSupported };\n//# sourceMappingURL=unsafeEvalSupported.mjs.map\n","// Cache the result to prevent running this over and over\nlet unsafeEval: boolean;\n\n/**\n * Not all platforms allow to generate function code (e.g., `new Function`).\n * this provides the platform-level detection.\n * @private\n * @returns {boolean} `true` if `new Function` is supported.\n */\nexport function unsafeEvalSupported(): boolean\n{\n    if (typeof unsafeEval === 'boolean')\n    {\n        return unsafeEval;\n    }\n\n    try\n    {\n        /* eslint-disable no-new-func */\n        const func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');\n        /* eslint-enable no-new-func */\n\n        unsafeEval = func({ a: 'b' }, 'a', 'b') === true;\n    }\n    catch (e)\n    {\n        unsafeEval = false;\n    }\n\n    return unsafeEval;\n}\n","\"use strict\";\nvar CLEAR = /* @__PURE__ */ ((CLEAR2) => {\n  CLEAR2[CLEAR2[\"NONE\"] = 0] = \"NONE\";\n  CLEAR2[CLEAR2[\"COLOR\"] = 16384] = \"COLOR\";\n  CLEAR2[CLEAR2[\"STENCIL\"] = 1024] = \"STENCIL\";\n  CLEAR2[CLEAR2[\"DEPTH\"] = 256] = \"DEPTH\";\n  CLEAR2[CLEAR2[\"COLOR_DEPTH\"] = 16640] = \"COLOR_DEPTH\";\n  CLEAR2[CLEAR2[\"COLOR_STENCIL\"] = 17408] = \"COLOR_STENCIL\";\n  CLEAR2[CLEAR2[\"DEPTH_STENCIL\"] = 1280] = \"DEPTH_STENCIL\";\n  CLEAR2[CLEAR2[\"ALL\"] = 17664] = \"ALL\";\n  return CLEAR2;\n})(CLEAR || {});\n\nexport { CLEAR };\n//# sourceMappingURL=const.mjs.map\n","export enum CLEAR\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    NONE = 0,\n    COLOR = 16384,\n    STENCIL = 1024,\n    DEPTH = 256,\n\n    COLOR_DEPTH = COLOR | DEPTH,\n    COLOR_STENCIL = COLOR | STENCIL,\n    DEPTH_STENCIL = DEPTH | STENCIL,\n    ALL = COLOR | DEPTH | STENCIL,\n\n}\n\n/** Used for clearing render textures. true is the same as `ALL` false is the same as `NONE` */\nexport type CLEAR_OR_BOOL = CLEAR | boolean;\n","\"use strict\";\nclass SystemRunner {\n  /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */\n  constructor(name) {\n    this.items = [];\n    this._name = name;\n  }\n  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */\n  /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */\n  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    const { name, items } = this;\n    for (let i = 0, len = items.length; i < len; i++) {\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    return this;\n  }\n  /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */\n  add(item) {\n    if (item[this._name]) {\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  }\n  /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */\n  remove(item) {\n    const index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.items.splice(index, 1);\n    }\n    return this;\n  }\n  /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */\n  contains(item) {\n    return this.items.indexOf(item) !== -1;\n  }\n  /** Remove all listeners from the Runner */\n  removeAll() {\n    this.items.length = 0;\n    return this;\n  }\n  /** Remove all references, don't use after this. */\n  destroy() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  }\n  /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */\n  get empty() {\n    return this.items.length === 0;\n  }\n  /**\n   * The name of the runner.\n   * @readonly\n   */\n  get name() {\n    return this._name;\n  }\n}\n\nexport { SystemRunner };\n//# sourceMappingURL=SystemRunner.mjs.map\n","/**\n * SystemRunner is used internally by the renderers as an efficient way for systems to\n * be notified about what the renderer is up to during the rendering phase.\n *\n * ```\n * import { SystemRunner } from 'pixi.js';\n *\n * const myObject = {\n *     loaded: new SystemRunner('loaded')\n * }\n *\n * const listener = {\n *     loaded: function(){\n *         // thin\n *     }\n * }\n *\n * myObject.loaded.add(listener);\n *\n * myObject.loaded.emit();\n * ```\n *\n * Or for handling calling the same function on many items\n * ```\n * import { SystemRunner } from 'pixi.js';\n *\n * const myGame = {\n *     update: new SystemRunner('update')\n * }\n *\n * const gameObject = {\n *     update: function(time){\n *         // update my gamey state\n *     }\n * }\n *\n * myGame.update.add(gameObject);\n *\n * myGame.update.emit(time);\n * ```\n * @memberof rendering\n */\nexport class SystemRunner\n{\n    public items: any[];\n    private _name: string;\n\n    /**\n     * @param name - The function name that will be executed on the listeners added to this Runner.\n     */\n    constructor(name: string)\n    {\n        this.items = [];\n        this._name = name;\n    }\n\n    /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */\n    /**\n     * Dispatch/Broadcast Runner to all listeners added to the queue.\n     * @param {...any} params - (optional) parameters to pass to each listener\n     */\n    /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */\n    public emit(a0?: unknown, a1?: unknown, a2?: unknown, a3?: unknown,\n        a4?: unknown, a5?: unknown, a6?: unknown, a7?: unknown): this\n    {\n        const { name, items } = this;\n\n        for (let i = 0, len = items.length; i < len; i++)\n        {\n            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a listener to the Runner\n     *\n     * Runners do not need to have scope or functions passed to them.\n     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n     * as the name provided to the Runner when it was created.\n     *\n     * Eg A listener passed to this Runner will require a 'complete' function.\n     *\n     * ```\n     * import { Runner } from 'pixi.js';\n     *\n     * const complete = new Runner('complete');\n     * ```\n     *\n     * The scope used will be the object itself.\n     * @param {any} item - The object that will be listening.\n     */\n    public add(item: unknown): this\n    {\n        if ((item as any)[this._name])\n        {\n            this.remove(item);\n            this.items.push(item);\n        }\n\n        return this;\n    }\n\n    /**\n     * Remove a single listener from the dispatch queue.\n     * @param {any} item - The listener that you would like to remove.\n     */\n    public remove(item: unknown): this\n    {\n        const index = this.items.indexOf(item);\n\n        if (index !== -1)\n        {\n            this.items.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    /**\n     * Check to see if the listener is already in the Runner\n     * @param {any} item - The listener that you would like to check.\n     */\n    public contains(item: unknown): boolean\n    {\n        return this.items.indexOf(item) !== -1;\n    }\n\n    /** Remove all listeners from the Runner */\n    public removeAll(): this\n    {\n        this.items.length = 0;\n\n        return this;\n    }\n\n    /** Remove all references, don't use after this. */\n    public destroy(): void\n    {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n\n    /**\n     * `true` if there are no this Runner contains no listeners\n     * @readonly\n     */\n    public get empty(): boolean\n    {\n        return this.items.length === 0;\n    }\n\n    /**\n     * The name of the runner.\n     * @readonly\n     */\n    public get name(): string\n    {\n        return this._name;\n    }\n}\n","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = Promise.all([load(\"eNXth\"), load(\"7OvPL\"), load(\"aNM0B\")]).then(() => parcelRequire('aIpib'));","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = Promise.all([load(\"eNXth\"), load(\"7OvPL\"), load(\"7EYKF\")]).then(() => parcelRequire('kpxDv'));","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { BatchGeometry } from '../../../rendering/batcher/gpu/BatchGeometry.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { Batcher } from '../../../rendering/batcher/shared/Batcher.mjs';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { buildContextBatches } from './utils/buildContextBatches.mjs';\n\n\"use strict\";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.geometry = new BatchGeometry();\n    this.instructions = new InstructionSet();\n  }\n  init() {\n    this.instructions.reset();\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor() {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._activeBatchers = [];\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n    this._needsContextNeedsRebuild = [];\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  prerender() {\n    this._returnActiveBatchers();\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === \"no-batch\") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === \"auto\") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _returnActiveBatchers() {\n    for (let i = 0; i < this._activeBatchers.length; i++) {\n      BigPool.return(this._activeBatchers[i]);\n    }\n    this._activeBatchers.length = 0;\n  }\n  _initContextRenderData(context) {\n    const graphicsData = BigPool.get(GraphicsContextRenderData);\n    const { batches, geometryData } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = BigPool.get(Batcher);\n    this._activeBatchers.push(batcher);\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = graphicsData.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on(\"update\", this.onGraphicsContextUpdate, this);\n    context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextUpdate(context) {\n    this._needsContextNeedsRebuild.push(context);\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off(\"update\", this.onGraphicsContextUpdate, this);\n    context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        BigPool.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        BigPool.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const context of this._needsContextNeedsRebuild) {\n      if (this._gpuContextHash[context.uid]) {\n        this.onGraphicsContextDestroy(context);\n      }\n    }\n    this._needsContextNeedsRebuild.length = 0;\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem };\n//# sourceMappingURL=GraphicsContextSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { BatchGeometry } from '../../../rendering/batcher/gpu/BatchGeometry';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsContext\n{\n    public isBatchable: boolean;\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public geometry = new BatchGeometry();\n    public instructions = new InstructionSet();\n\n    public init()\n    {\n        this.instructions.reset();\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @memberof rendering\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @memberof rendering\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    private readonly _activeBatchers: Batcher[] = [];\n    private _gpuContextHash: Record<number, GpuGraphicsContext> = {};\n    // used for non-batchable graphics\n    private _graphicsDataContextHash: Record<number, GraphicsContextRenderData> = Object.create(null);\n    private readonly _needsContextNeedsRebuild: GraphicsContext[] = [];\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    protected prerender()\n    {\n        this._returnActiveBatchers();\n    }\n\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n\n    // Context management functions\n    public updateGpuContext(context: GraphicsContext)\n    {\n        let gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid]\n\n            || this._initContext(context);\n\n        if (context.dirty)\n        {\n            if (gpuContext)\n            {\n                this._cleanGraphicsContextData(context);\n            }\n            else\n            {\n                gpuContext = this._initContext(context);\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n\n    private _returnActiveBatchers()\n    {\n        for (let i = 0; i < this._activeBatchers.length; i++)\n        {\n            BigPool.return(this._activeBatchers[i] as PoolItem);\n        }\n\n        this._activeBatchers.length = 0;\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData);// ();\n\n        const { batches, geometryData } = this._gpuContextHash[context.uid];\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = BigPool.get(Batcher);\n\n        this._activeBatchers.push(batcher);\n\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = graphicsData.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n        }\n\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        this._gpuContextHash[context.uid] = gpuContext;\n\n        context.on('update', this.onGraphicsContextUpdate, this);\n        context.on('destroy', this.onGraphicsContextDestroy, this);\n\n        return this._gpuContextHash[context.uid];\n    }\n\n    protected onGraphicsContextUpdate(context: GraphicsContext)\n    {\n        this._needsContextNeedsRebuild.push(context);\n    }\n\n    protected onGraphicsContextDestroy(context: GraphicsContext)\n    {\n        this._cleanGraphicsContextData(context);\n\n        context.off('update', this.onGraphicsContextUpdate, this);\n        context.off('destroy', this.onGraphicsContextDestroy, this);\n\n        this._gpuContextHash[context.uid] = null;\n    }\n\n    private _cleanGraphicsContextData(context: GraphicsContext)\n    {\n        const gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid];\n\n        if (!gpuContext.isBatchable)\n        {\n            if (this._graphicsDataContextHash[context.uid])\n            {\n                BigPool.return(this.getContextRenderData(context) as PoolItem);\n\n                // we will rebuild this...\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n\n        if (gpuContext.batches)\n        {\n            gpuContext.batches.forEach((batch) =>\n            {\n                BigPool.return(batch as PoolItem);\n            });\n        }\n    }\n\n    public destroy()\n    {\n        // Clean up all graphics contexts\n        for (const context of this._needsContextNeedsRebuild)\n        {\n            // only clean if it exists\n            if (this._gpuContextHash[context.uid])\n            {\n                this.onGraphicsContextDestroy(context);\n            }\n        }\n\n        this._needsContextNeedsRebuild.length = 0;\n    }\n}\n","import { Buffer } from '../../renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry.mjs';\n\n\"use strict\";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends Geometry {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new Buffer({\n      data: placeHolderBufferData,\n      label: \"attribute-batch-buffer\",\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new Buffer({\n      data: placeHolderIndexData,\n      label: \"index-batch-buffer\",\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 0,\n          location: 1\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 2 * 4,\n          location: 3\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: \"unorm8x4\",\n          stride,\n          offset: 4 * 4,\n          location: 0\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: \"uint16x2\",\n          stride,\n          offset: 5 * 4,\n          location: 2\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\nexport { BatchGeometry };\n//# sourceMappingURL=BatchGeometry.mjs.map\n","import { Buffer } from '../../renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../renderers/shared/buffer/const';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\nexport class BatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 6;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                    location: 1,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                    location: 3,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                    location: 0,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 5 * 4,\n                    location: 2,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { BufferUsage } from './const.mjs';\n\n\"use strict\";\nclass Buffer extends EventEmitter {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = \"buffer\";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size = size ?? data?.byteLength;\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & BufferUsage.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= BufferUsage.STATIC;\n    } else {\n      this.descriptor.usage &= ~BufferUsage.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit(\"update\", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    if (oldData.length !== value.length) {\n      if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit(\"update\", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = uid(\"resource\");\n        this.emit(\"change\", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit(\"update\", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit(\"update\", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { Buffer };\n//# sourceMappingURL=Buffer.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { BufferUsage } from './const';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\n\n/** All the various typed arrays that exist in js */\n// eslint-disable-next-line max-len\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n\n/** Options for creating a buffer */\nexport interface BufferOptions\n{\n    /**\n     * the data to initialize the buffer with, this can be a typed array,\n     * or a regular number array. If it is a number array, it will be converted to a Float32Array\n     */\n    data?: TypedArray | number[];\n    /** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n    size?: number;\n    /** the usage of the buffer, see {@link rendering.BufferUsage} */\n    usage: number;\n    /** a label for the buffer, this is useful for debugging */\n    label?: string;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    shrinkToFit?: boolean;\n}\n\nexport interface BufferDescriptor\n{\n    label?: string;\n    size: GPUSize64;\n    usage: BufferUsage;\n    mappedAtCreation?: boolean;\n}\n\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @memberof rendering\n */\nexport class Buffer extends EventEmitter<{\n    change: BindResource,\n    update: Buffer,\n    destroy: Buffer,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    public readonly uid = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'buffer';\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * a description of the buffer and how it should be set up on the GPU\n     * @internal\n     * @ignore\n     */\n    public readonly descriptor: BufferDescriptor;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateID = 1;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateSize: number;\n\n    private _data: TypedArray;\n\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    public shrinkToFit = true;\n\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Creates a new Buffer with the given options\n     * @param options - the options for the buffer\n     */\n    constructor(options: BufferOptions)\n    {\n        let { data, size } = options;\n        const { usage, label, shrinkToFit } = options;\n\n        super();\n\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data as number[]);\n        }\n\n        this._data = data as TypedArray;\n\n        size = size ?? (data as TypedArray)?.byteLength;\n\n        const mappedAtCreation = !!data;\n\n        this.descriptor = {\n            size,\n            usage,\n            mappedAtCreation,\n            label,\n        };\n\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n\n    /** the data in the buffer */\n    get data()\n    {\n        return this._data;\n    }\n\n    set data(value: TypedArray)\n    {\n        this.setDataWithSize(value, value.length, true);\n    }\n\n    /** whether the buffer is static or not */\n    get static()\n    {\n        return !!(this.descriptor.usage & BufferUsage.STATIC);\n    }\n\n    set static(value: boolean)\n    {\n        if (value)\n        {\n            this.descriptor.usage |= BufferUsage.STATIC;\n        }\n        else\n        {\n            this.descriptor.usage &= ~BufferUsage.STATIC;\n        }\n    }\n\n    /**\n     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n     * If you only want to update a subset of the buffer, you can pass in the size of the data.\n     * @param value - the data to set\n     * @param size - the size of the data in bytes\n     * @param syncGPU - should the buffer be updated on the GPU immediately?\n     */\n    public setDataWithSize(value: TypedArray, size: number, syncGPU: boolean)\n    {\n        // Increment update ID\n        this._updateID++;\n\n        this._updateSize = (size * value.BYTES_PER_ELEMENT);\n\n        // If the data hasn't changed, early return after emitting 'update'\n        if (this._data === value)\n        {\n            if (syncGPU) this.emit('update', this);\n\n            return;\n        }\n\n        // Cache old data and update to new value\n        const oldData = this._data;\n\n        this._data = value;\n\n        // Event handling\n        if (oldData.length !== value.length)\n        {\n            if (!this.shrinkToFit && value.byteLength < oldData.byteLength)\n            {\n                if (syncGPU) this.emit('update', this);\n            }\n            else\n            {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = uid('resource');\n                this.emit('change', this);\n            }\n\n            return;\n        }\n\n        if (syncGPU) this.emit('update', this);\n    }\n\n    /**\n     * updates the buffer on the GPU to reflect the data in the buffer.\n     * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n     * you can pass in the size of the buffer to update.\n     * @param sizeInBytes - the new size of the buffer in bytes\n     */\n    public update(sizeInBytes?: number): void\n    {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n\n        this._updateID++;\n\n        this.emit('update', this);\n    }\n\n    /** Destroys the buffer */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this._data = null;\n        (this.descriptor as null) = null;\n\n        this.removeAllListeners();\n    }\n}\n\n","\"use strict\";\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n  BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n  BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n  BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n  BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n  BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n  BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n  BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n  BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n  BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n  BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n  return BufferUsage2;\n})(BufferUsage || {});\n\nexport { BufferUsage };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @memberof rendering\n */\nexport enum BufferUsage\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n     * May only be combined with COPY_DST.\n     */\n    MAP_READ = 0x0001,\n    /**\n     * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n     * May only be combined with COPY_SRC.\n     */\n    MAP_WRITE = 0x0002,\n    /**\n     * The buffer can be used as the source of a copy operation.\n     * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n     */\n    COPY_SRC = 0x0004,\n    /**\n     * The buffer can be used as the destination of a copy or write operation.\n     * (Examples: as the destination argument of a copyBufferToBuffer() or\n     * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n     */\n    COPY_DST = 0x0008,\n    /** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n    INDEX = 0x0010,\n    /** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n    VERTEX = 0x0020,\n    /**\n     * The buffer can be used as a uniform buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n     */\n    UNIFORM = 0x0040,\n    /**\n     * The buffer can be used as a storage buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n     */\n    STORAGE = 0x0080,\n    /**\n     * The buffer can be used as to store indirect command arguments.\n     * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n     */\n    INDIRECT = 0x0100,\n    /**\n     * The buffer can be used to capture query results.\n     * (Example: as the destination argument of a resolveQuerySet() call.)\n     */\n    QUERY_RESOLVE = 0x0200,\n    /** the buffer will not be updated frequently */\n    STATIC = 0x0400\n}\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer.mjs';\nimport { getGeometryBounds } from './utils/getGeometryBounds.mjs';\n\n\"use strict\";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends EventEmitter {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options) {\n    const { attributes, indexBuffer, topology } = options;\n    super();\n    /** The unique id of the geometry. */\n    this.uid = uid(\"geometry\");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n    this.attributes = attributes;\n    this.buffers = [];\n    this.instanceCount = options.instanceCount || 1;\n    for (const i in attributes) {\n      const attribute = attributes[i] = ensureIsAttribute(attributes[i]);\n      const bufferIndex = this.buffers.indexOf(attribute.buffer);\n      if (bufferIndex === -1) {\n        this.buffers.push(attribute.buffer);\n        attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n        attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n      }\n    }\n    if (indexBuffer) {\n      this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n      this.buffers.push(this.indexBuffer);\n    }\n    this.topology = topology || \"triangle-list\";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit(\"update\", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, \"aPosition\", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\nexport { Geometry };\n//# sourceMappingURL=Geometry.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { uid } from '../../../../utils/data/uid';\nimport { Buffer } from '../buffer/Buffer';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer';\nimport { getGeometryBounds } from './utils/getGeometryBounds';\n\nimport type { TypedArray } from '../buffer/Buffer';\nimport type { Topology, VertexFormat } from './const';\n\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n\n/**\n * The attribute data for a geometries attributes\n * @memberof rendering\n */\nexport interface Attribute\n{\n    /** the buffer that this attributes data belongs to */\n    buffer: Buffer;\n    /** the format of the attribute */\n    format?: VertexFormat;\n    /** set where the shader location is for this attribute */\n    location?: number;\n    /** the stride of the data in the buffer*/\n    stride?: number;\n    /** the offset of the attribute from the buffer, defaults to 0 */\n    offset?: number;\n    /** is this an instanced buffer? (defaults to false) */\n    instance?: boolean;\n    /**  The number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n    size?: number;\n    /** the type of attribute  */\n    type?: number;\n    /**\n     * The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     */\n    start?: number;\n}\n\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link rendering.Attribute} but allows for the buffer to be a typed or number array\n * @memberof rendering\n */\ntype AttributeOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]}\n| Buffer | TypedArray | number[];\n\nexport type AttributeOptions = Record<string, AttributeOption>;\n\n/**\n * the interface that describes the structure of the geometry\n * @memberof rendering\n */\nexport interface GeometryDescriptor\n{\n    /** an optional label to easily identify the geometry */\n    label?: string;\n    /** the attributes that make up the geometry */\n    attributes: AttributeOptions;\n    /** optional index buffer for this geometry */\n    indexBuffer?: Buffer | TypedArray | number[];\n    /** the topology of the geometry, defaults to 'triangle-list' */\n    topology?: Topology;\n\n    instanceCount?: number;\n}\nfunction ensureIsAttribute(attribute: AttributeOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        };\n    }\n\n    (attribute as Attribute).buffer = ensureIsBuffer(attribute.buffer as Buffer | TypedArray | number[], false);\n\n    return attribute as Attribute;\n}\n\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @memberof rendering\n * @class\n */\nexport class Geometry extends EventEmitter<{\n    update: Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology;\n    /** The unique id of the geometry. */\n    public readonly uid: number = uid('geometry');\n    /** A record of the attributes of the geometry. */\n    public readonly attributes: Record<string, Attribute>;\n    /** The buffers that the attributes use */\n    public readonly buffers: Buffer[];\n    /** The index buffer of the geometry */\n    public readonly indexBuffer: Buffer;\n\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the instance count of the geometry to draw */\n    public instanceCount = 1;\n\n    private readonly _bounds: Bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Create a new instance of a geometry\n     * @param options - The options for the geometry.\n     */\n    constructor(options: GeometryDescriptor)\n    {\n        const { attributes, indexBuffer, topology } = options;\n\n        super();\n\n        this.attributes = attributes as Record<string, Attribute>;\n        this.buffers = [];\n\n        this.instanceCount = options.instanceCount || 1;\n\n        for (const i in attributes)\n        {\n            const attribute = attributes[i] = ensureIsAttribute(attributes[i]);\n\n            const bufferIndex = this.buffers.indexOf(attribute.buffer);\n\n            if (bufferIndex === -1)\n            {\n                this.buffers.push(attribute.buffer);\n\n                // two events here - one for a resize (new buffer change)\n                // and one for an update (existing buffer change)\n                attribute.buffer.on('update', this.onBufferUpdate, this);\n                attribute.buffer.on('change', this.onBufferUpdate, this);\n            }\n        }\n\n        if (indexBuffer)\n        {\n            this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n            this.buffers.push(this.indexBuffer);\n        }\n\n        this.topology = topology || 'triangle-list';\n    }\n\n    protected onBufferUpdate(): void\n    {\n        this._boundsDirty = true;\n        this.emit('update', this);\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    public getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    public getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    public getBuffer(id: string): Buffer\n    {\n        return this.getAttribute(id).buffer;\n    }\n\n    /**\n     * Used to figure out how many vertices there are in this geometry\n     * @returns the number of vertices in the geometry\n     */\n    public getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n\n            // TODO use SIZE again like v7..\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /** Returns the bounds of the geometry. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        return getGeometryBounds(this, 'aPosition', this._bounds);\n    }\n\n    /**\n     * destroys the geometry.\n     * @param destroyBuffers - destroy the buffers associated with this geometry\n     */\n    public destroy(destroyBuffers = false): void\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n\n        if (destroyBuffers)\n        {\n            this.buffers.forEach((buffer) => buffer.destroy());\n        }\n\n        (this.attributes as null) = null;\n        (this.buffers as null) = null;\n        (this.indexBuffer as null) = null;\n        (this._bounds as null) = null;\n    }\n}\n\n","import { Buffer } from '../../buffer/Buffer.mjs';\nimport { BufferUsage } from '../../buffer/const.mjs';\n\n\"use strict\";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer)) {\n    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n      }\n    }\n    buffer = new Buffer({\n      data: buffer,\n      label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n      usage\n    });\n  }\n  return buffer;\n}\n\nexport { ensureIsBuffer };\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n","import { Buffer } from '../../buffer/Buffer';\nimport { BufferUsage } from '../../buffer/const';\n\nimport type { TypedArray } from '../../buffer/Buffer';\n\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @memberof rendering\n */\nexport function ensureIsBuffer(buffer: Buffer | TypedArray | number[], index: boolean): Buffer\n{\n    if (!(buffer instanceof Buffer))\n    {\n        let usage: number = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n\n        // its an array!\n        if (buffer instanceof Array)\n        {\n            if (index)\n            {\n                buffer = new Uint32Array(buffer);\n                usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n            }\n\n            else\n            {\n                buffer = new Float32Array(buffer);\n                usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n            }\n        }\n\n        buffer = new Buffer({\n            data: buffer,\n            label: index ? 'index-mesh-buffer' : 'vertex-mesh-buffer',\n            usage\n        });\n    }\n\n    return buffer;\n}\n","\"use strict\";\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\nexport { getGeometryBounds };\n//# sourceMappingURL=getGeometryBounds.mjs.map\n","import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n","import { BindGroup } from '../../renderers/gpu/shader/BindGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { MAX_TEXTURES } from '../shared/const.mjs';\n\n\"use strict\";\nconst cachedGroups = {};\nfunction getTextureBatchBindGroup(textures, size) {\n  let uid = 0;\n  for (let i = 0; i < size; i++) {\n    uid = uid * 31 + textures[i].uid >>> 0;\n  }\n  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, uid);\n}\nfunction generateTextureBatchBindGroup(textures, key) {\n  const bindGroupResources = {};\n  let bindIndex = 0;\n  for (let i = 0; i < MAX_TEXTURES; i++) {\n    const texture = i < textures.length ? textures[i] : Texture.EMPTY.source;\n    bindGroupResources[bindIndex++] = texture.source;\n    bindGroupResources[bindIndex++] = texture.style;\n  }\n  const bindGroup = new BindGroup(bindGroupResources);\n  cachedGroups[key] = bindGroup;\n  return bindGroup;\n}\n\nexport { getTextureBatchBindGroup };\n//# sourceMappingURL=getTextureBatchBindGroup.mjs.map\n","import { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { MAX_TEXTURES } from '../shared/const';\n\nimport type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\nconst cachedGroups: Record<number, BindGroup> = {};\n\nexport function getTextureBatchBindGroup(textures: TextureSource[], size: number)\n{\n    let uid = 0;\n\n    for (let i = 0; i < size; i++)\n    {\n        uid = ((uid * 31) + textures[i].uid) >>> 0;\n    }\n\n    return cachedGroups[uid] || generateTextureBatchBindGroup(textures, uid);\n}\n\nfunction generateTextureBatchBindGroup(textures: TextureSource[], key: number): BindGroup\n{\n    const bindGroupResources: Record<string, any> = {};\n\n    let bindIndex = 0;\n\n    for (let i = 0; i < MAX_TEXTURES; i++)\n    {\n        const texture = i < textures.length ? textures[i] : Texture.EMPTY.source;\n\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n\n    // pad out with empty textures\n    const bindGroup = new BindGroup(bindGroupResources);\n\n    cachedGroups[key] = bindGroup;\n\n    return bindGroup;\n}\n\n","\"use strict\";\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join(\"|\");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    resource.on?.(\"change\", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange(resource) {\n    this._dirty = true;\n    if (resource.destroyed) {\n      const resources = this.resources;\n      for (const i in resources) {\n        if (resources[i] === resource) {\n          resources[i] = null;\n        }\n      }\n    } else {\n      this._updateKey();\n    }\n  }\n}\n\nexport { BindGroup };\n//# sourceMappingURL=BindGroup.mjs.map\n","import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @memberof rendering\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     * @ignore\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     * @ignore\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     * @ignore\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n","\"use strict\";\nconst MAX_TEXTURES = 16;\n\nexport { MAX_TEXTURES };\n//# sourceMappingURL=const.mjs.map\n","export const MAX_TEXTURES = 16;\n","import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\nimport { MAX_TEXTURES } from './const.mjs';\n\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.blendMode = \"normal\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    this.uid = uid(\"batcher\");\n    this.dirty = true;\n    this.batchIndex = 0;\n    this.batches = [];\n    // specifics.\n    this._vertexSize = 6;\n    this._elements = [];\n    this._batchPool = [];\n    this._batchPoolIndex = 0;\n    this._textureBatchPool = [];\n    this._textureBatchPoolIndex = 0;\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { vertexSize, indexSize } = options;\n    this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n    this.indexBuffer = new Uint16Array(indexSize);\n  }\n  begin() {\n    this.batchIndex = 0;\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    this._batchPoolIndex = 0;\n    this._textureBatchPoolIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject.indexStart = this.indexSize;\n    batchableObject.location = this.attributeSize;\n    batchableObject.batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject.textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    batchableObject.packAttributes(\n      this.attributeBuffer.float32View,\n      this.attributeBuffer.uint32View,\n      batchableObject.location,\n      batchableObject.textureId\n    );\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n    textureBatch.clear();\n    if (!elements[this.elementStart])\n      return;\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const iBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const blendModeChange = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !blendModeChange) {\n        element.textureId = source._textureBindLocation;\n        size += element.indexSize;\n        element.packAttributes(f32, u32, element.location, element.textureId);\n        element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        element.batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= MAX_TEXTURES || blendModeChange) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          instructionSet,\n          action\n        );\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n        textureBatch.clear();\n        batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n        ++BATCH_TICK;\n      }\n      element.textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element.batch = batch;\n      size += element.indexSize;\n      element.packAttributes(f32, u32, element.location, element.textureId);\n      element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      this.batches[i].destroy();\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i].batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  vertexSize: 4,\n  indexSize: 6\n};\nlet Batcher = _Batcher;\n\nexport { Batch, Batcher };\n//# sourceMappingURL=Batcher.mjs.map\n","import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BatchTextureArray } from './BatchTextureArray';\nimport { MAX_TEXTURES } from './const';\n\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray;\n\n    public blendMode: BLEND_MODES = 'normal';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\nexport interface BatchableObject\n{\n    indexStart: number;\n\n    packAttributes: (\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    ) => void;\n    packIndex: (indexBuffer: IndexBufferArray, index: number, indicesOffset: number) => void;\n\n    texture: Texture;\n    blendMode: BLEND_MODES;\n    vertexSize: number;\n    indexSize: number;\n\n    // stored for efficient updating..\n    textureId: number;\n    location: number; // location in the buffer\n    batcher: Batcher;\n    batch: Batch;\n\n    roundPixels: 0 | 1;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @ignore\n */\nexport interface BatcherOptions\n{\n    /** The size of the vertex buffer. */\n    vertexSize?: number;\n    /** The size of the index buffer. */\n    indexSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * @ignore\n */\nexport class Batcher\n{\n    public static defaultOptions: BatcherOptions = {\n        vertexSize: 4,\n        indexSize: 6,\n    };\n\n    public uid = uid('batcher');\n    public attributeBuffer: ViewableBuffer;\n    public indexBuffer: IndexBufferArray;\n\n    public attributeSize: number;\n    public indexSize: number;\n    public elementSize: number;\n    public elementStart: number;\n\n    public dirty = true;\n\n    public batchIndex = 0;\n    public batches: Batch[] = [];\n\n    // specifics.\n    private readonly _vertexSize: number = 6;\n\n    private _elements: BatchableObject[] = [];\n\n    private readonly _batchPool: Batch[] = [];\n    private _batchPoolIndex = 0;\n    private readonly _textureBatchPool: BatchTextureArray[] = [];\n    private _textureBatchPoolIndex = 0;\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    constructor(options: BatcherOptions = {})\n    {\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { vertexSize, indexSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n\n        this.indexBuffer = new Uint16Array(indexSize);\n    }\n\n    public begin()\n    {\n        this.batchIndex = 0;\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n        this._batchPoolIndex = 0;\n        this._textureBatchPoolIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableObject)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject.indexStart = this.indexSize;\n        batchableObject.location = this.attributeSize;\n        batchableObject.batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.vertexSize) * this._vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableObject, texture: Texture): boolean\n    {\n        const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject.textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableObject)\n    {\n        this.dirty = true;\n\n        batchableObject.packAttributes(\n            this.attributeBuffer.float32View,\n            this.attributeBuffer.uint32View,\n            batchableObject.location, batchableObject.textureId);\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        // ++BATCH_TICK;\n        const elements = this._elements;\n\n        let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n\n        textureBatch.clear();\n\n        // length 0??!! (we broke without ading anything)\n        if (!elements[this.elementStart]) return;\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const iBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n        let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const blendModeChange = blendMode !== adjustedBlendMode;\n\n            if (source._batchTick === BATCH_TICK && !blendModeChange)\n            {\n                element.textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n                element.packAttributes(f32, u32, element.location, element.textureId);\n                element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n\n                element.batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= MAX_TEXTURES || blendModeChange)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n\n                textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n                textureBatch.clear();\n\n                batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n                ++BATCH_TICK;\n            }\n\n            element.textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element.batch = batch;\n\n            size += element.indexSize;\n            element.packAttributes(f32, u32, element.location, element.textureId);\n            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            this.batches[i].destroy();\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i].batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n","\"use strict\";\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === \"number\") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(`${type} isn't a valid view type`);\n    }\n  }\n}\n\nexport { ViewableBuffer };\n//# sourceMappingURL=ViewableBuffer.mjs.map\n","type TypedArray = Float32Array | Uint32Array | Int32Array | Uint8Array;\n\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @memberof utils\n */\nexport class ViewableBuffer\n{\n    /** The size of the buffer in bytes. */\n    public size: number;\n\n    /** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n    public rawBinaryData: ArrayBuffer;\n\n    /** View on the raw binary data as a `Uint32Array`. */\n    public uint32View: Uint32Array;\n\n    /** View on the raw binary data as a `Float32Array`. */\n    public float32View: Float32Array;\n    public uint16View: Uint16Array;\n\n    private _int8View: Int8Array;\n    private _uint8View: Uint8Array;\n    private _int16View: Int16Array;\n    private _int32View: Int32Array;\n    private _float64Array: Float64Array;\n    private _bigUint64Array: BigUint64Array;\n\n    /**\n     * @param length - The size of the buffer in bytes.\n     */\n    constructor(length: number);\n\n    /**\n     * @param arrayBuffer - The source array buffer.\n     */\n    constructor(arrayBuffer: ArrayBuffer);\n\n    constructor(sizeOrBuffer: number | ArrayBuffer | Uint8Array)\n    {\n        if (typeof sizeOrBuffer === 'number')\n        {\n            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        }\n        else if (sizeOrBuffer instanceof Uint8Array)\n        {\n            this.rawBinaryData = sizeOrBuffer.buffer;\n        }\n        else\n        {\n            this.rawBinaryData = sizeOrBuffer;\n        }\n\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n\n        this.size = this.rawBinaryData.byteLength;\n    }\n\n    /** View on the raw binary data as a `Int8Array`. */\n    get int8View(): Int8Array\n    {\n        if (!this._int8View)\n        {\n            this._int8View = new Int8Array(this.rawBinaryData);\n        }\n\n        return this._int8View;\n    }\n\n    /** View on the raw binary data as a `Uint8Array`. */\n    get uint8View(): Uint8Array\n    {\n        if (!this._uint8View)\n        {\n            this._uint8View = new Uint8Array(this.rawBinaryData);\n        }\n\n        return this._uint8View;\n    }\n\n    /**  View on the raw binary data as a `Int16Array`. */\n    get int16View(): Int16Array\n    {\n        if (!this._int16View)\n        {\n            this._int16View = new Int16Array(this.rawBinaryData);\n        }\n\n        return this._int16View;\n    }\n\n    /** View on the raw binary data as a `Int32Array`. */\n    get int32View(): Int32Array\n    {\n        if (!this._int32View)\n        {\n            this._int32View = new Int32Array(this.rawBinaryData);\n        }\n\n        return this._int32View;\n    }\n\n    /** View on the raw binary data as a `Float64Array`. */\n    get float64View(): Float64Array\n    {\n        if (!this._float64Array)\n        {\n            this._float64Array = new Float64Array(this.rawBinaryData);\n        }\n\n        return this._float64Array;\n    }\n\n    /** View on the raw binary data as a `BigUint64Array`. */\n    get bigUint64View(): BigUint64Array\n    {\n        if (!this._bigUint64Array)\n        {\n            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        }\n\n        return this._bigUint64Array;\n    }\n\n    /**\n     * Returns the view of the given type.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *    `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - typed array of given type\n     */\n    public view(type: string): TypedArray\n    {\n        return (this as any)[`${type}View`];\n    }\n\n    /** Destroys all buffer references. Do not use after calling this. */\n    public destroy(): void\n    {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n\n    /**\n     * Returns the size of the given type in bytes.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *   `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - size of the type in bytes\n     */\n    public static sizeOf(type: string): number\n    {\n        switch (type)\n        {\n            case 'int8':\n            case 'uint8':\n                return 1;\n            case 'int16':\n            case 'uint16':\n                return 2;\n            case 'int32':\n            case 'uint32':\n            case 'float32':\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n","\"use strict\";\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\nexport { fastCopy };\n//# sourceMappingURL=fastCopy.mjs.map\n","/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void\n{\n    const lengthDouble = (sourceBuffer.byteLength / 8) | 0;\n\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n\n    // Use set for faster copying\n    destinationFloat64View.set(sourceFloat64View);\n\n    // copying over the remaining bytes\n    const remainingBytes = sourceBuffer.byteLength - (lengthDouble * 8);\n\n    if (remainingBytes > 0)\n    {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n\n        // Direct copy for remaining bytes\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n","import { BLEND_TO_NPM } from './const.mjs';\n\n\"use strict\";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === \"no-premultiply-alpha\") {\n    return BLEND_TO_NPM[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\nexport { getAdjustedBlendModeBlend };\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n","import { type BLEND_MODES, BLEND_TO_NPM } from './const';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES\n{\n    if (textureSource.alphaMode === 'no-premultiply-alpha')\n    {\n        return (BLEND_TO_NPM[blendMode as keyof typeof BLEND_TO_NPM] || blendMode) as BLEND_MODES;\n    }\n\n    return blendMode;\n}\n","\"use strict\";\nconst BLEND_TO_NPM = {\n  normal: \"normal-npm\",\n  add: \"add-npm\",\n  screen: \"screen-npm\"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n  STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 3] = \"RENDERING_MASK_REMOVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 4] = \"NONE\";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\nexport { BLEND_TO_NPM, STENCIL_MODES };\n//# sourceMappingURL=const.mjs.map\n","/* eslint-disable @typescript-eslint/indent */\n/**\n * Various blend modes supported by Pixi\n * @memberof filters\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation';\n\n/**\n * The map of blend modes supported by Pixi\n * @memberof rendering\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @memberof rendering\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    RENDERING_MASK_REMOVE = 3,\n    NONE = 4,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @memberof rendering\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n","\"use strict\";\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\nexport { BatchTextureArray };\n//# sourceMappingURL=BatchTextureArray.mjs.map\n","import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @memberof rendering\n */\nexport class BatchTextureArray\n{\n    /** Inside textures array. */\n    public textures: TextureSource[];\n\n    /** Respective locations for textures. */\n    public ids: Record<number, number> = Object.create(null);\n\n    /** Number of filled elements. */\n    public count: number;\n\n    constructor()\n    {\n        this.textures = [];\n        this.count = 0;\n    }\n\n    /** Clear the textures and their locations. */\n    public clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            const t = this.textures[i];\n\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n\n        this.count = 0;\n    }\n}\n","import { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { buildUvs, buildSimpleUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { BigPool } from '../../../../utils/pool/PoolGroup.mjs';\nimport { BatchableGraphics } from '../BatchableGraphics.mjs';\nimport { buildCircle } from '../buildCommands/buildCircle.mjs';\nimport { buildLine } from '../buildCommands/buildLine.mjs';\nimport { buildPolygon } from '../buildCommands/buildPolygon.mjs';\nimport { buildRectangle } from '../buildCommands/buildRectangle.mjs';\nimport { buildTriangle } from '../buildCommands/buildTriangle.mjs';\nimport { triangulateWithHoles } from './triangulateWithHoles.mjs';\n\n\"use strict\";\nconst buildMap = {\n  rectangle: buildRectangle,\n  polygon: buildPolygon,\n  triangle: buildTriangle,\n  circle: buildCircle,\n  ellipse: buildCircle,\n  roundedRectangle: buildCircle\n};\nconst tempRect = new Rectangle();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === \"texture\") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n      const isStroke = instruction.action === \"stroke\";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = buildMap.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = BigPool.get(BatchableGraphics);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.vertexOffset = vertOffset;\n  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.color = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = buildMap[shape.type];\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn(\"[Pixi Graphics] only the last shape have be cut out\");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture.WHITE) {\n      const textureMatrix = style.matrix;\n      if (matrix) {\n        textureMatrix.append(matrix.clone().invert());\n      }\n      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.color = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape)\n    return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = buildMap[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\n\nexport { buildContextBatches };\n//# sourceMappingURL=buildContextBatches.mjs.map\n","import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { GraphicsPath } from '../path/GraphicsPath';\nimport type { ShapePath } from '../path/ShapePath';\n\nconst buildMap: Record<string, ShapeBuildCommand> = {\n    rectangle: buildRectangle,\n    polygon: buildPolygon,\n    triangle: buildTriangle,\n    circle: buildCircle,\n    ellipse: buildCircle,\n    roundedRectangle: buildCircle,\n};\n\nconst tempRect = new Rectangle();\n\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            }\n\n            addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    const points: number[] = [];\n\n    const build = buildMap.rectangle;\n\n    const rect = tempRect;\n\n    const texture = data.image;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    build.build(rect, points);\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.color = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle,\n    hole: GraphicsPath,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = buildMap[shape.type];\n\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (hole && lastIndex === i)\n            {\n                if (lastIndex !== 0)\n                {\n                    console.warn('[Pixi Graphics] only the last shape have be cut out');\n                }\n\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(hole.shapePath);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style;\n\n            buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = style.matrix;\n\n            if (matrix)\n            {\n                // todo can prolly do this before calculating uvs..\n                textureMatrix.append(matrix.clone().invert());\n            }\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.vertexOffset = vertOffset;\n        graphicsBatch.vertexSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.color = style.color as number;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(shape: ShapePath)\n{\n    if (!shape) return [];\n\n    const holePrimitives = shape.shapePrimitives;\n\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = buildMap[holePrimitive.type] as ShapeBuildCommand;\n\n        holeBuilder.build(holePrimitive, holePoints);\n\n        holeArrays.push(holePoints);\n    }\n\n    return holeArrays;\n}\n","\"use strict\";\nfunction buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n  let index = 0;\n  verticesOffset *= verticesStride;\n  uvsOffset *= uvsStride;\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  while (index < size) {\n    const x = vertices[verticesOffset];\n    const y = vertices[verticesOffset + 1];\n    uvs[uvsOffset] = a * x + c * y + tx;\n    uvs[uvsOffset + 1] = b * x + d * y + ty;\n    uvsOffset += uvsStride;\n    verticesOffset += verticesStride;\n    index++;\n  }\n}\nfunction buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {\n  let index = 0;\n  uvsOffset *= uvsStride;\n  while (index < size) {\n    uvs[uvsOffset] = 0;\n    uvs[uvsOffset + 1] = 0;\n    uvsOffset += uvsStride;\n    index++;\n  }\n}\n\nexport { buildSimpleUvs, buildUvs };\n//# sourceMappingURL=buildUvs.mjs.map\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @memberof rendering\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n","\"use strict\";\nfunction transformVertices(vertices, m, offset, stride, size) {\n  const a = m.a;\n  const b = m.b;\n  const c = m.c;\n  const d = m.d;\n  const tx = m.tx;\n  const ty = m.ty;\n  offset = offset || 0;\n  stride = stride || 2;\n  size = size || vertices.length / stride - offset;\n  let index = offset * stride;\n  for (let i = 0; i < size; i++) {\n    const x = vertices[index];\n    const y = vertices[index + 1];\n    vertices[index] = a * x + c * y + tx;\n    vertices[index + 1] = b * x + d * y + ty;\n    index += stride;\n  }\n}\n\nexport { transformVertices };\n//# sourceMappingURL=transformVertices.mjs.map\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @memberof rendering\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset = offset || 0;\n    stride = stride || 2;\n    size = size || (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n","import { mixColors } from '../../container/utils/mixColors.mjs';\n\n\"use strict\";\nclass BatchableGraphics {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.applyTransform = true;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    if (this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return \"normal\";\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometryData.indices;\n    for (let i = 0; i < this.indexSize; i++) {\n      indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const geometry = this.geometryData;\n    const graphics = this.renderable;\n    const positions = geometry.vertices;\n    const uvs = geometry.uvs;\n    const offset = this.vertexOffset * 2;\n    const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n    const rgb = this.color;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    if (this.applyTransform) {\n      const argb = mixColors(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);\n      const wt = graphics.groupTransform;\n      const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n      const a = wt.a;\n      const b = wt.b;\n      const c = wt.c;\n      const d = wt.d;\n      const tx = wt.tx;\n      const ty = wt.ty;\n      for (let i = offset; i < vertSize; i += 2) {\n        const x = positions[i];\n        const y = positions[i + 1];\n        float32View[index] = a * x + c * y + tx;\n        float32View[index + 1] = b * x + d * y + ty;\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n        index += 6;\n      }\n    } else {\n      const argb = bgr + (this.alpha * 255 << 24);\n      for (let i = offset; i < vertSize; i += 2) {\n        float32View[index] = positions[i];\n        float32View[index + 1] = positions[i + 1];\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureId << 16;\n        index += 6;\n      }\n    }\n  }\n  // TODO rename to vertexSize\n  get vertSize() {\n    return this.vertexSize;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.vertexOffset = this.vertexOffset;\n    gpuBuffer.vertexSize = this.vertexSize;\n    gpuBuffer.color = this.color;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n  }\n  reset() {\n    this.applyTransform = true;\n  }\n}\n\nexport { BatchableGraphics };\n//# sourceMappingURL=BatchableGraphics.mjs.map\n","import { mixColors } from '../../container/utils/mixColors';\n\nimport type { Batch, BatchableObject, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Graphics } from './Graphics';\n\n/**\n * A batchable graphics object.\n * @ignore\n */\nexport class BatchableGraphics implements BatchableObject\n{\n    public indexStart: number;\n    public textureId: number;\n    public texture: Texture;\n    public location: number;\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public renderable: Graphics;\n    public indexOffset: number;\n    public indexSize: number;\n    public vertexOffset: number;\n    public vertexSize: number;\n    public color: number;\n    public alpha: number;\n    public applyTransform = true;\n    public roundPixels: 0 | 1 = 0;\n\n    public geometryData: { vertices: number[]; uvs: number[]; indices: number[]; };\n\n    get blendMode()\n    {\n        if (this.applyTransform)\n        {\n            return this.renderable.groupBlendMode;\n        }\n\n        return 'normal';\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.geometryData.indices;\n\n        for (let i = 0; i < this.indexSize; i++)\n        {\n            indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n        }\n    }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const geometry = this.geometryData;\n        const graphics = this.renderable;\n\n        const positions = geometry.vertices;\n        const uvs = geometry.uvs;\n\n        const offset = this.vertexOffset * 2;\n        const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n\n        const rgb = this.color;\n        const bgr = (rgb >> 16) | (rgb & 0xff00) | ((rgb & 0xff) << 16);\n\n        if (this.applyTransform)\n        {\n            const argb = mixColors(bgr, graphics.groupColor)\n            + ((this.alpha * graphics.groupAlpha * 255) << 24);\n\n            const wt = graphics.groupTransform;\n            const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n            const a = wt.a;\n            const b = wt.b;\n            const c = wt.c;\n            const d = wt.d;\n            const tx = wt.tx;\n            const ty = wt.ty;\n\n            for (let i = offset; i < vertSize; i += 2)\n            {\n                const x = positions[i];\n                const y = positions[i + 1];\n\n                float32View[index] = (a * x) + (c * y) + tx;\n                float32View[index + 1] = (b * x) + (d * y) + ty;\n\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureIdAndRound;\n\n                index += 6;\n            }\n        }\n        else\n        {\n            const argb = bgr + ((this.alpha * 255) << 24);\n\n            for (let i = offset; i < vertSize; i += 2)\n            {\n                float32View[index] = positions[i];\n                float32View[index + 1] = positions[i + 1];\n\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureId << 16;\n\n                index += 6;\n            }\n        }\n    }\n\n    // TODO rename to vertexSize\n    get vertSize()\n    {\n        return this.vertexSize;\n    }\n\n    public copyTo(gpuBuffer: BatchableGraphics)\n    {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n\n        gpuBuffer.vertexOffset = this.vertexOffset;\n        gpuBuffer.vertexSize = this.vertexSize;\n\n        gpuBuffer.color = this.color;\n        gpuBuffer.alpha = this.alpha;\n\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n    }\n\n    public reset()\n    {\n        this.applyTransform = true;\n    }\n}\n","import { mixHexColors } from './mixHexColors.mjs';\n\n\"use strict\";\nconst WHITE_BGR = 16777215;\nfunction mixColors(localBGRColor, parentBGRColor) {\n  if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {\n    return localBGRColor + parentBGRColor - WHITE_BGR;\n  }\n  return mixHexColors(localBGRColor, parentBGRColor, 0.5);\n}\nfunction mixStandardAnd32BitColors(localColorRGB, localAlpha, parentColor) {\n  const parentAlpha = (parentColor >> 24 & 255) / 255;\n  const globalAlpha = localAlpha * parentAlpha * 255;\n  const localBGRColor = ((localColorRGB & 255) << 16) + (localColorRGB & 65280) + (localColorRGB >> 16 & 255);\n  const parentBGRColor = parentColor & 16777215;\n  let sharedBGRColor;\n  if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {\n    sharedBGRColor = localBGRColor + parentBGRColor - WHITE_BGR;\n  } else {\n    sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);\n  }\n  return sharedBGRColor + (globalAlpha << 24);\n}\n\nexport { mixColors, mixStandardAnd32BitColors };\n//# sourceMappingURL=mixColors.mjs.map\n","import { mixHexColors } from './mixHexColors';\n\nconst WHITE_BGR = 0xFFFFFF;\n\nexport function mixColors(localBGRColor: number, parentBGRColor: number)\n{\n    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR)\n    {\n        return localBGRColor + parentBGRColor - WHITE_BGR;\n    }\n\n    return mixHexColors(localBGRColor, parentBGRColor, 0.5);\n}\n\nexport function mixStandardAnd32BitColors(localColorRGB: number, localAlpha: number, parentColor: number)\n{\n    const parentAlpha = ((parentColor >> 24) & 0xFF) / 255;\n\n    const globalAlpha = ((localAlpha * parentAlpha) * 255);\n\n    // flip rgb to bgr\n    const localBGRColor = ((localColorRGB & 0xFF) << 16) + (localColorRGB & 0xFF00) + ((localColorRGB >> 16) & 0xFF);\n\n    const parentBGRColor = parentColor & 0x00FFFFFF;\n\n    let sharedBGRColor: number;\n\n    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR)\n    {\n        sharedBGRColor = localBGRColor + parentBGRColor - WHITE_BGR;\n    }\n    else\n    {\n        sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);\n    }\n\n    return sharedBGRColor + (globalAlpha << 24);\n}\n\n","\"use strict\";\nfunction mixHexColors(color1, color2, ratio) {\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 + (r2 - r1) * ratio;\n  const g = g1 + (g2 - g1) * ratio;\n  const b = b1 + (b2 - b1) * ratio;\n  return (r << 16) + (g << 8) + b;\n}\n\nexport { mixHexColors };\n//# sourceMappingURL=mixHexColors.mjs.map\n","export function mixHexColors(color1: number, color2: number, ratio: number): number\n{\n    const r1 = (color1 >> 16) & 0xFF;\n    const g1 = (color1 >> 8) & 0xFF;\n    const b1 = color1 & 0xFF;\n\n    const r2 = (color2 >> 16) & 0xFF;\n    const g2 = (color2 >> 8) & 0xFF;\n    const b2 = color2 & 0xFF;\n\n    const r = r1 + ((r2 - r1) * ratio);\n    const g = g1 + ((g2 - g1) * ratio);\n    const b = b1 + ((b2 - b1) * ratio);\n\n    return (r << 16) + (g << 8) + b;\n}\n\n","\"use strict\";\nconst buildCircle = {\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === \"circle\") {\n      const circle = shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (shape.type === \"ellipse\") {\n      const ellipse = shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      return points;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return points;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return points;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\n\nexport { buildCircle };\n//# sourceMappingURL=buildCircle.mjs.map\n","import type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n\n    build(shape: RoundedShape, points: number[])\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            return points;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return points;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return points;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return points;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { closePointEps, curveEps } from '../const.mjs';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints.mjs';\n\n\"use strict\";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point(points[0], points[1]);\n  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === \"round\") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === \"round\") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === \"round\") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\nexport { buildLine };\n//# sourceMappingURL=buildLine.mjs.map\n","import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeStyle } from '../GraphicsContext';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param _verticesStride\n * @param _verticesOffset\n * @param indices\n * @param _indicesOffset\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeStyle,\n    flipAlignment: boolean,\n    closed: boolean,\n    // alignment:number,\n\n    vertices: number[],\n    _verticesStride: number,\n    _verticesOffset: number,\n\n    indices: number[],\n    _indicesOffset: number,\n\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n","\"use strict\";\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\nexport { closePointEps, curveEps };\n//# sourceMappingURL=const.mjs.map\n","export type LineCap = 'butt' | 'round' | 'square';\nexport type LineJoin = 'round' | 'bevel' | 'miter';\n\nexport const closePointEps = 1e-4;\nexport const curveEps = 0.0001;\n","\"use strict\";\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\nexport { getOrientationOfPoints };\n//# sourceMappingURL=getOrientationOfPoints.mjs.map\n","export function getOrientationOfPoints(points: number[]): number\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return 1;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if (area < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n","import { triangulateWithHoles } from '../utils/triangulateWithHoles.mjs';\n\n\"use strict\";\nconst emptyArray = [];\nconst buildPolygon = {\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\nexport { buildPolygon };\n//# sourceMappingURL=buildPolygon.mjs.map\n","import { triangulateWithHoles } from '../utils/triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\nconst emptyArray: number[] = [];\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon> = {\n\n    build(shape: Polygon, points: number[]): number[]\n    {\n        for (let i = 0; i < shape.points.length; i++)\n        {\n            points[i] = shape.points[i];\n        }\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n        //  holes: number[],\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    },\n\n};\n","import earcut from 'earcut';\n\n\"use strict\";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\nexport { triangulateWithHoles };\n//# sourceMappingURL=triangulateWithHoles.mjs.map\n","import { default as earcut } from 'earcut';\n\nexport function triangulateWithHoles(\n    points: number[],\n    holes: number[],\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    indices: number[],\n    indicesOffset: number\n)\n{\n    const triangles = earcut(points, holes, 2);\n\n    if (!triangles)\n    {\n        return;\n    }\n\n    for (let i = 0; i < triangles.length; i += 3)\n    {\n        indices[indicesOffset++] = (triangles[i] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 1] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 2] + verticesOffset);\n    }\n\n    let index = verticesOffset * verticesStride;\n\n    for (let i = 0; i < points.length; i += 2)\n    {\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n\n        index += verticesStride;\n    }\n}\n\n","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n","\"use strict\";\nconst buildRectangle = {\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width >= 0 && height >= 0)) {\n      return points;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildRectangle };\n//# sourceMappingURL=buildRectangle.mjs.map\n","import type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle> = {\n\n    build(shape: Rectangle, points: number[]): number[]\n    {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        if (!(width >= 0 && height >= 0))\n        {\n            return points;\n        }\n\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        count += verticesStride;\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n\n        // triangle 2\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","\"use strict\";\nconst buildTriangle = {\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildTriangle };\n//# sourceMappingURL=buildTriangle.mjs.map\n","import type { Triangle } from '../../../../maths/shapes/Triangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle> = {\n\n    build(shape: Triangle, points: number[]): number[]\n    {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { Color } from '../../../../color/Color.mjs';\nimport { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nconst _FillGradient = class _FillGradient {\n  constructor(x0, y0, x1, y1) {\n    this.uid = uid(\"fillGradient\");\n    this.type = \"linear\";\n    this.gradientStops = [];\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n  addColorStop(offset, color) {\n    this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHex() });\n    return this;\n  }\n  // TODO move to the system!\n  buildLinearGradient() {\n    const defaultSize = _FillGradient.defaultTextureSize;\n    const { gradientStops } = this;\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = defaultSize;\n    canvas.height = defaultSize;\n    const ctx = canvas.getContext(\"2d\");\n    const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n    for (let i = 0; i < gradientStops.length; i++) {\n      const stop = gradientStops[i];\n      gradient.addColorStop(stop.offset, stop.color);\n    }\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new Texture({\n      source: new ImageSource({\n        resource: canvas,\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"repeat\"\n      })\n    });\n    const { x0, y0, x1, y1 } = this;\n    const m = new Matrix();\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    m.translate(-x0, -y0);\n    m.scale(1 / defaultSize, 1 / defaultSize);\n    m.rotate(-angle);\n    m.scale(256 / dist, 1);\n    this.transform = m;\n  }\n};\n_FillGradient.defaultTextureSize = 256;\nlet FillGradient = _FillGradient;\n\nexport { FillGradient };\n//# sourceMappingURL=FillGradient.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { ColorSource } from '../../../../color/Color';\n\nexport type GradientType = 'linear' | 'radial';\n\n// export type GradientSource =\n//     string // CSS gradient string: 'linear-gradient(...)'\n//     | IGradientOptions // Gradient options: { x0, y0, x1, y1, ...}\n//     | Gradient; // class Gradient itself\n\nexport interface LinearGradientFillStyle\n{\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    colors: number[];\n    stops: number[];\n}\n\nexport class FillGradient implements CanvasGradient\n{\n    public static defaultTextureSize = 256;\n\n    public readonly uid = uid('fillGradient');\n    public readonly type: GradientType = 'linear';\n\n    public x0: number;\n    public y0: number;\n    public x1: number;\n    public y1: number;\n\n    public texture: Texture;\n    public transform: Matrix;\n    public gradientStops: Array<{ offset: number, color: string }> = [];\n\n    constructor(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.x0 = x0;\n        this.y0 = y0;\n\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n\n    public addColorStop(offset: number, color: ColorSource): this\n    {\n        this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHex() });\n\n        return this;\n    }\n\n    // TODO move to the system!\n    public buildLinearGradient(): void\n    {\n        const defaultSize = FillGradient.defaultTextureSize;\n\n        const { gradientStops } = this;\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = defaultSize;\n        canvas.height = defaultSize;\n\n        const ctx = canvas.getContext('2d');\n\n        const gradient = ctx.createLinearGradient(0, 0, FillGradient.defaultTextureSize, 1);\n\n        for (let i = 0; i < gradientStops.length; i++)\n        {\n            const stop = gradientStops[i];\n\n            gradient.addColorStop(stop.offset, stop.color);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, defaultSize, defaultSize);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressModeU: 'clamp-to-edge',\n                addressModeV: 'repeat',\n            }),\n        });\n\n        // generate some UVS based on the gradient direction sent\n\n        const { x0, y0, x1, y1 } = this;\n\n        const m = new Matrix();\n\n        // get angle\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n\n        const dist = Math.sqrt((dx * dx) + (dy * dy));\n\n        const angle = Math.atan2(dy, dx);\n\n        m.translate(-x0, -y0);\n        m.scale(1 / defaultSize, 1 / defaultSize);\n        m.rotate(-angle);\n        m.scale(256 / dist, 1);\n\n        this.transform = m;\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: \"repeat\",\n    addressModeV: \"repeat\"\n  },\n  \"repeat-x\": {\n    addressModeU: \"repeat\",\n    addressModeV: \"clamp-to-edge\"\n  },\n  \"repeat-y\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"repeat\"\n  },\n  \"no-repeat\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"clamp-to-edge\"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    this.uid = uid(\"fillPattern\");\n    this.transform = new Matrix();\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n  }\n}\n\nexport { FillPattern };\n//# sourceMappingURL=FillPattern.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\n\nexport type PatternRepetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n\nconst repetitionMap = {\n    repeat: {\n        addressModeU: 'repeat',\n        addressModeV: 'repeat',\n    },\n    'repeat-x': {\n        addressModeU: 'repeat',\n        addressModeV: 'clamp-to-edge',\n    },\n    'repeat-y': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'repeat',\n    },\n    'no-repeat': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n    },\n};\n\nexport class FillPattern implements CanvasPattern\n{\n    public readonly uid = uid('fillPattern');\n    public texture: Texture;\n    public transform = new Matrix();\n\n    constructor(texture: Texture, repetition?: PatternRepetition)\n    {\n        this.texture = texture;\n\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        if (repetition)\n        {\n            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU as WRAP_MODE;\n            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV as WRAP_MODE;\n        }\n    }\n\n    public setTransform(transform?: Matrix): void\n    {\n        const texture = this.texture;\n\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        //  transform.scale\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n    }\n}\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Container } from '../../container/Container.mjs';\nimport { GraphicsContext } from './GraphicsContext.mjs';\n\n\"use strict\";\nclass Graphics extends Container {\n  /**\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: \"Graphics\",\n      ...rest\n    });\n    this.canBundle = true;\n    this.renderPipeId = \"graphics\";\n    this._roundPixels = 0;\n    if (!context) {\n      this._context = this._ownedContext = new GraphicsContext();\n    } else {\n      this._context = context;\n    }\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off(\"update\", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    bounds.addBounds(this._context.bounds);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   *  Whether or not to round the x/y position of the graphic.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didGraphicsUpdate = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    if (this.renderGroup) {\n      this.renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod(\"setFillStyle\", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod(\"setStrokeStyle\", args);\n  }\n  fill(...args) {\n    return this._callContextMethod(\"fill\", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(...args) {\n    return this._callContextMethod(\"stroke\", args);\n  }\n  texture(...args) {\n    return this._callContextMethod(\"texture\", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    return this._callContextMethod(\"beginPath\", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */\n  cut() {\n    return this._callContextMethod(\"cut\", []);\n  }\n  arc(...args) {\n    return this._callContextMethod(\"arc\", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod(\"arcTo\", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod(\"arcToSvg\", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod(\"bezierCurveTo\", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    return this._callContextMethod(\"closePath\", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  circle(...args) {\n    return this._callContextMethod(\"circle\", args);\n  }\n  path(...args) {\n    return this._callContextMethod(\"path\", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod(\"lineTo\", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod(\"moveTo\", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod(\"quadraticCurveTo\", args);\n  }\n  rect(...args) {\n    return this._callContextMethod(\"rect\", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  poly(...args) {\n    return this._callContextMethod(\"poly\", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod(\"regularPoly\", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod(\"roundPoly\", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod(\"roundShape\", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod(\"filletRect\", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod(\"chamferRect\", args);\n  }\n  star(...args) {\n    return this._callContextMethod(\"star\", args);\n  }\n  svg(...args) {\n    return this._callContextMethod(\"svg\", args);\n  }\n  restore(...args) {\n    return this._callContextMethod(\"restore\", args);\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    return this._callContextMethod(\"save\", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    return this._callContextMethod(\"resetTransform\", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod(\"rotate\", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod(\"scale\", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod(\"setTransform\", args);\n  }\n  transform(...args) {\n    return this._callContextMethod(\"transform\", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod(\"translate\", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    return this._callContextMethod(\"clear\", []);\n  }\n  /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    deprecation(v8_0_0, \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    deprecation(v8_0_0, \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    const fillStyle = {};\n    color && (fillStyle.color = color);\n    alpha && (fillStyle.alpha = alpha);\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    deprecation(v8_0_0, \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    deprecation(v8_0_0, \"Graphics#drawCircle has been renamed to Graphics#circle\");\n    return this._callContextMethod(\"circle\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    deprecation(v8_0_0, \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    deprecation(v8_0_0, \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n    return this._callContextMethod(\"poly\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRect has been renamed to Graphics#rect\");\n    return this._callContextMethod(\"rect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    deprecation(v8_0_0, \"Graphics#drawStar has been renamed to Graphics#star\");\n    return this._callContextMethod(\"star\", args);\n  }\n}\n\nexport { Graphics };\n//# sourceMappingURL=Graphics.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Container } from '../../container/Container';\nimport { GraphicsContext } from './GraphicsContext';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { View } from '../../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillStyle, FillStyleInputs, StrokeStyle } from './GraphicsContext';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for `Graphics` instances.\n * ```js\n * const graphics = new Graphics({\n *    fillStyle: { color: 0xff0000, alpha: 0.5 },\n *    strokeStyle: { color: 0x00ff00, width: 2 },\n * });\n * ```\n * @see {@link scene.Graphics}\n * @memberof scene\n */\nexport interface GraphicsOptions extends ContainerOptions\n{\n    /** The GraphicsContext to use, useful for reuse and optimisation */\n    context?: GraphicsContext;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n * @memberof scene\n * @extends scene.Container\n */\nexport class Graphics extends Container implements View, Instruction\n{\n    public readonly canBundle = true;\n    public readonly renderPipeId = 'graphics';\n    public batched: boolean;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    public _didGraphicsUpdate: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphic.\n     * @type {rendering.Bounds}\n     */\n    get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this._context.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the graphic.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    protected onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n        this._didGraphicsUpdate = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n     * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n     * @param {boolean} [options.context=false] - Should destroy the context\n     */\n    public destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n     * pattern object, or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     * or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyleInputs object for advanced fills.\n     * @param {FillStyleInputs} style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a\n     * complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillStyleInputs): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(...args: [FillStyleInputs, ColorSource?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n     * complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise\n     * (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction.\n     * If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified,\n     * the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * The fill style to use.\n     * @type {ConvertedFillStyle}\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillStyleInputs)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * The stroke style to use.\n     * @type {ConvertedStrokeStyle}\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: FillStyleInputs)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object.\n     * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n     * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n     * will be shared between the two objects (default false). If true, the context will be\n     * cloned (recommended if you need to modify the context in any way).\n     * @returns - A clone of the graphics object\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        color && (fillStyle.color = color);\n        alpha && (fillStyle.alpha = alpha);\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../../color/Color.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\nimport { GraphicsPath } from './path/GraphicsPath.mjs';\nimport { SVGParser } from './svg/SVGParser.mjs';\nimport { convertFillInputToFillStyle } from './utils/convertFillInputToFillStyle.mjs';\n\n\"use strict\";\nconst tmpPoint = new Point();\nconst tempMatrix = new Matrix();\nconst _GraphicsContext = class _GraphicsContext extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.uid = uid(\"graphicsContext\");\n    this.dirty = true;\n    this.batchMode = \"auto\";\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: \"texture\",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      if (alpha !== void 0 && typeof style === \"number\") {\n        deprecation(v8_0_0, \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: \"fill\",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      this._strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: \"stroke\",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty)\n      return;\n    this.emit(\"update\", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === \"fill\") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === \"texture\") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === \"stroke\") {\n        const data = instruction.data;\n        const padding = data.style.width / 2;\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - padding,\n          _bounds.minY - padding,\n          _bounds.maxX + padding,\n          _bounds.maxY + padding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === \"fill\") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: \"butt\",\n  /** The line join style to use. */\n  join: \"miter\",\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\nlet GraphicsContext = _GraphicsContext;\n\nexport { GraphicsContext };\n//# sourceMappingURL=GraphicsContext.mjs.map\n","/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { convertFillInputToFillStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { LineCap, LineJoin } from './const';\nimport type { FillGradient } from './fill/FillGradient';\nimport type { FillPattern } from './fill/FillPattern';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * A fill style object.\n * @memberof scene\n */\nexport interface FillStyle\n{\n    /** The color to use for the fill. */\n    color?: ColorSource;\n    /** The alpha value to use for the fill. */\n    alpha?: number;\n    /** The texture to use for the fill. */\n    texture?: Texture | null;\n    /** The matrix to apply. */\n    matrix?: Matrix | null;\n    /** The fill pattern to use. */\n    fill?: FillPattern | FillGradient | null;\n}\n\nexport type ConvertedFillStyle = Omit<Required<FillStyle>, 'color'> & { color: number };\n\nexport interface PatternFillStyle\n{\n    fill?: FillPattern | FillGradient;\n    color?: number;\n    alpha?: number;\n}\n\n/**\n * A stroke style object.\n * @memberof scene\n */\nexport interface StrokeStyle extends FillStyle\n{\n    /** The width of the stroke. */\n    width?: number;\n    /** The alignment of the stroke. */\n    alignment?: number;\n    // native?: boolean;\n    /** The line cap style to use. */\n    cap?: LineCap;\n    /** The line join style to use. */\n    join?: LineJoin;\n    /** The miter limit to use. */\n    miterLimit?: number;\n}\n\nexport type ConvertedStrokeStyle = Omit<StrokeStyle, 'color'> & ConvertedFillStyle;\n\nconst tmpPoint = new Point();\n\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\nexport type FillStyleInputs = ColorSource | FillGradient | CanvasPattern | PatternFillStyle | FillStyle | ConvertedFillStyle | StrokeStyle | ConvertedStrokeStyle;\n\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @memberof scene\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n}>\n{\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    public uid = uid('graphicsContext');\n    public dirty = true;\n    public batchMode: BatchMode = 'auto';\n    public instructions: GraphicsInstructions[] = [];\n    public customShader?: Shader;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillStyleInputs)\n    {\n        this._fillStyle = convertFillInputToFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillStyleInputs)\n    {\n        this._strokeStyle = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillStyleInputs): this\n    {\n        this._fillStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: FillStyleInputs): this\n    {\n        this._strokeStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture, tint, and dimensions.\n     * If only a texture is provided, it uses the texture's width and height for drawing. Additional parameters allow for specifying\n     * a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint: ColorSource): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number, dw: number, dh: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyleInputs object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillStyleInputs): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillStyleInputs, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: FillStyleInputs): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        if (this.dirty) return;\n\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const padding = data.style.width / 2;\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - padding,\n                    _bounds.minY - padding,\n                    _bounds.maxX + padding,\n                    _bounds.maxY + padding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, (style as ConvertedStrokeStyle).width);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n     * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath.mjs';\nimport { ShapePath } from './ShapePath.mjs';\n\n\"use strict\";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    this.uid = uid(\"graphicsPath\");\n    this._dirty = true;\n    if (typeof instructions === \"string\") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: \"addPath\", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: \"arc\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: \"arcTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: \"arcToSvg\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: \"bezierCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== \"bezierCurveTo\") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: \"bezierCurveTo\", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: \"closePath\", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: \"ellipse\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: \"lineTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: \"moveTo\", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: \"quadraticCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== \"quadraticCurveTo\") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: \"quadraticCurveTo\", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: \"rect\", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: \"circle\", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: \"roundRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: \"poly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: \"regularPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: \"roundPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: \"roundShape\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: \"filletRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: \"chamferRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius = innerRadius || radius / 2;\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case \"moveTo\":\n        case \"lineTo\":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case \"bezierCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case \"quadraticCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case \"arcToSvg\":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case \"circle\":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case \"rect\":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case \"ellipse\":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case \"roundRect\":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case \"addPath\":\n          data[0].transform(matrix);\n          break;\n        case \"poly\":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          warn(\"unknown transform action\", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === \"closePath\") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case \"moveTo\":\n      case \"lineTo\":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case \"quadraticCurveTo\":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case \"bezierCurveTo\":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case \"arc\":\n      case \"arcToSvg\":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case \"addPath\":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\nexport { GraphicsPath };\n//# sourceMappingURL=GraphicsPath.mjs.map\n","import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    public uid = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     */\n    constructor(instructions?: string | PathInstruction[])\n    {\n        if (typeof instructions === 'string')\n        {\n            SVGToGraphicsPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n","import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction SVGToGraphicsPath(svgPath, path) {\n  const commands = parse(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case \"M\":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"m\":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"H\":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"h\":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"V\":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"v\":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"L\":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"l\":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"C\":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          lastX,\n          lastY\n        );\n        break;\n      case \"c\":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4],\n          lastX + data[5],\n          lastY + data[6]\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case \"S\":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case \"s\":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"Q\":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case \"q\":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"T\":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case \"t\":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case \"A\":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case \"a\":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case \"Z\":\n      case \"z\":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        warn(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== \"Z\" && type !== \"z\") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\nexport { SVGToGraphicsPath };\n//# sourceMappingURL=SVGToGraphicsPath.mjs.map\n","/* eslint-disable no-console */\nimport parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { GraphicsPath } from '../path/GraphicsPath';\n\ninterface SubPath\n{\n    startX: number;\n    startY: number;\n}\n\n// TODO optimise and cache the paths?\nexport function SVGToGraphicsPath(svgPath: string, path: GraphicsPath): GraphicsPath\n{\n    const commands = parse(svgPath);\n\n    const subpaths: SubPath[] = [];\n    let currentSubPath: SubPath | null = null;\n\n    let lastX = 0;\n    let lastY = 0;\n\n    for (let i = 0; i < commands.length; i++)\n    {\n        const command = commands[i];\n        const type = command[0];\n        const data = command; // alias for 1-based referencing\n\n        switch (type)\n        {\n            case 'M':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'm':\n\n                lastX += data[1];\n                lastY += data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'H':\n                lastX = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'h':\n                lastX += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'V':\n                lastY = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'v':\n                lastY += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'L':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'l':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'C':\n\n                lastX = data[5];\n                lastY = data[6];\n\n                path.bezierCurveTo(\n                    data[1], data[2],\n                    data[3], data[4],\n                    lastX, lastY\n                );\n                break;\n            case 'c':\n                path.bezierCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                    lastX + data[5], lastY + data[6]\n                );\n\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case 'S':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.bezierCurveToShort(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 's':\n                path.bezierCurveToShort(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'Q':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.quadraticCurveTo(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 'q':\n                path.quadraticCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4]\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'T':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 't':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 'A':\n                lastX = data[6];\n                lastY = data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'a':\n                lastX += data[6];\n                lastY += data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'Z':\n            case 'z':\n                path.closePath();\n                if (subpaths.length > 0)\n                {\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath)\n                    {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    }\n                    else\n                    {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                // #if _DEBUG\n                warn(`Unknown SVG path command: ${type}`);\n                // #endif\n        }\n\n        if (type !== 'Z' && type !== 'z')\n        {\n            if (currentSubPath === null)\n            {\n                currentSubPath = { startX: lastX, startY: lastY };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n\n    return path;\n}\n","\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n","import { Circle } from '../../../../maths/shapes/Circle.mjs';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse.mjs';\nimport { Polygon } from '../../../../maths/shapes/Polygon.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle.mjs';\nimport { Bounds } from '../../../container/bounds/Bounds.mjs';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier.mjs';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic.mjs';\nimport { buildArc } from '../buildCommands/buildArc.mjs';\nimport { buildArcTo } from '../buildCommands/buildArcTo.mjs';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg.mjs';\nimport { roundedShapeQuadraticCurve, roundedShapeArc } from './roundShape.mjs';\n\n\"use strict\";\nconst tempRectangle = new Rectangle();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds();\n    this._graphicsPath2D = graphicsPath2D;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (!lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\nexport { ShapePath };\n//# sourceMappingURL=ShapePath.mjs.map\n","// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @memberof scene\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: { shape: ShapePrimitive, transform?: Matrix }[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n            // build out the path points\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (!lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    this.type = \"circle\";\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return false;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  strokeContains(x, y, width) {\n    if (this.radius === 0)\n      return false;\n    const dx = this.x - x;\n    const dy = this.y - y;\n    const r = this.radius;\n    const w2 = width / 2;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < r + w2 && distance > r - w2;\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.x = this.x - this.radius;\n    out.y = this.y - this.radius;\n    out.width = this.radius * 2;\n    out.height = this.radius * 2;\n    return out;\n  }\n  /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(circle) {\n    this.x = circle.x;\n    this.y = circle.y;\n    this.radius = circle.radius;\n    return this;\n  }\n  /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(circle) {\n    circle.copyFrom(this);\n    return circle;\n  }\n  toString() {\n    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\nexport { Circle };\n//# sourceMappingURL=Circle.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Circle object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @memberof maths\n */\nexport class Circle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this circle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this circle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The radius of the circle\n     *  @default 0\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'circle';\n\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    constructor(x = 0, y = 0, radius = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    /**\n     * Creates a clone of this Circle instance\n     * @returns A copy of the Circle\n     */\n    public clone(): Circle\n    {\n        return new Circle(this.x, this.y, this.radius);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.radius <= 0) return false;\n\n        const r2 = this.radius * this.radius;\n        let dx = (this.x - x);\n        let dy = (this.y - y);\n\n        dx *= dx;\n        dy *= dy;\n\n        return (dx + dy <= r2);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width - The width of the line to check\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public strokeContains(x: number, y: number, width: number): boolean\n    {\n        if (this.radius === 0) return false;\n\n        const dx = (this.x - x);\n        const dy = (this.y - y);\n        const r = this.radius;\n        const w2 = width / 2;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n        return (distance < r + w2 && distance > r - w2);\n    }\n\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another circle to this one.\n     * @param circle - The circle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(circle: Circle): this\n    {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n\n        return this;\n    }\n\n    /**\n     * Copies this circle to another one.\n     * @param circle - The circle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(circle: Circle): Circle\n    {\n        circle.copyFrom(this);\n\n        return circle;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    this.type = \"ellipse\";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  strokeContains(x, y, width) {\n    const { halfWidth, halfHeight } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const halfStrokeWidth = width / 2;\n    const innerA = halfWidth - halfStrokeWidth;\n    const innerB = halfHeight - halfStrokeWidth;\n    const outerA = halfWidth + halfStrokeWidth;\n    const outerB = halfHeight + halfStrokeWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n    const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @returns The framing rectangle\n   */\n  getBounds() {\n    return new Rectangle(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\n\nexport { Ellipse };\n//# sourceMappingURL=Ellipse.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * ```js\n * import { Ellipse } from 'pixi.js';\n *\n * const ellipse = new Ellipse(0, 0, 20, 10); // 40x20 rectangle\n * const isPointInEllipse = ellipse.contains(0, 0); // true\n * ```\n * @memberof maths\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance\n     * @returns {Ellipse} A copy of the ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public strokeContains(x: number, y: number, width: number): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const halfStrokeWidth = width / 2;\n        const innerA = halfWidth - halfStrokeWidth;\n        const innerB = halfHeight - halfStrokeWidth;\n        const outerA = halfWidth + halfStrokeWidth;\n        const outerB = halfHeight + halfStrokeWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerA * innerA))\n                           + ((normalizedY * normalizedY) / (innerB * innerB));\n        const outerEllipse = ((normalizedX * normalizedX) / (outerA * outerA))\n                           + ((normalizedY * normalizedY) / (outerB * outerB));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object\n     * @returns The framing rectangle\n     */\n    public getBounds(): Rectangle\n    {\n        return new Rectangle(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @param ellipse - The ellipse to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @param ellipse - The ellipse to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n","import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment.mjs';\nimport { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    this.type = \"polygon\";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== \"number\") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth) {\n    const halfStrokeWidth = strokeWidth / 2;\n    const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n    const { points } = this;\n    const iterationLength = points.length - (this.closePath ? 0 : 2);\n    for (let i = 0; i < iterationLength; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      if (distanceSqrd <= halfStrokeWidthSqrd) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, \"\")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\nexport { Polygon };\n//# sourceMappingURL=Polygon.mjs.map\n","import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { PointData } from '../point/PointData';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * A class to define a shape via user defined coordinates.\n *\n *\n * `Polygon` can accept the following different constructor arguments:\n * - An array of `Point` objects\n * - An array of coordinate pairs\n *\n *\n * These can be passed as a single array, or as a sequence of arguments.\n * ```js\n * import { Polygon } from 'pixi.js';\n *\n * // create a polygon object from an array of points, or an array of coordinate pairs\n * const polygon1 = new Polygon([ new Point(0, 0), new Point(0, 100), new Point(100, 100) ]);\n * const polygon2 = new Polygon([ 0, 0, 0, 100, 100, 100 ]);\n *\n * // or create a polygon object from a sequence of points, or coordinate pairs\n * const polygon3 = new Polygon(new Point(0, 0), new Point(0, 100), new Point(100, 100));\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n * ```\n * @memberof maths\n */\nexport class Polygon implements ShapePrimitive\n{\n    /** An array of the points of this polygon. */\n    public points: number[];\n\n    /** `false` after moveTo, `true` after `closePath`. In all other cases it is `true`. */\n    public closePath: boolean;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'polygon';\n\n    constructor(points: PointData[] | number[]);\n    constructor(...points: PointData[] | number[]);\n    /**\n     * @param points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points: (PointData[] | number[])[] | PointData[] | number[])\n    {\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number')\n        {\n            const p: number[] = [];\n\n            for (let i = 0, il = flat.length; i < il; i++)\n            {\n                p.push((flat[i] as PointData).x, (flat[i] as PointData).y);\n            }\n\n            flat = p;\n        }\n\n        this.points = flat as number[];\n\n        this.closePath = true;\n    }\n\n    /**\n     * Creates a clone of this polygon.\n     * @returns - A copy of the polygon.\n     */\n    public clone(): Polygon\n    {\n        const points = this.points.slice();\n        const polygon = new Polygon(points);\n\n        polygon.closePath = this.closePath;\n\n        return polygon;\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this polygon.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this polygon\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number): boolean\n    {\n        const halfStrokeWidth = strokeWidth / 2;\n        const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n        const { points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n\n        for (let i = 0; i < iterationLength; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n\n            const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n\n            if (distanceSqrd <= halfStrokeWidthSqrd)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the framing rectangle of the polygon as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        const points = this.points;\n\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0, n = points.length; i < n; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        out.x = minX;\n        out.width = maxX - minX;\n\n        out.y = minY;\n        out.height = maxY - minY;\n\n        return out;\n    }\n\n    /**\n     * Copies another polygon to this one.\n     * @param polygon - The polygon to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(polygon: Polygon): this\n    {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n\n        return this;\n    }\n\n    /**\n     * Copies this polygon to another one.\n     * @param polygon - The polygon to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(polygon: Polygon): Polygon\n    {\n        polygon.copyFrom(this);\n\n        return polygon;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Polygon`\n            + `closeStroke=${this.closePath}`\n            + `points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, '')}]`;\n    }\n    // #endif\n\n    /**\n     * Get the last X coordinate of the polygon\n     * @readonly\n     */\n    get lastX(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon\n     * @readonly\n     */\n    get lastY(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n\n    /**\n     * Get the first X coordinate of the polygon\n     * @readonly\n     */\n    get x(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n    /**\n     * Get the first Y coordinate of the polygon\n     * @readonly\n     */\n    get y(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n}\n\n","\"use strict\";\nfunction squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {\n  const a = x - x1;\n  const b = y - y1;\n  const c = x2 - x1;\n  const d = y2 - y1;\n  const dot = a * c + b * d;\n  const lenSq = c * c + d * d;\n  let param = -1;\n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  let xx;\n  let yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * c;\n    yy = y1 + param * d;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return dx * dx + dy * dy;\n}\n\nexport { squaredDistanceToLineSegment };\n//# sourceMappingURL=squaredDistanceToLineSegment.mjs.map\n","export function squaredDistanceToLineSegment(\n    x: number, y: number,\n    x1: number, y1: number,\n    x2: number, y2: number\n): number\n{\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n\n    const dot = (a * c) + (b * d);\n    const lenSq = (c * c) + (d * d);\n    let param = -1;\n\n    if (lenSq !== 0)\n    {\n        param = dot / lenSq;\n    }\n\n    let xx; let\n        yy;\n\n    if (param < 0)\n    {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1)\n    {\n        xx = x2;\n        yy = y2;\n    }\n\n    else\n    {\n        xx = x1 + (param * c);\n        yy = y1 + (param * d);\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n\n    return (dx * dx) + (dy * dy);\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nconst isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {\n  const dx = pX - cornerX;\n  const dy = pY - cornerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    this.type = \"roundedRectangle\";\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n  }\n  /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(pX, pY, strokeWidth) {\n    const { x, y, width, height, radius } = this;\n    const halfStrokeWidth = strokeWidth / 2;\n    const innerX = x + radius;\n    const innerY = y + radius;\n    const innerWidth = width - radius * 2;\n    const innerHeight = height - radius * 2;\n    const rightBound = x + width;\n    const bottomBound = y + height;\n    if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {\n      return true;\n    }\n    if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {\n      return true;\n    }\n    return (\n      // Top-left\n      pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)\n    );\n  }\n  toString() {\n    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\nexport { RoundedRectangle };\n//# sourceMappingURL=RoundedRectangle.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n// Check corner within stroke width\nconst isCornerWithinStroke = (\n    pX: number,\n    pY: number,\n    cornerX: number,\n    cornerY: number,\n    radius: number,\n    halfStrokeWidth: number\n) =>\n{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n    return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\n\n/**\n * The `RoundedRectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`, including a `radius` property that\n * defines the radius of the rounded corners.\n * @memberof maths\n */\nexport class RoundedRectangle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rounded rectangle\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rounded rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * Controls the radius of the rounded corners\n     * @default 20\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    public readonly type = 'roundedRectangle';\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n\n    /**\n     * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n\n        return out;\n    }\n\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @returns - A copy of the rounded rectangle.\n     */\n    public clone(): RoundedRectangle\n    {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: RoundedRectangle): this\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: RoundedRectangle): RoundedRectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width)\n        {\n            if (y >= this.y && y <= this.y + this.height)\n            {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                || (x >= this.x + radius && x <= this.x + this.width - radius))\n                {\n                    return true;\n                }\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param pX - The X coordinate of the point to test\n     * @param pY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(pX: number, pY: number, strokeWidth: number): boolean\n    {\n        const { x, y, width, height, radius } = this;\n\n        const halfStrokeWidth = strokeWidth / 2;\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - (radius * 2);\n        const innerHeight = height - (radius * 2);\n        const rightBound = x + width;\n        const bottomBound = y + height;\n\n        // Check if point is within the vertical edges (excluding corners)\n        if (((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth)\n             || (pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth))\n            && pY >= innerY && pY <= innerY + innerHeight)\n        {\n            return true;\n        }\n\n        // Check if point is within the horizontal edges (excluding corners)\n        if (((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth)\n             || (pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth))\n            && pX >= innerX && pX <= innerX + innerWidth)\n        {\n            return true;\n        }\n\n        // Top-left, top-right, bottom-right, bottom-left corners\n        return (\n            // Top-left\n            (pX < innerX && pY < innerY\n                && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth))\n            //  top-right\n            || (pX > rightBound - radius && pY < innerY\n                && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth))\n            // bottom-right\n            || (pX > rightBound - radius && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth))\n            // bottom-left\n            || (pX < innerX && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)));\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}`\n            + `width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveBezier };\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n","// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (mAngleTolerance < curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveQuadratic };\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n","// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n","\"use strict\";\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\nexport { buildArc };\n//# sourceMappingURL=buildArc.mjs.map\n","export function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n","import { buildArc } from './buildArc.mjs';\n\n\"use strict\";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\nexport { buildArcTo };\n//# sourceMappingURL=buildArcTo.mjs.map\n","import { buildArc } from './buildArc';\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n */\nexport function buildArcTo(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    radius: number,\n): void\n{\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n\n        return;\n    }\n\n    const dd = (a1 * a1) + (b1 * b1);\n    const cc = (a2 * a2) + (b2 * b2);\n    const tt = (a1 * a2) + (b1 * b2);\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = (k1 * b2) + (k2 * b1);\n    const cy = (k1 * a2) + (k2 * a1);\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n\n    buildArc(points,\n        (cx + x1),\n        (cy + y1),\n        radius,\n        startAngle,\n        endAngle,\n        b1 * a2 > b2 * a1\n    );\n}\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier.mjs';\n\n\"use strict\";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\nexport { buildArcToSvg };\n//# sourceMappingURL=buildArcToSvg.mjs.map\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n","\"use strict\";\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\nexport { roundedShapeArc, roundedShapeQuadraticCurve };\n//# sourceMappingURL=roundShape.mjs.map\n","import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { GraphicsPath } from '../path/GraphicsPath.mjs';\n\n\"use strict\";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === \"string\") {\n    const div = document.createElement(\"div\");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector(\"svg\");\n  }\n  const session = {\n    context: graphicsContext,\n    path: new GraphicsPath()\n  };\n  renderChildren(svg, session, null, null);\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  session.context.fillStyle = fillStyle;\n  session.context.strokeStyle = strokeStyle;\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case \"path\":\n      d = svg.getAttribute(\"d\");\n      graphicsPath = new GraphicsPath(d);\n      session.context.path(graphicsPath);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"circle\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      r = parseFloatAttribute(svg, \"r\", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"rect\":\n      x = parseFloatAttribute(svg, \"x\", 0);\n      y = parseFloatAttribute(svg, \"y\", 0);\n      width = parseFloatAttribute(svg, \"width\", 0);\n      height = parseFloatAttribute(svg, \"height\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"ellipse\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"line\":\n      x1 = parseFloatAttribute(svg, \"x1\", 0);\n      y1 = parseFloatAttribute(svg, \"y1\", 0);\n      x2 = parseFloatAttribute(svg, \"x2\", 0);\n      y2 = parseFloatAttribute(svg, \"y2\", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"polygon\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"polyline\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"g\":\n    case \"svg\":\n      break;\n    default: {\n      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nfunction parseFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\nfunction parseStyle(svg) {\n  const style = svg.getAttribute(\"style\");\n  const strokeStyle = {};\n  const fillStyle = {};\n  let useFill = false;\n  let useStroke = false;\n  if (style) {\n    const styleParts = style.split(\";\");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i];\n      const [key, value] = stylePart.split(\":\");\n      switch (key) {\n        case \"stroke\":\n          if (value !== \"none\") {\n            strokeStyle.color = Color.shared.setValue(value).toNumber();\n            useStroke = true;\n          }\n          break;\n        case \"stroke-width\":\n          strokeStyle.width = Number(value);\n          break;\n        case \"fill\":\n          if (value !== \"none\") {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(value).toNumber();\n          }\n          break;\n        case \"fill-opacity\":\n          fillStyle.alpha = Number(value);\n          break;\n        case \"stroke-opacity\":\n          strokeStyle.alpha = Number(value);\n          break;\n        case \"opacity\":\n          fillStyle.alpha = Number(value);\n          strokeStyle.alpha = Number(value);\n          break;\n      }\n    }\n  } else {\n    const stroke = svg.getAttribute(\"stroke\");\n    if (stroke && stroke !== \"none\") {\n      useStroke = true;\n      strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n      strokeStyle.width = parseFloatAttribute(svg, \"stroke-width\", 1);\n    }\n    const fill = svg.getAttribute(\"fill\");\n    if (fill && fill !== \"none\") {\n      useFill = true;\n      fillStyle.color = Color.shared.setValue(fill).toNumber();\n    }\n  }\n  return {\n    strokeStyle: useStroke ? strokeStyle : null,\n    fillStyle: useFill ? fillStyle : null\n  };\n}\n\nexport { SVGParser };\n//# sourceMappingURL=SVGParser.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { GraphicsPath } from '../path/GraphicsPath';\n\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillStyle,\n    GraphicsContext,\n    StrokeStyle,\n} from '../GraphicsContext';\n\ninterface Session\n{\n    context: GraphicsContext;\n    path: GraphicsPath;\n}\n\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    if (typeof svg === 'string')\n    {\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    const session = {\n        context: graphicsContext,\n        path: new GraphicsPath(),\n    };\n\n    renderChildren(svg, session, null, null);\n\n    return graphicsContext;\n}\n\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n            d = svg.getAttribute('d') as string;\n\n            graphicsPath = new GraphicsPath(d);\n\n            session.context.path(graphicsPath);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'circle':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            r = parseFloatAttribute(svg, 'r', 0);\n\n            session.context.ellipse(cx, cy, r, r);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'rect':\n            x = parseFloatAttribute(svg, 'x', 0);\n            y = parseFloatAttribute(svg, 'y', 0);\n\n            width = parseFloatAttribute(svg, 'width', 0);\n            height = parseFloatAttribute(svg, 'height', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'ellipse':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry); // , 0, Math.PI * 2);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'line':\n            x1 = parseFloatAttribute(svg, 'x1', 0);\n            y1 = parseFloatAttribute(svg, 'y1', 0);\n\n            x2 = parseFloatAttribute(svg, 'x2', 0);\n            y2 = parseFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, true);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, false);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        // children will cover these two..\n        case 'g':\n        case 'svg':\n            break;\n        default: {\n            // eslint-disable-next-line no-console\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n\nfunction parseFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n\nfunction parseStyle(svg: SVGElement): { strokeStyle: ConvertedStrokeStyle; fillStyle: ConvertedFillStyle }\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    let useFill = false;\n    let useStroke = false;\n\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i];\n\n            const [key, value] = stylePart.split(':');\n\n            switch (key)\n            {\n                case 'stroke':\n                    if (value !== 'none')\n                    {\n                        strokeStyle.color = Color.shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n\n                    break;\n                case 'stroke-width':\n                    strokeStyle.width = Number(value);\n                    break;\n                case 'fill':\n                    if (value !== 'none')\n                    {\n                        useFill = true;\n                        fillStyle.color = Color.shared.setValue(value).toNumber();\n                    }\n                    break;\n                case 'fill-opacity':\n                    fillStyle.alpha = Number(value);\n                    break;\n                case 'stroke-opacity':\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case 'opacity':\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    }\n    else\n    {\n        const stroke = svg.getAttribute('stroke');\n\n        if (stroke && stroke !== 'none')\n        {\n            useStroke = true;\n            strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n\n            strokeStyle.width = parseFloatAttribute(svg, 'stroke-width', 1);\n        }\n\n        const fill = svg.getAttribute('fill');\n\n        if (fill && fill !== 'none')\n        {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(fill).toNumber();\n        }\n    }\n\n    return {\n        strokeStyle: useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: useFill ? (fillStyle as ConvertedFillStyle) : null,\n    };\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { FillGradient } from '../fill/FillGradient.mjs';\nimport { FillPattern } from '../fill/FillPattern.mjs';\n\n\"use strict\";\nfunction convertFillInputToFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  let fillStyleToParse;\n  let styleToMerge;\n  if (value?.fill) {\n    styleToMerge = value.fill;\n    fillStyleToParse = { ...defaultStyle, ...value };\n  } else {\n    styleToMerge = value;\n    fillStyleToParse = defaultStyle;\n  }\n  if (Color.isColorLike(styleToMerge)) {\n    const temp = Color.shared.setValue(styleToMerge ?? 0);\n    const opts = {\n      ...fillStyleToParse,\n      color: temp.toNumber(),\n      alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,\n      texture: Texture.WHITE\n    };\n    return opts;\n  } else if (styleToMerge instanceof FillPattern) {\n    const pattern = styleToMerge;\n    return {\n      ...fillStyleToParse,\n      color: 16777215,\n      texture: pattern.texture,\n      matrix: pattern.transform,\n      fill: fillStyleToParse.fill ?? null\n    };\n  } else if (styleToMerge instanceof FillGradient) {\n    const gradient = styleToMerge;\n    gradient.buildLinearGradient();\n    return {\n      ...fillStyleToParse,\n      color: 16777215,\n      texture: gradient.texture,\n      matrix: gradient.transform\n    };\n  }\n  const style = { ...defaultStyle, ...value };\n  if (style.texture) {\n    if (style.texture !== Texture.WHITE) {\n      const m = style.matrix?.invert() || new Matrix();\n      m.scale(\n        1 / style.texture.frame.width,\n        1 / style.texture.frame.height\n      );\n      style.matrix = m;\n    }\n    const sourceStyle = style.texture.source.style;\n    if (sourceStyle.addressMode === \"clamp-to-edge\") {\n      sourceStyle.addressMode = \"repeat\";\n    }\n  }\n  const color = Color.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  style.matrix = style.matrix ? style.matrix.clone() : null;\n  return style;\n}\n\nexport { convertFillInputToFillStyle };\n//# sourceMappingURL=convertFillInputToFillStyle.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    FillStyle,\n    FillStyleInputs,\n    PatternFillStyle,\n} from '../GraphicsContext';\n\nexport function convertFillInputToFillStyle(\n    value: FillStyleInputs,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    let fillStyleToParse: ConvertedFillStyle;\n    let styleToMerge: FillStyleInputs;\n\n    if ((value as PatternFillStyle)?.fill)\n    {\n        styleToMerge = (value as PatternFillStyle).fill;\n        fillStyleToParse = { ...defaultStyle, ...(value as PatternFillStyle) };\n    }\n    else\n    {\n        styleToMerge = value;\n        fillStyleToParse = defaultStyle;\n    }\n\n    if (Color.isColorLike(styleToMerge as ColorSource))\n    {\n        const temp = Color.shared.setValue(styleToMerge as ColorSource ?? 0);\n        const opts: ConvertedFillStyle = {\n            ...fillStyleToParse,\n            color: temp.toNumber(),\n            alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,\n            texture: Texture.WHITE,\n        };\n\n        return opts;\n    }\n    else if (styleToMerge instanceof FillPattern)\n    {\n        const pattern = styleToMerge as FillPattern;\n\n        return {\n            ...fillStyleToParse,\n            color: 0xffffff,\n            texture: pattern.texture,\n            matrix: pattern.transform,\n            fill: fillStyleToParse.fill ?? null,\n        };\n    }\n\n    // // TODO Texture\n    else if (styleToMerge instanceof FillGradient)\n    {\n        const gradient = styleToMerge as FillGradient;\n\n        gradient.buildLinearGradient();\n\n        return {\n            ...fillStyleToParse,\n            color: 0xffffff,\n            texture: gradient.texture,\n            matrix: gradient.transform,\n        };\n    }\n\n    const style: FillStyle = { ...defaultStyle, ...(value as FillStyle) };\n\n    if (style.texture)\n    {\n        if (style.texture !== Texture.WHITE)\n        {\n            const m = style.matrix?.invert() || new Matrix();\n\n            m.scale(\n                1 / style.texture.frame.width,\n                1 / style.texture.frame.height\n            );\n\n            style.matrix = m;\n        }\n\n        const sourceStyle = style.texture.source.style;\n\n        if (sourceStyle.addressMode === 'clamp-to-edge')\n        {\n            sourceStyle.addressMode = 'repeat';\n        }\n    }\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null; // todo: lets optimise this!\n\n    // its a regular fill style!\n    return style as ConvertedFillStyle;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _MeshGeometry = class _MeshGeometry extends Geometry {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      deprecation(v8_0_0, \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new Buffer({\n      data: positions,\n      label: \"attribute-mesh-positions\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const uvBuffer = new Buffer({\n      data: uvs,\n      label: \"attribute-mesh-uvs\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const indexBuffer = new Buffer({\n      data: indices,\n      label: \"index-mesh-buffer\",\n      shrinkToFit,\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = \"auto\";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: \"triangle-list\",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\nexport { MeshGeometry };\n//# sourceMappingURL=MeshGeometry.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry.mjs';\n\n\"use strict\";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const positions = this.positions;\n    const w = this._leftWidth + this._rightWidth;\n    const scaleW = this.width > w ? 1 : this.width / w;\n    const h = this._topHeight + this._bottomHeight;\n    const scaleH = this.height > h ? 1 : this.height / h;\n    const scale = Math.min(scaleW, scaleH);\n    positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n    positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;\n    positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n    positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n    positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;\n    positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n    this.getBuffer(\"aPosition\").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer(\"aUV\").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\nexport { NineSliceGeometry };\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const positions = this.positions;\n\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1.0 : this.width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1.0 : this.height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - (this._bottomHeight * scale);\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - (this._rightWidth * scale);\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(v8_0_0, \"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead\");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\nexport { PlaneGeometry };\n//# sourceMappingURL=PlaneGeometry.mjs.map\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\n\n\"use strict\";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = fontStringFromTextStyle(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    let width = context.measureText(text).width;\n    if (width > 0) {\n      if (useExperimentalLetterSpacing) {\n        width -= letterSpacing;\n      } else {\n        width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n      }\n    }\n    return width;\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext(\"2d\", contextSettings);\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== \"\") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convienience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== \"number\") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = \"\") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext(\"2d\", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = DOMAdapter.get().createCanvas();\n      } catch (ex) {\n        canvas = DOMAdapter.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === \"function\") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\nexport { CanvasTextMetrics };\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @memberof text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { TextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = TextMetrics.measureText('Your text', style);\n * @memberof text\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|ÉqÅ';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) => [...segmenter.segment(s)].map((x) => x.segment);\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result !== undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@see TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    private static readonly _measurementCache: Record<string, CanvasTextMetrics> = {};\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}:${style.styleKey}`;\n\n        // TODO - if we find this starts to go nuts with memory, we can remove the cache\n        // or instead just stick a usage tick that we increment each time we return it.\n        // if some are not used, we can just tidy them up!\n        if (CanvasTextMetrics._measurementCache[textKey]) return CanvasTextMetrics._measurementCache[textKey];\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth * 2))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // CanvasTextMetrics._measurementCache[textKey] = measurements;\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        let width = context.measureText(text).width;\n\n        if (width > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                width -= letterSpacing;\n            }\n            else\n            {\n                width += (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n            }\n        }\n\n        return width;\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convienience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                tokens.push(char);\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (ex)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n","\"use strict\";\nconst genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === \"number\" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(\",\");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `\"${fontFamily}\"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(\",\")}`;\n}\n\nexport { fontStringFromTextStyle };\n//# sourceMappingURL=fontStringFromTextStyle.mjs.map\n","import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../color/Color.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient.mjs';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext.mjs';\nimport { convertFillInputToFillStyle } from '../graphics/shared/utils/convertFillInputToFillStyle.mjs';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey.mjs';\n\n\"use strict\";\nconst _TextStyle = class _TextStyle extends EventEmitter {\n  constructor(style = {}) {\n    super();\n    convertV7Tov8Style(style);\n    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };\n    for (const key in fullStyle) {\n      const thisKey = key;\n      this[thisKey] = fullStyle[key];\n    }\n    this.update();\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align = value;\n    this.update();\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(value) {\n    this._breakWords = value;\n    this.update();\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(value) {\n    if (value !== null && typeof value === \"object\") {\n      this._dropShadow = {\n        ..._TextStyle.defaultDropShadow,\n        ...value\n      };\n    } else {\n      this._dropShadow = value ? {\n        ..._TextStyle.defaultDropShadow\n      } : null;\n    }\n    this.update();\n  }\n  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(value) {\n    this._fontFamily = value;\n    this.update();\n  }\n  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(value) {\n    if (typeof value === \"string\") {\n      this._fontSize = parseInt(value, 10);\n    } else {\n      this._fontSize = value;\n    }\n    this.update();\n  }\n  /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(value) {\n    this._fontStyle = value;\n    this.update();\n  }\n  /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(value) {\n    this._fontVariant = value;\n    this.update();\n  }\n  /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(value) {\n    this._fontWeight = value;\n    this.update();\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(value) {\n    this._leading = value;\n    this.update();\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing = value;\n    this.update();\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(value) {\n    this._lineHeight = value;\n    this.update();\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(value) {\n    this._padding = value;\n    this.update();\n  }\n  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n  get trim() {\n    return this._trim;\n  }\n  set trim(value) {\n    this._trim = value;\n    this.update();\n  }\n  /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(value) {\n    this._textBaseline = value;\n    this.update();\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(value) {\n    this._whiteSpace = value;\n    this.update();\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(value) {\n    this._wordWrap = value;\n    this.update();\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(value) {\n    this._wordWrapWidth = value;\n    this.update();\n  }\n  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n  get fill() {\n    return this._originalFill;\n  }\n  set fill(value) {\n    if (value === this._originalFill)\n      return;\n    this._originalFill = value;\n    this._fill = convertFillInputToFillStyle(\n      value === 0 ? \"black\" : value,\n      GraphicsContext.defaultFillStyle\n    );\n    this.update();\n  }\n  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n  get stroke() {\n    return this._originalStroke;\n  }\n  set stroke(value) {\n    if (value === this._originalStroke)\n      return;\n    this._originalStroke = value;\n    this._stroke = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle);\n    this.update();\n  }\n  _generateKey() {\n    this._styleKey = generateTextStyleKey(this);\n    return this._styleKey;\n  }\n  update() {\n    this._styleKey = null;\n    this.emit(\"update\", this);\n  }\n  /** Resets all properties to the default values */\n  reset() {\n    const defaultStyle = _TextStyle.defaultTextStyle;\n    for (const key in defaultStyle) {\n      this[key] = defaultStyle[key];\n    }\n  }\n  get styleKey() {\n    return this._styleKey || this._generateKey();\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */\n  clone() {\n    return new _TextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      leading: this.leading,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      textBaseline: this.textBaseline,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth\n    });\n  }\n  /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */\n  destroy(options = false) {\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fill?.texture) {\n        this._fill.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalFill?.texture) {\n        this._originalFill.texture.destroy(destroyTextureSource);\n      }\n      if (this._stroke?.texture) {\n        this._stroke.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalStroke?.texture) {\n        this._originalStroke.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fill = null;\n    this._stroke = null;\n    this.dropShadow = null;\n    this._originalStroke = null;\n    this._originalFill = null;\n  }\n};\n/** The default drop shadow settings */\n_TextStyle.defaultDropShadow = {\n  /** Set alpha for the drop shadow */\n  alpha: 1,\n  /** Set a angle of the drop shadow */\n  angle: Math.PI / 6,\n  /** Set a shadow blur radius */\n  blur: 0,\n  /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n  color: \"black\",\n  /** Set a distance of the drop shadow */\n  distance: 5\n};\n/** The default text style settings */\n_TextStyle.defaultTextStyle = {\n  /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */\n  align: \"left\",\n  /** See {@link TextStyle.breakWords} */\n  breakWords: false,\n  /** See {@link TextStyle.dropShadow} */\n  dropShadow: null,\n  /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  fill: \"black\",\n  /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */\n  fontFamily: \"Arial\",\n  /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */\n  fontSize: 26,\n  /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */\n  fontStyle: \"normal\",\n  /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */\n  fontVariant: \"normal\",\n  /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  fontWeight: \"normal\",\n  /** See {@link TextStyle.leading} */\n  leading: 0,\n  /** See {@link TextStyle.letterSpacing} */\n  letterSpacing: 0,\n  /** See {@link TextStyle.lineHeight} */\n  lineHeight: 0,\n  /** See {@link TextStyle.padding} */\n  padding: 0,\n  /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */\n  stroke: null,\n  /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  textBaseline: \"alphabetic\",\n  /** See {@link TextStyle.trim} */\n  trim: false,\n  /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */\n  whiteSpace: \"pre\",\n  /** See {@link TextStyle.wordWrap} */\n  wordWrap: false,\n  /** See {@link TextStyle.wordWrapWidth} */\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction convertV7Tov8Style(style) {\n  const oldStyle = style;\n  if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n    const defaults = TextStyle.defaultDropShadow;\n    style.dropShadow = {\n      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n      angle: oldStyle.dropShadowAngle ?? defaults.angle,\n      blur: oldStyle.dropShadowBlur ?? defaults.blur,\n      color: oldStyle.dropShadowColor ?? defaults.color,\n      distance: oldStyle.dropShadowDistance ?? defaults.distance\n    };\n  }\n  if (oldStyle.strokeThickness) {\n    deprecation(v8_0_0, \"strokeThickness is now a part of stroke\");\n    const color = oldStyle.stroke;\n    style.stroke = {\n      color,\n      width: oldStyle.strokeThickness\n    };\n  }\n  if (Array.isArray(oldStyle.fill)) {\n    deprecation(v8_0_0, \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n    const gradientFill = new FillGradient(0, 0, 0, style.fontSize * 1.7);\n    const fills = oldStyle.fill.map((color) => Color.shared.setValue(color).toNumber());\n    fills.forEach((number, index) => {\n      const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n      gradientFill.addColorStop(ratio, number);\n    });\n    style.fill = {\n      fill: gradientFill\n    };\n  }\n}\n\nexport { TextStyle };\n//# sourceMappingURL=TextStyle.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport { convertFillInputToFillStyle } from '../graphics/shared/utils/convertFillInputToFillStyle';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillStyle,\n    FillStyleInputs\n} from '../graphics/shared/GraphicsContext';\n\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n// eslint-disable-next-line max-len\nexport type TextStyleFontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * A collection of text related classes.\n * @namespace text\n */\n\n/**\n * A drop shadow effect.\n * @memberof text\n */\nexport type TextDropShadow = {\n    /** Set alpha for the drop shadow  */\n    alpha: number;\n    /** Set a angle of the drop shadow */\n    angle: number;\n    /** Set a shadow blur radius */\n    blur: number;\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n    color: ColorSource;\n    /** Set a distance of the drop shadow */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances.\n * ```js\n * const textStyle = new TextStyle({\n *    fontSize: 12,\n *    fill: 'black',\n * });\n * ```\n * @see {@link text.TextStyle}\n * @memberof text\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    align?: TextStyleAlign;\n    /** Indicates if lines can be wrapped within words, it needs `wordWrap` to be set to `true` */\n    breakWords?: boolean;\n    /** Set a drop shadow for the text */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.\n     * Can be an array to create a gradient, e.g., `['#000000','#FFFFFF']`\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    fill?: FillStyleInputs;\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    fontFamily?: string | string[];\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    fontSize?: number | string;\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /** A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00' */\n    stroke?: FillStyleInputs;\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    textBaseline?: TextStyleTextBaseline;\n    trim?: boolean,\n    /**\n     * Determines whether newlines & spaces are collapsed or preserved \"normal\"\n     * (collapse, collapse), \"pre\" (preserve, preserve) | \"pre-line\" (preserve,\n     * collapse). It needs wordWrap to be set to true.\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n}\n\n/**\n * A TextStyle Object contains information to decorate a Text objects.\n *\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @memberof text\n * @example\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *   fontSize: 36,\n * });\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /** The default drop shadow settings */\n    public static defaultDropShadow: TextDropShadow = {\n        /** Set alpha for the drop shadow */\n        alpha: 1,\n        /** Set a angle of the drop shadow */\n        angle: Math.PI / 6,\n        /** Set a shadow blur radius */\n        blur: 0,\n        /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n        color: 'black',\n        /** Set a distance of the drop shadow */\n        distance: 5,\n    };\n\n    /** The default text style settings */\n    public static defaultTextStyle: TextStyleOptions = {\n        /**\n         * See {@link TextStyle.align}\n         * @type {'left'|'center'|'right'|'justify'}\n         */\n        align: 'left',\n        /** See {@link TextStyle.breakWords} */\n        breakWords: false,\n        /** See {@link TextStyle.dropShadow} */\n        dropShadow:  null,\n        /**\n         * See {@link TextStyle.fill}\n         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n         */\n        fill: 'black',\n        /**\n         * See {@link TextStyle.fontFamily}\n         * @type {string|string[]}\n         */\n        fontFamily: 'Arial',\n        /**\n         * See {@link TextStyle.fontSize}\n         * @type {number|string}\n         */\n        fontSize: 26,\n        /**\n         * See {@link TextStyle.fontStyle}\n         * @type {'normal'|'italic'|'oblique'}\n         */\n        fontStyle: 'normal',\n        /**\n         * See {@link TextStyle.fontVariant}\n         * @type {'normal'|'small-caps'}\n         */\n        fontVariant: 'normal',\n        /**\n         * See {@link TextStyle.fontWeight}\n         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n         */\n        fontWeight: 'normal',\n        /** See {@link TextStyle.leading} */\n        leading: 0,\n        /** See {@link TextStyle.letterSpacing} */\n        letterSpacing: 0,\n        /** See {@link TextStyle.lineHeight} */\n        lineHeight: 0,\n        /** See {@link TextStyle.padding} */\n        padding: 0,\n        /**\n         * See {@link TextStyle.stroke}\n         * @type {string|number}\n         */\n        stroke: null,\n        /**\n         * See {@link TextStyle.textBaseline}\n         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n         */\n        textBaseline: 'alphabetic',\n        /** See {@link TextStyle.trim} */\n        trim: false,\n        /**\n         * See {@link TextStyle.whiteSpace}\n         * @type {'normal'|'pre'|'pre-line'}\n         */\n        whiteSpace: 'pre',\n        /** See {@link TextStyle.wordWrap} */\n        wordWrap: false,\n        /** See {@link TextStyle.wordWrapWidth} */\n        wordWrapWidth: 100,\n    };\n\n    // colors!!\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillStyleInputs;\n\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: FillStyleInputs;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n\n    private _padding: number;\n\n    protected _styleKey: string;\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @member {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n    set align(value: TextStyleAlign) { this._align = value; this.update(); }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n    set breakWords(value: boolean) { this._breakWords = value; this.update(); }\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = {\n                ...TextStyle.defaultDropShadow as TextDropShadow,\n                ...value as TextDropShadow\n            };\n        }\n        else\n        {\n            this._dropShadow = value ? {\n                ...TextStyle.defaultDropShadow as TextDropShadow\n            } : null;\n        }\n\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n    set fontFamily(value: string | string[]) { this._fontFamily = value; this.update(); }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n    set fontSize(value: string | number)\n    {\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n    /**\n     * The font style.\n     * @member {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n    set fontStyle(value: TextStyleFontStyle) { this._fontStyle = value; this.update(); }\n    /**\n     * The font variant.\n     * @member {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n    set fontVariant(value: TextStyleFontVariant) { this._fontVariant = value; this.update(); }\n    /**\n     * The font weight.\n     * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n    set fontWeight(value: TextStyleFontWeight) { this._fontWeight = value; this.update(); }\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n    set leading(value: number) { this._leading = value; this.update(); }\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n    set letterSpacing(value: number) { this._letterSpacing = value; this.update(); }\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n    set lineHeight(value: number) { this._lineHeight = value; this.update(); }\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     */\n    get padding(): number { return this._padding; }\n    set padding(value: number) { this._padding = value; this.update(); }\n\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n    get trim(): boolean { return this._trim; }\n    set trim(value: boolean) { this._trim = value; this.update(); }\n    /**\n     * The baseline of the text that is rendered.\n     * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n    set textBaseline(value: TextStyleTextBaseline) { this._textBaseline = value; this.update(); }\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @member {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n    set whiteSpace(value: TextStyleWhiteSpace) { this._whiteSpace = value; this.update(); }\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n    set wordWrap(value: boolean) { this._wordWrap = value; this.update(); }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n    set wordWrapWidth(value: number) { this._wordWrapWidth = value; this.update(); }\n\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n    get fill(): FillStyleInputs\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillStyleInputs)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n        this._fill = convertFillInputToFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): FillStyleInputs\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: FillStyleInputs)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n        this._stroke = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    protected _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this);\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._styleKey = null;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    get styleKey()\n    {\n        return this._styleKey || this._generateKey();\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n        });\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as any;\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance:   oldStyle.dropShadowDistance ?? defaults.distance,\n        };\n    }\n\n    if (oldStyle.strokeThickness)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n\n        style.stroke = {\n            color,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fill))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        const gradientFill = new FillGradient(0, 0, 0, (style.fontSize as number) * 1.7);\n\n        const fills: number[] = oldStyle.fill.map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fills.forEach((number, index) =>\n        {\n            const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n\n            gradientFill.addColorStop(ratio, number);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n","\"use strict\";\nconst valuesToIterateForKeys = [\n  \"_fontFamily\",\n  \"_fontStyle\",\n  \"_fontSize\",\n  \"_fontVariant\",\n  \"_fontWeight\",\n  \"_breakWords\",\n  \"_align\",\n  \"_leading\",\n  \"_letterSpacing\",\n  \"_lineHeight\",\n  \"_textBaseline\",\n  \"_whiteSpace\",\n  \"_wordWrap\",\n  \"_wordWrapWidth\",\n  \"_padding\",\n  \"_cssOverrides\",\n  \"_trim\"\n];\nfunction generateTextStyleKey(style) {\n  const key = [];\n  let index = 0;\n  for (let i = 0; i < valuesToIterateForKeys.length; i++) {\n    const prop = valuesToIterateForKeys[i];\n    key[index++] = style[prop];\n  }\n  index = addFillStyleKey(style._fill, key, index);\n  index = addStokeStyleKey(style._stroke, key, index);\n  return key.join(\"-\");\n}\nfunction addFillStyleKey(fillStyle, key, index) {\n  if (!fillStyle)\n    return index;\n  key[index++] = fillStyle.color;\n  key[index++] = fillStyle.alpha;\n  key[index++] = fillStyle.fill?.uid;\n  return index;\n}\nfunction addStokeStyleKey(strokeStyle, key, index) {\n  if (!strokeStyle)\n    return index;\n  index = addFillStyleKey(strokeStyle, key, index);\n  key[index++] = strokeStyle.width;\n  key[index++] = strokeStyle.alignment;\n  key[index++] = strokeStyle.cap;\n  key[index++] = strokeStyle.join;\n  key[index++] = strokeStyle.miterLimit;\n  return index;\n}\n\nexport { generateTextStyleKey };\n//# sourceMappingURL=generateTextStyleKey.mjs.map\n","import type { FillGradient } from '../../graphics/shared/fill/FillGradient';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../../graphics/shared/GraphicsContext';\nimport type { TextStyle } from '../TextStyle';\n\nconst valuesToIterateForKeys = [\n    '_fontFamily',\n    '_fontStyle',\n    '_fontSize',\n    '_fontVariant',\n    '_fontWeight',\n    '_breakWords',\n    '_align',\n    '_leading',\n    '_letterSpacing',\n    '_lineHeight',\n    '_textBaseline',\n    '_whiteSpace',\n    '_wordWrap',\n    '_wordWrapWidth',\n    '_padding',\n    '_cssOverrides',\n    '_trim'\n];\n\n/**\n * Generates a unique key for the text style.\n * @param style - The style to generate a key for.\n * @returns the key for the style.\n */\nexport function generateTextStyleKey(style: TextStyle): string\n{\n    const key = [];\n\n    let index = 0;\n\n    for (let i = 0; i < valuesToIterateForKeys.length; i++)\n    {\n        const prop = valuesToIterateForKeys[i];\n\n        key[index++] = style[prop as keyof typeof style];\n    }\n\n    index = addFillStyleKey(style._fill, key as string[], index);\n    index = addStokeStyleKey(style._stroke, key as string[], index);\n\n    // TODO - we need to add some shadow stuff here!\n\n    return key.join('-');\n}\n\nfunction addFillStyleKey(fillStyle: ConvertedFillStyle, key: (number | string)[], index: number)\n{\n    if (!fillStyle) return index;\n\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = (fillStyle.fill as FillGradient)?.uid;\n\n    return index;\n}\n\nfunction addStokeStyleKey(strokeStyle: ConvertedStrokeStyle, key: (number | string)[], index: number)\n{\n    if (!strokeStyle) return index;\n\n    index = addFillStyleKey(strokeStyle, key, index);\n\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n\n    return index;\n}\n","import \"./main-menu.ts\";\n","import { LitElement, css, html } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators.js\";\nimport { game } from \"./game\";\n\n@customElement(\"main-menu\")\nexport class MainMenu extends LitElement {\n  static styles = css`\n    :host {\n      width: 100%;\n      aspect-ratio: 16 / 9;\n      position: relative;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      flex-direction: column;\n      background: #f0cfbb;\n    }\n    .large-title {\n      font-family: \"Poppins\", sans-serif;\n      font-size: 12vw;\n      position: absolute;\n      margin: 0;\n      top: 5%;\n      color: #a0484c;\n    }\n    .text-button {\n      position: absolute;\n      background: none;\n      border: none;\n      font-size: 3vw;\n      font-weight: bold;\n      color: #a0484c;\n      cursor: pointer;\n      opacity: 60%;\n      transition: all 0.25s ease-in-out;\n    }\n    .text-button:hover {\n      opacity: 100%;\n    }\n    #play-button {\n      left: 50%;\n      top: 50%;\n      padding: 0 15vw 15vw 15vw;\n      transform: translate(-50%);\n    }\n    #settings-button {\n      right: 8%;\n      top: 35%;\n      padding-bottom: 25vw;\n    }\n    :host([play-hovered]) #play-button {\n      opacity: 100%;\n    }\n    :host([settings-hovered]) #settings-button {\n      opacity: 100%;\n    }\n    .bg {\n      width: 100%;\n      height: 100%;\n      position: absolute;\n      top: 0;\n      left: 0;\n    }\n    .bg svg {\n      width: 100%;\n      height: 100%;\n    }\n    #barbell {\n      transition: all 0.25s ease-in-out;\n    }\n    :host([play-hovered]) #barbell {\n      transform: translateY(-5%);\n    }\n    #mirror-sheen {\n      transform-origin: 0 0;\n      transition: all 0.25s ease-in-out;\n    }\n    :host([settings-hovered]) #mirror-sheen {\n      transform: translate(30px, -40px);\n    }\n\n    @media (min-aspect-ratio: 16/9) {\n      :host {\n        height: 100%;\n        width: unset;\n      }\n      .large-title {\n        font-size: calc(12vh * 16 / 9);\n      }\n      .text-button {\n        font-size: calc(3vh * 16 / 9);\n      }\n      #play-button {\n        padding: 0 calc(15vh * 16 / 9) calc(15vh * 16 / 9) calc(15vh * 16 / 9);\n      }\n      #settings-button {\n        padding-bottom: calc(25vh * 16 / 9);\n      }\n    }\n  `;\n\n  @property({ type: Boolean, reflect: true, attribute: \"play-hovered\" })\n  private playHovered = false;\n  @property({ type: Boolean, reflect: true, attribute: \"settings-hovered\" })\n  private settingsHovered = false;\n\n  @state()\n  private settingsOpen = false;\n  /**\n   * If the game is currently loading or not. The \"loaded\" state\n   * accounts for the state when all assets are loaded but we are\n   * waiting on the user to click \"start\" to launch the main menu.\n   * Note that this state is needed so we can force a user\n   * interaction before showing the main menu which will\n   * attempt to play audio. Something we can not do before first\n   * user interaction.\n   * */\n  @state()\n  private loadState: \"loading\" | \"loaded\" | \"done\" = \"loading\";\n\n  protected override async firstUpdated() {\n    await game.preload();\n    this.loadState = \"loaded\";\n  }\n\n  protected override render() {\n    if (this.loadState === \"loading\") {\n      return this.renderLoadingScreen();\n    }\n    if (this.loadState === \"loaded\") {\n      return this.renderLoadedScreen();\n    }\n    if (this.settingsOpen) {\n      return this.renderSettings();\n    }\n\n    return html`\n      <div class=\"bg\">\n        <svg\n          viewBox=\"0 0 1600 900\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n        >\n          <g clip-path=\"url(#clip0_61_2)\">\n            <rect width=\"1600\" height=\"900\" fill=\"#f0cfbb\" />\n            <rect\n              x=\"-28\"\n              y=\"653\"\n              width=\"1656\"\n              height=\"315\"\n              fill=\"#D3AE72\"\n              stroke=\"#B3935D\"\n              stroke-width=\"10\"\n            />\n            <rect\n              x=\"-4.71411\"\n              y=\"862\"\n              width=\"1632.71\"\n              height=\"106\"\n              fill=\"#C7A567\"\n              stroke=\"#B3935D\"\n              stroke-width=\"10\"\n            />\n            <rect\n              x=\"9.33789\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"73.3379\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"137.338\"\n              y=\"715\"\n              width=\"8\"\n              height=\"123\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"137.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"201.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"265.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"122\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"265.338\"\n              y=\"802\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"329.338\"\n              y=\"715\"\n              width=\"8\"\n              height=\"123\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"329.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"393.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"68\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"393.338\"\n              y=\"747\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"393.338\"\n              y=\"789\"\n              width=\"8\"\n              height=\"49\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"457.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"521.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"585.338\"\n              y=\"715\"\n              width=\"8\"\n              height=\"123\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"585.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"649.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"713.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"122\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"713.338\"\n              y=\"802\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"777.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"122\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"777.338\"\n              y=\"802\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"841.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"68\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"841.338\"\n              y=\"747\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"841.338\"\n              y=\"789\"\n              width=\"8\"\n              height=\"49\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"905.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"969.338\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1033.34\"\n              y=\"715\"\n              width=\"8\"\n              height=\"123\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1033.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1097.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1161.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"122\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1161.34\"\n              y=\"802\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1225.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"122\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1225.34\"\n              y=\"802\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1289.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"68\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1289.34\"\n              y=\"747\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1289.34\"\n              y=\"789\"\n              width=\"8\"\n              height=\"49\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1353.34\"\n              y=\"715\"\n              width=\"8\"\n              height=\"123\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1353.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1417.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"68\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1417.34\"\n              y=\"747\"\n              width=\"8\"\n              height=\"36\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1417.34\"\n              y=\"789\"\n              width=\"8\"\n              height=\"49\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1481.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"1545.34\"\n              y=\"673\"\n              width=\"8\"\n              height=\"165\"\n              rx=\"4\"\n              fill=\"#B3935D\"\n            />\n            <rect\n              x=\"152.727\"\n              y=\"686.399\"\n              width=\"40.9657\"\n              height=\"39.3901\"\n              rx=\"7.87802\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n            />\n            <rect\n              x=\"250.414\"\n              y=\"686.399\"\n              width=\"40.9657\"\n              height=\"39.3901\"\n              rx=\"7.87802\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n            />\n            <rect\n              x=\"148\"\n              y=\"428\"\n              width=\"148.107\"\n              height=\"272.58\"\n              rx=\"12.6048\"\n              fill=\"#DFB97F\"\n            />\n            <path\n              d=\"M148 514.658V687.975C148 694.936 153.643 700.58 160.605 700.58H283.502C290.463 700.58 296.107 694.936 296.107 687.975V440.605C296.107 433.643 290.463 428 283.502 428H160.605C153.643 428 148 433.643 148 440.605V496.145\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n              stroke-linecap=\"round\"\n            />\n            <rect\n              x=\"153.563\"\n              y=\"447.447\"\n              width=\"145.764\"\n              height=\"27.9749\"\n              rx=\"13.9874\"\n              fill=\"#F4D776\"\n            />\n            <path\n              d=\"M179.329 459.436C182.274 458.437 190.814 457.038 201.415 459.436C212.016 461.834 218.101 460.435 219.819 459.436\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M225.708 468.754C228.653 467.755 237.193 466.356 247.794 468.754C258.395 471.152 264.481 469.753 266.198 468.754\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M276.505 460.55C273.56 459.551 265.02 458.152 254.419 460.55C243.818 462.948 237.733 461.549 236.015 460.55\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M178.593 447.447H167.55C159.825 447.447 153.563 453.709 153.563 461.434V461.434C153.563 469.159 159.825 475.422 167.55 475.422H285.339C293.064 475.422 299.327 469.159 299.327 461.434V461.434C299.327 453.709 293.064 447.447 285.339 447.447H190.372\"\n              stroke=\"#835243\"\n              stroke-width=\"8.83417\"\n              stroke-linecap=\"round\"\n            />\n            <circle\n              cx=\"120.435\"\n              cy=\"461.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <circle\n              cx=\"326.565\"\n              cy=\"461.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <mask id=\"path-57-inside-1_61_2\" fill=\"white\">\n              <rect x=\"207\" y=\"469\" width=\"29\" height=\"25\" rx=\"7\" />\n            </mask>\n            <rect\n              x=\"207\"\n              y=\"469\"\n              width=\"29\"\n              height=\"25\"\n              rx=\"7\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"16\"\n              mask=\"url(#path-57-inside-1_61_2)\"\n            />\n            <rect\n              x=\"153.563\"\n              y=\"542.447\"\n              width=\"145.764\"\n              height=\"27.9749\"\n              rx=\"13.9874\"\n              fill=\"#F4D776\"\n            />\n            <path\n              d=\"M179.329 554.436C182.274 553.437 190.814 552.038 201.415 554.436C212.016 556.834 218.101 555.435 219.819 554.436\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M225.708 563.754C228.653 562.755 237.193 561.356 247.794 563.754C258.395 566.152 264.481 564.753 266.198 563.754\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M276.505 555.55C273.56 554.551 265.02 553.152 254.419 555.55C243.818 557.948 237.733 556.549 236.015 555.55\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M178.593 542.447H167.55C159.825 542.447 153.563 548.709 153.563 556.434V556.434C153.563 564.159 159.825 570.422 167.55 570.422H285.339C293.064 570.422 299.327 564.159 299.327 556.434V556.434C299.327 548.709 293.064 542.447 285.339 542.447H190.372\"\n              stroke=\"#835243\"\n              stroke-width=\"8.83417\"\n              stroke-linecap=\"round\"\n            />\n            <circle\n              cx=\"120.435\"\n              cy=\"556.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <circle\n              cx=\"326.565\"\n              cy=\"556.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <mask id=\"path-65-inside-2_61_2\" fill=\"white\">\n              <rect x=\"207\" y=\"564\" width=\"29\" height=\"25\" rx=\"7\" />\n            </mask>\n            <rect\n              x=\"207\"\n              y=\"564\"\n              width=\"29\"\n              height=\"25\"\n              rx=\"7\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"16\"\n              mask=\"url(#path-65-inside-2_61_2)\"\n            />\n            <rect\n              x=\"153.563\"\n              y=\"637.447\"\n              width=\"145.764\"\n              height=\"27.9749\"\n              rx=\"13.9874\"\n              fill=\"#F4D776\"\n            />\n            <path\n              d=\"M179.329 649.436C182.274 648.437 190.814 647.038 201.415 649.436C212.016 651.834 218.101 650.435 219.819 649.436\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M225.708 658.754C228.653 657.755 237.193 656.356 247.794 658.754C258.395 661.152 264.481 659.753 266.198 658.754\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M276.505 650.55C273.56 649.551 265.02 648.152 254.419 650.55C243.818 652.948 237.733 651.549 236.015 650.55\"\n              stroke=\"#EDC76A\"\n              stroke-width=\"5.88945\"\n              stroke-linecap=\"round\"\n            />\n            <path\n              d=\"M178.593 637.447H167.55C159.825 637.447 153.563 643.709 153.563 651.434V651.434C153.563 659.159 159.825 665.422 167.55 665.422H285.339C293.064 665.422 299.327 659.159 299.327 651.434V651.434C299.327 643.709 293.064 637.447 285.339 637.447H190.372\"\n              stroke=\"#835243\"\n              stroke-width=\"8.83417\"\n              stroke-linecap=\"round\"\n            />\n            <circle\n              cx=\"120.435\"\n              cy=\"651.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <circle\n              cx=\"326.565\"\n              cy=\"651.435\"\n              r=\"39.0176\"\n              fill=\"#C9BDA6\"\n              stroke=\"#7A4A3B\"\n              stroke-width=\"8.83417\"\n            />\n            <mask id=\"path-73-inside-3_61_2\" fill=\"white\">\n              <rect x=\"207\" y=\"659\" width=\"29\" height=\"25\" rx=\"7\" />\n            </mask>\n            <rect\n              x=\"207\"\n              y=\"659\"\n              width=\"29\"\n              height=\"25\"\n              rx=\"7\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"16\"\n              mask=\"url(#path-73-inside-3_61_2)\"\n            />\n            <rect\n              x=\"535.727\"\n              y=\"667.727\"\n              width=\"530.546\"\n              height=\"61.5464\"\n              rx=\"7.87802\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n            />\n            <g id=\"barbell\">\n              <rect\n                x=\"728.563\"\n                y=\"620.447\"\n                width=\"145.764\"\n                height=\"27.9749\"\n                rx=\"13.9874\"\n                fill=\"#F4D776\"\n              />\n              <path\n                d=\"M754.329 632.436C757.274 631.437 765.814 630.038 776.415 632.436C787.016 634.834 793.101 633.435 794.819 632.436\"\n                stroke=\"#EDC76A\"\n                stroke-width=\"5.88945\"\n                stroke-linecap=\"round\"\n              />\n              <path\n                d=\"M800.708 641.754C803.653 640.755 812.193 639.356 822.794 641.754C833.395 644.152 839.481 642.753 841.198 641.754\"\n                stroke=\"#EDC76A\"\n                stroke-width=\"5.88945\"\n                stroke-linecap=\"round\"\n              />\n              <path\n                d=\"M851.505 633.55C848.56 632.551 840.02 631.152 829.419 633.55C818.818 635.948 812.733 634.549 811.015 633.55\"\n                stroke=\"#EDC76A\"\n                stroke-width=\"5.88945\"\n                stroke-linecap=\"round\"\n              />\n              <path\n                d=\"M753.593 620.447H742.55C734.825 620.447 728.563 626.709 728.563 634.434V634.434C728.563 642.159 734.825 648.422 742.55 648.422H860.339C868.064 648.422 874.327 642.159 874.327 634.434V634.434C874.327 626.709 868.064 620.447 860.339 620.447H765.372\"\n                stroke=\"#835243\"\n                stroke-width=\"8.83417\"\n                stroke-linecap=\"round\"\n              />\n              <circle\n                cx=\"695.435\"\n                cy=\"634.435\"\n                r=\"39.0176\"\n                fill=\"#C9BDA6\"\n                stroke=\"#7A4A3B\"\n                stroke-width=\"8.83417\"\n              />\n              <circle\n                cx=\"901.565\"\n                cy=\"634.435\"\n                r=\"39.0176\"\n                fill=\"#C9BDA6\"\n                stroke=\"#7A4A3B\"\n                stroke-width=\"8.83417\"\n              />\n            </g>\n            <rect\n              x=\"1296.73\"\n              y=\"679.399\"\n              width=\"40.9657\"\n              height=\"39.3901\"\n              rx=\"7.87802\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n            />\n            <rect\n              x=\"1394.41\"\n              y=\"679.399\"\n              width=\"40.9657\"\n              height=\"39.3901\"\n              rx=\"7.87802\"\n              fill=\"#B77938\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n            />\n            <rect\n              x=\"1292\"\n              y=\"421\"\n              width=\"148.107\"\n              height=\"272.58\"\n              rx=\"12.6048\"\n              fill=\"#C3D2D6\"\n            />\n            <path\n              d=\"M1292 507.658V680.975C1292 687.936 1297.64 693.58 1304.6 693.58H1427.5C1434.46 693.58 1440.11 687.936 1440.11 680.975V433.605C1440.11 426.643 1434.46 421 1427.5 421H1304.6C1297.64 421 1292 426.643 1292 433.605V489.145\"\n              stroke=\"#835035\"\n              stroke-width=\"9.45363\"\n              stroke-linecap=\"round\"\n            />\n            <mask\n              id=\"mask0_61_2\"\n              style=\"mask-type:alpha\"\n              maskUnits=\"userSpaceOnUse\"\n              x=\"1295\"\n              y=\"426\"\n              width=\"140\"\n              height=\"262\"\n            >\n              <rect\n                x=\"1295\"\n                y=\"426\"\n                width=\"140\"\n                height=\"262\"\n                rx=\"6\"\n                fill=\"#C3D2D6\"\n              />\n            </mask>\n            <g mask=\"url(#mask0_61_2)\">\n              <g id=\"mirror-sheen\">\n                <rect\n                  width=\"14.0505\"\n                  height=\"16.5682\"\n                  rx=\"7.02523\"\n                  transform=\"matrix(0.709637 0.704568 -0.709637 0.704568 1427.62 595)\"\n                  fill=\"white\"\n                  fill-opacity=\"0.68\"\n                />\n                <rect\n                  width=\"14.0505\"\n                  height=\"241.245\"\n                  rx=\"7.02523\"\n                  transform=\"matrix(0.709637 0.704568 -0.709637 0.704568 1412.1 610.635)\"\n                  fill=\"white\"\n                  fill-opacity=\"0.68\"\n                />\n                <rect\n                  width=\"160.272\"\n                  height=\"253.774\"\n                  rx=\"16\"\n                  transform=\"matrix(0.709637 0.704568 -0.709637 0.704568 1495.05 561.645)\"\n                  fill=\"white\"\n                  fill-opacity=\"0.68\"\n                />\n              </g>\n            </g>\n          </g>\n          <defs>\n            <clipPath id=\"clip0_61_2\">\n              <rect width=\"1600\" height=\"900\" fill=\"white\" />\n            </clipPath>\n          </defs>\n        </svg>\n      </div>\n      <h1 class=\"large-title\">Power Lifter</h1>\n      <button\n        @click=${this.startGame}\n        @mouseenter=${() => (this.playHovered = true)}\n        @mouseleave=${() => (this.playHovered = false)}\n        id=\"play-button\"\n        class=\"text-button\"\n      >\n        Play\n      </button>\n      <button\n        @mouseenter=${() => (this.settingsHovered = true)}\n        @mouseleave=${() => (this.settingsHovered = false)}\n        @click=${() => (this.settingsOpen = true)}\n        id=\"settings-button\"\n        class=\"text-button\"\n      >\n        Settings\n      </button>\n    `;\n  }\n\n  private renderLoadingScreen() {\n    return html`<h1 class=\"large-title\">Loading...</h1> `;\n  }\n\n  private renderLoadedScreen() {\n    return html`\n      <h1 class=\"large-title\">Loaded.</h1>\n      <button class=\"text-button\" @click=${this.launch}>Start</button>\n    `;\n  }\n\n  private renderSettings() {\n    return html`\n      <h1 class=\"large-title\">Settings</h1>\n      <button class=\"text-button\" @click=${() => (this.settingsOpen = false)}>\n        Back\n      </button>\n    `;\n  }\n\n  private startGame() {\n    this.remove();\n    game.start();\n  }\n\n  private launch() {\n    // At this point we forced the user to interact with the page\n    // so we can now play music.\n    game.audioController.playTitleScreenMusic();\n    this.loadState = \"done\";\n  }\n}\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import{getCompatibleStyle as t,adoptStyles as s}from\"./css-tag.js\";export{CSSResult,adoptStyles,css,getCompatibleStyle,supportsAdoptingStyleSheets,unsafeCSS}from\"./css-tag.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const{is:i,defineProperty:e,getOwnPropertyDescriptor:r,getOwnPropertyNames:h,getOwnPropertySymbols:o,getPrototypeOf:n}=Object,a=globalThis,c=a.trustedTypes,l=c?c.emptyScript:\"\",p=a.reactiveElementPolyfillSupport,d=(t,s)=>t,u={toAttribute(t,s){switch(s){case Boolean:t=t?l:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t)}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t)}catch(t){i=null}}return i}},f=(t,s)=>!i(t,s),y={attribute:!0,type:String,converter:u,reflect:!1,hasChanged:f};Symbol.metadata??=Symbol(\"metadata\"),a.litPropertyMetadata??=new WeakMap;class b extends HTMLElement{static addInitializer(t){this._$Ei(),(this.l??=[]).push(t)}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=y){if(s.state&&(s.attribute=!1),this._$Ei(),this.elementProperties.set(t,s),!s.noAccessor){const i=Symbol(),r=this.getPropertyDescriptor(t,i,s);void 0!==r&&e(this.prototype,t,r)}}static getPropertyDescriptor(t,s,i){const{get:e,set:h}=r(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t}};return{get(){return e?.call(this)},set(s){const r=e?.call(this);h.call(this,s),this.requestUpdate(t,r,i)},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)??y}static _$Ei(){if(this.hasOwnProperty(d(\"elementProperties\")))return;const t=n(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties)}static finalize(){if(this.hasOwnProperty(d(\"finalized\")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(d(\"properties\"))){const t=this.properties,s=[...h(t),...o(t)];for(const i of s)this.createProperty(i,t[i])}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,i]of s)this.elementProperties.set(t,i)}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const i=this._$Eu(t,s);void 0!==i&&this._$Eh.set(i,t)}this.elementStyles=this.finalizeStyles(this.styles)}static finalizeStyles(s){const i=[];if(Array.isArray(s)){const e=new Set(s.flat(1/0).reverse());for(const s of e)i.unshift(t(s))}else void 0!==s&&i.push(t(s));return i}static _$Eu(t,s){const i=s.attribute;return!1===i?void 0:\"string\"==typeof i?i:\"string\"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev()}_$Ev(){this._$ES=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((t=>t(this)))}addController(t){(this._$EO??=new Set).add(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.()}removeController(t){this._$EO?.delete(t)}_$E_(){const t=new Map,s=this.constructor.elementProperties;for(const i of s.keys())this.hasOwnProperty(i)&&(t.set(i,this[i]),delete this[i]);t.size>0&&(this._$Ep=t)}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return s(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$EO?.forEach((t=>t.hostConnected?.()))}enableUpdating(t){}disconnectedCallback(){this._$EO?.forEach((t=>t.hostDisconnected?.()))}attributeChangedCallback(t,s,i){this._$AK(t,i)}_$EC(t,s){const i=this.constructor.elementProperties.get(t),e=this.constructor._$Eu(t,i);if(void 0!==e&&!0===i.reflect){const r=(void 0!==i.converter?.toAttribute?i.converter:u).toAttribute(s,i.type);this._$Em=t,null==r?this.removeAttribute(e):this.setAttribute(e,r),this._$Em=null}}_$AK(t,s){const i=this.constructor,e=i._$Eh.get(t);if(void 0!==e&&this._$Em!==e){const t=i.getPropertyOptions(e),r=\"function\"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:u;this._$Em=e,this[e]=r.fromAttribute(s,t.type),this._$Em=null}}requestUpdate(t,s,i){if(void 0!==t){if(i??=this.constructor.getPropertyOptions(t),!(i.hasChanged??f)(this[t],s))return;this.P(t,s,i)}!1===this.isUpdatePending&&(this._$ES=this._$ET())}P(t,s,i){this._$AL.has(t)||this._$AL.set(t,s),!0===i.reflect&&this._$Em!==t&&(this._$Ej??=new Set).add(t)}async _$ET(){this.isUpdatePending=!0;try{await this._$ES}catch(t){Promise.reject(t)}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0}const t=this.constructor.elementProperties;if(t.size>0)for(const[s,i]of t)!0!==i.wrapped||this._$AL.has(s)||void 0===this[s]||this.P(s,this[s],i)}let t=!1;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$EO?.forEach((t=>t.hostUpdate?.())),this.update(s)):this._$EU()}catch(s){throw t=!1,this._$EU(),s}t&&this._$AE(s)}willUpdate(t){}_$AE(t){this._$EO?.forEach((t=>t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t)}_$EU(){this._$AL=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$ES}shouldUpdate(t){return!0}update(t){this._$Ej&&=this._$Ej.forEach((t=>this._$EC(t,this[t]))),this._$EU()}updated(t){}firstUpdated(t){}}b.elementStyles=[],b.shadowRootOptions={mode:\"open\"},b[d(\"elementProperties\")]=new Map,b[d(\"finalized\")]=new Map,p?.({ReactiveElement:b}),(a.reactiveElementVersions??=[]).push(\"2.0.4\");export{b as ReactiveElement,u as defaultConverter,f as notEqual};\n//# sourceMappingURL=reactive-element.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Use this module if you want to create your own base class extending\n * {@link ReactiveElement}.\n * @packageDocumentation\n */\n\nimport {\n  getCompatibleStyle,\n  adoptStyles,\n  CSSResultGroup,\n  CSSResultOrNative,\n} from './css-tag.js';\nimport type {\n  ReactiveController,\n  ReactiveControllerHost,\n} from './reactive-controller.js';\n\n// In the Node build, this import will be injected by Rollup:\n// import {HTMLElement, customElements} from '@lit-labs/ssr-dom-shim';\n\nexport * from './css-tag.js';\nexport type {\n  ReactiveController,\n  ReactiveControllerHost,\n} from './reactive-controller.js';\n\n/**\n * Removes the `readonly` modifier from properties in the union K.\n *\n * This is a safer way to cast a value to a type with a mutable version of a\n * readonly field, than casting to an interface with the field re-declared\n * because it preserves the type of all the fields and warns on typos.\n */\ntype Mutable<T, K extends keyof T> = Omit<T, K> & {\n  -readonly [P in keyof Pick<T, K>]: P extends K ? T[P] : never;\n};\n\n// TODO (justinfagnani): Add `hasOwn` here when we ship ES2022\nconst {\n  is,\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n  getPrototypeOf,\n} = Object;\n\nconst NODE_MODE = false;\n\n// Lets a minifier replace globalThis references with a minified name\nconst global = globalThis;\n\nif (NODE_MODE) {\n  global.customElements ??= customElements;\n}\n\nconst DEV_MODE = true;\n\nlet issueWarning: (code: string, warning: string) => void;\n\nconst trustedTypes = (global as unknown as {trustedTypes?: {emptyScript: ''}})\n  .trustedTypes;\n\n// Temporary workaround for https://crbug.com/993268\n// Currently, any attribute starting with \"on\" is considered to be a\n// TrustedScript source. Such boolean attributes must be set to the equivalent\n// trusted emptyScript value.\nconst emptyStringForBooleanAttribute = trustedTypes\n  ? (trustedTypes.emptyScript as unknown as '')\n  : '';\n\nconst polyfillSupport = DEV_MODE\n  ? global.reactiveElementPolyfillSupportDevMode\n  : global.reactiveElementPolyfillSupport;\n\nif (DEV_MODE) {\n  // Ensure warnings are issued only 1x, even if multiple versions of Lit\n  // are loaded.\n  const issuedWarnings: Set<string | undefined> = (global.litIssuedWarnings ??=\n    new Set());\n\n  // Issue a warning, if we haven't already.\n  issueWarning = (code: string, warning: string) => {\n    warning += ` See https://lit.dev/msg/${code} for more information.`;\n    if (!issuedWarnings.has(warning)) {\n      console.warn(warning);\n      issuedWarnings.add(warning);\n    }\n  };\n\n  issueWarning(\n    'dev-mode',\n    `Lit is in dev mode. Not recommended for production!`\n  );\n\n  // Issue polyfill support warning.\n  if (global.ShadyDOM?.inUse && polyfillSupport === undefined) {\n    issueWarning(\n      'polyfill-support-missing',\n      `Shadow DOM is being polyfilled via \\`ShadyDOM\\` but ` +\n        `the \\`polyfill-support\\` module has not been loaded.`\n    );\n  }\n}\n\n/**\n * Contains types that are part of the unstable debug API.\n *\n * Everything in this API is not stable and may change or be removed in the future,\n * even on patch releases.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace ReactiveUnstable {\n  /**\n   * When Lit is running in dev mode and `window.emitLitDebugLogEvents` is true,\n   * we will emit 'lit-debug' events to window, with live details about the update and render\n   * lifecycle. These can be useful for writing debug tooling and visualizations.\n   *\n   * Please be aware that running with window.emitLitDebugLogEvents has performance overhead,\n   * making certain operations that are normally very cheap (like a no-op render) much slower,\n   * because we must copy data and dispatch events.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  export namespace DebugLog {\n    export type Entry = Update;\n    export interface Update {\n      kind: 'update';\n    }\n  }\n}\n\ninterface DebugLoggingWindow {\n  // Even in dev mode, we generally don't want to emit these events, as that's\n  // another level of cost, so only emit them when DEV_MODE is true _and_ when\n  // window.emitLitDebugEvents is true.\n  emitLitDebugLogEvents?: boolean;\n}\n\n/**\n * Useful for visualizing and logging insights into what the Lit template system is doing.\n *\n * Compiled out of prod mode builds.\n */\nconst debugLogEvent = DEV_MODE\n  ? (event: ReactiveUnstable.DebugLog.Entry) => {\n      const shouldEmit = (global as unknown as DebugLoggingWindow)\n        .emitLitDebugLogEvents;\n      if (!shouldEmit) {\n        return;\n      }\n      global.dispatchEvent(\n        new CustomEvent<ReactiveUnstable.DebugLog.Entry>('lit-debug', {\n          detail: event,\n        })\n      );\n    }\n  : undefined;\n\n/*\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\n/*@__INLINE__*/\nconst JSCompiler_renameProperty = <P extends PropertyKey>(\n  prop: P,\n  _obj: unknown\n): P => prop;\n\n/**\n * Converts property values to and from attribute values.\n */\nexport interface ComplexAttributeConverter<Type = unknown, TypeHint = unknown> {\n  /**\n   * Called to convert an attribute value to a property\n   * value.\n   */\n  fromAttribute?(value: string | null, type?: TypeHint): Type;\n\n  /**\n   * Called to convert a property value to an attribute\n   * value.\n   *\n   * It returns unknown instead of string, to be compatible with\n   * https://github.com/WICG/trusted-types (and similar efforts).\n   */\n  toAttribute?(value: Type, type?: TypeHint): unknown;\n}\n\ntype AttributeConverter<Type = unknown, TypeHint = unknown> =\n  | ComplexAttributeConverter<Type>\n  | ((value: string | null, type?: TypeHint) => Type);\n\n/**\n * Defines options for a property accessor.\n */\nexport interface PropertyDeclaration<Type = unknown, TypeHint = unknown> {\n  /**\n   * When set to `true`, indicates the property is internal private state. The\n   * property should not be set by users. When using TypeScript, this property\n   * should be marked as `private` or `protected`, and it is also a common\n   * practice to use a leading `_` in the name. The property is not added to\n   * `observedAttributes`.\n   */\n  readonly state?: boolean;\n\n  /**\n   * Indicates how and whether the property becomes an observed attribute.\n   * If the value is `false`, the property is not added to `observedAttributes`.\n   * If true or absent, the lowercased property name is observed (e.g. `fooBar`\n   * becomes `foobar`). If a string, the string value is observed (e.g\n   * `attribute: 'foo-bar'`).\n   */\n  readonly attribute?: boolean | string;\n\n  /**\n   * Indicates the type of the property. This is used only as a hint for the\n   * `converter` to determine how to convert the attribute\n   * to/from a property.\n   */\n  readonly type?: TypeHint;\n\n  /**\n   * Indicates how to convert the attribute to/from a property. If this value\n   * is a function, it is used to convert the attribute value a the property\n   * value. If it's an object, it can have keys for `fromAttribute` and\n   * `toAttribute`. If no `toAttribute` function is provided and\n   * `reflect` is set to `true`, the property value is set directly to the\n   * attribute. A default `converter` is used if none is provided; it supports\n   * `Boolean`, `String`, `Number`, `Object`, and `Array`. Note,\n   * when a property changes and the converter is used to update the attribute,\n   * the property is never updated again as a result of the attribute changing,\n   * and vice versa.\n   */\n  readonly converter?: AttributeConverter<Type, TypeHint>;\n\n  /**\n   * Indicates if the property should reflect to an attribute.\n   * If `true`, when the property is set, the attribute is set using the\n   * attribute name determined according to the rules for the `attribute`\n   * property option and the value of the property converted using the rules\n   * from the `converter` property option.\n   */\n  readonly reflect?: boolean;\n\n  /**\n   * A function that indicates if a property should be considered changed when\n   * it is set. The function should take the `newValue` and `oldValue` and\n   * return `true` if an update should be requested.\n   */\n  hasChanged?(value: Type, oldValue: Type): boolean;\n\n  /**\n   * Indicates whether an accessor will be created for this property. By\n   * default, an accessor will be generated for this property that requests an\n   * update when set. If this flag is `true`, no accessor will be created, and\n   * it will be the user's responsibility to call\n   * `this.requestUpdate(propertyName, oldValue)` to request an update when\n   * the property changes.\n   */\n  readonly noAccessor?: boolean;\n\n  /**\n   * Whether this property is wrapping accessors. This is set by `@property`\n   * to control the initial value change and reflection logic.\n   *\n   * @internal\n   */\n  wrapped?: boolean;\n}\n\n/**\n * Map of properties to PropertyDeclaration options. For each property an\n * accessor is made, and the property is processed according to the\n * PropertyDeclaration options.\n */\nexport interface PropertyDeclarations {\n  readonly [key: string]: PropertyDeclaration;\n}\n\ntype PropertyDeclarationMap = Map<PropertyKey, PropertyDeclaration>;\n\ntype AttributeMap = Map<string, PropertyKey>;\n\n/**\n * A Map of property keys to values.\n *\n * Takes an optional type parameter T, which when specified as a non-any,\n * non-unknown type, will make the Map more strongly-typed, associating the map\n * keys with their corresponding value type on T.\n *\n * Use `PropertyValues<this>` when overriding ReactiveElement.update() and\n * other lifecycle methods in order to get stronger type-checking on keys\n * and values.\n */\n// This type is conditional so that if the parameter T is not specified, or\n// is `any`, the type will include `Map<PropertyKey, unknown>`. Since T is not\n// given in the uses of PropertyValues in this file, all uses here fallback to\n// meaning `Map<PropertyKey, unknown>`, but if a developer uses\n// `PropertyValues<this>` (or any other value for T) they will get a\n// strongly-typed Map type.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PropertyValues<T = any> = T extends object\n  ? PropertyValueMap<T>\n  : Map<PropertyKey, unknown>;\n\n/**\n * Do not use, instead prefer {@linkcode PropertyValues}.\n */\n// This type must be exported such that JavaScript generated by the Google\n// Closure Compiler can import a type reference.\nexport interface PropertyValueMap<T> extends Map<PropertyKey, unknown> {\n  get<K extends keyof T>(k: K): T[K] | undefined;\n  set<K extends keyof T>(key: K, value: T[K]): this;\n  has<K extends keyof T>(k: K): boolean;\n  delete<K extends keyof T>(k: K): boolean;\n}\n\nexport const defaultConverter: ComplexAttributeConverter = {\n  toAttribute(value: unknown, type?: unknown): unknown {\n    switch (type) {\n      case Boolean:\n        value = value ? emptyStringForBooleanAttribute : null;\n        break;\n      case Object:\n      case Array:\n        // if the value is `null` or `undefined` pass this through\n        // to allow removing/no change behavior.\n        value = value == null ? value : JSON.stringify(value);\n        break;\n    }\n    return value;\n  },\n\n  fromAttribute(value: string | null, type?: unknown) {\n    let fromValue: unknown = value;\n    switch (type) {\n      case Boolean:\n        fromValue = value !== null;\n        break;\n      case Number:\n        fromValue = value === null ? null : Number(value);\n        break;\n      case Object:\n      case Array:\n        // Do *not* generate exception when invalid JSON is set as elements\n        // don't normally complain on being mis-configured.\n        // TODO(sorvell): Do generate exception in *dev mode*.\n        try {\n          // Assert to adhere to Bazel's \"must type assert JSON parse\" rule.\n          fromValue = JSON.parse(value!) as unknown;\n        } catch (e) {\n          fromValue = null;\n        }\n        break;\n    }\n    return fromValue;\n  },\n};\n\nexport interface HasChanged {\n  (value: unknown, old: unknown): boolean;\n}\n\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */\nexport const notEqual: HasChanged = (value: unknown, old: unknown): boolean =>\n  !is(value, old);\n\nconst defaultPropertyDeclaration: PropertyDeclaration = {\n  attribute: true,\n  type: String,\n  converter: defaultConverter,\n  reflect: false,\n  hasChanged: notEqual,\n};\n\n/**\n * A string representing one of the supported dev mode warning categories.\n */\nexport type WarningKind =\n  | 'change-in-update'\n  | 'migration'\n  | 'async-perform-update';\n\nexport type Initializer = (element: ReactiveElement) => void;\n\n// Temporary, until google3 is on TypeScript 5.2\ndeclare global {\n  interface SymbolConstructor {\n    readonly metadata: unique symbol;\n  }\n}\n\n// Ensure metadata is enabled. TypeScript does not polyfill\n// Symbol.metadata, so we must ensure that it exists.\n(Symbol as {metadata: symbol}).metadata ??= Symbol('metadata');\n\ndeclare global {\n  // This is public global API, do not change!\n  // eslint-disable-next-line no-var\n  var litPropertyMetadata: WeakMap<\n    object,\n    Map<PropertyKey, PropertyDeclaration>\n  >;\n}\n\n// Map from a class's metadata object to property options\n// Note that we must use nullish-coalescing assignment so that we only use one\n// map even if we load multiple version of this module.\nglobal.litPropertyMetadata ??= new WeakMap<\n  object,\n  Map<PropertyKey, PropertyDeclaration>\n>();\n\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclasses to render updates as desired.\n * @noInheritDoc\n */\nexport abstract class ReactiveElement\n  // In the Node build, this `extends` clause will be substituted with\n  // `(globalThis.HTMLElement ?? HTMLElement)`.\n  //\n  // This way, we will first prefer any global `HTMLElement` polyfill that the\n  // user has assigned, and then fall back to the `HTMLElement` shim which has\n  // been imported (see note at the top of this file about how this import is\n  // generated by Rollup). Note that the `HTMLElement` variable has been\n  // shadowed by this import, so it no longer refers to the global.\n  extends HTMLElement\n  implements ReactiveControllerHost\n{\n  // Note: these are patched in only in DEV_MODE.\n  /**\n   * Read or set all the enabled warning categories for this class.\n   *\n   * This property is only used in development builds.\n   *\n   * @nocollapse\n   * @category dev-mode\n   */\n  static enabledWarnings?: WarningKind[];\n\n  /**\n   * Enable the given warning category for this class.\n   *\n   * This method only exists in development builds, so it should be accessed\n   * with a guard like:\n   *\n   * ```ts\n   * // Enable for all ReactiveElement subclasses\n   * ReactiveElement.enableWarning?.('migration');\n   *\n   * // Enable for only MyElement and subclasses\n   * MyElement.enableWarning?.('migration');\n   * ```\n   *\n   * @nocollapse\n   * @category dev-mode\n   */\n  static enableWarning?: (warningKind: WarningKind) => void;\n\n  /**\n   * Disable the given warning category for this class.\n   *\n   * This method only exists in development builds, so it should be accessed\n   * with a guard like:\n   *\n   * ```ts\n   * // Disable for all ReactiveElement subclasses\n   * ReactiveElement.disableWarning?.('migration');\n   *\n   * // Disable for only MyElement and subclasses\n   * MyElement.disableWarning?.('migration');\n   * ```\n   *\n   * @nocollapse\n   * @category dev-mode\n   */\n  static disableWarning?: (warningKind: WarningKind) => void;\n\n  /**\n   * Adds an initializer function to the class that is called during instance\n   * construction.\n   *\n   * This is useful for code that runs against a `ReactiveElement`\n   * subclass, such as a decorator, that needs to do work for each\n   * instance, such as setting up a `ReactiveController`.\n   *\n   * ```ts\n   * const myDecorator = (target: typeof ReactiveElement, key: string) => {\n   *   target.addInitializer((instance: ReactiveElement) => {\n   *     // This is run during construction of the element\n   *     new MyController(instance);\n   *   });\n   * }\n   * ```\n   *\n   * Decorating a field will then cause each instance to run an initializer\n   * that adds a controller:\n   *\n   * ```ts\n   * class MyElement extends LitElement {\n   *   @myDecorator foo;\n   * }\n   * ```\n   *\n   * Initializers are stored per-constructor. Adding an initializer to a\n   * subclass does not add it to a superclass. Since initializers are run in\n   * constructors, initializers will run in order of the class hierarchy,\n   * starting with superclasses and progressing to the instance's class.\n   *\n   * @nocollapse\n   */\n  static addInitializer(initializer: Initializer) {\n    this.__prepare();\n    (this._initializers ??= []).push(initializer);\n  }\n\n  static _initializers?: Initializer[];\n\n  /*\n   * Due to closure compiler ES6 compilation bugs, @nocollapse is required on\n   * all static methods and properties with initializers.  Reference:\n   * - https://github.com/google/closure-compiler/issues/1776\n   */\n\n  /**\n   * Maps attribute names to properties; for example `foobar` attribute to\n   * `fooBar` property. Created lazily on user subclasses when finalizing the\n   * class.\n   * @nocollapse\n   */\n  private static __attributeToPropertyMap: AttributeMap;\n\n  /**\n   * Marks class as having been finalized, which includes creating properties\n   * from `static properties`, but does *not* include all properties created\n   * from decorators.\n   * @nocollapse\n   */\n  protected static finalized: true | undefined;\n\n  /**\n   * Memoized list of all element properties, including any superclass\n   * properties. Created lazily on user subclasses when finalizing the class.\n   *\n   * @nocollapse\n   * @category properties\n   */\n  static elementProperties: PropertyDeclarationMap;\n\n  /**\n   * User-supplied object that maps property names to `PropertyDeclaration`\n   * objects containing options for configuring reactive properties. When\n   * a reactive property is set the element will update and render.\n   *\n   * By default properties are public fields, and as such, they should be\n   * considered as primarily settable by element users, either via attribute or\n   * the property itself.\n   *\n   * Generally, properties that are changed by the element should be private or\n   * protected fields and should use the `state: true` option. Properties\n   * marked as `state` do not reflect from the corresponding attribute\n   *\n   * However, sometimes element code does need to set a public property. This\n   * should typically only be done in response to user interaction, and an event\n   * should be fired informing the user; for example, a checkbox sets its\n   * `checked` property when clicked and fires a `changed` event. Mutating\n   * public properties should typically not be done for non-primitive (object or\n   * array) properties. In other cases when an element needs to manage state, a\n   * private property set with the `state: true` option should be used. When\n   * needed, state properties can be initialized via public properties to\n   * facilitate complex interactions.\n   * @nocollapse\n   * @category properties\n   */\n  static properties: PropertyDeclarations;\n\n  /**\n   * Memoized list of all element styles.\n   * Created lazily on user subclasses when finalizing the class.\n   * @nocollapse\n   * @category styles\n   */\n  static elementStyles: Array<CSSResultOrNative> = [];\n\n  /**\n   * Array of styles to apply to the element. The styles should be defined\n   * using the {@linkcode css} tag function, via constructible stylesheets, or\n   * imported from native CSS module scripts.\n   *\n   * Note on Content Security Policy:\n   *\n   * Element styles are implemented with `<style>` tags when the browser doesn't\n   * support adopted StyleSheets. To use such `<style>` tags with the style-src\n   * CSP directive, the style-src value must either include 'unsafe-inline' or\n   * `nonce-<base64-value>` with `<base64-value>` replaced be a server-generated\n   * nonce.\n   *\n   * To provide a nonce to use on generated `<style>` elements, set\n   * `window.litNonce` to a server-generated nonce in your page's HTML, before\n   * loading application code:\n   *\n   * ```html\n   * <script>\n   *   // Generated and unique per request:\n   *   window.litNonce = 'a1b2c3d4';\n   * </script>\n   * ```\n   * @nocollapse\n   * @category styles\n   */\n  static styles?: CSSResultGroup;\n\n  /**\n   * Returns a list of attributes corresponding to the registered properties.\n   * @nocollapse\n   * @category attributes\n   */\n  static get observedAttributes() {\n    // Ensure we've created all properties\n    this.finalize();\n    // this.__attributeToPropertyMap is only undefined after finalize() in\n    // ReactiveElement itself. ReactiveElement.observedAttributes is only\n    // accessed with ReactiveElement as the receiver when a subclass or mixin\n    // calls super.observedAttributes\n    return (\n      this.__attributeToPropertyMap && [...this.__attributeToPropertyMap.keys()]\n    );\n  }\n\n  private __instanceProperties?: PropertyValues = undefined;\n\n  /**\n   * Creates a property accessor on the element prototype if one does not exist\n   * and stores a {@linkcode PropertyDeclaration} for the property with the\n   * given options. The property setter calls the property's `hasChanged`\n   * property option or uses a strict identity check to determine whether or not\n   * to request an update.\n   *\n   * This method may be overridden to customize properties; however,\n   * when doing so, it's important to call `super.createProperty` to ensure\n   * the property is setup correctly. This method calls\n   * `getPropertyDescriptor` internally to get a descriptor to install.\n   * To customize what properties do when they are get or set, override\n   * `getPropertyDescriptor`. To customize the options for a property,\n   * implement `createProperty` like this:\n   *\n   * ```ts\n   * static createProperty(name, options) {\n   *   options = Object.assign(options, {myOption: true});\n   *   super.createProperty(name, options);\n   * }\n   * ```\n   *\n   * @nocollapse\n   * @category properties\n   */\n  static createProperty(\n    name: PropertyKey,\n    options: PropertyDeclaration = defaultPropertyDeclaration\n  ) {\n    // If this is a state property, force the attribute to false.\n    if (options.state) {\n      (options as Mutable<PropertyDeclaration, 'attribute'>).attribute = false;\n    }\n    this.__prepare();\n    this.elementProperties.set(name, options);\n    if (!options.noAccessor) {\n      const key = DEV_MODE\n        ? // Use Symbol.for in dev mode to make it easier to maintain state\n          // when doing HMR.\n          Symbol.for(`${String(name)} (@property() cache)`)\n        : Symbol();\n      const descriptor = this.getPropertyDescriptor(name, key, options);\n      if (descriptor !== undefined) {\n        defineProperty(this.prototype, name, descriptor);\n      }\n    }\n  }\n\n  /**\n   * Returns a property descriptor to be defined on the given named property.\n   * If no descriptor is returned, the property will not become an accessor.\n   * For example,\n   *\n   * ```ts\n   * class MyElement extends LitElement {\n   *   static getPropertyDescriptor(name, key, options) {\n   *     const defaultDescriptor =\n   *         super.getPropertyDescriptor(name, key, options);\n   *     const setter = defaultDescriptor.set;\n   *     return {\n   *       get: defaultDescriptor.get,\n   *       set(value) {\n   *         setter.call(this, value);\n   *         // custom action.\n   *       },\n   *       configurable: true,\n   *       enumerable: true\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * @nocollapse\n   * @category properties\n   */\n  protected static getPropertyDescriptor(\n    name: PropertyKey,\n    key: string | symbol,\n    options: PropertyDeclaration\n  ): PropertyDescriptor | undefined {\n    const {get, set} = getOwnPropertyDescriptor(this.prototype, name) ?? {\n      get(this: ReactiveElement) {\n        return this[key as keyof typeof this];\n      },\n      set(this: ReactiveElement, v: unknown) {\n        (this as unknown as Record<string | symbol, unknown>)[key] = v;\n      },\n    };\n    if (DEV_MODE && get == null) {\n      if ('value' in (getOwnPropertyDescriptor(this.prototype, name) ?? {})) {\n        throw new Error(\n          `Field ${JSON.stringify(String(name))} on ` +\n            `${this.name} was declared as a reactive property ` +\n            `but it's actually declared as a value on the prototype. ` +\n            `Usually this is due to using @property or @state on a method.`\n        );\n      }\n      issueWarning(\n        'reactive-property-without-getter',\n        `Field ${JSON.stringify(String(name))} on ` +\n          `${this.name} was declared as a reactive property ` +\n          `but it does not have a getter. This will be an error in a ` +\n          `future version of Lit.`\n      );\n    }\n    return {\n      get(this: ReactiveElement) {\n        return get?.call(this);\n      },\n      set(this: ReactiveElement, value: unknown) {\n        const oldValue = get?.call(this);\n        set!.call(this, value);\n        this.requestUpdate(name, oldValue, options);\n      },\n      configurable: true,\n      enumerable: true,\n    };\n  }\n\n  /**\n   * Returns the property options associated with the given property.\n   * These options are defined with a `PropertyDeclaration` via the `properties`\n   * object or the `@property` decorator and are registered in\n   * `createProperty(...)`.\n   *\n   * Note, this method should be considered \"final\" and not overridden. To\n   * customize the options for a given property, override\n   * {@linkcode createProperty}.\n   *\n   * @nocollapse\n   * @final\n   * @category properties\n   */\n  static getPropertyOptions(name: PropertyKey) {\n    return this.elementProperties.get(name) ?? defaultPropertyDeclaration;\n  }\n\n  // Temporary, until google3 is on TypeScript 5.2\n  declare static [Symbol.metadata]: object & Record<PropertyKey, unknown>;\n\n  /**\n   * Initializes static own properties of the class used in bookkeeping\n   * for element properties, initializers, etc.\n   *\n   * Can be called multiple times by code that needs to ensure these\n   * properties exist before using them.\n   *\n   * This method ensures the superclass is finalized so that inherited\n   * property metadata can be copied down.\n   * @nocollapse\n   */\n  private static __prepare() {\n    if (\n      this.hasOwnProperty(JSCompiler_renameProperty('elementProperties', this))\n    ) {\n      // Already prepared\n      return;\n    }\n    // Finalize any superclasses\n    const superCtor = getPrototypeOf(this) as typeof ReactiveElement;\n    superCtor.finalize();\n\n    // Create own set of initializers for this class if any exist on the\n    // superclass and copy them down. Note, for a small perf boost, avoid\n    // creating initializers unless needed.\n    if (superCtor._initializers !== undefined) {\n      this._initializers = [...superCtor._initializers];\n    }\n    // Initialize elementProperties from the superclass\n    this.elementProperties = new Map(superCtor.elementProperties);\n  }\n\n  /**\n   * Finishes setting up the class so that it's ready to be registered\n   * as a custom element and instantiated.\n   *\n   * This method is called by the ReactiveElement.observedAttributes getter.\n   * If you override the observedAttributes getter, you must either call\n   * super.observedAttributes to trigger finalization, or call finalize()\n   * yourself.\n   *\n   * @nocollapse\n   */\n  protected static finalize() {\n    if (this.hasOwnProperty(JSCompiler_renameProperty('finalized', this))) {\n      return;\n    }\n    this.finalized = true;\n    this.__prepare();\n\n    // Create properties from the static properties block:\n    if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\n      const props = this.properties;\n      const propKeys = [\n        ...getOwnPropertyNames(props),\n        ...getOwnPropertySymbols(props),\n      ] as Array<keyof typeof props>;\n      for (const p of propKeys) {\n        this.createProperty(p, props[p]);\n      }\n    }\n\n    // Create properties from standard decorator metadata:\n    const metadata = this[Symbol.metadata];\n    if (metadata !== null) {\n      const properties = litPropertyMetadata.get(metadata);\n      if (properties !== undefined) {\n        for (const [p, options] of properties) {\n          this.elementProperties.set(p, options);\n        }\n      }\n    }\n\n    // Create the attribute-to-property map\n    this.__attributeToPropertyMap = new Map();\n    for (const [p, options] of this.elementProperties) {\n      const attr = this.__attributeNameForProperty(p, options);\n      if (attr !== undefined) {\n        this.__attributeToPropertyMap.set(attr, p);\n      }\n    }\n\n    this.elementStyles = this.finalizeStyles(this.styles);\n\n    if (DEV_MODE) {\n      if (this.hasOwnProperty('createProperty')) {\n        issueWarning(\n          'no-override-create-property',\n          'Overriding ReactiveElement.createProperty() is deprecated. ' +\n            'The override will not be called with standard decorators'\n        );\n      }\n      if (this.hasOwnProperty('getPropertyDescriptor')) {\n        issueWarning(\n          'no-override-get-property-descriptor',\n          'Overriding ReactiveElement.getPropertyDescriptor() is deprecated. ' +\n            'The override will not be called with standard decorators'\n        );\n      }\n    }\n  }\n\n  /**\n   * Options used when calling `attachShadow`. Set this property to customize\n   * the options for the shadowRoot; for example, to create a closed\n   * shadowRoot: `{mode: 'closed'}`.\n   *\n   * Note, these options are used in `createRenderRoot`. If this method\n   * is customized, options should be respected if possible.\n   * @nocollapse\n   * @category rendering\n   */\n  static shadowRootOptions: ShadowRootInit = {mode: 'open'};\n\n  /**\n   * Takes the styles the user supplied via the `static styles` property and\n   * returns the array of styles to apply to the element.\n   * Override this method to integrate into a style management system.\n   *\n   * Styles are deduplicated preserving the _last_ instance in the list. This\n   * is a performance optimization to avoid duplicated styles that can occur\n   * especially when composing via subclassing. The last item is kept to try\n   * to preserve the cascade order with the assumption that it's most important\n   * that last added styles override previous styles.\n   *\n   * @nocollapse\n   * @category styles\n   */\n  protected static finalizeStyles(\n    styles?: CSSResultGroup\n  ): Array<CSSResultOrNative> {\n    const elementStyles = [];\n    if (Array.isArray(styles)) {\n      // Dedupe the flattened array in reverse order to preserve the last items.\n      // Casting to Array<unknown> works around TS error that\n      // appears to come from trying to flatten a type CSSResultArray.\n      const set = new Set((styles as Array<unknown>).flat(Infinity).reverse());\n      // Then preserve original order by adding the set items in reverse order.\n      for (const s of set) {\n        elementStyles.unshift(getCompatibleStyle(s as CSSResultOrNative));\n      }\n    } else if (styles !== undefined) {\n      elementStyles.push(getCompatibleStyle(styles));\n    }\n    return elementStyles;\n  }\n\n  /**\n   * Node or ShadowRoot into which element DOM should be rendered. Defaults\n   * to an open shadowRoot.\n   * @category rendering\n   */\n  readonly renderRoot!: HTMLElement | DocumentFragment;\n\n  /**\n   * Returns the property name for the given attribute `name`.\n   * @nocollapse\n   */\n  private static __attributeNameForProperty(\n    name: PropertyKey,\n    options: PropertyDeclaration\n  ) {\n    const attribute = options.attribute;\n    return attribute === false\n      ? undefined\n      : typeof attribute === 'string'\n      ? attribute\n      : typeof name === 'string'\n      ? name.toLowerCase()\n      : undefined;\n  }\n\n  // Initialize to an unresolved Promise so we can make sure the element has\n  // connected before first update.\n  private __updatePromise!: Promise<boolean>;\n\n  /**\n   * True if there is a pending update as a result of calling `requestUpdate()`.\n   * Should only be read.\n   * @category updates\n   */\n  isUpdatePending = false;\n\n  /**\n   * Is set to `true` after the first update. The element code cannot assume\n   * that `renderRoot` exists before the element `hasUpdated`.\n   * @category updates\n   */\n  hasUpdated = false;\n\n  /**\n   * Map with keys for any properties that have changed since the last\n   * update cycle with previous values.\n   *\n   * @internal\n   */\n  _$changedProperties!: PropertyValues;\n\n  /**\n   * Properties that should be reflected when updated.\n   */\n  private __reflectingProperties?: Set<PropertyKey>;\n\n  /**\n   * Name of currently reflecting property\n   */\n  private __reflectingProperty: PropertyKey | null = null;\n\n  /**\n   * Set of controllers.\n   */\n  private __controllers?: Set<ReactiveController>;\n\n  constructor() {\n    super();\n    this.__initialize();\n  }\n\n  /**\n   * Internal only override point for customizing work done when elements\n   * are constructed.\n   */\n  private __initialize() {\n    this.__updatePromise = new Promise<boolean>(\n      (res) => (this.enableUpdating = res)\n    );\n    this._$changedProperties = new Map();\n    // This enqueues a microtask that ust run before the first update, so it\n    // must be called before requestUpdate()\n    this.__saveInstanceProperties();\n    // ensures first update will be caught by an early access of\n    // `updateComplete`\n    this.requestUpdate();\n    (this.constructor as typeof ReactiveElement)._initializers?.forEach((i) =>\n      i(this)\n    );\n  }\n\n  /**\n   * Registers a `ReactiveController` to participate in the element's reactive\n   * update cycle. The element automatically calls into any registered\n   * controllers during its lifecycle callbacks.\n   *\n   * If the element is connected when `addController()` is called, the\n   * controller's `hostConnected()` callback will be immediately called.\n   * @category controllers\n   */\n  addController(controller: ReactiveController) {\n    (this.__controllers ??= new Set()).add(controller);\n    // If a controller is added after the element has been connected,\n    // call hostConnected. Note, re-using existence of `renderRoot` here\n    // (which is set in connectedCallback) to avoid the need to track a\n    // first connected state.\n    if (this.renderRoot !== undefined && this.isConnected) {\n      controller.hostConnected?.();\n    }\n  }\n\n  /**\n   * Removes a `ReactiveController` from the element.\n   * @category controllers\n   */\n  removeController(controller: ReactiveController) {\n    this.__controllers?.delete(controller);\n  }\n\n  /**\n   * Fixes any properties set on the instance before upgrade time.\n   * Otherwise these would shadow the accessor and break these properties.\n   * The properties are stored in a Map which is played back after the\n   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n   * (<=41), properties created for native platform properties like (`id` or\n   * `name`) may not have default values set in the element constructor. On\n   * these browsers native properties appear on instances and therefore their\n   * default value will overwrite any element default (e.g. if the element sets\n   * this.id = 'id' in the constructor, the 'id' will become '' since this is\n   * the native platform default).\n   */\n  private __saveInstanceProperties() {\n    const instanceProperties = new Map<PropertyKey, unknown>();\n    const elementProperties = (this.constructor as typeof ReactiveElement)\n      .elementProperties;\n    for (const p of elementProperties.keys() as IterableIterator<keyof this>) {\n      if (this.hasOwnProperty(p)) {\n        instanceProperties.set(p, this[p]);\n        delete this[p];\n      }\n    }\n    if (instanceProperties.size > 0) {\n      this.__instanceProperties = instanceProperties;\n    }\n  }\n\n  /**\n   * Returns the node into which the element should render and by default\n   * creates and returns an open shadowRoot. Implement to customize where the\n   * element's DOM is rendered. For example, to render into the element's\n   * childNodes, return `this`.\n   *\n   * @return Returns a node into which to render.\n   * @category rendering\n   */\n  protected createRenderRoot(): HTMLElement | DocumentFragment {\n    const renderRoot =\n      this.shadowRoot ??\n      this.attachShadow(\n        (this.constructor as typeof ReactiveElement).shadowRootOptions\n      );\n    adoptStyles(\n      renderRoot,\n      (this.constructor as typeof ReactiveElement).elementStyles\n    );\n    return renderRoot;\n  }\n\n  /**\n   * On first connection, creates the element's renderRoot, sets up\n   * element styling, and enables updating.\n   * @category lifecycle\n   */\n  connectedCallback() {\n    // Create renderRoot before controllers `hostConnected`\n    (this as Mutable<typeof this, 'renderRoot'>).renderRoot ??=\n      this.createRenderRoot();\n    this.enableUpdating(true);\n    this.__controllers?.forEach((c) => c.hostConnected?.());\n  }\n\n  /**\n   * Note, this method should be considered final and not overridden. It is\n   * overridden on the element instance with a function that triggers the first\n   * update.\n   * @category updates\n   */\n  protected enableUpdating(_requestedUpdate: boolean) {}\n\n  /**\n   * Allows for `super.disconnectedCallback()` in extensions while\n   * reserving the possibility of making non-breaking feature additions\n   * when disconnecting at some point in the future.\n   * @category lifecycle\n   */\n  disconnectedCallback() {\n    this.__controllers?.forEach((c) => c.hostDisconnected?.());\n  }\n\n  /**\n   * Synchronizes property values when attributes change.\n   *\n   * Specifically, when an attribute is set, the corresponding property is set.\n   * You should rarely need to implement this callback. If this method is\n   * overridden, `super.attributeChangedCallback(name, _old, value)` must be\n   * called.\n   *\n   * See [using the lifecycle callbacks](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks)\n   * on MDN for more information about the `attributeChangedCallback`.\n   * @category attributes\n   */\n  attributeChangedCallback(\n    name: string,\n    _old: string | null,\n    value: string | null\n  ) {\n    this._$attributeToProperty(name, value);\n  }\n\n  private __propertyToAttribute(name: PropertyKey, value: unknown) {\n    const elemProperties: PropertyDeclarationMap = (\n      this.constructor as typeof ReactiveElement\n    ).elementProperties;\n    const options = elemProperties.get(name)!;\n    const attr = (\n      this.constructor as typeof ReactiveElement\n    ).__attributeNameForProperty(name, options);\n    if (attr !== undefined && options.reflect === true) {\n      const converter =\n        (options.converter as ComplexAttributeConverter)?.toAttribute !==\n        undefined\n          ? (options.converter as ComplexAttributeConverter)\n          : defaultConverter;\n      const attrValue = converter.toAttribute!(value, options.type);\n      if (\n        DEV_MODE &&\n        (this.constructor as typeof ReactiveElement).enabledWarnings!.includes(\n          'migration'\n        ) &&\n        attrValue === undefined\n      ) {\n        issueWarning(\n          'undefined-attribute-value',\n          `The attribute value for the ${name as string} property is ` +\n            `undefined on element ${this.localName}. The attribute will be ` +\n            `removed, but in the previous version of \\`ReactiveElement\\`, ` +\n            `the attribute would not have changed.`\n        );\n      }\n      // Track if the property is being reflected to avoid\n      // setting the property again via `attributeChangedCallback`. Note:\n      // 1. this takes advantage of the fact that the callback is synchronous.\n      // 2. will behave incorrectly if multiple attributes are in the reaction\n      // stack at time of calling. However, since we process attributes\n      // in `update` this should not be possible (or an extreme corner case\n      // that we'd like to discover).\n      // mark state reflecting\n      this.__reflectingProperty = name;\n      if (attrValue == null) {\n        this.removeAttribute(attr);\n      } else {\n        this.setAttribute(attr, attrValue as string);\n      }\n      // mark state not reflecting\n      this.__reflectingProperty = null;\n    }\n  }\n\n  /** @internal */\n  _$attributeToProperty(name: string, value: string | null) {\n    const ctor = this.constructor as typeof ReactiveElement;\n    // Note, hint this as an `AttributeMap` so closure clearly understands\n    // the type; it has issues with tracking types through statics\n    const propName = (ctor.__attributeToPropertyMap as AttributeMap).get(name);\n    // Use tracking info to avoid reflecting a property value to an attribute\n    // if it was just set because the attribute changed.\n    if (propName !== undefined && this.__reflectingProperty !== propName) {\n      const options = ctor.getPropertyOptions(propName);\n      const converter =\n        typeof options.converter === 'function'\n          ? {fromAttribute: options.converter}\n          : options.converter?.fromAttribute !== undefined\n          ? options.converter\n          : defaultConverter;\n      // mark state reflecting\n      this.__reflectingProperty = propName;\n      this[propName as keyof this] = converter.fromAttribute!(\n        value,\n        options.type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      ) as any;\n      // mark state not reflecting\n      this.__reflectingProperty = null;\n    }\n  }\n\n  /**\n   * Requests an update which is processed asynchronously. This should be called\n   * when an element should update based on some state not triggered by setting\n   * a reactive property. In this case, pass no arguments. It should also be\n   * called when manually implementing a property setter. In this case, pass the\n   * property `name` and `oldValue` to ensure that any configured property\n   * options are honored.\n   *\n   * @param name name of requesting property\n   * @param oldValue old value of requesting property\n   * @param options property options to use instead of the previously\n   *     configured options\n   * @category updates\n   */\n  requestUpdate(\n    name?: PropertyKey,\n    oldValue?: unknown,\n    options?: PropertyDeclaration\n  ): void {\n    // If we have a property key, perform property update steps.\n    if (name !== undefined) {\n      if (DEV_MODE && (name as unknown) instanceof Event) {\n        issueWarning(\n          ``,\n          `The requestUpdate() method was called with an Event as the property name. This is probably a mistake caused by binding this.requestUpdate as an event listener. Instead bind a function that will call it with no arguments: () => this.requestUpdate()`\n        );\n      }\n      options ??= (\n        this.constructor as typeof ReactiveElement\n      ).getPropertyOptions(name);\n      const hasChanged = options.hasChanged ?? notEqual;\n      const newValue = this[name as keyof this];\n      if (hasChanged(newValue, oldValue)) {\n        this._$changeProperty(name, oldValue, options);\n      } else {\n        // Abort the request if the property should not be considered changed.\n        return;\n      }\n    }\n    if (this.isUpdatePending === false) {\n      this.__updatePromise = this.__enqueueUpdate();\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _$changeProperty(\n    name: PropertyKey,\n    oldValue: unknown,\n    options: PropertyDeclaration\n  ) {\n    // TODO (justinfagnani): Create a benchmark of Map.has() + Map.set(\n    // vs just Map.set()\n    if (!this._$changedProperties.has(name)) {\n      this._$changedProperties.set(name, oldValue);\n    }\n    // Add to reflecting properties set.\n    // Note, it's important that every change has a chance to add the\n    // property to `__reflectingProperties`. This ensures setting\n    // attribute + property reflects correctly.\n    if (options.reflect === true && this.__reflectingProperty !== name) {\n      (this.__reflectingProperties ??= new Set<PropertyKey>()).add(name);\n    }\n  }\n\n  /**\n   * Sets up the element to asynchronously update.\n   */\n  private async __enqueueUpdate() {\n    this.isUpdatePending = true;\n    try {\n      // Ensure any previous update has resolved before updating.\n      // This `await` also ensures that property changes are batched.\n      await this.__updatePromise;\n    } catch (e) {\n      // Refire any previous errors async so they do not disrupt the update\n      // cycle. Errors are refired so developers have a chance to observe\n      // them, and this can be done by implementing\n      // `window.onunhandledrejection`.\n      Promise.reject(e);\n    }\n    const result = this.scheduleUpdate();\n    // If `scheduleUpdate` returns a Promise, we await it. This is done to\n    // enable coordinating updates with a scheduler. Note, the result is\n    // checked to avoid delaying an additional microtask unless we need to.\n    if (result != null) {\n      await result;\n    }\n    return !this.isUpdatePending;\n  }\n\n  /**\n   * Schedules an element update. You can override this method to change the\n   * timing of updates by returning a Promise. The update will await the\n   * returned Promise, and you should resolve the Promise to allow the update\n   * to proceed. If this method is overridden, `super.scheduleUpdate()`\n   * must be called.\n   *\n   * For instance, to schedule updates to occur just before the next frame:\n   *\n   * ```ts\n   * override protected async scheduleUpdate(): Promise<unknown> {\n   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n   *   super.scheduleUpdate();\n   * }\n   * ```\n   * @category updates\n   */\n  protected scheduleUpdate(): void | Promise<unknown> {\n    const result = this.performUpdate();\n    if (\n      DEV_MODE &&\n      (this.constructor as typeof ReactiveElement).enabledWarnings!.includes(\n        'async-perform-update'\n      ) &&\n      typeof (result as unknown as Promise<unknown> | undefined)?.then ===\n        'function'\n    ) {\n      issueWarning(\n        'async-perform-update',\n        `Element ${this.localName} returned a Promise from performUpdate(). ` +\n          `This behavior is deprecated and will be removed in a future ` +\n          `version of ReactiveElement.`\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Performs an element update. Note, if an exception is thrown during the\n   * update, `firstUpdated` and `updated` will not be called.\n   *\n   * Call `performUpdate()` to immediately process a pending update. This should\n   * generally not be needed, but it can be done in rare cases when you need to\n   * update synchronously.\n   *\n   * @category updates\n   */\n  protected performUpdate(): void {\n    // Abort any update if one is not pending when this is called.\n    // This can happen if `performUpdate` is called early to \"flush\"\n    // the update.\n    if (!this.isUpdatePending) {\n      return;\n    }\n    debugLogEvent?.({kind: 'update'});\n    if (!this.hasUpdated) {\n      // Create renderRoot before first update. This occurs in `connectedCallback`\n      // but is done here to support out of tree calls to `enableUpdating`/`performUpdate`.\n      (this as Mutable<typeof this, 'renderRoot'>).renderRoot ??=\n        this.createRenderRoot();\n      if (DEV_MODE) {\n        // Produce warning if any reactive properties on the prototype are\n        // shadowed by class fields. Instance fields set before upgrade are\n        // deleted by this point, so any own property is caused by class field\n        // initialization in the constructor.\n        const ctor = this.constructor as typeof ReactiveElement;\n        const shadowedProperties = [...ctor.elementProperties.keys()].filter(\n          (p) => this.hasOwnProperty(p) && p in getPrototypeOf(this)\n        );\n        if (shadowedProperties.length) {\n          throw new Error(\n            `The following properties on element ${this.localName} will not ` +\n              `trigger updates as expected because they are set using class ` +\n              `fields: ${shadowedProperties.join(', ')}. ` +\n              `Native class fields and some compiled output will overwrite ` +\n              `accessors used for detecting changes. See ` +\n              `https://lit.dev/msg/class-field-shadowing ` +\n              `for more information.`\n          );\n        }\n      }\n      // Mixin instance properties once, if they exist.\n      if (this.__instanceProperties) {\n        // TODO (justinfagnani): should we use the stored value? Could a new value\n        // have been set since we stored the own property value?\n        for (const [p, value] of this.__instanceProperties) {\n          this[p as keyof this] = value as this[keyof this];\n        }\n        this.__instanceProperties = undefined;\n      }\n      // Trigger initial value reflection and populate the initial\n      // changedProperties map, but only for the case of experimental\n      // decorators on accessors, which will not have already populated the\n      // changedProperties map. We can't know if these accessors had\n      // initializers, so we just set them anyway - a difference from\n      // experimental decorators on fields and standard decorators on\n      // auto-accessors.\n      // For context why experimentalDecorators with auto accessors are handled\n      // specifically also see:\n      // https://github.com/lit/lit/pull/4183#issuecomment-1711959635\n      const elementProperties = (this.constructor as typeof ReactiveElement)\n        .elementProperties;\n      if (elementProperties.size > 0) {\n        for (const [p, options] of elementProperties) {\n          if (\n            options.wrapped === true &&\n            !this._$changedProperties.has(p) &&\n            this[p as keyof this] !== undefined\n          ) {\n            this._$changeProperty(p, this[p as keyof this], options);\n          }\n        }\n      }\n    }\n    let shouldUpdate = false;\n    const changedProperties = this._$changedProperties;\n    try {\n      shouldUpdate = this.shouldUpdate(changedProperties);\n      if (shouldUpdate) {\n        this.willUpdate(changedProperties);\n        this.__controllers?.forEach((c) => c.hostUpdate?.());\n        this.update(changedProperties);\n      } else {\n        this.__markUpdated();\n      }\n    } catch (e) {\n      // Prevent `firstUpdated` and `updated` from running when there's an\n      // update exception.\n      shouldUpdate = false;\n      // Ensure element can accept additional updates after an exception.\n      this.__markUpdated();\n      throw e;\n    }\n    // The update is no longer considered pending and further updates are now allowed.\n    if (shouldUpdate) {\n      this._$didUpdate(changedProperties);\n    }\n  }\n\n  /**\n   * Invoked before `update()` to compute values needed during the update.\n   *\n   * Implement `willUpdate` to compute property values that depend on other\n   * properties and are used in the rest of the update process.\n   *\n   * ```ts\n   * willUpdate(changedProperties) {\n   *   // only need to check changed properties for an expensive computation.\n   *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {\n   *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);\n   *   }\n   * }\n   *\n   * render() {\n   *   return html`SHA: ${this.sha}`;\n   * }\n   * ```\n   *\n   * @category updates\n   */\n  protected willUpdate(_changedProperties: PropertyValues): void {}\n\n  // Note, this is an override point for polyfill-support.\n  // @internal\n  _$didUpdate(changedProperties: PropertyValues) {\n    this.__controllers?.forEach((c) => c.hostUpdated?.());\n    if (!this.hasUpdated) {\n      this.hasUpdated = true;\n      this.firstUpdated(changedProperties);\n    }\n    this.updated(changedProperties);\n    if (\n      DEV_MODE &&\n      this.isUpdatePending &&\n      (this.constructor as typeof ReactiveElement).enabledWarnings!.includes(\n        'change-in-update'\n      )\n    ) {\n      issueWarning(\n        'change-in-update',\n        `Element ${this.localName} scheduled an update ` +\n          `(generally because a property was set) ` +\n          `after an update completed, causing a new update to be scheduled. ` +\n          `This is inefficient and should be avoided unless the next update ` +\n          `can only be scheduled as a side effect of the previous update.`\n      );\n    }\n  }\n\n  private __markUpdated() {\n    this._$changedProperties = new Map();\n    this.isUpdatePending = false;\n  }\n\n  /**\n   * Returns a Promise that resolves when the element has completed updating.\n   * The Promise value is a boolean that is `true` if the element completed the\n   * update without triggering another update. The Promise result is `false` if\n   * a property was set inside `updated()`. If the Promise is rejected, an\n   * exception was thrown during the update.\n   *\n   * To await additional asynchronous work, override the `getUpdateComplete`\n   * method. For example, it is sometimes useful to await a rendered element\n   * before fulfilling this Promise. To do this, first await\n   * `super.getUpdateComplete()`, then any subsequent state.\n   *\n   * @return A promise of a boolean that resolves to true if the update completed\n   *     without triggering another update.\n   * @category updates\n   */\n  get updateComplete(): Promise<boolean> {\n    return this.getUpdateComplete();\n  }\n\n  /**\n   * Override point for the `updateComplete` promise.\n   *\n   * It is not safe to override the `updateComplete` getter directly due to a\n   * limitation in TypeScript which means it is not possible to call a\n   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n   * This method should be overridden instead. For example:\n   *\n   * ```ts\n   * class MyElement extends LitElement {\n   *   override async getUpdateComplete() {\n   *     const result = await super.getUpdateComplete();\n   *     await this._myChild.updateComplete;\n   *     return result;\n   *   }\n   * }\n   * ```\n   *\n   * @return A promise of a boolean that resolves to true if the update completed\n   *     without triggering another update.\n   * @category updates\n   */\n  protected getUpdateComplete(): Promise<boolean> {\n    return this.__updatePromise;\n  }\n\n  /**\n   * Controls whether or not `update()` should be called when the element requests\n   * an update. By default, this method always returns `true`, but this can be\n   * customized to control when to update.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  protected shouldUpdate(_changedProperties: PropertyValues): boolean {\n    return true;\n  }\n\n  /**\n   * Updates the element. This method reflects property values to attributes.\n   * It can be overridden to render and keep updated element DOM.\n   * Setting properties inside this method will *not* trigger\n   * another update.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  protected update(_changedProperties: PropertyValues) {\n    // The forEach() expression will only run when when __reflectingProperties is\n    // defined, and it returns undefined, setting __reflectingProperties to\n    // undefined\n    this.__reflectingProperties &&= this.__reflectingProperties.forEach((p) =>\n      this.__propertyToAttribute(p, this[p as keyof this])\n    ) as undefined;\n    this.__markUpdated();\n  }\n\n  /**\n   * Invoked whenever the element is updated. Implement to perform\n   * post-updating tasks via DOM APIs, for example, focusing an element.\n   *\n   * Setting properties inside this method will trigger the element to update\n   * again after this update cycle completes.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  protected updated(_changedProperties: PropertyValues) {}\n\n  /**\n   * Invoked when the element is first updated. Implement to perform one time\n   * work on the element after update.\n   *\n   * ```ts\n   * firstUpdated() {\n   *   this.renderRoot.getElementById('my-text-area').focus();\n   * }\n   * ```\n   *\n   * Setting properties inside this method will trigger the element to update\n   * again after this update cycle completes.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  protected firstUpdated(_changedProperties: PropertyValues) {}\n}\n// Assigned here to work around a jscompiler bug with static fields\n// when compiling to ES5.\n// https://github.com/google/closure-compiler/issues/3177\n(ReactiveElement as unknown as Record<string, unknown>)[\n  JSCompiler_renameProperty('elementProperties', ReactiveElement)\n] = new Map();\n(ReactiveElement as unknown as Record<string, unknown>)[\n  JSCompiler_renameProperty('finalized', ReactiveElement)\n] = new Map();\n\n// Apply polyfills if available\npolyfillSupport?.({ReactiveElement});\n\n// Dev mode warnings...\nif (DEV_MODE) {\n  // Default warning set.\n  ReactiveElement.enabledWarnings = [\n    'change-in-update',\n    'async-perform-update',\n  ];\n  const ensureOwnWarnings = function (ctor: typeof ReactiveElement) {\n    if (\n      !ctor.hasOwnProperty(JSCompiler_renameProperty('enabledWarnings', ctor))\n    ) {\n      ctor.enabledWarnings = ctor.enabledWarnings!.slice();\n    }\n  };\n  ReactiveElement.enableWarning = function (\n    this: typeof ReactiveElement,\n    warning: WarningKind\n  ) {\n    ensureOwnWarnings(this);\n    if (!this.enabledWarnings!.includes(warning)) {\n      this.enabledWarnings!.push(warning);\n    }\n  };\n  ReactiveElement.disableWarning = function (\n    this: typeof ReactiveElement,\n    warning: WarningKind\n  ) {\n    ensureOwnWarnings(this);\n    const i = this.enabledWarnings!.indexOf(warning);\n    if (i >= 0) {\n      this.enabledWarnings!.splice(i, 1);\n    }\n  };\n}\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for ReactiveElement usage.\n(global.reactiveElementVersions ??= []).push('2.0.4');\nif (DEV_MODE && global.reactiveElementVersions.length > 1) {\n  issueWarning!(\n    'multiple-versions',\n    `Multiple versions of Lit loaded. Loading multiple versions ` +\n      `is not recommended.`\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst t=globalThis,e=t.ShadowRoot&&(void 0===t.ShadyCSS||t.ShadyCSS.nativeShadow)&&\"adoptedStyleSheets\"in Document.prototype&&\"replace\"in CSSStyleSheet.prototype,s=Symbol(),o=new WeakMap;class n{constructor(t,e,o){if(this._$cssResult$=!0,o!==s)throw Error(\"CSSResult is not constructable. Use `unsafeCSS` or `css` instead.\");this.cssText=t,this.t=e}get styleSheet(){let t=this.o;const s=this.t;if(e&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o.set(s,t))}return t}toString(){return this.cssText}}const r=t=>new n(\"string\"==typeof t?t:t+\"\",void 0,s),i=(t,...e)=>{const o=1===t.length?t[0]:e.reduce(((e,s,o)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if(\"number\"==typeof t)return t;throw Error(\"Value passed to 'css' function must be a 'css' function result: \"+t+\". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.\")})(s)+t[o+1]),t[0]);return new n(o,t,s)},S=(s,o)=>{if(e)s.adoptedStyleSheets=o.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of o){const o=document.createElement(\"style\"),n=t.litNonce;void 0!==n&&o.setAttribute(\"nonce\",n),o.textContent=e.cssText,s.appendChild(o)}},c=e?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e=\"\";for(const s of t.cssRules)e+=s.cssText;return r(e)})(t):t;export{n as CSSResult,S as adoptStyles,i as css,c as getCompatibleStyle,e as supportsAdoptingStyleSheets,r as unsafeCSS};\n//# sourceMappingURL=css-tag.js.map\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nconst NODE_MODE = false;\n\n// Allows minifiers to rename references to globalThis\nconst global = globalThis;\n\n/**\n * Whether the current browser supports `adoptedStyleSheets`.\n */\nexport const supportsAdoptingStyleSheets: boolean =\n  global.ShadowRoot &&\n  (global.ShadyCSS === undefined || global.ShadyCSS.nativeShadow) &&\n  'adoptedStyleSheets' in Document.prototype &&\n  'replace' in CSSStyleSheet.prototype;\n\n/**\n * A CSSResult or native CSSStyleSheet.\n *\n * In browsers that support constructible CSS style sheets, CSSStyleSheet\n * object can be used for styling along side CSSResult from the `css`\n * template tag.\n */\nexport type CSSResultOrNative = CSSResult | CSSStyleSheet;\n\nexport type CSSResultArray = Array<CSSResultOrNative | CSSResultArray>;\n\n/**\n * A single CSSResult, CSSStyleSheet, or an array or nested arrays of those.\n */\nexport type CSSResultGroup = CSSResultOrNative | CSSResultArray;\n\nconst constructionToken = Symbol();\n\nconst cssTagCache = new WeakMap<TemplateStringsArray, CSSStyleSheet>();\n\n/**\n * A container for a string of CSS text, that may be used to create a CSSStyleSheet.\n *\n * CSSResult is the return value of `css`-tagged template literals and\n * `unsafeCSS()`. In order to ensure that CSSResults are only created via the\n * `css` tag and `unsafeCSS()`, CSSResult cannot be constructed directly.\n */\nexport class CSSResult {\n  // This property needs to remain unminified.\n  ['_$cssResult$'] = true;\n  readonly cssText: string;\n  private _styleSheet?: CSSStyleSheet;\n  private _strings: TemplateStringsArray | undefined;\n\n  private constructor(\n    cssText: string,\n    strings: TemplateStringsArray | undefined,\n    safeToken: symbol\n  ) {\n    if (safeToken !== constructionToken) {\n      throw new Error(\n        'CSSResult is not constructable. Use `unsafeCSS` or `css` instead.'\n      );\n    }\n    this.cssText = cssText;\n    this._strings = strings;\n  }\n\n  // This is a getter so that it's lazy. In practice, this means stylesheets\n  // are not created until the first element instance is made.\n  get styleSheet(): CSSStyleSheet | undefined {\n    // If `supportsAdoptingStyleSheets` is true then we assume CSSStyleSheet is\n    // constructable.\n    let styleSheet = this._styleSheet;\n    const strings = this._strings;\n    if (supportsAdoptingStyleSheets && styleSheet === undefined) {\n      const cacheable = strings !== undefined && strings.length === 1;\n      if (cacheable) {\n        styleSheet = cssTagCache.get(strings);\n      }\n      if (styleSheet === undefined) {\n        (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(\n          this.cssText\n        );\n        if (cacheable) {\n          cssTagCache.set(strings, styleSheet);\n        }\n      }\n    }\n    return styleSheet;\n  }\n\n  toString(): string {\n    return this.cssText;\n  }\n}\n\ntype ConstructableCSSResult = CSSResult & {\n  new (\n    cssText: string,\n    strings: TemplateStringsArray | undefined,\n    safeToken: symbol\n  ): CSSResult;\n};\n\nconst textFromCSSResult = (value: CSSResultGroup | number) => {\n  // This property needs to remain unminified.\n  if ((value as CSSResult)['_$cssResult$'] === true) {\n    return (value as CSSResult).cssText;\n  } else if (typeof value === 'number') {\n    return value;\n  } else {\n    throw new Error(\n      `Value passed to 'css' function must be a 'css' function result: ` +\n        `${value}. Use 'unsafeCSS' to pass non-literal values, but take care ` +\n        `to ensure page security.`\n    );\n  }\n};\n\n/**\n * Wrap a value for interpolation in a {@linkcode css} tagged template literal.\n *\n * This is unsafe because untrusted CSS text can be used to phone home\n * or exfiltrate data to an attacker controlled site. Take care to only use\n * this with trusted input.\n */\nexport const unsafeCSS = (value: unknown) =>\n  new (CSSResult as ConstructableCSSResult)(\n    typeof value === 'string' ? value : String(value),\n    undefined,\n    constructionToken\n  );\n\n/**\n * A template literal tag which can be used with LitElement's\n * {@linkcode LitElement.styles} property to set element styles.\n *\n * For security reasons, only literal string values and number may be used in\n * embedded expressions. To incorporate non-literal values {@linkcode unsafeCSS}\n * may be used inside an expression.\n */\nexport const css = (\n  strings: TemplateStringsArray,\n  ...values: (CSSResultGroup | number)[]\n): CSSResult => {\n  const cssText =\n    strings.length === 1\n      ? strings[0]\n      : values.reduce(\n          (acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1],\n          strings[0]\n        );\n  return new (CSSResult as ConstructableCSSResult)(\n    cssText,\n    strings,\n    constructionToken\n  );\n};\n\n/**\n * Applies the given styles to a `shadowRoot`. When Shadow DOM is\n * available but `adoptedStyleSheets` is not, styles are appended to the\n * `shadowRoot` to [mimic spec behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n * Note, when shimming is used, any styles that are subsequently placed into\n * the shadowRoot should be placed *before* any shimmed adopted styles. This\n * will match spec behavior that gives adopted sheets precedence over styles in\n * shadowRoot.\n */\nexport const adoptStyles = (\n  renderRoot: ShadowRoot,\n  styles: Array<CSSResultOrNative>\n) => {\n  if (supportsAdoptingStyleSheets) {\n    (renderRoot as ShadowRoot).adoptedStyleSheets = styles.map((s) =>\n      s instanceof CSSStyleSheet ? s : s.styleSheet!\n    );\n  } else {\n    for (const s of styles) {\n      const style = document.createElement('style');\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const nonce = (global as any)['litNonce'];\n      if (nonce !== undefined) {\n        style.setAttribute('nonce', nonce);\n      }\n      style.textContent = (s as CSSResult).cssText;\n      renderRoot.appendChild(style);\n    }\n  }\n};\n\nconst cssResultFromStyleSheet = (sheet: CSSStyleSheet) => {\n  let cssText = '';\n  for (const rule of sheet.cssRules) {\n    cssText += rule.cssText;\n  }\n  return unsafeCSS(cssText);\n};\n\nexport const getCompatibleStyle =\n  supportsAdoptingStyleSheets ||\n  (NODE_MODE && global.CSSStyleSheet === undefined)\n    ? (s: CSSResultOrNative) => s\n    : (s: CSSResultOrNative) =>\n        s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst t=globalThis,i=t.trustedTypes,s=i?i.createPolicy(\"lit-html\",{createHTML:t=>t}):void 0,e=\"$lit$\",h=`lit$${Math.random().toFixed(9).slice(2)}$`,o=\"?\"+h,n=`<${o}>`,r=document,l=()=>r.createComment(\"\"),c=t=>null===t||\"object\"!=typeof t&&\"function\"!=typeof t,a=Array.isArray,u=t=>a(t)||\"function\"==typeof t?.[Symbol.iterator],d=\"[ \\t\\n\\f\\r]\",f=/<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g,v=/-->/g,_=/>/g,m=RegExp(`>|${d}(?:([^\\\\s\"'>=/]+)(${d}*=${d}*(?:[^ \\t\\n\\f\\r\"'\\`<>=]|(\"|')|))|$)`,\"g\"),p=/'/g,g=/\"/g,$=/^(?:script|style|textarea|title)$/i,y=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=y(1),b=y(2),w=Symbol.for(\"lit-noChange\"),T=Symbol.for(\"lit-nothing\"),A=new WeakMap,E=r.createTreeWalker(r,129);function C(t,i){if(!Array.isArray(t)||!t.hasOwnProperty(\"raw\"))throw Error(\"invalid template strings array\");return void 0!==s?s.createHTML(i):i}const P=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?\"<svg>\":\"\",c=f;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f?\"!--\"===u[1]?c=v:void 0!==u[1]?c=_:void 0!==u[2]?($.test(u[2])&&(r=RegExp(\"</\"+u[2],\"g\")),c=m):void 0!==u[3]&&(c=m):c===m?\">\"===u[0]?(c=r??f,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m:'\"'===u[3]?g:p):c===g||c===p?c=m:c===v||c===_?c=f:(c=m,r=void 0);const x=c===m&&t[i+1].startsWith(\"/>\")?\" \":\"\";l+=c===f?s+n:d>=0?(o.push(a),s.slice(0,d)+e+s.slice(d)+h+x):s+h+(-2===d?i:x)}return[C(t,l+(t[s]||\"<?>\")+(2===i?\"</svg>\":\"\")),o]};class V{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=P(t,s);if(this.el=V.createElement(f,n),E.currentNode=this.el.content,2===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes)}for(;null!==(r=E.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e)){const i=v[a++],s=r.getAttribute(t).split(h),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:\".\"===e[1]?k:\"?\"===e[1]?H:\"@\"===e[1]?I:R}),r.removeAttribute(t)}else t.startsWith(h)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($.test(r.tagName)){const t=r.textContent.split(h),s=t.length-1;if(s>0){r.textContent=i?i.emptyScript:\"\";for(let i=0;i<s;i++)r.append(t[i],l()),E.nextNode(),d.push({type:2,index:++c});r.append(t[s],l())}}}else if(8===r.nodeType)if(r.data===o)d.push({type:2,index:c});else{let t=-1;for(;-1!==(t=r.data.indexOf(h,t+1));)d.push({type:7,index:c}),t+=h.length-1}c++}}static createElement(t,i){const s=r.createElement(\"template\");return s.innerHTML=t,s}}function N(t,i,s=t,e){if(i===w)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=N(t,h._$AS(t,i.values),h,e)),i}class S{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r).importNode(i,!0);E.currentNode=e;let h=E.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new M(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new L(h,this,t)),this._$AV.push(i),l=s[++n]}o!==l?.index&&(h=E.nextNode(),o++)}return E.currentNode=r,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++}}class M{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=T,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N(this,t,i),c(t)?t===T||null==t||\"\"===t?(this._$AH!==T&&this._$AR(),this._$AH=T):t!==this._$AH&&t!==w&&this._(t):void 0!==t._$litType$?this.$(t):void 0!==t.nodeType?this.T(t):u(t)?this.k(t):this._(t)}S(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}T(t){this._$AH!==t&&(this._$AR(),this._$AH=this.S(t))}_(t){this._$AH!==T&&c(this._$AH)?this._$AA.nextSibling.data=t:this.T(r.createTextNode(t)),this._$AH=t}$(t){const{values:i,_$litType$:s}=t,e=\"number\"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=V.createElement(C(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else{const t=new S(e,this),s=t.u(this.options);t.p(i),this.T(s),this._$AH=t}}_$AC(t){let i=A.get(t.strings);return void 0===i&&A.set(t.strings,i=new V(t)),i}k(t){a(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new M(this.S(l()),this.S(l()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e)}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t))}}class R{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=T,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||\"\"!==s[0]||\"\"!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=T}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=N(this,t,i,0),o=!c(t)||t!==this._$AH&&t!==w,o&&(this._$AH=t);else{const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=N(this,e[s+n],i,n),r===w&&(r=this._$AH[n]),o||=!c(r)||r!==this._$AH[n],r===T?t=T:t!==T&&(t+=(r??\"\")+h[n+1]),this._$AH[n]=r}o&&!e&&this.j(t)}j(t){t===T?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??\"\")}}class k extends R{constructor(){super(...arguments),this.type=3}j(t){this.element[this.name]=t===T?void 0:t}}class H extends R{constructor(){super(...arguments),this.type=4}j(t){this.element.toggleAttribute(this.name,!!t&&t!==T)}}class I extends R{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5}_$AI(t,i=this){if((t=N(this,t,i,0)??T)===w)return;const s=this._$AH,e=t===T&&s!==T||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==T&&(s===T||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t}handleEvent(t){\"function\"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t)}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s}get _$AU(){return this._$AM._$AU}_$AI(t){N(this,t)}}const z={P:e,A:h,C:o,M:1,L:P,R:S,D:u,V:N,I:M,H:R,N:H,U:I,B:k,F:L},Z=t.litHtmlPolyfillSupport;Z?.(V,M),(t.litHtmlVersions??=[]).push(\"3.1.3\");const j=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new M(i.insertBefore(l(),t),t,void 0,s??{})}return h._$AI(t),h};export{z as _$LH,x as html,w as noChange,T as nothing,j as render,b as svg};\n//# sourceMappingURL=lit-html.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// IMPORTANT: these imports must be type-only\nimport type {Directive, DirectiveResult, PartInfo} from './directive.js';\n\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\nconst ENABLE_SHADYDOM_NOPATCH = true;\nconst NODE_MODE = false;\n\n// Allows minifiers to rename references to globalThis\nconst global = globalThis;\n\n/**\n * Contains types that are part of the unstable debug API.\n *\n * Everything in this API is not stable and may change or be removed in the future,\n * even on patch releases.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace LitUnstable {\n  /**\n   * When Lit is running in dev mode and `window.emitLitDebugLogEvents` is true,\n   * we will emit 'lit-debug' events to window, with live details about the update and render\n   * lifecycle. These can be useful for writing debug tooling and visualizations.\n   *\n   * Please be aware that running with window.emitLitDebugLogEvents has performance overhead,\n   * making certain operations that are normally very cheap (like a no-op render) much slower,\n   * because we must copy data and dispatch events.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  export namespace DebugLog {\n    export type Entry =\n      | TemplatePrep\n      | TemplateInstantiated\n      | TemplateInstantiatedAndUpdated\n      | TemplateUpdating\n      | BeginRender\n      | EndRender\n      | CommitPartEntry\n      | SetPartValue;\n    export interface TemplatePrep {\n      kind: 'template prep';\n      template: Template;\n      strings: TemplateStringsArray;\n      clonableTemplate: HTMLTemplateElement;\n      parts: TemplatePart[];\n    }\n    export interface BeginRender {\n      kind: 'begin render';\n      id: number;\n      value: unknown;\n      container: HTMLElement | DocumentFragment;\n      options: RenderOptions | undefined;\n      part: ChildPart | undefined;\n    }\n    export interface EndRender {\n      kind: 'end render';\n      id: number;\n      value: unknown;\n      container: HTMLElement | DocumentFragment;\n      options: RenderOptions | undefined;\n      part: ChildPart;\n    }\n    export interface TemplateInstantiated {\n      kind: 'template instantiated';\n      template: Template | CompiledTemplate;\n      instance: TemplateInstance;\n      options: RenderOptions | undefined;\n      fragment: Node;\n      parts: Array<Part | undefined>;\n      values: unknown[];\n    }\n    export interface TemplateInstantiatedAndUpdated {\n      kind: 'template instantiated and updated';\n      template: Template | CompiledTemplate;\n      instance: TemplateInstance;\n      options: RenderOptions | undefined;\n      fragment: Node;\n      parts: Array<Part | undefined>;\n      values: unknown[];\n    }\n    export interface TemplateUpdating {\n      kind: 'template updating';\n      template: Template | CompiledTemplate;\n      instance: TemplateInstance;\n      options: RenderOptions | undefined;\n      parts: Array<Part | undefined>;\n      values: unknown[];\n    }\n    export interface SetPartValue {\n      kind: 'set part';\n      part: Part;\n      value: unknown;\n      valueIndex: number;\n      values: unknown[];\n      templateInstance: TemplateInstance;\n    }\n\n    export type CommitPartEntry =\n      | CommitNothingToChildEntry\n      | CommitText\n      | CommitNode\n      | CommitAttribute\n      | CommitProperty\n      | CommitBooleanAttribute\n      | CommitEventListener\n      | CommitToElementBinding;\n\n    export interface CommitNothingToChildEntry {\n      kind: 'commit nothing to child';\n      start: ChildNode;\n      end: ChildNode | null;\n      parent: Disconnectable | undefined;\n      options: RenderOptions | undefined;\n    }\n\n    export interface CommitText {\n      kind: 'commit text';\n      node: Text;\n      value: unknown;\n      options: RenderOptions | undefined;\n    }\n\n    export interface CommitNode {\n      kind: 'commit node';\n      start: Node;\n      parent: Disconnectable | undefined;\n      value: Node;\n      options: RenderOptions | undefined;\n    }\n\n    export interface CommitAttribute {\n      kind: 'commit attribute';\n      element: Element;\n      name: string;\n      value: unknown;\n      options: RenderOptions | undefined;\n    }\n\n    export interface CommitProperty {\n      kind: 'commit property';\n      element: Element;\n      name: string;\n      value: unknown;\n      options: RenderOptions | undefined;\n    }\n\n    export interface CommitBooleanAttribute {\n      kind: 'commit boolean attribute';\n      element: Element;\n      name: string;\n      value: boolean;\n      options: RenderOptions | undefined;\n    }\n\n    export interface CommitEventListener {\n      kind: 'commit event listener';\n      element: Element;\n      name: string;\n      value: unknown;\n      oldListener: unknown;\n      options: RenderOptions | undefined;\n      // True if we're removing the old event listener (e.g. because settings changed, or value is nothing)\n      removeListener: boolean;\n      // True if we're adding a new event listener (e.g. because first render, or settings changed)\n      addListener: boolean;\n    }\n\n    export interface CommitToElementBinding {\n      kind: 'commit to element binding';\n      element: Element;\n      value: unknown;\n      options: RenderOptions | undefined;\n    }\n  }\n}\n\ninterface DebugLoggingWindow {\n  // Even in dev mode, we generally don't want to emit these events, as that's\n  // another level of cost, so only emit them when DEV_MODE is true _and_ when\n  // window.emitLitDebugEvents is true.\n  emitLitDebugLogEvents?: boolean;\n}\n\n/**\n * Useful for visualizing and logging insights into what the Lit template system is doing.\n *\n * Compiled out of prod mode builds.\n */\nconst debugLogEvent = DEV_MODE\n  ? (event: LitUnstable.DebugLog.Entry) => {\n      const shouldEmit = (global as unknown as DebugLoggingWindow)\n        .emitLitDebugLogEvents;\n      if (!shouldEmit) {\n        return;\n      }\n      global.dispatchEvent(\n        new CustomEvent<LitUnstable.DebugLog.Entry>('lit-debug', {\n          detail: event,\n        }),\n      );\n    }\n  : undefined;\n// Used for connecting beginRender and endRender events when there are nested\n// renders when errors are thrown preventing an endRender event from being\n// called.\nlet debugLogRenderId = 0;\n\nlet issueWarning: (code: string, warning: string) => void;\n\nif (DEV_MODE) {\n  global.litIssuedWarnings ??= new Set();\n\n  // Issue a warning, if we haven't already.\n  issueWarning = (code: string, warning: string) => {\n    warning += code\n      ? ` See https://lit.dev/msg/${code} for more information.`\n      : '';\n    if (!global.litIssuedWarnings!.has(warning)) {\n      console.warn(warning);\n      global.litIssuedWarnings!.add(warning);\n    }\n  };\n\n  issueWarning(\n    'dev-mode',\n    `Lit is in dev mode. Not recommended for production!`,\n  );\n}\n\nconst wrap =\n  ENABLE_SHADYDOM_NOPATCH &&\n  global.ShadyDOM?.inUse &&\n  global.ShadyDOM?.noPatch === true\n    ? (global.ShadyDOM!.wrap as <T extends Node>(node: T) => T)\n    : <T extends Node>(node: T) => node;\n\nconst trustedTypes = (global as unknown as Window).trustedTypes;\n\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = trustedTypes\n  ? trustedTypes.createPolicy('lit-html', {\n      createHTML: (s) => s,\n    })\n  : undefined;\n\n/**\n * Used to sanitize any value before it is written into the DOM. This can be\n * used to implement a security policy of allowed and disallowed values in\n * order to prevent XSS attacks.\n *\n * One way of using this callback would be to check attributes and properties\n * against a list of high risk fields, and require that values written to such\n * fields be instances of a class which is safe by construction. Closure's Safe\n * HTML Types is one implementation of this technique (\n * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).\n * The TrustedTypes polyfill in API-only mode could also be used as a basis\n * for this technique (https://github.com/WICG/trusted-types).\n *\n * @param node The HTML node (usually either a #text node or an Element) that\n *     is being written to. Note that this is just an exemplar node, the write\n *     may take place against another instance of the same class of node.\n * @param name The name of an attribute or property (for example, 'href').\n * @param type Indicates whether the write that's about to be performed will\n *     be to a property or a node.\n * @return A function that will sanitize this class of writes.\n */\nexport type SanitizerFactory = (\n  node: Node,\n  name: string,\n  type: 'property' | 'attribute',\n) => ValueSanitizer;\n\n/**\n * A function which can sanitize values that will be written to a specific kind\n * of DOM sink.\n *\n * See SanitizerFactory.\n *\n * @param value The value to sanitize. Will be the actual value passed into\n *     the lit-html template literal, so this could be of any type.\n * @return The value to write to the DOM. Usually the same as the input value,\n *     unless sanitization is needed.\n */\nexport type ValueSanitizer = (value: unknown) => unknown;\n\nconst identityFunction: ValueSanitizer = (value: unknown) => value;\nconst noopSanitizer: SanitizerFactory = (\n  _node: Node,\n  _name: string,\n  _type: 'property' | 'attribute',\n) => identityFunction;\n\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer: SanitizerFactory) => {\n  if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n    return;\n  }\n  if (sanitizerFactoryInternal !== noopSanitizer) {\n    throw new Error(\n      `Attempted to overwrite existing lit-html security policy.` +\n        ` setSanitizeDOMValueFactory should be called at most once.`,\n    );\n  }\n  sanitizerFactoryInternal = newSanitizer;\n};\n\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n  sanitizerFactoryInternal = noopSanitizer;\n};\n\nconst createSanitizer: SanitizerFactory = (node, name, type) => {\n  return sanitizerFactoryInternal(node, name, type);\n};\n\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${Math.random().toFixed(9).slice(2)}$`;\n\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\n\nconst d =\n  NODE_MODE && global.document === undefined\n    ? ({\n        createTreeWalker() {\n          return {};\n        },\n      } as unknown as Document)\n    : document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = () => d.createComment('');\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\nconst isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\n\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\n\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * So an attribute is:\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(\n  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`,\n  'g',\n);\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\n\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea|title)$/i;\n\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n\ntype ResultType = typeof HTML_RESULT | typeof SVG_RESULT;\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\n/**\n * The return type of the template tag functions, {@linkcode html} and\n * {@linkcode svg} when it hasn't been compiled by @lit-labs/compiler.\n *\n * A `TemplateResult` object holds all the information about a template\n * expression required to render it: the template strings, expression values,\n * and type of template (html or svg).\n *\n * `TemplateResult` objects do not create any DOM on their own. To create or\n * update DOM you need to render the `TemplateResult`. See\n * [Rendering](https://lit.dev/docs/components/rendering) for more information.\n *\n */\nexport type UncompiledTemplateResult<T extends ResultType = ResultType> = {\n  // This property needs to remain unminified.\n  ['_$litType$']: T;\n  strings: TemplateStringsArray;\n  values: unknown[];\n};\n\n/**\n * This is a template result that may be either uncompiled or compiled.\n *\n * In the future, TemplateResult will be this type. If you want to explicitly\n * note that a template result is potentially compiled, you can reference this\n * type and it will continue to behave the same through the next major version\n * of Lit. This can be useful for code that wants to prepare for the next\n * major version of Lit.\n */\nexport type MaybeCompiledTemplateResult<T extends ResultType = ResultType> =\n  | UncompiledTemplateResult<T>\n  | CompiledTemplateResult;\n\n/**\n * The return type of the template tag functions, {@linkcode html} and\n * {@linkcode svg}.\n *\n * A `TemplateResult` object holds all the information about a template\n * expression required to render it: the template strings, expression values,\n * and type of template (html or svg).\n *\n * `TemplateResult` objects do not create any DOM on their own. To create or\n * update DOM you need to render the `TemplateResult`. See\n * [Rendering](https://lit.dev/docs/components/rendering) for more information.\n *\n * In Lit 4, this type will be an alias of\n * MaybeCompiledTemplateResult, so that code will get type errors if it assumes\n * that Lit templates are not compiled. When deliberately working with only\n * one, use either {@linkcode CompiledTemplateResult} or\n * {@linkcode UncompiledTemplateResult} explicitly.\n */\nexport type TemplateResult<T extends ResultType = ResultType> =\n  UncompiledTemplateResult<T>;\n\nexport type HTMLTemplateResult = TemplateResult<typeof HTML_RESULT>;\n\nexport type SVGTemplateResult = TemplateResult<typeof SVG_RESULT>;\n\n/**\n * A TemplateResult that has been compiled by @lit-labs/compiler, skipping the\n * prepare step.\n */\nexport interface CompiledTemplateResult {\n  // This is a factory in order to make template initialization lazy\n  // and allow ShadyRenderOptions scope to be passed in.\n  // This property needs to remain unminified.\n  ['_$litType$']: CompiledTemplate;\n  values: unknown[];\n}\n\nexport interface CompiledTemplate extends Omit<Template, 'el'> {\n  // el is overridden to be optional. We initialize it on first render\n  el?: HTMLTemplateElement;\n\n  // The prepared HTML string to create a template element from.\n  // The type is a TemplateStringsArray to guarantee that the value came from\n  // source code, preventing a JSON injection attack.\n  h: TemplateStringsArray;\n}\n\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag =\n  <T extends ResultType>(type: T) =>\n  (strings: TemplateStringsArray, ...values: unknown[]): TemplateResult<T> => {\n    // Warn against templates octal escape sequences\n    // We do this here rather than in render so that the warning is closer to the\n    // template definition.\n    if (DEV_MODE && strings.some((s) => s === undefined)) {\n      console.warn(\n        'Some template strings are undefined.\\n' +\n          'This is probably caused by illegal octal escape sequences.',\n      );\n    }\n    if (DEV_MODE) {\n      // Import static-html.js results in a circular dependency which g3 doesn't\n      // handle. Instead we know that static values must have the field\n      // `_$litStatic$`.\n      if (\n        values.some((val) => (val as {_$litStatic$: unknown})?.['_$litStatic$'])\n      ) {\n        issueWarning(\n          '',\n          `Static values 'literal' or 'unsafeStatic' cannot be used as values to non-static templates.\\n` +\n            `Please use the static 'html' tag function. See https://lit.dev/docs/templates/expressions/#static-expressions`,\n        );\n      }\n    }\n    return {\n      // This property needs to remain unminified.\n      ['_$litType$']: type,\n      strings,\n      values,\n    };\n  };\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n *\n * ```ts\n * const header = (title: string) => html`<h1>${title}</h1>`;\n * ```\n *\n * The `html` tag returns a description of the DOM to render as a value. It is\n * lazy, meaning no work is done until the template is rendered. When rendering,\n * if a template comes from the same expression as a previously rendered result,\n * it's efficiently updated instead of replaced.\n */\nexport const html = tag(HTML_RESULT);\n\n/**\n * Interprets a template literal as an SVG fragment that can efficiently\n * render to and update a container.\n *\n * ```ts\n * const rect = svg`<rect width=\"10\" height=\"10\"></rect>`;\n *\n * const myImage = html`\n *   <svg viewBox=\"0 0 10 10\" xmlns=\"http://www.w3.org/2000/svg\">\n *     ${rect}\n *   </svg>`;\n * ```\n *\n * The `svg` *tag function* should only be used for SVG fragments, or elements\n * that would be contained **inside** an `<svg>` HTML element. A common error is\n * placing an `<svg>` *element* in a template tagged with the `svg` tag\n * function. The `<svg>` element is an HTML element and should be used within a\n * template tagged with the {@linkcode html} tag function.\n *\n * In LitElement usage, it's invalid to return an SVG fragment from the\n * `render()` method, as the SVG fragment will be contained within the element's\n * shadow root and thus cannot be used within an `<svg>` HTML element.\n */\nexport const svg = tag(SVG_RESULT);\n\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n *\n * ```ts\n * const button = html`${\n *  user.isAdmin\n *    ? html`<button>DELETE</button>`\n *    : nothing\n * }`;\n * ```\n *\n * Prefer using `nothing` over other falsy values as it provides a consistent\n * behavior between various expression binding contexts.\n *\n * In child expressions, `undefined`, `null`, `''`, and `nothing` all behave the\n * same and render no nodes. In attribute expressions, `nothing` _removes_ the\n * attribute, while `undefined` and `null` will render an empty string. In\n * property expressions `nothing` becomes `undefined`.\n */\nexport const nothing = Symbol.for('lit-nothing');\n\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new WeakMap<TemplateStringsArray, Template>();\n\n/**\n * Object specifying options for controlling lit-html rendering. Note that\n * while `render` may be called multiple times on the same `container` (and\n * `renderBefore` reference node) to efficiently update the rendered content,\n * only the options passed in during the first render are respected during\n * the lifetime of renders to that unique `container` + `renderBefore`\n * combination.\n */\nexport interface RenderOptions {\n  /**\n   * An object to use as the `this` value for event listeners. It's often\n   * useful to set this to the host component rendering a template.\n   */\n  host?: object;\n  /**\n   * A DOM node before which to render content in the container.\n   */\n  renderBefore?: ChildNode | null;\n  /**\n   * Node used for cloning the template (`importNode` will be called on this\n   * node). This controls the `ownerDocument` of the rendered DOM, along with\n   * any inherited context. Defaults to the global `document`.\n   */\n  creationScope?: {importNode(node: Node, deep?: boolean): Node};\n  /**\n   * The initial connected state for the top-level part being rendered. If no\n   * `isConnected` option is set, `AsyncDirective`s will be connected by\n   * default. Set to `false` if the initial render occurs in a disconnected tree\n   * and `AsyncDirective`s should see `isConnected === false` for their initial\n   * render. The `part.setConnected()` method must be used subsequent to initial\n   * render to change the connected state of the part.\n   */\n  isConnected?: boolean;\n}\n\nconst walker = d.createTreeWalker(\n  d,\n  129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */,\n);\n\nlet sanitizerFactoryInternal: SanitizerFactory = noopSanitizer;\n\n//\n// Classes only below here, const variable declarations only above here...\n//\n// Keeping variable declarations and classes together improves minification.\n// Interfaces and type aliases can be interleaved freely.\n//\n\n// Type for classes that have a `_directive` or `_directives[]` field, used by\n// `resolveDirective`\nexport interface DirectiveParent {\n  _$parent?: DirectiveParent;\n  _$isConnected: boolean;\n  __directive?: Directive;\n  __directives?: Array<Directive | undefined>;\n}\n\nfunction trustFromTemplateString(\n  tsa: TemplateStringsArray,\n  stringFromTSA: string,\n): TrustedHTML {\n  // A security check to prevent spoofing of Lit template results.\n  // In the future, we may be able to replace this with Array.isTemplateObject,\n  // though we might need to make that check inside of the html and svg\n  // functions, because precompiled templates don't come in as\n  // TemplateStringArray objects.\n  if (!Array.isArray(tsa) || !tsa.hasOwnProperty('raw')) {\n    let message = 'invalid template strings array';\n    if (DEV_MODE) {\n      message = `\n          Internal Error: expected template strings to be an array\n          with a 'raw' field. Faking a template strings array by\n          calling html or svg like an ordinary function is effectively\n          the same as calling unsafeHtml and can lead to major security\n          issues, e.g. opening your code up to XSS attacks.\n          If you're using the html or svg tagged template functions normally\n          and still seeing this error, please file a bug at\n          https://github.com/lit/lit/issues/new?template=bug_report.md\n          and include information about your build tooling, if any.\n        `\n        .trim()\n        .replace(/\\n */g, '\\n');\n    }\n    throw new Error(message);\n  }\n  return policy !== undefined\n    ? policy.createHTML(stringFromTSA)\n    : (stringFromTSA as unknown as TrustedHTML);\n}\n\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment markers denoting the `ChildPart`s\n * and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (\n  strings: TemplateStringsArray,\n  type: ResultType,\n): [TrustedHTML, Array<string>] => {\n  // Insert makers into the template HTML to represent the position of\n  // bindings. The following code scans the template strings to determine the\n  // syntactic position of the bindings. They can be in text position, where\n  // we insert an HTML comment, attribute value position, where we insert a\n  // sentinel string and re-write the attribute name, or inside a tag where\n  // we insert the sentinel string.\n  const l = strings.length - 1;\n  // Stores the case-sensitive bound attribute names in the order of their\n  // parts. ElementParts are also reflected in this array as undefined\n  // rather than a string, to disambiguate from attribute bindings.\n  const attrNames: Array<string> = [];\n  let html = type === SVG_RESULT ? '<svg>' : '';\n\n  // When we're inside a raw text tag (not it's text content), the regex\n  // will still be tagRegex so we can find attributes, but will switch to\n  // this regex when the tag ends.\n  let rawTextEndRegex: RegExp | undefined;\n\n  // The current parsing state, represented as a reference to one of the\n  // regexes\n  let regex = textEndRegex;\n\n  for (let i = 0; i < l; i++) {\n    const s = strings[i];\n    // The index of the end of the last attribute name. When this is\n    // positive at end of a string, it means we're in an attribute value\n    // position and need to rewrite the attribute name.\n    // We also use a special value of -2 to indicate that we encountered\n    // the end of a string in attribute name position.\n    let attrNameEndIndex = -1;\n    let attrName: string | undefined;\n    let lastIndex = 0;\n    let match!: RegExpExecArray | null;\n\n    // The conditions in this loop handle the current parse state, and the\n    // assignments to the `regex` variable are the state transitions.\n    while (lastIndex < s.length) {\n      // Make sure we start searching from where we previously left off\n      regex.lastIndex = lastIndex;\n      match = regex.exec(s);\n      if (match === null) {\n        break;\n      }\n      lastIndex = regex.lastIndex;\n      if (regex === textEndRegex) {\n        if (match[COMMENT_START] === '!--') {\n          regex = commentEndRegex;\n        } else if (match[COMMENT_START] !== undefined) {\n          // We started a weird comment, like </{\n          regex = comment2EndRegex;\n        } else if (match[TAG_NAME] !== undefined) {\n          if (rawTextElement.test(match[TAG_NAME])) {\n            // Record if we encounter a raw-text element. We'll switch to\n            // this regex at the end of the tag.\n            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n          }\n          regex = tagEndRegex;\n        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n          if (DEV_MODE) {\n            throw new Error(\n              'Bindings in tag names are not supported. Please use static templates instead. ' +\n                'See https://lit.dev/docs/templates/expressions/#static-expressions',\n            );\n          }\n          regex = tagEndRegex;\n        }\n      } else if (regex === tagEndRegex) {\n        if (match[ENTIRE_MATCH] === '>') {\n          // End of a tag. If we had started a raw-text element, use that\n          // regex\n          regex = rawTextEndRegex ?? textEndRegex;\n          // We may be ending an unquoted attribute value, so make sure we\n          // clear any pending attrNameEndIndex\n          attrNameEndIndex = -1;\n        } else if (match[ATTRIBUTE_NAME] === undefined) {\n          // Attribute name position\n          attrNameEndIndex = -2;\n        } else {\n          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n          attrName = match[ATTRIBUTE_NAME];\n          regex =\n            match[QUOTE_CHAR] === undefined\n              ? tagEndRegex\n              : match[QUOTE_CHAR] === '\"'\n                ? doubleQuoteAttrEndRegex\n                : singleQuoteAttrEndRegex;\n        }\n      } else if (\n        regex === doubleQuoteAttrEndRegex ||\n        regex === singleQuoteAttrEndRegex\n      ) {\n        regex = tagEndRegex;\n      } else if (regex === commentEndRegex || regex === comment2EndRegex) {\n        regex = textEndRegex;\n      } else {\n        // Not one of the five state regexes, so it must be the dynamically\n        // created raw text regex and we're at the close of that element.\n        regex = tagEndRegex;\n        rawTextEndRegex = undefined;\n      }\n    }\n\n    if (DEV_MODE) {\n      // If we have a attrNameEndIndex, which indicates that we should\n      // rewrite the attribute name, assert that we're in a valid attribute\n      // position - either in a tag, or a quoted attribute value.\n      console.assert(\n        attrNameEndIndex === -1 ||\n          regex === tagEndRegex ||\n          regex === singleQuoteAttrEndRegex ||\n          regex === doubleQuoteAttrEndRegex,\n        'unexpected parse state B',\n      );\n    }\n\n    // We have four cases:\n    //  1. We're in text position, and not in a raw text element\n    //     (regex === textEndRegex): insert a comment marker.\n    //  2. We have a non-negative attrNameEndIndex which means we need to\n    //     rewrite the attribute name to add a bound attribute suffix.\n    //  3. We're at the non-first binding in a multi-binding attribute, use a\n    //     plain marker.\n    //  4. We're somewhere else inside the tag. If we're in attribute name\n    //     position (attrNameEndIndex === -2), add a sequential suffix to\n    //     generate a unique attribute name.\n\n    // Detect a binding next to self-closing tag end and insert a space to\n    // separate the marker from the tag end:\n    const end =\n      regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';\n    html +=\n      regex === textEndRegex\n        ? s + nodeMarker\n        : attrNameEndIndex >= 0\n          ? (attrNames.push(attrName!),\n            s.slice(0, attrNameEndIndex) +\n              boundAttributeSuffix +\n              s.slice(attrNameEndIndex)) +\n            marker +\n            end\n          : s + marker + (attrNameEndIndex === -2 ? i : end);\n  }\n\n  const htmlResult: string | TrustedHTML =\n    html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');\n\n  // Returned as an array for terseness\n  return [trustFromTemplateString(strings, htmlResult), attrNames];\n};\n\n/** @internal */\nexport type {Template};\nclass Template {\n  /** @internal */\n  el!: HTMLTemplateElement;\n\n  parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: UncompiledTemplateResult,\n    options?: RenderOptions,\n  ) {\n    let node: Node | null;\n    let nodeIndex = 0;\n    let attrNameIndex = 0;\n    const partCount = strings.length - 1;\n    const parts = this.parts;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    this.el = Template.createElement(html, options);\n    walker.currentNode = this.el.content;\n\n    // Re-parent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const svgElement = this.el.content.firstChild!;\n      svgElement.replaceWith(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n      if (node.nodeType === 1) {\n        if (DEV_MODE) {\n          const tag = (node as Element).localName;\n          // Warn if `textarea` includes an expression and throw if `template`\n          // does since these are not supported. We do this by checking\n          // innerHTML for anything that looks like a marker. This catches\n          // cases like bindings in textarea there markers turn into text nodes.\n          if (\n            /^(?:textarea|template)$/i!.test(tag) &&\n            (node as Element).innerHTML.includes(marker)\n          ) {\n            const m =\n              `Expressions are not supported inside \\`${tag}\\` ` +\n              `elements. See https://lit.dev/msg/expression-in-${tag} for more ` +\n              `information.`;\n            if (tag === 'template') {\n              throw new Error(m);\n            } else issueWarning('', m);\n          }\n        }\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          for (const name of (node as Element).getAttributeNames()) {\n            if (name.endsWith(boundAttributeSuffix)) {\n              const realName = attrNames[attrNameIndex++];\n              const value = (node as Element).getAttribute(name)!;\n              const statics = value.split(marker);\n              const m = /([.?@])?(.*)/.exec(realName)!;\n              parts.push({\n                type: ATTRIBUTE_PART,\n                index: nodeIndex,\n                name: m[2],\n                strings: statics,\n                ctor:\n                  m[1] === '.'\n                    ? PropertyPart\n                    : m[1] === '?'\n                      ? BooleanAttributePart\n                      : m[1] === '@'\n                        ? EventPart\n                        : AttributePart,\n              });\n              (node as Element).removeAttribute(name);\n            } else if (name.startsWith(marker)) {\n              parts.push({\n                type: ELEMENT_PART,\n                index: nodeIndex,\n              });\n              (node as Element).removeAttribute(name);\n            }\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = trustedTypes\n              ? (trustedTypes.emptyScript as unknown as '')\n              : '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized when cloning in IE (could simplify when\n            // IE is no longer supported)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i], createMarker());\n              // Walk past the marker node we just added\n              walker.nextNode();\n              parts.push({type: CHILD_PART, index: ++nodeIndex});\n            }\n            // Note because this marker is added after the walker's current\n            // node, it will be walked to in the outer loop (and ignored), so\n            // we don't need to adjust nodeIndex here\n            (node as Element).append(strings[lastIndex], createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          parts.push({type: CHILD_PART, index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            parts.push({type: COMMENT_PART, index: nodeIndex});\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n\n    if (DEV_MODE) {\n      // If there was a duplicate attribute on a tag, then when the tag is\n      // parsed into an element the attribute gets de-duplicated. We can detect\n      // this mismatch if we haven't precisely consumed every attribute name\n      // when preparing the template. This works because `attrNames` is built\n      // from the template string and `attrNameIndex` comes from processing the\n      // resulting DOM.\n      if (attrNames.length !== attrNameIndex) {\n        throw new Error(\n          `Detected duplicate attribute bindings. This occurs if your template ` +\n            `has duplicate attributes on an element tag. For example ` +\n            `\"<input ?disabled=\\${true} ?disabled=\\${false}>\" contains a ` +\n            `duplicate \"disabled\" attribute. The error was detected in ` +\n            `the following template: \\n` +\n            '`' +\n            strings.join('${...}') +\n            '`',\n        );\n      }\n    }\n\n    // We could set walker.currentNode to another node here to prevent a memory\n    // leak, but every time we prepare a template, we immediately render it\n    // and re-use the walker in new TemplateInstance._clone().\n    debugLogEvent &&\n      debugLogEvent({\n        kind: 'template prep',\n        template: this,\n        clonableTemplate: this.el,\n        parts: this.parts,\n        strings,\n      });\n  }\n\n  // Overridden via `litHtmlPolyfillSupport` to provide platform support.\n  /** @nocollapse */\n  static createElement(html: TrustedHTML, _options?: RenderOptions) {\n    const el = d.createElement('template');\n    el.innerHTML = html as unknown as string;\n    return el;\n  }\n}\n\nexport interface Disconnectable {\n  _$parent?: Disconnectable;\n  _$disconnectableChildren?: Set<Disconnectable>;\n  // Rather than hold connection state on instances, Disconnectables recursively\n  // fetch the connection state from the RootPart they are connected in via\n  // getters up the Disconnectable tree via _$parent references. This pushes the\n  // cost of tracking the isConnected state to `AsyncDirectives`, and avoids\n  // needing to pass all Disconnectables (parts, template instances, and\n  // directives) their connection state each time it changes, which would be\n  // costly for trees that have no AsyncDirectives.\n  _$isConnected: boolean;\n}\n\nfunction resolveDirective(\n  part: ChildPart | AttributePart | ElementPart,\n  value: unknown,\n  parent: DirectiveParent = part,\n  attributeIndex?: number,\n): unknown {\n  // Bail early if the value is explicitly noChange. Note, this means any\n  // nested directive is still attached and is not run.\n  if (value === noChange) {\n    return value;\n  }\n  let currentDirective =\n    attributeIndex !== undefined\n      ? (parent as AttributePart).__directives?.[attributeIndex]\n      : (parent as ChildPart | ElementPart | Directive).__directive;\n  const nextDirectiveConstructor = isPrimitive(value)\n    ? undefined\n    : // This property needs to remain unminified.\n      (value as DirectiveResult)['_$litDirective$'];\n  if (currentDirective?.constructor !== nextDirectiveConstructor) {\n    // This property needs to remain unminified.\n    currentDirective?.['_$notifyDirectiveConnectionChanged']?.(false);\n    if (nextDirectiveConstructor === undefined) {\n      currentDirective = undefined;\n    } else {\n      currentDirective = new nextDirectiveConstructor(part as PartInfo);\n      currentDirective._$initialize(part, parent, attributeIndex);\n    }\n    if (attributeIndex !== undefined) {\n      ((parent as AttributePart).__directives ??= [])[attributeIndex] =\n        currentDirective;\n    } else {\n      (parent as ChildPart | Directive).__directive = currentDirective;\n    }\n  }\n  if (currentDirective !== undefined) {\n    value = resolveDirective(\n      part,\n      currentDirective._$resolve(part, (value as DirectiveResult).values),\n      currentDirective,\n      attributeIndex,\n    );\n  }\n  return value;\n}\n\nexport type {TemplateInstance};\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance implements Disconnectable {\n  _$template: Template;\n  _$parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$parent: ChildPart;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: Template, parent: ChildPart) {\n    this._$template = template;\n    this._$parent = parent;\n  }\n\n  // Called by ChildPart parentNode getter\n  get parentNode() {\n    return this._$parent.parentNode;\n  }\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    return this._$parent._$isConnected;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions | undefined) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this._$template;\n    const fragment = (options?.creationScope ?? d).importNode(content, true);\n    walker.currentNode = fragment;\n\n    let node = walker.nextNode()!;\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined) {\n      if (nodeIndex === templatePart.index) {\n        let part: Part | undefined;\n        if (templatePart.type === CHILD_PART) {\n          part = new ChildPart(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options,\n          );\n        } else if (templatePart.type === ATTRIBUTE_PART) {\n          part = new templatePart.ctor(\n            node as HTMLElement,\n            templatePart.name,\n            templatePart.strings,\n            this,\n            options,\n          );\n        } else if (templatePart.type === ELEMENT_PART) {\n          part = new ElementPart(node as HTMLElement, this, options);\n        }\n        this._$parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (nodeIndex !== templatePart?.index) {\n        node = walker.nextNode()!;\n        nodeIndex++;\n      }\n    }\n    // We need to set the currentNode away from the cloned tree so that we\n    // don't hold onto the tree even if the tree is detached and should be\n    // freed.\n    walker.currentNode = d;\n    return fragment;\n  }\n\n  _update(values: Array<unknown>) {\n    let i = 0;\n    for (const part of this._$parts) {\n      if (part !== undefined) {\n        debugLogEvent &&\n          debugLogEvent({\n            kind: 'set part',\n            part,\n            value: values[i],\n            valueIndex: i,\n            values,\n            templateInstance: this,\n          });\n        if ((part as AttributePart).strings !== undefined) {\n          (part as AttributePart)._$setValue(values, part as AttributePart, i);\n          // The number of values the part consumes is part.strings.length - 1\n          // since values are in between template spans. We increment i by 1\n          // later in the loop, so increment it by part.strings.length - 2 here\n          i += (part as AttributePart).strings!.length - 2;\n        } else {\n          part._$setValue(values[i]);\n        }\n      }\n      i++;\n    }\n  }\n}\n\n/*\n * Parts\n */\ntype AttributeTemplatePart = {\n  readonly type: typeof ATTRIBUTE_PART;\n  readonly index: number;\n  readonly name: string;\n  readonly ctor: typeof AttributePart;\n  readonly strings: ReadonlyArray<string>;\n};\ntype ChildTemplatePart = {\n  readonly type: typeof CHILD_PART;\n  readonly index: number;\n};\ntype ElementTemplatePart = {\n  readonly type: typeof ELEMENT_PART;\n  readonly index: number;\n};\ntype CommentTemplatePart = {\n  readonly type: typeof COMMENT_PART;\n  readonly index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | ChildTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part =\n  | ChildPart\n  | AttributePart\n  | PropertyPart\n  | BooleanAttributePart\n  | ElementPart\n  | EventPart;\n\nexport type {ChildPart};\nclass ChildPart implements Disconnectable {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions | undefined;\n  _$committedValue: unknown = nothing;\n  /** @internal */\n  __directive?: Directive;\n  /** @internal */\n  _$startNode: ChildNode;\n  /** @internal */\n  _$endNode: ChildNode | null;\n  private _textSanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n  /**\n   * Connection state for RootParts only (i.e. ChildPart without _$parent\n   * returned from top-level `render`). This field is unsed otherwise. The\n   * intention would clearer if we made `RootPart` a subclass of `ChildPart`\n   * with this field (and a different _$isConnected getter), but the subclass\n   * caused a perf regression, possibly due to making call sites polymorphic.\n   * @internal\n   */\n  __isConnected: boolean;\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    // ChildParts that are not at the root should always be created with a\n    // parent; only RootChildNode's won't, so they return the local isConnected\n    // state\n    return this._$parent?._$isConnected ?? this.__isConnected;\n  }\n\n  // The following fields will be patched onto ChildParts when required by\n  // AsyncDirective\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /** @internal */\n  _$notifyConnectionChanged?(\n    isConnected: boolean,\n    removeFromParent?: boolean,\n    from?: number,\n  ): void;\n  /** @internal */\n  _$reparentDisconnectables?(parent: Disconnectable): void;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions | undefined,\n  ) {\n    this._$startNode = startNode;\n    this._$endNode = endNode;\n    this._$parent = parent;\n    this.options = options;\n    // Note __isConnected is only ever accessed on RootParts (i.e. when there is\n    // no _$parent); the value on a non-root-part is \"don't care\", but checking\n    // for parent would be more code\n    this.__isConnected = options?.isConnected ?? true;\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      // Explicitly initialize for consistent class shape.\n      this._textSanitizer = undefined;\n    }\n  }\n\n  /**\n   * The parent node into which the part renders its content.\n   *\n   * A ChildPart's content consists of a range of adjacent child nodes of\n   * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and\n   * `.endNode`).\n   *\n   * - If both `.startNode` and `.endNode` are non-null, then the part's content\n   * consists of all siblings between `.startNode` and `.endNode`, exclusively.\n   *\n   * - If `.startNode` is non-null but `.endNode` is null, then the part's\n   * content consists of all siblings following `.startNode`, up to and\n   * including the last child of `.parentNode`. If `.endNode` is non-null, then\n   * `.startNode` will always be non-null.\n   *\n   * - If both `.endNode` and `.startNode` are null, then the part's content\n   * consists of all child nodes of `.parentNode`.\n   */\n  get parentNode(): Node {\n    let parentNode: Node = wrap(this._$startNode).parentNode!;\n    const parent = this._$parent;\n    if (\n      parent !== undefined &&\n      parentNode?.nodeType === 11 /* Node.DOCUMENT_FRAGMENT */\n    ) {\n      // If the parentNode is a DocumentFragment, it may be because the DOM is\n      // still in the cloned fragment during initial render; if so, get the real\n      // parentNode the part will be committed into by asking the parent.\n      parentNode = (parent as ChildPart | TemplateInstance).parentNode;\n    }\n    return parentNode;\n  }\n\n  /**\n   * The part's leading marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get startNode(): Node | null {\n    return this._$startNode;\n  }\n\n  /**\n   * The part's trailing marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get endNode(): Node | null {\n    return this._$endNode;\n  }\n\n  _$setValue(value: unknown, directiveParent: DirectiveParent = this): void {\n    if (DEV_MODE && this.parentNode === null) {\n      throw new Error(\n        `This \\`ChildPart\\` has no \\`parentNode\\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \\`innerHTML\\` or \\`textContent\\` can do this.`,\n      );\n    }\n    value = resolveDirective(this, value, directiveParent);\n    if (isPrimitive(value)) {\n      // Non-rendering child values. It's important that these do not render\n      // empty text nodes to avoid issues with preventing default <slot>\n      // fallback content.\n      if (value === nothing || value == null || value === '') {\n        if (this._$committedValue !== nothing) {\n          debugLogEvent &&\n            debugLogEvent({\n              kind: 'commit nothing to child',\n              start: this._$startNode,\n              end: this._$endNode,\n              parent: this._$parent,\n              options: this.options,\n            });\n          this._$clear();\n        }\n        this._$committedValue = nothing;\n      } else if (value !== this._$committedValue && value !== noChange) {\n        this._commitText(value);\n      }\n      // This property needs to remain unminified.\n    } else if ((value as TemplateResult)['_$litType$'] !== undefined) {\n      this._commitTemplateResult(value as TemplateResult);\n    } else if ((value as Node).nodeType !== undefined) {\n      if (DEV_MODE && this.options?.host === value) {\n        this._commitText(\n          `[probable mistake: rendered a template's host in itself ` +\n            `(commonly caused by writing \\${this} in a template]`,\n        );\n        console.warn(\n          `Attempted to render the template host`,\n          value,\n          `inside itself. This is almost always a mistake, and in dev mode `,\n          `we render some warning text. In production however, we'll `,\n          `render it, which will usually result in an error, and sometimes `,\n          `in the element disappearing from the DOM.`,\n        );\n        return;\n      }\n      this._commitNode(value as Node);\n    } else if (isIterable(value)) {\n      this._commitIterable(value);\n    } else {\n      // Fallback, will render the string representation\n      this._commitText(value);\n    }\n  }\n\n  private _insert<T extends Node>(node: T) {\n    return wrap(wrap(this._$startNode).parentNode!).insertBefore(\n      node,\n      this._$endNode,\n    );\n  }\n\n  private _commitNode(value: Node): void {\n    if (this._$committedValue !== value) {\n      this._$clear();\n      if (\n        ENABLE_EXTRA_SECURITY_HOOKS &&\n        sanitizerFactoryInternal !== noopSanitizer\n      ) {\n        const parentNodeName = this._$startNode.parentNode?.nodeName;\n        if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n          let message = 'Forbidden';\n          if (DEV_MODE) {\n            if (parentNodeName === 'STYLE') {\n              message =\n                `Lit does not support binding inside style nodes. ` +\n                `This is a security risk, as style injection attacks can ` +\n                `exfiltrate data and spoof UIs. ` +\n                `Consider instead using css\\`...\\` literals ` +\n                `to compose styles, and make do dynamic styling with ` +\n                `css custom properties, ::parts, <slot>s, ` +\n                `and by mutating the DOM rather than stylesheets.`;\n            } else {\n              message =\n                `Lit does not support binding inside script nodes. ` +\n                `This is a security risk, as it could allow arbitrary ` +\n                `code execution.`;\n            }\n          }\n          throw new Error(message);\n        }\n      }\n      debugLogEvent &&\n        debugLogEvent({\n          kind: 'commit node',\n          start: this._$startNode,\n          parent: this._$parent,\n          value: value,\n          options: this.options,\n        });\n      this._$committedValue = this._insert(value);\n    }\n  }\n\n  private _commitText(value: unknown): void {\n    // If the committed value is a primitive it means we called _commitText on\n    // the previous render, and we know that this._$startNode.nextSibling is a\n    // Text node. We can now just replace the text content (.data) of the node.\n    if (\n      this._$committedValue !== nothing &&\n      isPrimitive(this._$committedValue)\n    ) {\n      const node = wrap(this._$startNode).nextSibling as Text;\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(node, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n      }\n      debugLogEvent &&\n        debugLogEvent({\n          kind: 'commit text',\n          node,\n          value,\n          options: this.options,\n        });\n      (node as Text).data = value as string;\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        const textNode = d.createTextNode('');\n        this._commitNode(textNode);\n        // When setting text content, for security purposes it matters a lot\n        // what the parent is. For example, <style> and <script> need to be\n        // handled with care, while <span> does not. So first we need to put a\n        // text node into the document, then we can sanitize its content.\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n        debugLogEvent &&\n          debugLogEvent({\n            kind: 'commit text',\n            node: textNode,\n            value,\n            options: this.options,\n          });\n        textNode.data = value as string;\n      } else {\n        this._commitNode(d.createTextNode(value as string));\n        debugLogEvent &&\n          debugLogEvent({\n            kind: 'commit text',\n            node: wrap(this._$startNode).nextSibling as Text,\n            value,\n            options: this.options,\n          });\n      }\n    }\n    this._$committedValue = value;\n  }\n\n  private _commitTemplateResult(\n    result: TemplateResult | CompiledTemplateResult,\n  ): void {\n    // This property needs to remain unminified.\n    const {values, ['_$litType$']: type} = result;\n    // If $litType$ is a number, result is a plain TemplateResult and we get\n    // the template from the template cache. If not, result is a\n    // CompiledTemplateResult and _$litType$ is a CompiledTemplate and we need\n    // to create the <template> element the first time we see it.\n    const template: Template | CompiledTemplate =\n      typeof type === 'number'\n        ? this._$getTemplate(result as UncompiledTemplateResult)\n        : (type.el === undefined &&\n            (type.el = Template.createElement(\n              trustFromTemplateString(type.h, type.h[0]),\n              this.options,\n            )),\n          type);\n\n    if ((this._$committedValue as TemplateInstance)?._$template === template) {\n      debugLogEvent &&\n        debugLogEvent({\n          kind: 'template updating',\n          template,\n          instance: this._$committedValue as TemplateInstance,\n          parts: (this._$committedValue as TemplateInstance)._$parts,\n          options: this.options,\n          values,\n        });\n      (this._$committedValue as TemplateInstance)._update(values);\n    } else {\n      const instance = new TemplateInstance(template as Template, this);\n      const fragment = instance._clone(this.options);\n      debugLogEvent &&\n        debugLogEvent({\n          kind: 'template instantiated',\n          template,\n          instance,\n          parts: instance._$parts,\n          options: this.options,\n          fragment,\n          values,\n        });\n      instance._update(values);\n      debugLogEvent &&\n        debugLogEvent({\n          kind: 'template instantiated and updated',\n          template,\n          instance,\n          parts: instance._$parts,\n          options: this.options,\n          fragment,\n          values,\n        });\n      this._commitNode(fragment);\n      this._$committedValue = instance;\n    }\n  }\n\n  // Overridden via `litHtmlPolyfillSupport` to provide platform support.\n  /** @internal */\n  _$getTemplate(result: UncompiledTemplateResult) {\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n      templateCache.set(result.strings, (template = new Template(result)));\n    }\n    return template;\n  }\n\n  private _commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If value is an array, then the previous render was of an\n    // iterable and value will contain the ChildParts from the previous\n    // render. If value is not an array, clear this part and make a new\n    // array for ChildParts.\n    if (!isArray(this._$committedValue)) {\n      this._$committedValue = [];\n      this._$clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this._$committedValue as ChildPart[];\n    let partIndex = 0;\n    let itemPart: ChildPart | undefined;\n\n    for (const item of value) {\n      if (partIndex === itemParts.length) {\n        // If no existing part, create a new one\n        // TODO (justinfagnani): test perf impact of always creating two parts\n        // instead of sharing parts between nodes\n        // https://github.com/lit/lit/issues/1266\n        itemParts.push(\n          (itemPart = new ChildPart(\n            this._insert(createMarker()),\n            this._insert(createMarker()),\n            this,\n            this.options,\n          )),\n        );\n      } else {\n        // Reuse an existing part\n        itemPart = itemParts[partIndex];\n      }\n      itemPart._$setValue(item);\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // itemParts always have end nodes\n      this._$clear(\n        itemPart && wrap(itemPart._$endNode!).nextSibling,\n        partIndex,\n      );\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n    }\n  }\n\n  /**\n   * Removes the nodes contained within this Part from the DOM.\n   *\n   * @param start Start node to clear from, for clearing a subset of the part's\n   *     DOM (used when truncating iterables)\n   * @param from  When `start` is specified, the index within the iterable from\n   *     which ChildParts are being removed, used for disconnecting directives in\n   *     those Parts.\n   *\n   * @internal\n   */\n  _$clear(\n    start: ChildNode | null = wrap(this._$startNode).nextSibling,\n    from?: number,\n  ) {\n    this._$notifyConnectionChanged?.(false, true, from);\n    while (start && start !== this._$endNode) {\n      const n = wrap(start!).nextSibling;\n      (wrap(start!) as Element).remove();\n      start = n;\n    }\n  }\n  /**\n   * Implementation of RootPart's `isConnected`. Note that this metod\n   * should only be called on `RootPart`s (the `ChildPart` returned from a\n   * top-level `render()` call). It has no effect on non-root ChildParts.\n   * @param isConnected Whether to set\n   * @internal\n   */\n  setConnected(isConnected: boolean) {\n    if (this._$parent === undefined) {\n      this.__isConnected = isConnected;\n      this._$notifyConnectionChanged?.(isConnected);\n    } else if (DEV_MODE) {\n      throw new Error(\n        'part.setConnected() may only be called on a ' +\n          'RootPart returned from render().',\n      );\n    }\n  }\n}\n\n/**\n * A top-level `ChildPart` returned from `render` that manages the connected\n * state of `AsyncDirective`s created throughout the tree below it.\n */\nexport interface RootPart extends ChildPart {\n  /**\n   * Sets the connection state for `AsyncDirective`s contained within this root\n   * ChildPart.\n   *\n   * lit-html does not automatically monitor the connectedness of DOM rendered;\n   * as such, it is the responsibility of the caller to `render` to ensure that\n   * `part.setConnected(false)` is called before the part object is potentially\n   * discarded, to ensure that `AsyncDirective`s have a chance to dispose of\n   * any resources being held. If a `RootPart` that was previously\n   * disconnected is subsequently re-connected (and its `AsyncDirective`s should\n   * re-connect), `setConnected(true)` should be called.\n   *\n   * @param isConnected Whether directives within this tree should be connected\n   * or not\n   */\n  setConnected(isConnected: boolean): void;\n}\n\nexport type {AttributePart};\nclass AttributePart implements Disconnectable {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  _$committedValue: unknown | Array<unknown> = nothing;\n  /** @internal */\n  __directives?: Array<Directive | undefined>;\n  /** @internal */\n  _$parent: Disconnectable;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  protected _sanitizer: ValueSanitizer | undefined;\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    return this._$parent._$isConnected;\n  }\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable,\n    options: RenderOptions | undefined,\n  ) {\n    this.element = element;\n    this.name = name;\n    this._$parent = parent;\n    this.options = options;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this._$committedValue = new Array(strings.length - 1).fill(new String());\n      this.strings = strings;\n    } else {\n      this._$committedValue = nothing;\n    }\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      this._sanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the value of this part by resolving the value from possibly multiple\n   * values and static strings and committing it to the DOM.\n   * If this part is single-valued, `this._strings` will be undefined, and the\n   * method will be called with a single value argument. If this part is\n   * multi-value, `this._strings` will be defined, and the method is called\n   * with the value array of the part's owning TemplateInstance, and an offset\n   * into the value array from which the values should be read.\n   * This method is overloaded this way to eliminate short-lived array slices\n   * of the template instance values, and allow a fast-path for single-valued\n   * parts.\n   *\n   * @param value The part value, or an array of values for multi-valued parts\n   * @param valueIndex the index to start reading values from. `undefined` for\n   *   single-valued parts\n   * @param noCommit causes the part to not commit its value to the DOM. Used\n   *   in hydration to prime attribute parts with their first-rendered value,\n   *   but not set the attribute, and in SSR to no-op the DOM operation and\n   *   capture the value for serialization.\n   *\n   * @internal\n   */\n  _$setValue(\n    value: unknown | Array<unknown>,\n    directiveParent: DirectiveParent = this,\n    valueIndex?: number,\n    noCommit?: boolean,\n  ) {\n    const strings = this.strings;\n\n    // Whether any of the values has changed, for dirty-checking\n    let change = false;\n\n    if (strings === undefined) {\n      // Single-value binding case\n      value = resolveDirective(this, value, directiveParent, 0);\n      change =\n        !isPrimitive(value) ||\n        (value !== this._$committedValue && value !== noChange);\n      if (change) {\n        this._$committedValue = value;\n      }\n    } else {\n      // Interpolation case\n      const values = value as Array<unknown>;\n      value = strings[0];\n\n      let i, v;\n      for (i = 0; i < strings.length - 1; i++) {\n        v = resolveDirective(this, values[valueIndex! + i], directiveParent, i);\n\n        if (v === noChange) {\n          // If the user-provided value is `noChange`, use the previous value\n          v = (this._$committedValue as Array<unknown>)[i];\n        }\n        change ||=\n          !isPrimitive(v) || v !== (this._$committedValue as Array<unknown>)[i];\n        if (v === nothing) {\n          value = nothing;\n        } else if (value !== nothing) {\n          value += (v ?? '') + strings[i + 1];\n        }\n        // We always record each value, even if one is `nothing`, for future\n        // change detection.\n        (this._$committedValue as Array<unknown>)[i] = v;\n      }\n    }\n    if (change && !noCommit) {\n      this._commitValue(value);\n    }\n  }\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value === nothing) {\n      (wrap(this.element) as Element).removeAttribute(this.name);\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._sanitizer === undefined) {\n          this._sanitizer = sanitizerFactoryInternal(\n            this.element,\n            this.name,\n            'attribute',\n          );\n        }\n        value = this._sanitizer(value ?? '');\n      }\n      debugLogEvent &&\n        debugLogEvent({\n          kind: 'commit attribute',\n          element: this.element,\n          name: this.name,\n          value,\n          options: this.options,\n        });\n      (wrap(this.element) as Element).setAttribute(\n        this.name,\n        (value ?? '') as string,\n      );\n    }\n  }\n}\n\nexport type {PropertyPart};\nclass PropertyPart extends AttributePart {\n  override readonly type = PROPERTY_PART;\n\n  /** @internal */\n  override _commitValue(value: unknown) {\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      if (this._sanitizer === undefined) {\n        this._sanitizer = sanitizerFactoryInternal(\n          this.element,\n          this.name,\n          'property',\n        );\n      }\n      value = this._sanitizer(value);\n    }\n    debugLogEvent &&\n      debugLogEvent({\n        kind: 'commit property',\n        element: this.element,\n        name: this.name,\n        value,\n        options: this.options,\n      });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.element as any)[this.name] = value === nothing ? undefined : value;\n  }\n}\n\nexport type {BooleanAttributePart};\nclass BooleanAttributePart extends AttributePart {\n  override readonly type = BOOLEAN_ATTRIBUTE_PART;\n\n  /** @internal */\n  override _commitValue(value: unknown) {\n    debugLogEvent &&\n      debugLogEvent({\n        kind: 'commit boolean attribute',\n        element: this.element,\n        name: this.name,\n        value: !!(value && value !== nothing),\n        options: this.options,\n      });\n    (wrap(this.element) as Element).toggleAttribute(\n      this.name,\n      !!value && value !== nothing,\n    );\n  }\n}\n\ntype EventListenerWithOptions = EventListenerOrEventListenerObject &\n  Partial<AddEventListenerOptions>;\n\n/**\n * An AttributePart that manages an event listener via add/removeEventListener.\n *\n * This part works by adding itself as the event listener on an element, then\n * delegating to the value passed to it. This reduces the number of calls to\n * add/removeEventListener if the listener changes frequently, such as when an\n * inline function is used as a listener.\n *\n * Because event options are passed when adding listeners, we must take case\n * to add and remove the part as a listener when the event options change.\n */\nexport type {EventPart};\nclass EventPart extends AttributePart {\n  override readonly type = EVENT_PART;\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable,\n    options: RenderOptions | undefined,\n  ) {\n    super(element, name, strings, parent, options);\n\n    if (DEV_MODE && this.strings !== undefined) {\n      throw new Error(\n        `A \\`<${element.localName}>\\` has a \\`@${name}=...\\` listener with ` +\n          'invalid content. Event listeners in templates must have exactly ' +\n          'one expression and no surrounding text.',\n      );\n    }\n  }\n\n  // EventPart does not use the base _$setValue/_resolveValue implementation\n  // since the dirty checking is more complex\n  /** @internal */\n  override _$setValue(\n    newListener: unknown,\n    directiveParent: DirectiveParent = this,\n  ) {\n    newListener =\n      resolveDirective(this, newListener, directiveParent, 0) ?? nothing;\n    if (newListener === noChange) {\n      return;\n    }\n    const oldListener = this._$committedValue;\n\n    // If the new value is nothing or any options change we have to remove the\n    // part as a listener.\n    const shouldRemoveListener =\n      (newListener === nothing && oldListener !== nothing) ||\n      (newListener as EventListenerWithOptions).capture !==\n        (oldListener as EventListenerWithOptions).capture ||\n      (newListener as EventListenerWithOptions).once !==\n        (oldListener as EventListenerWithOptions).once ||\n      (newListener as EventListenerWithOptions).passive !==\n        (oldListener as EventListenerWithOptions).passive;\n\n    // If the new value is not nothing and we removed the listener, we have\n    // to add the part as a listener.\n    const shouldAddListener =\n      newListener !== nothing &&\n      (oldListener === nothing || shouldRemoveListener);\n\n    debugLogEvent &&\n      debugLogEvent({\n        kind: 'commit event listener',\n        element: this.element,\n        name: this.name,\n        value: newListener,\n        options: this.options,\n        removeListener: shouldRemoveListener,\n        addListener: shouldAddListener,\n        oldListener,\n      });\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n        this.name,\n        this,\n        oldListener as EventListenerWithOptions,\n      );\n    }\n    if (shouldAddListener) {\n      // Beware: IE11 and Chrome 41 don't like using the listener as the\n      // options object. Figure out how to deal w/ this in IE11 - maybe\n      // patch addEventListener?\n      this.element.addEventListener(\n        this.name,\n        this,\n        newListener as EventListenerWithOptions,\n      );\n    }\n    this._$committedValue = newListener;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this._$committedValue === 'function') {\n      this._$committedValue.call(this.options?.host ?? this.element, event);\n    } else {\n      (this._$committedValue as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\nexport type {ElementPart};\nclass ElementPart implements Disconnectable {\n  readonly type = ELEMENT_PART;\n\n  /** @internal */\n  __directive?: Directive;\n\n  // This is to ensure that every Part has a _$committedValue\n  _$committedValue: undefined;\n\n  /** @internal */\n  _$parent!: Disconnectable;\n\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  options: RenderOptions | undefined;\n\n  constructor(\n    public element: Element,\n    parent: Disconnectable,\n    options: RenderOptions | undefined,\n  ) {\n    this._$parent = parent;\n    this.options = options;\n  }\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    return this._$parent._$isConnected;\n  }\n\n  _$setValue(value: unknown): void {\n    debugLogEvent &&\n      debugLogEvent({\n        kind: 'commit to element binding',\n        element: this.element,\n        value,\n        options: this.options,\n      });\n    resolveDirective(this, value);\n  }\n}\n\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _$LH object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-element, which re-exports all of lit-html.\n *\n * @private\n */\nexport const _$LH = {\n  // Used in lit-ssr\n  _boundAttributeSuffix: boundAttributeSuffix,\n  _marker: marker,\n  _markerMatch: markerMatch,\n  _HTML_RESULT: HTML_RESULT,\n  _getTemplateHtml: getTemplateHtml,\n  // Used in tests and private-ssr-support\n  _TemplateInstance: TemplateInstance,\n  _isIterable: isIterable,\n  _resolveDirective: resolveDirective,\n  _ChildPart: ChildPart,\n  _AttributePart: AttributePart,\n  _BooleanAttributePart: BooleanAttributePart,\n  _EventPart: EventPart,\n  _PropertyPart: PropertyPart,\n  _ElementPart: ElementPart,\n};\n\n// Apply polyfills if available\nconst polyfillSupport = DEV_MODE\n  ? global.litHtmlPolyfillSupportDevMode\n  : global.litHtmlPolyfillSupport;\npolyfillSupport?.(Template, ChildPart);\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n(global.litHtmlVersions ??= []).push('3.1.3');\nif (DEV_MODE && global.litHtmlVersions.length > 1) {\n  issueWarning!(\n    'multiple-versions',\n    `Multiple versions of Lit loaded. ` +\n      `Loading multiple versions is not recommended.`,\n  );\n}\n\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n *\n * This example renders the text \"Hello, Zoe!\" inside a paragraph tag, appending\n * it to the container `document.body`.\n *\n * ```js\n * import {html, render} from 'lit';\n *\n * const name = \"Zoe\";\n * render(html`<p>Hello, ${name}!</p>`, document.body);\n * ```\n *\n * @param value Any [renderable\n *   value](https://lit.dev/docs/templates/expressions/#child-expressions),\n *   typically a {@linkcode TemplateResult} created by evaluating a template tag\n *   like {@linkcode html} or {@linkcode svg}.\n * @param container A DOM container to render to. The first render will append\n *   the rendered value to the container, and subsequent renders will\n *   efficiently update the rendered value if the same result type was\n *   previously rendered there.\n * @param options See {@linkcode RenderOptions} for options documentation.\n * @see\n * {@link https://lit.dev/docs/libraries/standalone-templates/#rendering-lit-html-templates| Rendering Lit HTML Templates}\n */\nexport const render = (\n  value: unknown,\n  container: HTMLElement | DocumentFragment,\n  options?: RenderOptions,\n): RootPart => {\n  if (DEV_MODE && container == null) {\n    // Give a clearer error message than\n    //     Uncaught TypeError: Cannot read properties of null (reading\n    //     '_$litPart$')\n    // which reads like an internal Lit error.\n    throw new TypeError(`The container to render into may not be ${container}`);\n  }\n  const renderId = DEV_MODE ? debugLogRenderId++ : 0;\n  const partOwnerNode = options?.renderBefore ?? container;\n  // This property needs to remain unminified.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let part: ChildPart = (partOwnerNode as any)['_$litPart$'];\n  debugLogEvent &&\n    debugLogEvent({\n      kind: 'begin render',\n      id: renderId,\n      value,\n      container,\n      options,\n      part,\n    });\n  if (part === undefined) {\n    const endNode = options?.renderBefore ?? null;\n    // This property needs to remain unminified.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (partOwnerNode as any)['_$litPart$'] = part = new ChildPart(\n      container.insertBefore(createMarker(), endNode),\n      endNode,\n      undefined,\n      options ?? {},\n    );\n  }\n  part._$setValue(value);\n  debugLogEvent &&\n    debugLogEvent({\n      kind: 'end render',\n      id: renderId,\n      value,\n      container,\n      options,\n      part,\n    });\n  return part as RootPart;\n};\n\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n  render.setSanitizer = setSanitizer;\n  render.createSanitizer = createSanitizer;\n  if (DEV_MODE) {\n    render._testOnlyClearSanitizerFactoryDoNotCallOrElse =\n      _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n  }\n}\n","import{ReactiveElement as t}from\"@lit/reactive-element\";export*from\"@lit/reactive-element\";import{render as e,noChange as i}from\"lit-html\";export*from\"lit-html\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */class s extends t{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0}createRenderRoot(){const t=super.createRenderRoot();return this.renderOptions.renderBefore??=t.firstChild,t}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=e(i,this.renderRoot,this.renderOptions)}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0)}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1)}render(){return i}}s._$litElement$=!0,s[(\"finalized\",\"finalized\")]=!0,globalThis.litElementHydrateSupport?.({LitElement:s});const r=globalThis.litElementPolyfillSupport;r?.({LitElement:s});const o={_$AK:(t,e,i)=>{t._$AK(e,i)},_$AL:t=>t._$AL};(globalThis.litElementVersions??=[]).push(\"4.0.5\");export{s as LitElement,o as _$LE};\n//# sourceMappingURL=lit-element.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * The main LitElement module, which defines the {@linkcode LitElement} base\n * class and related APIs.\n *\n *  LitElement components can define a template and a set of observed\n * properties. Changing an observed property triggers a re-render of the\n * element.\n *\n *  Import {@linkcode LitElement} and {@linkcode html} from this module to\n * create a component:\n *\n *  ```js\n * import {LitElement, html} from 'lit-element';\n *\n * class MyElement extends LitElement {\n *\n *   // Declare observed properties\n *   static get properties() {\n *     return {\n *       adjective: {}\n *     }\n *   }\n *\n *   constructor() {\n *     this.adjective = 'awesome';\n *   }\n *\n *   // Define the element's template\n *   render() {\n *     return html`<p>your ${adjective} template here</p>`;\n *   }\n * }\n *\n * customElements.define('my-element', MyElement);\n * ```\n *\n * `LitElement` extends {@linkcode ReactiveElement} and adds lit-html\n * templating. The `ReactiveElement` class is provided for users that want to\n * build their own custom element base classes that don't use lit-html.\n *\n * @packageDocumentation\n */\nimport {PropertyValues, ReactiveElement} from '@lit/reactive-element';\nimport {render, RenderOptions, noChange, RootPart} from 'lit-html';\nexport * from '@lit/reactive-element';\nexport * from 'lit-html';\n\nimport {LitUnstable} from 'lit-html';\nimport {ReactiveUnstable} from '@lit/reactive-element';\n\n/**\n * Contains types that are part of the unstable debug API.\n *\n * Everything in this API is not stable and may change or be removed in the future,\n * even on patch releases.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace Unstable {\n  /**\n   * When Lit is running in dev mode and `window.emitLitDebugLogEvents` is true,\n   * we will emit 'lit-debug' events to window, with live details about the update and render\n   * lifecycle. These can be useful for writing debug tooling and visualizations.\n   *\n   * Please be aware that running with window.emitLitDebugLogEvents has performance overhead,\n   * making certain operations that are normally very cheap (like a no-op render) much slower,\n   * because we must copy data and dispatch events.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  export namespace DebugLog {\n    export type Entry =\n      | LitUnstable.DebugLog.Entry\n      | ReactiveUnstable.DebugLog.Entry;\n  }\n}\n/*\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\n/*@__INLINE__*/\nconst JSCompiler_renameProperty = <P extends PropertyKey>(\n  prop: P,\n  _obj: unknown\n): P => prop;\n\nconst DEV_MODE = true;\n\nlet issueWarning: (code: string, warning: string) => void;\n\nif (DEV_MODE) {\n  // Ensure warnings are issued only 1x, even if multiple versions of Lit\n  // are loaded.\n  const issuedWarnings: Set<string | undefined> =\n    (globalThis.litIssuedWarnings ??= new Set());\n\n  // Issue a warning, if we haven't already.\n  issueWarning = (code: string, warning: string) => {\n    warning += ` See https://lit.dev/msg/${code} for more information.`;\n    if (!issuedWarnings.has(warning)) {\n      console.warn(warning);\n      issuedWarnings.add(warning);\n    }\n  };\n}\n\n/**\n * Base element class that manages element properties and attributes, and\n * renders a lit-html template.\n *\n * To define a component, subclass `LitElement` and implement a\n * `render` method to provide the component's template. Define properties\n * using the {@linkcode LitElement.properties properties} property or the\n * {@linkcode property} decorator.\n */\nexport class LitElement extends ReactiveElement {\n  // This property needs to remain unminified.\n  static ['_$litElement$'] = true;\n\n  /**\n   * @category rendering\n   */\n  readonly renderOptions: RenderOptions = {host: this};\n\n  private __childPart: RootPart | undefined = undefined;\n\n  /**\n   * @category rendering\n   */\n  protected override createRenderRoot() {\n    const renderRoot = super.createRenderRoot();\n    // When adoptedStyleSheets are shimmed, they are inserted into the\n    // shadowRoot by createRenderRoot. Adjust the renderBefore node so that\n    // any styles in Lit content render before adoptedStyleSheets. This is\n    // important so that adoptedStyleSheets have precedence over styles in\n    // the shadowRoot.\n    this.renderOptions.renderBefore ??= renderRoot!.firstChild as ChildNode;\n    return renderRoot;\n  }\n\n  /**\n   * Updates the element. This method reflects property values to attributes\n   * and calls `render` to render DOM via lit-html. Setting properties inside\n   * this method will *not* trigger another update.\n   * @param changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  protected override update(changedProperties: PropertyValues) {\n    // Setting properties in `render` should not trigger an update. Since\n    // updates are allowed after super.update, it's important to call `render`\n    // before that.\n    const value = this.render();\n    if (!this.hasUpdated) {\n      this.renderOptions.isConnected = this.isConnected;\n    }\n    super.update(changedProperties);\n    this.__childPart = render(value, this.renderRoot, this.renderOptions);\n  }\n\n  /**\n   * Invoked when the component is added to the document's DOM.\n   *\n   * In `connectedCallback()` you should setup tasks that should only occur when\n   * the element is connected to the document. The most common of these is\n   * adding event listeners to nodes external to the element, like a keydown\n   * event handler added to the window.\n   *\n   * ```ts\n   * connectedCallback() {\n   *   super.connectedCallback();\n   *   addEventListener('keydown', this._handleKeydown);\n   * }\n   * ```\n   *\n   * Typically, anything done in `connectedCallback()` should be undone when the\n   * element is disconnected, in `disconnectedCallback()`.\n   *\n   * @category lifecycle\n   */\n  override connectedCallback() {\n    super.connectedCallback();\n    this.__childPart?.setConnected(true);\n  }\n\n  /**\n   * Invoked when the component is removed from the document's DOM.\n   *\n   * This callback is the main signal to the element that it may no longer be\n   * used. `disconnectedCallback()` should ensure that nothing is holding a\n   * reference to the element (such as event listeners added to nodes external\n   * to the element), so that it is free to be garbage collected.\n   *\n   * ```ts\n   * disconnectedCallback() {\n   *   super.disconnectedCallback();\n   *   window.removeEventListener('keydown', this._handleKeydown);\n   * }\n   * ```\n   *\n   * An element may be re-connected after being disconnected.\n   *\n   * @category lifecycle\n   */\n  override disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__childPart?.setConnected(false);\n  }\n\n  /**\n   * Invoked on each update to perform rendering tasks. This method may return\n   * any value renderable by lit-html's `ChildPart` - typically a\n   * `TemplateResult`. Setting properties inside this method will *not* trigger\n   * the element to update.\n   * @category rendering\n   */\n  protected render(): unknown {\n    return noChange;\n  }\n}\n\n/**\n * Ensure this class is marked as `finalized` as an optimization ensuring\n * it will not needlessly try to `finalize`.\n *\n * Note this property name is a string to prevent breaking Closure JS Compiler\n * optimizations. See @lit/reactive-element for more information.\n */\n(LitElement as unknown as Record<string, unknown>)[\n  JSCompiler_renameProperty('finalized', LitElement)\n] = true;\n\n// Install hydration if available\nglobalThis.litElementHydrateSupport?.({LitElement});\n\n// Apply polyfills if available\nconst polyfillSupport = DEV_MODE\n  ? globalThis.litElementPolyfillSupportDevMode\n  : globalThis.litElementPolyfillSupport;\npolyfillSupport?.({LitElement});\n\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _$LE object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-html, since this module re-exports all of lit-html.\n *\n * @private\n */\nexport const _$LE = {\n  _$attributeToProperty: (\n    el: LitElement,\n    name: string,\n    value: string | null\n  ) => {\n    // eslint-disable-next-line\n    (el as any)._$attributeToProperty(name, value);\n  },\n  // eslint-disable-next-line\n  _$changedProperties: (el: LitElement) => (el as any)._$changedProperties,\n};\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for LitElement usage.\n(globalThis.litElementVersions ??= []).push('4.0.5');\nif (DEV_MODE && globalThis.litElementVersions.length > 1) {\n  issueWarning!(\n    'multiple-versions',\n    `Multiple versions of Lit loaded. Loading multiple versions ` +\n      `is not recommended.`\n  );\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst o=!1;export{o as isServer};\n//# sourceMappingURL=is-server.js.map\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * @fileoverview\n *\n * This file exports a boolean const whose value will depend on what environment\n * the module is being imported from.\n */\n\nconst NODE_MODE = false;\n\n/**\n * A boolean that will be `true` in server environments like Node, and `false`\n * in browser environments. Note that your server environment or toolchain must\n * support the `\"node\"` export condition for this to be `true`.\n *\n * This can be used when authoring components to change behavior based on\n * whether or not the component is executing in an SSR context.\n */\nexport const isServer = NODE_MODE;\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst t=t=>(e,o)=>{void 0!==o?o.addInitializer((()=>{customElements.define(t,e)})):customElements.define(t,e)};export{t as customElement};\n//# sourceMappingURL=custom-element.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\nimport type {Constructor} from './base.js';\n\n/**\n * Allow for custom element classes with private constructors\n */\ntype CustomElementClass = Omit<typeof HTMLElement, 'new'>;\n\nexport type CustomElementDecorator = {\n  // legacy\n  (cls: CustomElementClass): void;\n\n  // standard\n  (\n    target: CustomElementClass,\n    context: ClassDecoratorContext<Constructor<HTMLElement>>\n  ): void;\n};\n\n/**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * ```js\n * @customElement('my-element')\n * class MyElement extends LitElement {\n *   render() {\n *     return html``;\n *   }\n * }\n * ```\n * @category Decorator\n * @param tagName The tag name of the custom element to define.\n */\nexport const customElement =\n  (tagName: string): CustomElementDecorator =>\n  (\n    classOrTarget: CustomElementClass | Constructor<HTMLElement>,\n    context?: ClassDecoratorContext<Constructor<HTMLElement>>\n  ) => {\n    if (context !== undefined) {\n      context.addInitializer(() => {\n        customElements.define(\n          tagName,\n          classOrTarget as CustomElementConstructor\n        );\n      });\n    } else {\n      customElements.define(tagName, classOrTarget as CustomElementConstructor);\n    }\n  };\n","import{defaultConverter as t,notEqual as e}from\"../reactive-element.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const o={attribute:!0,type:String,converter:t,reflect:!1,hasChanged:e},r=(t=o,e,r)=>{const{kind:n,metadata:i}=r;let s=globalThis.litPropertyMetadata.get(i);if(void 0===s&&globalThis.litPropertyMetadata.set(i,s=new Map),s.set(r.name,t),\"accessor\"===n){const{name:o}=r;return{set(r){const n=e.get.call(this);e.set.call(this,r),this.requestUpdate(o,n,t)},init(e){return void 0!==e&&this.P(o,void 0,t),e}}}if(\"setter\"===n){const{name:o}=r;return function(r){const n=this[o];e.call(this,r),this.requestUpdate(o,n,t)}}throw Error(\"Unsupported decorator location: \"+n)};function n(t){return(e,o)=>\"object\"==typeof o?r(t,e,o):((t,e,o)=>{const r=e.hasOwnProperty(o);return e.constructor.createProperty(o,r?{...t,wrapped:!0}:t),r?Object.getOwnPropertyDescriptor(e,o):void 0})(t,e,o)}export{n as property,r as standardProperty};\n//# sourceMappingURL=property.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\nimport {\n  type PropertyDeclaration,\n  type ReactiveElement,\n  defaultConverter,\n  notEqual,\n} from '../reactive-element.js';\nimport type {Interface} from './base.js';\n\nconst DEV_MODE = true;\n\nlet issueWarning: (code: string, warning: string) => void;\n\nif (DEV_MODE) {\n  // Ensure warnings are issued only 1x, even if multiple versions of Lit\n  // are loaded.\n  const issuedWarnings: Set<string | undefined> =\n    (globalThis.litIssuedWarnings ??= new Set());\n\n  // Issue a warning, if we haven't already.\n  issueWarning = (code: string, warning: string) => {\n    warning += ` See https://lit.dev/msg/${code} for more information.`;\n    if (!issuedWarnings.has(warning)) {\n      console.warn(warning);\n      issuedWarnings.add(warning);\n    }\n  };\n}\n\n// Overloads for property decorator so that TypeScript can infer the correct\n// return type when a decorator is used as an accessor decorator or a setter\n// decorator.\nexport type PropertyDecorator = {\n  // accessor decorator signature\n  <C extends Interface<ReactiveElement>, V>(\n    target: ClassAccessorDecoratorTarget<C, V>,\n    context: ClassAccessorDecoratorContext<C, V>\n  ): ClassAccessorDecoratorResult<C, V>;\n\n  // setter decorator signature\n  <C extends Interface<ReactiveElement>, V>(\n    target: (value: V) => void,\n    context: ClassSetterDecoratorContext<C, V>\n  ): (this: C, value: V) => void;\n\n  // legacy decorator signature\n  (\n    protoOrDescriptor: Object,\n    name: PropertyKey,\n    descriptor?: PropertyDescriptor\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): any;\n};\n\nconst legacyProperty = (\n  options: PropertyDeclaration | undefined,\n  proto: Object,\n  name: PropertyKey\n) => {\n  const hasOwnProperty = proto.hasOwnProperty(name);\n  (proto.constructor as typeof ReactiveElement).createProperty(\n    name,\n    hasOwnProperty ? {...options, wrapped: true} : options\n  );\n  // For accessors (which have a descriptor on the prototype) we need to\n  // return a descriptor, otherwise TypeScript overwrites the descriptor we\n  // define in createProperty() with the original descriptor. We don't do this\n  // for fields, which don't have a descriptor, because this could overwrite\n  // descriptor defined by other decorators.\n  return hasOwnProperty\n    ? Object.getOwnPropertyDescriptor(proto, name)\n    : undefined;\n};\n\n// This is duplicated from a similar variable in reactive-element.ts, but\n// actually makes sense to have this default defined with the decorator, so\n// that different decorators could have different defaults.\nconst defaultPropertyDeclaration: PropertyDeclaration = {\n  attribute: true,\n  type: String,\n  converter: defaultConverter,\n  reflect: false,\n  hasChanged: notEqual,\n};\n\n// Temporary type, until google3 is on TypeScript 5.2\ntype StandardPropertyContext<C, V> = (\n  | ClassAccessorDecoratorContext<C, V>\n  | ClassSetterDecoratorContext<C, V>\n) & {metadata: object};\n\n/**\n * Wraps a class accessor or setter so that `requestUpdate()` is called with the\n * property name and old value when the accessor is set.\n */\nexport const standardProperty = <C extends Interface<ReactiveElement>, V>(\n  options: PropertyDeclaration = defaultPropertyDeclaration,\n  target: ClassAccessorDecoratorTarget<C, V> | ((value: V) => void),\n  context: StandardPropertyContext<C, V>\n): ClassAccessorDecoratorResult<C, V> | ((this: C, value: V) => void) => {\n  const {kind, metadata} = context;\n\n  if (DEV_MODE && metadata == null) {\n    issueWarning(\n      'missing-class-metadata',\n      `The class ${target} is missing decorator metadata. This ` +\n        `could mean that you're using a compiler that supports decorators ` +\n        `but doesn't support decorator metadata, such as TypeScript 5.1. ` +\n        `Please update your compiler.`\n    );\n  }\n\n  // Store the property options\n  let properties = globalThis.litPropertyMetadata.get(metadata);\n  if (properties === undefined) {\n    globalThis.litPropertyMetadata.set(metadata, (properties = new Map()));\n  }\n  properties.set(context.name, options);\n\n  if (kind === 'accessor') {\n    // Standard decorators cannot dynamically modify the class, so we can't\n    // replace a field with accessors. The user must use the new `accessor`\n    // keyword instead.\n    const {name} = context;\n    return {\n      set(this: ReactiveElement, v: V) {\n        const oldValue = (\n          target as ClassAccessorDecoratorTarget<C, V>\n        ).get.call(this as unknown as C);\n        (target as ClassAccessorDecoratorTarget<C, V>).set.call(\n          this as unknown as C,\n          v\n        );\n        this.requestUpdate(name, oldValue, options);\n      },\n      init(this: ReactiveElement, v: V): V {\n        if (v !== undefined) {\n          this._$changeProperty(name, undefined, options);\n        }\n        return v;\n      },\n    } as unknown as ClassAccessorDecoratorResult<C, V>;\n  } else if (kind === 'setter') {\n    const {name} = context;\n    return function (this: ReactiveElement, value: V) {\n      const oldValue = this[name as keyof ReactiveElement];\n      (target as (value: V) => void).call(this, value);\n      this.requestUpdate(name, oldValue, options);\n    } as unknown as (this: C, value: V) => void;\n  }\n  throw new Error(`Unsupported decorator location: ${kind}`);\n};\n\n/**\n * A class field or accessor decorator which creates a reactive property that\n * reflects a corresponding attribute value. When a decorated property is set\n * the element will update and render. A {@linkcode PropertyDeclaration} may\n * optionally be supplied to configure property features.\n *\n * This decorator should only be used for public fields. As public fields,\n * properties should be considered as primarily settable by element users,\n * either via attribute or the property itself.\n *\n * Generally, properties that are changed by the element should be private or\n * protected fields and should use the {@linkcode state} decorator.\n *\n * However, sometimes element code does need to set a public property. This\n * should typically only be done in response to user interaction, and an event\n * should be fired informing the user; for example, a checkbox sets its\n * `checked` property when clicked and fires a `changed` event. Mutating public\n * properties should typically not be done for non-primitive (object or array)\n * properties. In other cases when an element needs to manage state, a private\n * property decorated via the {@linkcode state} decorator should be used. When\n * needed, state properties can be initialized via public properties to\n * facilitate complex interactions.\n *\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nexport function property(options?: PropertyDeclaration): PropertyDecorator {\n  return <C extends Interface<ReactiveElement>, V>(\n    protoOrTarget:\n      | object\n      | ClassAccessorDecoratorTarget<C, V>\n      | ((value: V) => void),\n    nameOrContext:\n      | PropertyKey\n      | ClassAccessorDecoratorContext<C, V>\n      | ClassSetterDecoratorContext<C, V>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): any => {\n    return (\n      typeof nameOrContext === 'object'\n        ? standardProperty<C, V>(\n            options,\n            protoOrTarget as\n              | ClassAccessorDecoratorTarget<C, V>\n              | ((value: V) => void),\n            nameOrContext as StandardPropertyContext<C, V>\n          )\n        : legacyProperty(\n            options,\n            protoOrTarget as Object,\n            nameOrContext as PropertyKey\n          )\n    ) as PropertyDecorator;\n  };\n}\n","import{property as t}from\"./property.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function r(r){return t({...r,state:!0,attribute:!1})}export{r as state};\n//# sourceMappingURL=state.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\nimport {property} from './property.js';\n\nexport interface StateDeclaration<Type = unknown> {\n  /**\n   * A function that indicates if a property should be considered changed when\n   * it is set. The function should take the `newValue` and `oldValue` and\n   * return `true` if an update should be requested.\n   */\n  hasChanged?(value: Type, oldValue: Type): boolean;\n}\n\n/**\n * @deprecated use StateDeclaration\n */\nexport type InternalPropertyDeclaration<Type = unknown> =\n  StateDeclaration<Type>;\n\n/**\n * Declares a private or protected reactive property that still triggers\n * updates to the element when it changes. It does not reflect from the\n * corresponding attribute.\n *\n * Properties declared this way must not be used from HTML or HTML templating\n * systems, they're solely for properties internal to the element. These\n * properties may be renamed by optimization tools like closure compiler.\n * @category Decorator\n */\nexport function state(options?: StateDeclaration) {\n  return property({\n    ...options,\n    // Add both `state` and `attribute` because we found a third party\n    // controller that is keying off of PropertyOptions.state to determine\n    // whether a field is a private internal property or not.\n    state: true,\n    attribute: false,\n  });\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nfunction t(t){return(n,o)=>{const c=\"function\"==typeof n?n:n[o];Object.assign(c,t)}}export{t as eventOptions};\n//# sourceMappingURL=event-options.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\nimport type {ReactiveElement} from '../reactive-element.js';\nimport type {Interface} from './base.js';\n\nexport type EventOptionsDecorator = {\n  // legacy\n  (\n    proto: Interface<ReactiveElement>,\n    name: PropertyKey\n    // Note TypeScript requires the return type to be `void|any`\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): void | any;\n\n  // standard\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  <C, V extends (this: C, ...args: any) => any>(\n    value: V,\n    _context: ClassMethodDecoratorContext<C, V>\n  ): void;\n};\n\n/**\n * Adds event listener options to a method used as an event listener in a\n * lit-html template.\n *\n * @param options An object that specifies event listener options as accepted by\n * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.\n *\n * Current browsers support the `capture`, `passive`, and `once` options. See:\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\n *\n * ```ts\n * class MyElement {\n *   clicked = false;\n *\n *   render() {\n *     return html`\n *       <div @click=${this._onClick}>\n *         <button></button>\n *       </div>\n *     `;\n *   }\n *\n *   @eventOptions({capture: true})\n *   _onClick(e) {\n *     this.clicked = true;\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function eventOptions(\n  options: AddEventListenerOptions\n): EventOptionsDecorator {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (<C, V extends (this: C, ...args: any) => any>(\n    protoOrValue: V,\n    nameOrContext: PropertyKey | ClassMethodDecoratorContext<C, V>\n  ) => {\n    const method =\n      typeof protoOrValue === 'function'\n        ? protoOrValue\n        : protoOrValue[nameOrContext as keyof ReactiveElement];\n    Object.assign(method, options);\n  }) as EventOptionsDecorator;\n}\n","import{desc as t}from\"./base.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function e(e,r){return(n,s,i)=>{const o=t=>t.renderRoot?.querySelector(e)??null;if(r){const{get:e,set:r}=\"object\"==typeof s?n:i??(()=>{const t=Symbol();return{get(){return this[t]},set(e){this[t]=e}}})();return t(n,s,{get(){let t=e.call(this);return void 0===t&&(t=o(this),(null!==t||this.hasUpdated)&&r.call(this,t)),t}})}return t(n,s,{get(){return o(this)}})}}export{e as query};\n//# sourceMappingURL=query.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\nimport type {ReactiveElement} from '../reactive-element.js';\nimport {desc, type Interface} from './base.js';\n\nconst DEV_MODE = true;\n\nlet issueWarning: (code: string, warning: string) => void;\n\nif (DEV_MODE) {\n  // Ensure warnings are issued only 1x, even if multiple versions of Lit\n  // are loaded.\n  const issuedWarnings: Set<string | undefined> =\n    (globalThis.litIssuedWarnings ??= new Set());\n\n  // Issue a warning, if we haven't already.\n  issueWarning = (code: string, warning: string) => {\n    warning += code\n      ? ` See https://lit.dev/msg/${code} for more information.`\n      : '';\n    if (!issuedWarnings.has(warning)) {\n      console.warn(warning);\n      issuedWarnings.add(warning);\n    }\n  };\n}\n\nexport type QueryDecorator = {\n  // legacy\n  (\n    proto: Interface<ReactiveElement>,\n    name: PropertyKey,\n    descriptor?: PropertyDescriptor\n    // Note TypeScript requires the return type to be `void|any`\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): void | any;\n\n  // standard\n  <C extends Interface<ReactiveElement>, V extends Element | null>(\n    value: ClassAccessorDecoratorTarget<C, V>,\n    context: ClassAccessorDecoratorContext<C, V>\n  ): ClassAccessorDecoratorResult<C, V>;\n};\n\n/**\n * A property decorator that converts a class property into a getter that\n * executes a querySelector on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n * @param cache An optional boolean which when true performs the DOM query only\n *     once and caches the result.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * ```ts\n * class MyElement {\n *   @query('#first')\n *   first: HTMLDivElement;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function query(selector: string, cache?: boolean): QueryDecorator {\n  return (<C extends Interface<ReactiveElement>, V extends Element | null>(\n    protoOrTarget: ClassAccessorDecoratorTarget<C, V>,\n    nameOrContext: PropertyKey | ClassAccessorDecoratorContext<C, V>,\n    descriptor?: PropertyDescriptor\n  ) => {\n    const doQuery = (el: Interface<ReactiveElement>): V => {\n      const result = (el.renderRoot?.querySelector(selector) ?? null) as V;\n      if (DEV_MODE && result === null && cache && !el.hasUpdated) {\n        const name =\n          typeof nameOrContext === 'object'\n            ? nameOrContext.name\n            : nameOrContext;\n        issueWarning(\n          '',\n          `@query'd field ${JSON.stringify(String(name))} with the 'cache' ` +\n            `flag set for selector '${selector}' has been accessed before ` +\n            `the first update and returned null. This is expected if the ` +\n            `renderRoot tree has not been provided beforehand (e.g. via ` +\n            `Declarative Shadow DOM). Therefore the value hasn't been cached.`\n        );\n      }\n      // TODO: if we want to allow users to assert that the query will never\n      // return null, we need a new option and to throw here if the result\n      // is null.\n      return result;\n    };\n    if (cache) {\n      // Accessors to wrap from either:\n      //   1. The decorator target, in the case of standard decorators\n      //   2. The property descriptor, in the case of experimental decorators\n      //      on auto-accessors.\n      //   3. Functions that access our own cache-key property on the instance,\n      //      in the case of experimental decorators on fields.\n      const {get, set} =\n        typeof nameOrContext === 'object'\n          ? protoOrTarget\n          : descriptor ??\n            (() => {\n              const key = DEV_MODE\n                ? Symbol(`${String(nameOrContext)} (@query() cache)`)\n                : Symbol();\n              type WithCache = ReactiveElement & {\n                [key: symbol]: Element | null;\n              };\n              return {\n                get() {\n                  return (this as WithCache)[key];\n                },\n                set(v) {\n                  (this as WithCache)[key] = v;\n                },\n              };\n            })();\n      return desc(protoOrTarget, nameOrContext, {\n        get(this: ReactiveElement): V {\n          let result: V = get!.call(this);\n          if (result === undefined) {\n            result = doQuery(this);\n            if (result !== null || this.hasUpdated) {\n              set!.call(this, result);\n            }\n          }\n          return result;\n        },\n      });\n    } else {\n      // This object works as the return type for both standard and\n      // experimental decorators.\n      return desc(protoOrTarget, nameOrContext, {\n        get(this: ReactiveElement) {\n          return doQuery(this);\n        },\n      });\n    }\n  }) as QueryDecorator;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst e=(e,t,c)=>(c.configurable=!0,c.enumerable=!0,Reflect.decorate&&\"object\"!=typeof t&&Object.defineProperty(e,t,c),c);export{e as desc};\n//# sourceMappingURL=base.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Generates a public interface type that removes private and protected fields.\n * This allows accepting otherwise incompatible versions of the type (e.g. from\n * multiple copies of the same package in `node_modules`).\n */\nexport type Interface<T> = {\n  [K in keyof T]: T[K];\n};\n\nexport type Constructor<T> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  new (...args: any[]): T;\n};\n\n/**\n * Wraps up a few best practices when returning a property descriptor from a\n * decorator.\n *\n * Marks the defined property as configurable, and enumerable, and handles\n * the case where we have a busted Reflect.decorate zombiefill (e.g. in Angular\n * apps).\n *\n * @internal\n */\nexport const desc = (\n  obj: object,\n  name: PropertyKey | ClassAccessorDecoratorContext<unknown, unknown>,\n  descriptor: PropertyDescriptor\n) => {\n  // For backwards compatibility, we keep them configurable and enumerable.\n  descriptor.configurable = true;\n  descriptor.enumerable = true;\n  if (\n    // We check for Reflect.decorate each time, in case the zombiefill\n    // is applied via lazy loading some Angular code.\n    (Reflect as typeof Reflect & {decorate?: unknown}).decorate &&\n    typeof name !== 'object'\n  ) {\n    // If we're called as a legacy decorator, and Reflect.decorate is present\n    // then we have no guarantees that the returned descriptor will be\n    // defined on the class, so we must apply it directly ourselves.\n\n    Object.defineProperty(obj, name, descriptor);\n  }\n  return descriptor;\n};\n","import{desc as t}from\"./base.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet e;function r(r){return(n,o)=>t(n,o,{get(){return(this.renderRoot??(e??=document.createDocumentFragment())).querySelectorAll(r)}})}export{r as queryAll};\n//# sourceMappingURL=query-all.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\nimport type {ReactiveElement} from '../reactive-element.js';\nimport {desc, type Interface} from './base.js';\n\nexport type QueryAllDecorator = {\n  // legacy\n  (\n    proto: Interface<ReactiveElement>,\n    name: PropertyKey,\n    descriptor?: PropertyDescriptor\n    // Note TypeScript requires the return type to be `void|any`\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): void | any;\n\n  // standard\n  <C extends Interface<ReactiveElement>, V extends NodeList>(\n    value: ClassAccessorDecoratorTarget<C, V>,\n    context: ClassAccessorDecoratorContext<C, V>\n  ): ClassAccessorDecoratorResult<C, V>;\n};\n\n// Shared fragment used to generate empty NodeLists when a render root is\n// undefined\nlet fragment: DocumentFragment;\n\n/**\n * A property decorator that converts a class property into a getter\n * that executes a querySelectorAll on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See:\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\n *\n * ```ts\n * class MyElement {\n *   @queryAll('div')\n *   divs: NodeListOf<HTMLDivElement>;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function queryAll(selector: string): QueryAllDecorator {\n  return ((\n    obj: object,\n    name: PropertyKey | ClassAccessorDecoratorContext<unknown, unknown>\n  ) => {\n    return desc(obj, name, {\n      get(this: ReactiveElement) {\n        const container =\n          this.renderRoot ?? (fragment ??= document.createDocumentFragment());\n        return container.querySelectorAll(selector);\n      },\n    });\n  }) as QueryAllDecorator;\n}\n","import{desc as t}from\"./base.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nfunction r(r){return(n,e)=>t(n,e,{async get(){return await this.updateComplete,this.renderRoot?.querySelector(r)??null}})}export{r as queryAsync};\n//# sourceMappingURL=query-async.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\nimport type {ReactiveElement} from '../reactive-element.js';\nimport {desc, type Interface} from './base.js';\n\nexport type QueryAsyncDecorator = {\n  // legacy\n  (\n    proto: Interface<ReactiveElement>,\n    name: PropertyKey,\n    descriptor?: PropertyDescriptor\n    // Note TypeScript requires the return type to be `void|any`\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): void | any;\n\n  // standard\n  <C extends Interface<ReactiveElement>, V extends Promise<Element | null>>(\n    value: ClassAccessorDecoratorTarget<C, V>,\n    context: ClassAccessorDecoratorContext<C, V>\n  ): ClassAccessorDecoratorResult<C, V>;\n};\n\n// Note, in the future, we may extend this decorator to support the use case\n// where the queried element may need to do work to become ready to interact\n// with (e.g. load some implementation code). If so, we might elect to\n// add a second argument defining a function that can be run to make the\n// queried element loaded/updated/ready.\n/**\n * A property decorator that converts a class property into a getter that\n * returns a promise that resolves to the result of a querySelector on the\n * element's renderRoot done after the element's `updateComplete` promise\n * resolves. When the queried property may change with element state, this\n * decorator can be used instead of requiring users to await the\n * `updateComplete` before accessing the property.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * ```ts\n * class MyElement {\n *   @queryAsync('#first')\n *   first: Promise<HTMLDivElement>;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n *\n * // external usage\n * async doSomethingWithFirst() {\n *  (await aMyElement.first).doSomething();\n * }\n * ```\n * @category Decorator\n */\nexport function queryAsync(selector: string) {\n  return ((\n    obj: object,\n    name: PropertyKey | ClassAccessorDecoratorContext<unknown, unknown>\n  ) => {\n    return desc(obj, name, {\n      async get(this: ReactiveElement) {\n        await this.updateComplete;\n        return this.renderRoot?.querySelector(selector) ?? null;\n      },\n    });\n  }) as QueryAsyncDecorator;\n}\n","import{desc as t}from\"./base.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function o(o){return(e,n)=>{const{slot:r,selector:s}=o??{},c=\"slot\"+(r?`[name=${r}]`:\":not([name])\");return t(e,n,{get(){const t=this.renderRoot?.querySelector(c),e=t?.assignedElements(o)??[];return void 0===s?e:e.filter((t=>t.matches(s)))}})}}export{o as queryAssignedElements};\n//# sourceMappingURL=query-assigned-elements.js.map\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\nimport type {ReactiveElement} from '../reactive-element.js';\nimport type {QueryAssignedNodesOptions} from './query-assigned-nodes.js';\nimport {desc, type Interface} from './base.js';\n\nexport type QueryAssignedElementsDecorator = {\n  // legacy\n  (\n    proto: Interface<ReactiveElement>,\n    name: PropertyKey,\n    descriptor?: PropertyDescriptor\n    // Note TypeScript requires the return type to be `void|any`\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): void | any;\n\n  // standard\n  <C extends Interface<ReactiveElement>, V extends Array<Element>>(\n    value: ClassAccessorDecoratorTarget<C, V>,\n    context: ClassAccessorDecoratorContext<C, V>\n  ): ClassAccessorDecoratorResult<C, V>;\n};\n\n/**\n * Options for the {@linkcode queryAssignedElements} decorator. Extends the\n * options that can be passed into\n * [HTMLSlotElement.assignedElements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/assignedElements).\n */\nexport interface QueryAssignedElementsOptions\n  extends QueryAssignedNodesOptions {\n  /**\n   * CSS selector used to filter the elements returned. For example, a selector\n   * of `\".item\"` will only include elements with the `item` class.\n   */\n  selector?: string;\n}\n\n/**\n * A property decorator that converts a class property into a getter that\n * returns the `assignedElements` of the given `slot`. Provides a declarative\n * way to use\n * [`HTMLSlotElement.assignedElements`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/assignedElements).\n *\n * Can be passed an optional {@linkcode QueryAssignedElementsOptions} object.\n *\n * Example usage:\n * ```ts\n * class MyElement {\n *   @queryAssignedElements({ slot: 'list' })\n *   listItems!: Array<HTMLElement>;\n *   @queryAssignedElements()\n *   unnamedSlotEls!: Array<HTMLElement>;\n *\n *   render() {\n *     return html`\n *       <slot name=\"list\"></slot>\n *       <slot></slot>\n *     `;\n *   }\n * }\n * ```\n *\n * Note, the type of this property should be annotated as `Array<HTMLElement>`.\n *\n * @category Decorator\n */\nexport function queryAssignedElements(\n  options?: QueryAssignedElementsOptions\n): QueryAssignedElementsDecorator {\n  return (<V extends Array<Element>>(\n    obj: object,\n    name: PropertyKey | ClassAccessorDecoratorContext<unknown, unknown>\n  ) => {\n    const {slot, selector} = options ?? {};\n    const slotSelector = `slot${slot ? `[name=${slot}]` : ':not([name])'}`;\n    return desc(obj, name, {\n      get(this: ReactiveElement): V {\n        const slotEl =\n          this.renderRoot?.querySelector<HTMLSlotElement>(slotSelector);\n        const elements = slotEl?.assignedElements(options) ?? [];\n        return (\n          selector === undefined\n            ? elements\n            : elements.filter((node) => node.matches(selector))\n        ) as V;\n      },\n    });\n  }) as QueryAssignedElementsDecorator;\n}\n","import{desc as t}from\"./base.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function n(n){return(o,r)=>{const{slot:e}=n??{},s=\"slot\"+(e?`[name=${e}]`:\":not([name])\");return t(o,r,{get(){const t=this.renderRoot?.querySelector(s);return t?.assignedNodes(n)??[]}})}}export{n as queryAssignedNodes};\n//# sourceMappingURL=query-assigned-nodes.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\nimport type {ReactiveElement} from '../reactive-element.js';\nimport {desc, type Interface} from './base.js';\n\n/**\n * Options for the {@linkcode queryAssignedNodes} decorator. Extends the options\n * that can be passed into [HTMLSlotElement.assignedNodes](https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/assignedNodes).\n */\nexport interface QueryAssignedNodesOptions extends AssignedNodesOptions {\n  /**\n   * Name of the slot to query. Leave empty for the default slot.\n   */\n  slot?: string;\n}\n\nexport type QueryAssignedNodesDecorator = {\n  // legacy\n  (\n    proto: Interface<ReactiveElement>,\n    name: PropertyKey,\n    descriptor?: PropertyDescriptor\n    // Note TypeScript requires the return type to be `void|any`\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): void | any;\n\n  // standard\n  <C extends Interface<ReactiveElement>, V extends Array<Node>>(\n    value: ClassAccessorDecoratorTarget<C, V>,\n    context: ClassAccessorDecoratorContext<C, V>\n  ): ClassAccessorDecoratorResult<C, V>;\n};\n\n/**\n * A property decorator that converts a class property into a getter that\n * returns the `assignedNodes` of the given `slot`.\n *\n * Can be passed an optional {@linkcode QueryAssignedNodesOptions} object.\n *\n * Example usage:\n * ```ts\n * class MyElement {\n *   @queryAssignedNodes({slot: 'list', flatten: true})\n *   listItems!: Array<Node>;\n *\n *   render() {\n *     return html`\n *       <slot name=\"list\"></slot>\n *     `;\n *   }\n * }\n * ```\n *\n * Note the type of this property should be annotated as `Array<Node>`. Use the\n * queryAssignedElements decorator to list only elements, and optionally filter\n * the element list using a CSS selector.\n *\n * @category Decorator\n */\nexport function queryAssignedNodes(\n  options?: QueryAssignedNodesOptions\n): QueryAssignedNodesDecorator {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (<V extends Array<Node>>(\n    obj: object,\n    name: PropertyKey | ClassAccessorDecoratorContext<unknown, unknown>\n  ) => {\n    const {slot} = options ?? {};\n    const slotSelector = `slot${slot ? `[name=${slot}]` : ':not([name])'}`;\n    return desc(obj, name, {\n      get(this: ReactiveElement): V {\n        const slotEl =\n          this.renderRoot?.querySelector<HTMLSlotElement>(slotSelector);\n        return (slotEl?.assignedNodes(options) ?? []) as unknown as V;\n      },\n    });\n  }) as QueryAssignedNodesDecorator;\n}\n","import \"pixi.js/lib/math-extras/init\";\n\nimport { Application } from \"pixi.js\";\nimport { Controller } from \"./controller\";\nimport { AudioController } from \"./audio/audio_controller\";\n\nclass Game {\n  private app: Application;\n  private controller: Controller;\n  // Keep this public as main menu needs to be able to play\n  // music before the game has started.\n  audioController = new AudioController();\n\n  constructor() {\n    this.app = new Application();\n    this.controller = new Controller(this.app);\n  }\n\n  async start(): Promise<void> {\n    const screenHeight = Math.max(\n      document.documentElement.clientHeight,\n      window.innerHeight || 0,\n    );\n    const screenWidth = Math.max(\n      document.documentElement.clientWidth,\n      window.innerWidth || 0,\n    );\n\n    const constrainByWidth = (screenHeight * 16) / 9 > screenWidth;\n\n    await this.app.init({\n      width: constrainByWidth\n        ? screenWidth\n        : Math.floor((screenHeight * 16) / 9),\n      height: constrainByWidth\n        ? Math.floor((screenWidth / 16) * 9)\n        : screenHeight,\n      resolution: window.devicePixelRatio || 1,\n      antialias: true,\n      autoDensity: true,\n    });\n    document.body.appendChild(this.app.canvas);\n\n    this.controller.start();\n  }\n\n  async preload() {\n    this.controller.preload();\n    await this.audioController.preload();\n  }\n}\n\n/** Global singleton representing the game. */\nexport const game = new Game();\n","import { ObservablePoint } from '../maths/point/ObservablePoint.mjs';\nimport { Point } from '../maths/point/Point.mjs';\nimport { Rectangle } from '../maths/shapes/Rectangle.mjs';\nimport { pointExtraMixins } from './pointExtras.mjs';\nimport { rectangleExtraMixins } from './rectangleExtras.mjs';\n\n\"use strict\";\nObject.assign(Point.prototype, pointExtraMixins);\nObject.assign(ObservablePoint.prototype, pointExtraMixins);\nObject.assign(Rectangle.prototype, rectangleExtraMixins);\n//# sourceMappingURL=init.mjs.map\n","import { ObservablePoint } from '../maths/point/ObservablePoint';\nimport { Point } from '../maths/point/Point';\nimport { Rectangle } from '../maths/shapes/Rectangle';\nimport { pointExtraMixins } from './pointExtras';\nimport { rectangleExtraMixins } from './rectangleExtras';\n\nObject.assign(Point.prototype, pointExtraMixins);\nObject.assign(ObservablePoint.prototype, pointExtraMixins);\nObject.assign(Rectangle.prototype, rectangleExtraMixins);\n","import { Point } from '../maths/point/Point.mjs';\n\n\"use strict\";\nconst pointExtraMixins = {\n  /**\n   * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method add\n   * @memberof maths.Point#\n   * @param {maths.PointData} other - The point to add to `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the addition.\n   */\n  /**\n   * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method add\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} other - The point to add to `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the addition.\n   */\n  add(other, outPoint) {\n    if (!outPoint) {\n      outPoint = new Point();\n    }\n    outPoint.x = this.x + other.x;\n    outPoint.y = this.y + other.y;\n    return outPoint;\n  },\n  /**\n   * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method subtract\n   * @memberof maths.Point#\n   * @param {maths.PointData} other - The point to subtract to `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n   */\n  /**\n   * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method subtract\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} other - The point to subtract to `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n   */\n  subtract(other, outPoint) {\n    if (!outPoint) {\n      outPoint = new Point();\n    }\n    outPoint.x = this.x - other.x;\n    outPoint.y = this.y - other.y;\n    return outPoint;\n  },\n  /**\n   * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method multiply\n   * @memberof maths.Point#\n   * @param {maths.PointData} other - The point to multiply with `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n   */\n  /**\n   * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method multiply\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} other - The point to multiply with `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n   */\n  multiply(other, outPoint) {\n    if (!outPoint) {\n      outPoint = new Point();\n    }\n    outPoint.x = this.x * other.x;\n    outPoint.y = this.y * other.y;\n    return outPoint;\n  },\n  /**\n   * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method multiplyScalar\n   * @memberof maths.Point#\n   * @param {number} scalar - The number to multiply both components of `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the multiplication.\n   */\n  /**\n   * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method multiplyScalar\n   * @memberof maths.ObservablePoint#\n   * @param {number} scalar - The number to multiply both components of `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `outPoint` reference or a new Point, with the multiplication.\n   */\n  multiplyScalar(scalar, outPoint) {\n    if (!outPoint) {\n      outPoint = new Point();\n    }\n    outPoint.x = this.x * scalar;\n    outPoint.y = this.y * scalar;\n    return outPoint;\n  },\n  /**\n   * Computes the dot product of `other` with `this` point.\n   * The dot product is the sum of the products of the corresponding components of two vectors.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method dot\n   * @memberof maths.Point#\n   * @param {maths.PointData} other - The other point to calculate the dot product with `this`.\n   * @returns {number} The result of the dot product. This is an scalar value.\n   */\n  /**\n   * Computes the dot product of `other` with `this` point.\n   * The dot product is the sum of the products of the corresponding components of two vectors.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method dot\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} other - The other point to calculate the dot product with `this`.\n   * @returns {number} The result of the dot product. This is an scalar value.\n   */\n  dot(other) {\n    return this.x * other.x + this.y * other.y;\n  },\n  /**\n   * Computes the cross product of `other` with `this` point.\n   * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n   * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n   * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n   * the result becomes a vector that will only have magnitude on the z axis.\n   *\n   * This function returns the z component of the cross product of the two points.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method cross\n   * @memberof maths.Point#\n   * @param {maths.PointData} other - The other point to calculate the cross product with `this`.\n   * @returns {number} The z component of the result of the cross product.\n   */\n  /**\n   * Computes the cross product of `other` with `this` point.\n   * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n   * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n   * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n   * the result becomes a vector that will only have magnitude on the z axis.\n   *\n   * This function returns the z component of the cross product of the two points.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method cross\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} other - The other point to calculate the cross product with `this`.\n   * @returns {number} The z component of the result of the cross product.\n   */\n  cross(other) {\n    return this.x * other.y - this.y * other.x;\n  },\n  /**\n   * Computes a normalized version of `this` point.\n   *\n   * A normalized vector is a vector of magnitude (length) 1\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method normalize\n   * @memberof maths.Point#\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The normalized point.\n   */\n  /**\n   * Computes a normalized version of `this` point.\n   *\n   * A normalized vector is a vector of magnitude (length) 1\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method normalize\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The normalized point.\n   */\n  normalize(outPoint) {\n    if (!outPoint) {\n      outPoint = new Point();\n    }\n    const magnitude = Math.sqrt(this.x * this.x + this.y * this.y);\n    outPoint.x = this.x / magnitude;\n    outPoint.y = this.y / magnitude;\n    return outPoint;\n  },\n  /**\n   * Computes the magnitude of this point (Euclidean distance from 0, 0).\n   *\n   * Defined as the square root of the sum of the squares of each component.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method magnitude\n   * @memberof maths.Point#\n   * @returns {number} The magnitude (length) of the vector.\n   */\n  /**\n   * Computes the magnitude of this point (Euclidean distance from 0, 0).\n   *\n   * Defined as the square root of the sum of the squares of each component.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method magnitude\n   * @memberof maths.ObservablePoint#\n   * @returns {number} The magnitude (length) of the vector.\n   */\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  },\n  /**\n   * Computes the square magnitude of this point.\n   * If you are comparing the lengths of vectors, you should compare the length squared instead\n   * as it is slightly more efficient to calculate.\n   *\n   * Defined as the sum of the squares of each component.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method magnitudeSquared\n   * @memberof maths.Point#\n   * @returns {number} The magnitude squared (length squared) of the vector.\n   */\n  /**\n   * Computes the square magnitude of this point.\n   * If you are comparing the lengths of vectors, you should compare the length squared instead\n   * as it is slightly more efficient to calculate.\n   *\n   * Defined as the sum of the squares of each component.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method magnitudeSquared\n   * @memberof maths.ObservablePoint#\n   * @returns {number} The magnitude squared (length squared) of the vector.\n   */\n  magnitudeSquared() {\n    return this.x * this.x + this.y * this.y;\n  },\n  /**\n   * Computes vector projection of `this` on `onto`.\n   *\n   * Imagine a light source, parallel to `onto`, above `this`.\n   * The light would cast rays perpendicular to `onto`.\n   * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method project\n   * @memberof maths.Point#\n   * @param {maths.PointData} onto - A non zero vector describing a line on which to project `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `this` on `onto` projection.\n   */\n  /**\n   * Computes vector projection of `this` on `onto`.\n   *\n   * Imagine a light source, parallel to `onto`, above `this`.\n   * The light would cast rays perpendicular to `onto`.\n   * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method project\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} onto - A non zero vector describing a line on which to project `this`.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The `this` on `onto` projection.\n   */\n  project(onto, outPoint) {\n    if (!outPoint) {\n      outPoint = new Point();\n    }\n    const normalizedScalarProjection = (this.x * onto.x + this.y * onto.y) / (onto.x * onto.x + onto.y * onto.y);\n    outPoint.x = onto.x * normalizedScalarProjection;\n    outPoint.y = onto.y * normalizedScalarProjection;\n    return outPoint;\n  },\n  /**\n   * Reflects `this` vector off of a plane orthogonal to `normal`.\n   * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n   *\n   * Imagine a light source bouncing onto a mirror.\n   * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n   * `this.reflect(normal)` is the reflection of `this` on that mirror.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method reflect\n   * @memberof maths.Point#\n   * @param {maths.PointData} normal - The normal vector of your reflecting plane.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The reflection of `this` on your reflecting plane.\n   */\n  /**\n   * Reflects `this` vector off of a plane orthogonal to `normal`.\n   * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n   *\n   * Imagine a light source bouncing onto a mirror.\n   * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n   * `this.reflect(normal)` is the reflection of `this` on that mirror.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method reflect\n   * @memberof maths.ObservablePoint#\n   * @param {maths.PointData} normal - The normal vector of your reflecting plane.\n   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {PointData} The reflection of `this` on your reflecting plane.\n   */\n  reflect(normal, outPoint) {\n    if (!outPoint) {\n      outPoint = new Point();\n    }\n    const dotProduct = this.x * normal.x + this.y * normal.y;\n    outPoint.x = this.x - 2 * dotProduct * normal.x;\n    outPoint.y = this.y - 2 * dotProduct * normal.y;\n    return outPoint;\n  }\n};\n\nexport { pointExtraMixins };\n//# sourceMappingURL=pointExtras.mjs.map\n","import { Point } from '../maths/point/Point';\n\nimport type { PointData } from '../maths/point/PointData';\n\nexport const pointExtraMixins: any = {\n    /**\n     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method add\n     * @memberof maths.Point#\n     * @param {maths.PointData} other - The point to add to `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the result of the addition.\n     */\n    /**\n     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method add\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} other - The point to add to `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the result of the addition.\n     */\n    add<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x + other.x;\n        outPoint.y = this.y + other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method subtract\n     * @memberof maths.Point#\n     * @param {maths.PointData} other - The point to subtract to `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n     */\n    /**\n     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method subtract\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} other - The point to subtract to `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n     */\n    subtract<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x - other.x;\n        outPoint.y = this.y - other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method multiply\n     * @memberof maths.Point#\n     * @param {maths.PointData} other - The point to multiply with `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n     */\n    /**\n     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method multiply\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} other - The point to multiply with `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n     */\n    multiply<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x * other.x;\n        outPoint.y = this.y * other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method multiplyScalar\n     * @memberof maths.Point#\n     * @param {number} scalar - The number to multiply both components of `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the multiplication.\n     */\n    /**\n     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method multiplyScalar\n     * @memberof maths.ObservablePoint#\n     * @param {number} scalar - The number to multiply both components of `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the multiplication.\n     */\n    multiplyScalar<T extends PointData>(scalar: number, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x * scalar;\n        outPoint.y = this.y * scalar;\n\n        return outPoint;\n    },\n\n    /**\n     * Computes the dot product of `other` with `this` point.\n     * The dot product is the sum of the products of the corresponding components of two vectors.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method dot\n     * @memberof maths.Point#\n     * @param {maths.PointData} other - The other point to calculate the dot product with `this`.\n     * @returns {number} The result of the dot product. This is an scalar value.\n     */\n    /**\n     * Computes the dot product of `other` with `this` point.\n     * The dot product is the sum of the products of the corresponding components of two vectors.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method dot\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} other - The other point to calculate the dot product with `this`.\n     * @returns {number} The result of the dot product. This is an scalar value.\n     */\n    dot(other: PointData): number\n    {\n        return (this.x * other.x) + (this.y * other.y);\n    },\n\n    /**\n     * Computes the cross product of `other` with `this` point.\n     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n     * the result becomes a vector that will only have magnitude on the z axis.\n     *\n     * This function returns the z component of the cross product of the two points.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method cross\n     * @memberof maths.Point#\n     * @param {maths.PointData} other - The other point to calculate the cross product with `this`.\n     * @returns {number} The z component of the result of the cross product.\n     */\n    /**\n     * Computes the cross product of `other` with `this` point.\n     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n     * the result becomes a vector that will only have magnitude on the z axis.\n     *\n     * This function returns the z component of the cross product of the two points.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method cross\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} other - The other point to calculate the cross product with `this`.\n     * @returns {number} The z component of the result of the cross product.\n     */\n    cross(other: PointData): number\n    {\n        /*\n         * Returns the magnitude of the vector that would result\n         * from a regular 3D cross product of the input vectors,\n         * taking their Z values implicitly as 0\n         * (i.e. treating the 2D space as a plane in the 3D space).\n         * The 3D cross product will be perpendicular to that plane,\n         * and thus have 0 X & Y components\n         * (thus the scalar returned is the Z value of the 3D cross product vector).\n         */\n        return (this.x * other.y) - (this.y * other.x);\n    },\n\n    /**\n     * Computes a normalized version of `this` point.\n     *\n     * A normalized vector is a vector of magnitude (length) 1\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method normalize\n     * @memberof maths.Point#\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The normalized point.\n     */\n    /**\n     * Computes a normalized version of `this` point.\n     *\n     * A normalized vector is a vector of magnitude (length) 1\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method normalize\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The normalized point.\n     */\n    normalize<T extends PointData>(outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        const magnitude = Math.sqrt((this.x * this.x) + (this.y * this.y));\n\n        outPoint.x = this.x / magnitude;\n        outPoint.y = this.y / magnitude;\n\n        return outPoint;\n    },\n\n    /**\n     * Computes the magnitude of this point (Euclidean distance from 0, 0).\n     *\n     * Defined as the square root of the sum of the squares of each component.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method magnitude\n     * @memberof maths.Point#\n     * @returns {number} The magnitude (length) of the vector.\n     */\n    /**\n     * Computes the magnitude of this point (Euclidean distance from 0, 0).\n     *\n     * Defined as the square root of the sum of the squares of each component.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method magnitude\n     * @memberof maths.ObservablePoint#\n     * @returns {number} The magnitude (length) of the vector.\n     */\n    magnitude(): number\n    {\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\n    },\n\n    /**\n     * Computes the square magnitude of this point.\n     * If you are comparing the lengths of vectors, you should compare the length squared instead\n     * as it is slightly more efficient to calculate.\n     *\n     * Defined as the sum of the squares of each component.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method magnitudeSquared\n     * @memberof maths.Point#\n     * @returns {number} The magnitude squared (length squared) of the vector.\n     */\n    /**\n     * Computes the square magnitude of this point.\n     * If you are comparing the lengths of vectors, you should compare the length squared instead\n     * as it is slightly more efficient to calculate.\n     *\n     * Defined as the sum of the squares of each component.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method magnitudeSquared\n     * @memberof maths.ObservablePoint#\n     * @returns {number} The magnitude squared (length squared) of the vector.\n     */\n    magnitudeSquared(): number\n    {\n        return (this.x * this.x) + (this.y * this.y);\n    },\n\n    /**\n     * Computes vector projection of `this` on `onto`.\n     *\n     * Imagine a light source, parallel to `onto`, above `this`.\n     * The light would cast rays perpendicular to `onto`.\n     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method project\n     * @memberof maths.Point#\n     * @param {maths.PointData} onto - A non zero vector describing a line on which to project `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `this` on `onto` projection.\n     */\n    /**\n     * Computes vector projection of `this` on `onto`.\n     *\n     * Imagine a light source, parallel to `onto`, above `this`.\n     * The light would cast rays perpendicular to `onto`.\n     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method project\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} onto - A non zero vector describing a line on which to project `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `this` on `onto` projection.\n     */\n    project<T extends PointData>(onto: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        // Math says: a Projected over b = [(a·b) / (b·b)] * b;\n        const normalizedScalarProjection = ((this.x * onto.x) + (this.y * onto.y)) / ((onto.x * onto.x) + (onto.y * onto.y));\n\n        outPoint.x = onto.x * normalizedScalarProjection;\n        outPoint.y = onto.y * normalizedScalarProjection;\n\n        return outPoint;\n    },\n\n    /**\n     * Reflects `this` vector off of a plane orthogonal to `normal`.\n     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n     *\n     * Imagine a light source bouncing onto a mirror.\n     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n     * `this.reflect(normal)` is the reflection of `this` on that mirror.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method reflect\n     * @memberof maths.Point#\n     * @param {maths.PointData} normal - The normal vector of your reflecting plane.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The reflection of `this` on your reflecting plane.\n     */\n    /**\n     * Reflects `this` vector off of a plane orthogonal to `normal`.\n     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n     *\n     * Imagine a light source bouncing onto a mirror.\n     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n     * `this.reflect(normal)` is the reflection of `this` on that mirror.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method reflect\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} normal - The normal vector of your reflecting plane.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The reflection of `this` on your reflecting plane.\n     */\n    reflect<T extends PointData>(normal: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n\n        // Given an incident vector i and a normal vector n, returns the reflection vector r = i - 2 * dot(i, n) * n\n\n        const dotProduct = (this.x * normal.x) + (this.y * normal.y);\n\n        outPoint.x = this.x - (2 * dotProduct * normal.x);\n        outPoint.y = this.y - (2 * dotProduct * normal.y);\n\n        return outPoint;\n    }\n};\n","import { Rectangle } from '../maths/shapes/Rectangle.mjs';\n\n\"use strict\";\nconst rectangleExtraMixins = {\n  /**\n   * Determines whether the `other` Rectangle is contained within `this` Rectangle object.\n   * Rectangles that occupy the same space are considered to be containing each other.\n   * Rectangles without area (width or height equal to zero) can't contain anything,\n   * not even other arealess rectangles.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method containsRect\n   * @memberof maths.Rectangle#\n   * @param {Rectangle} other - The Rectangle to fit inside `this`.\n   * @returns {boolean} A value of `true` if `this` Rectangle contains `other`; otherwise `false`.\n   */\n  containsRect(other) {\n    if (other.width <= 0 || other.height <= 0) {\n      return other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom;\n    }\n    return other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;\n  },\n  /**\n   * Accepts `other` Rectangle and returns true if the given Rectangle is equal to `this` Rectangle.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method equals\n   * @memberof maths.Rectangle#\n   * @param {Rectangle} other - The Rectangle to compare with `this`\n   * @returns {boolean} Returns true if all `x`, `y`, `width`, and `height` are equal.\n   */\n  equals(other) {\n    if (other === this) {\n      return true;\n    }\n    return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n  },\n  /**\n   * If the area of the intersection between the Rectangles `other` and `this` is not zero,\n   * returns the area of intersection as a Rectangle object. Otherwise, return an empty Rectangle\n   * with its properties set to zero.\n   * Rectangles without area (width or height equal to zero) can't intersect or be intersected\n   * and will always return an empty rectangle with its properties set to zero.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method intersection\n   * @memberof maths.Rectangle#\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n   * optional (otherwise will create a new Rectangle).\n   * @returns {Rectangle} The intersection of `this` and `other`.\n   */\n  intersection(other, outRect) {\n    if (!outRect) {\n      outRect = new Rectangle();\n    }\n    const x0 = this.x < other.x ? other.x : this.x;\n    const x1 = this.right > other.right ? other.right : this.right;\n    if (x1 <= x0) {\n      outRect.x = outRect.y = outRect.width = outRect.height = 0;\n      return outRect;\n    }\n    const y0 = this.y < other.y ? other.y : this.y;\n    const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n    if (y1 <= y0) {\n      outRect.x = outRect.y = outRect.width = outRect.height = 0;\n      return outRect;\n    }\n    outRect.x = x0;\n    outRect.y = y0;\n    outRect.width = x1 - x0;\n    outRect.height = y1 - y0;\n    return outRect;\n  },\n  /**\n   * Adds `this` and `other` Rectangles together to create a new Rectangle object filling\n   * the horizontal and vertical space between the two rectangles.\n   *\n   * _Note: Only available with **pixi.js/math-extras**._\n   * @method union\n   * @memberof maths.Rectangle#\n   * @param {Rectangle} other - The Rectangle to unite with `this`.\n   * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n   * optional (otherwise will create a new Rectangle).\n   * @returns {Rectangle} The union of `this` and `other`.\n   */\n  union(other, outRect) {\n    if (!outRect) {\n      outRect = new Rectangle();\n    }\n    const x1 = Math.min(this.x, other.x);\n    const x2 = Math.max(this.x + this.width, other.x + other.width);\n    const y1 = Math.min(this.y, other.y);\n    const y2 = Math.max(this.y + this.height, other.y + other.height);\n    outRect.x = x1;\n    outRect.y = y1;\n    outRect.width = x2 - x1;\n    outRect.height = y2 - y1;\n    return outRect;\n  }\n};\n\nexport { rectangleExtraMixins };\n//# sourceMappingURL=rectangleExtras.mjs.map\n","import { Rectangle } from '../maths/shapes/Rectangle';\n\nexport const rectangleExtraMixins: Partial<Rectangle> = {\n    /**\n     * Determines whether the `other` Rectangle is contained within `this` Rectangle object.\n     * Rectangles that occupy the same space are considered to be containing each other.\n     * Rectangles without area (width or height equal to zero) can't contain anything,\n     * not even other arealess rectangles.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method containsRect\n     * @memberof maths.Rectangle#\n     * @param {Rectangle} other - The Rectangle to fit inside `this`.\n     * @returns {boolean} A value of `true` if `this` Rectangle contains `other`; otherwise `false`.\n     */\n    containsRect(other: Rectangle): boolean\n    {\n        if (other.width <= 0 || other.height <= 0)\n        {\n            return other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom;\n        }\n\n        return other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;\n    },\n    /**\n     * Accepts `other` Rectangle and returns true if the given Rectangle is equal to `this` Rectangle.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method equals\n     * @memberof maths.Rectangle#\n     * @param {Rectangle} other - The Rectangle to compare with `this`\n     * @returns {boolean} Returns true if all `x`, `y`, `width`, and `height` are equal.\n     */\n    equals(other: Rectangle): boolean\n    {\n        if (other === this)\n        {\n            return true;\n        }\n\n        return (\n            other\n            && this.x === other.x\n            && this.y === other.y\n            && this.width === other.width\n            && this.height === other.height\n        );\n    },\n\n    /**\n     * If the area of the intersection between the Rectangles `other` and `this` is not zero,\n     * returns the area of intersection as a Rectangle object. Otherwise, return an empty Rectangle\n     * with its properties set to zero.\n     * Rectangles without area (width or height equal to zero) can't intersect or be intersected\n     * and will always return an empty rectangle with its properties set to zero.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method intersection\n     * @memberof maths.Rectangle#\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n     * optional (otherwise will create a new Rectangle).\n     * @returns {Rectangle} The intersection of `this` and `other`.\n     */\n    intersection<T extends Rectangle>(other: Rectangle, outRect?: T): T\n    {\n        if (!outRect)\n        {\n            outRect = new Rectangle() as T;\n        }\n\n        const x0 = this.x < other.x ? other.x : this.x;\n        const x1 = this.right > other.right ? other.right : this.right;\n\n        if (x1 <= x0)\n        {\n            outRect.x = outRect.y = outRect.width = outRect.height = 0;\n\n            return outRect;\n        }\n\n        const y0 = this.y < other.y ? other.y : this.y;\n        const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n        if (y1 <= y0)\n        {\n            outRect.x = outRect.y = outRect.width = outRect.height = 0;\n\n            return outRect;\n        }\n\n        outRect.x = x0;\n        outRect.y = y0;\n        outRect.width = x1 - x0;\n        outRect.height = y1 - y0;\n\n        return outRect;\n    },\n\n    /**\n     * Adds `this` and `other` Rectangles together to create a new Rectangle object filling\n     * the horizontal and vertical space between the two rectangles.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method union\n     * @memberof maths.Rectangle#\n     * @param {Rectangle} other - The Rectangle to unite with `this`.\n     * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n     * optional (otherwise will create a new Rectangle).\n     * @returns {Rectangle} The union of `this` and `other`.\n     */\n    union<T extends Rectangle>(other: Rectangle, outRect?: T): T\n    {\n        if (!outRect)\n        {\n            outRect = new Rectangle() as T;\n        }\n\n        const x1 = Math.min(this.x, other.x);\n        const x2 = Math.max(this.x + this.width, other.x + other.width);\n        const y1 = Math.min(this.y, other.y);\n        const y2 = Math.max(this.y + this.height, other.y + other.height);\n\n        outRect.x = x1;\n        outRect.y = y1;\n        outRect.width = x2 - x1;\n        outRect.height = y2 - y1;\n\n        return outRect;\n    },\n};\n","import { browserExt } from './environment-browser/browserExt.mjs';\nimport { webworkerExt } from './environment-webworker/webworkerExt.mjs';\nimport { extensions } from './extensions/Extensions.mjs';\nexport { ExtensionType, normalizeExtensionPriority } from './extensions/Extensions.mjs';\nimport './rendering/init.mjs';\nimport './spritesheet/init.mjs';\nimport './accessibility/index.mjs';\nimport './advanced-blend-modes/index.mjs';\nimport './app/index.mjs';\nimport './assets/index.mjs';\nimport './color/index.mjs';\nimport './compressed-textures/index.mjs';\nimport './culling/index.mjs';\nimport './environment/index.mjs';\nimport './environment-browser/index.mjs';\nimport './environment-webworker/index.mjs';\nimport './events/index.mjs';\nimport './extensions/index.mjs';\nimport './filters/index.mjs';\nimport './maths/index.mjs';\nimport './prepare/index.mjs';\nimport './rendering/index.mjs';\nimport './scene/index.mjs';\nimport './spritesheet/index.mjs';\nimport './ticker/index.mjs';\nimport './utils/index.mjs';\nexport { AccessibilitySystem } from './accessibility/AccessibilitySystem.mjs';\nexport { accessibilityTarget } from './accessibility/accessibilityTarget.mjs';\nexport { ColorBlend } from './advanced-blend-modes/ColorBlend.mjs';\nexport { ColorBurnBlend } from './advanced-blend-modes/ColorBurnBlend.mjs';\nexport { ColorDodgeBlend } from './advanced-blend-modes/ColorDodgeBlend.mjs';\nexport { DarkenBlend } from './advanced-blend-modes/DarkenBlend.mjs';\nexport { DifferenceBlend } from './advanced-blend-modes/DifferenceBlend.mjs';\nexport { DivideBlend } from './advanced-blend-modes/DivideBlend.mjs';\nexport { ExclusionBlend } from './advanced-blend-modes/ExclusionBlend.mjs';\nexport { HardLightBlend } from './advanced-blend-modes/HardLightBlend.mjs';\nexport { HardMixBlend } from './advanced-blend-modes/HardMixBlend.mjs';\nexport { LightenBlend } from './advanced-blend-modes/LightenBlend.mjs';\nexport { LinearBurnBlend } from './advanced-blend-modes/LinearBurnBlend.mjs';\nexport { LinearDodgeBlend } from './advanced-blend-modes/LinearDodgeBlend.mjs';\nexport { LinearLightBlend } from './advanced-blend-modes/LinearLightBlend.mjs';\nexport { LuminosityBlend } from './advanced-blend-modes/LuminosityBlend.mjs';\nexport { NegationBlend } from './advanced-blend-modes/NegationBlend.mjs';\nexport { OverlayBlend } from './advanced-blend-modes/OverlayBlend.mjs';\nexport { PinLightBlend } from './advanced-blend-modes/PinLightBlend.mjs';\nexport { SaturationBlend } from './advanced-blend-modes/SaturationBlend.mjs';\nexport { SoftLightBlend } from './advanced-blend-modes/SoftLightBlend.mjs';\nexport { SubtractBlend } from './advanced-blend-modes/SubtractBlend.mjs';\nexport { VividLightBlend } from './advanced-blend-modes/VividLightBlend.mjs';\nexport { Application } from './app/Application.mjs';\nexport { ResizePlugin } from './app/ResizePlugin.mjs';\nexport { TickerPlugin } from './app/TickerPlugin.mjs';\nexport { Assets, AssetsClass } from './assets/Assets.mjs';\nexport { BackgroundLoader } from './assets/BackgroundLoader.mjs';\nexport { Cache } from './assets/cache/Cache.mjs';\nexport { cacheTextureArray } from './assets/cache/parsers/cacheTextureArray.mjs';\nexport { detectAvif } from './assets/detections/parsers/detectAvif.mjs';\nexport { detectDefaults } from './assets/detections/parsers/detectDefaults.mjs';\nexport { detectMp4 } from './assets/detections/parsers/detectMp4.mjs';\nexport { detectOgv } from './assets/detections/parsers/detectOgv.mjs';\nexport { detectWebm } from './assets/detections/parsers/detectWebm.mjs';\nexport { detectWebp } from './assets/detections/parsers/detectWebp.mjs';\nexport { testImageFormat } from './assets/detections/utils/testImageFormat.mjs';\nexport { testVideoFormat } from './assets/detections/utils/testVideoFormat.mjs';\nexport { Loader } from './assets/loader/Loader.mjs';\nexport { LoaderParserPriority } from './assets/loader/parsers/LoaderParser.mjs';\nexport { loadJson } from './assets/loader/parsers/loadJson.mjs';\nexport { loadTxt } from './assets/loader/parsers/loadTxt.mjs';\nexport { getFontFamilyName, loadWebFont } from './assets/loader/parsers/loadWebFont.mjs';\nexport { loadSvg } from './assets/loader/parsers/textures/loadSVG.mjs';\nexport { loadImageBitmap, loadTextures } from './assets/loader/parsers/textures/loadTextures.mjs';\nexport { crossOrigin, determineCrossOrigin, loadVideoTextures, preloadVideo } from './assets/loader/parsers/textures/loadVideoTextures.mjs';\nexport { createTexture } from './assets/loader/parsers/textures/utils/createTexture.mjs';\nexport { WorkerManager } from './assets/loader/workers/WorkerManager.mjs';\nexport { resolveJsonUrl } from './assets/resolver/parsers/resolveJsonUrl.mjs';\nexport { resolveTextureUrl } from './assets/resolver/parsers/resolveTextureUrl.mjs';\nexport { Resolver, getUrlExtension } from './assets/resolver/Resolver.mjs';\nexport { checkDataUrl } from './assets/utils/checkDataUrl.mjs';\nexport { checkExtension } from './assets/utils/checkExtension.mjs';\nexport { convertToList } from './assets/utils/convertToList.mjs';\nexport { copySearchParams } from './assets/utils/copySearchParams.mjs';\nexport { createStringVariations } from './assets/utils/createStringVariations.mjs';\nexport { isSingleItem } from './assets/utils/isSingleItem.mjs';\nexport { Color } from './color/Color.mjs';\nexport { detectBasis } from './compressed-textures/basis/detectBasis.mjs';\nexport { loadBasis } from './compressed-textures/basis/loadBasis.mjs';\nexport { createLevelBuffers } from './compressed-textures/basis/utils/createLevelBuffers.mjs';\nexport { gpuFormatToBasisTranscoderFormat } from './compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs';\nexport { basisTranscoderUrls, setBasisTranscoderPath } from './compressed-textures/basis/utils/setBasisTranscoderPath.mjs';\nexport { loadBasisOnWorker } from './compressed-textures/basis/worker/loadBasisOnWorker.mjs';\nexport { DDS, DXGI_TO_TEXTURE_FORMAT, FOURCC_TO_TEXTURE_FORMAT, TEXTURE_FORMAT_BLOCK_SIZE } from './compressed-textures/dds/const.mjs';\nexport { loadDDS } from './compressed-textures/dds/loadDDS.mjs';\nexport { parseDDS } from './compressed-textures/dds/parseDDS.mjs';\nexport { loadKTX } from './compressed-textures/ktx/loadKTX.mjs';\nexport { parseKTX } from './compressed-textures/ktx/parseKTX.mjs';\nexport { GL_INTERNAL_FORMAT, KTX } from './compressed-textures/ktx2/const.mjs';\nexport { loadKTX2 } from './compressed-textures/ktx2/loadKTX2.mjs';\nexport { convertFormatIfRequired } from './compressed-textures/ktx2/utils/convertFormatIfRequired.mjs';\nexport { createLevelBuffersFromKTX } from './compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs';\nexport { getTextureFormatFromKTXTexture } from './compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs';\nexport { glFormatToGPUFormat } from './compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs';\nexport { gpuFormatToKTXBasisTranscoderFormat } from './compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs';\nexport { ktxTranscoderUrls, setKTXTranscoderPath } from './compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs';\nexport { vkFormatToGPUFormat } from './compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs';\nexport { loadKTX2onWorker } from './compressed-textures/ktx2/worker/loadKTX2onWorker.mjs';\nexport { detectCompressed } from './compressed-textures/shared/detectCompressed.mjs';\nexport { resolveCompressedTextureUrl, validFormats } from './compressed-textures/shared/resolveCompressedTextureUrl.mjs';\nexport { Culler } from './culling/Culler.mjs';\nexport { CullerPlugin } from './culling/CullerPlugin.mjs';\nexport { cullingMixin } from './culling/cullingMixin.mjs';\nexport { DOMAdapter } from './environment/adapter.mjs';\nexport { autoDetectEnvironment } from './environment/autoDetectEnvironment.mjs';\nexport { BrowserAdapter } from './environment-browser/BrowserAdapter.mjs';\nexport { WebWorkerAdapter } from './environment-webworker/WebWorkerAdapter.mjs';\nexport { EventBoundary } from './events/EventBoundary.mjs';\nexport { EventSystem } from './events/EventSystem.mjs';\nexport { EventsTicker } from './events/EventTicker.mjs';\nexport { FederatedEvent } from './events/FederatedEvent.mjs';\nexport { FederatedContainer } from './events/FederatedEventTarget.mjs';\nexport { FederatedMouseEvent } from './events/FederatedMouseEvent.mjs';\nexport { FederatedPointerEvent } from './events/FederatedPointerEvent.mjs';\nexport { FederatedWheelEvent } from './events/FederatedWheelEvent.mjs';\nexport { default as blendTemplateFrag } from './filters/blend-modes/blend-template.frag.mjs';\nexport { default as blendTemplateVert } from './filters/blend-modes/blend-template.vert.mjs';\nexport { default as blendTemplateWgsl } from './filters/blend-modes/blend-template.wgsl.mjs';\nexport { default as hslWgsl } from './filters/blend-modes/hsl.wgsl.mjs';\nexport { default as alphaFrag } from './filters/defaults/alpha/alpha.frag.mjs';\nexport { default as alphaWgsl } from './filters/defaults/alpha/alpha.wgsl.mjs';\nexport { default as blurTemplateWgsl } from './filters/defaults/blur/gpu/blur-template.wgsl.mjs';\nexport { default as colorMatrixFilterFrag } from './filters/defaults/color-matrix/colorMatrixFilter.frag.mjs';\nexport { default as colorMatrixFilterWgsl } from './filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs';\nexport { default as defaultFilterVert } from './filters/defaults/defaultFilter.vert.mjs';\nexport { default as displacementFrag } from './filters/defaults/displacement/displacement.frag.mjs';\nexport { default as displacementVert } from './filters/defaults/displacement/displacement.vert.mjs';\nexport { default as displacementWgsl } from './filters/defaults/displacement/displacement.wgsl.mjs';\nexport { default as noiseFrag } from './filters/defaults/noise/noise.frag.mjs';\nexport { default as noiseWgsl } from './filters/defaults/noise/noise.wgsl.mjs';\nexport { default as maskFrag } from './filters/mask/mask.frag.mjs';\nexport { default as maskVert } from './filters/mask/mask.vert.mjs';\nexport { default as maskWgsl } from './filters/mask/mask.wgsl.mjs';\nexport { BlendModeFilter } from './filters/blend-modes/BlendModeFilter.mjs';\nexport { hslgl } from './filters/blend-modes/hls/GLhls.mjs';\nexport { hslgpu } from './filters/blend-modes/hls/GPUhls.mjs';\nexport { AlphaFilter } from './filters/defaults/alpha/AlphaFilter.mjs';\nexport { BlurFilter } from './filters/defaults/blur/BlurFilter.mjs';\nexport { BlurFilterPass } from './filters/defaults/blur/BlurFilterPass.mjs';\nexport { GAUSSIAN_VALUES } from './filters/defaults/blur/const.mjs';\nexport { generateBlurFragSource } from './filters/defaults/blur/gl/generateBlurFragSource.mjs';\nexport { generateBlurGlProgram } from './filters/defaults/blur/gl/generateBlurGlProgram.mjs';\nexport { generateBlurVertSource } from './filters/defaults/blur/gl/generateBlurVertSource.mjs';\nexport { generateBlurProgram } from './filters/defaults/blur/gpu/generateBlurProgram.mjs';\nexport { ColorMatrixFilter } from './filters/defaults/color-matrix/ColorMatrixFilter.mjs';\nexport { DisplacementFilter } from './filters/defaults/displacement/DisplacementFilter.mjs';\nexport { NoiseFilter } from './filters/defaults/noise/NoiseFilter.mjs';\nexport { Filter } from './filters/Filter.mjs';\nexport { FilterEffect } from './filters/FilterEffect.mjs';\nexport { FilterPipe } from './filters/FilterPipe.mjs';\nexport { FilterSystem } from './filters/FilterSystem.mjs';\nexport { MaskFilter } from './filters/mask/MaskFilter.mjs';\nexport { groupD8 } from './maths/matrix/groupD8.mjs';\nexport { Matrix } from './maths/matrix/Matrix.mjs';\nexport { DEG_TO_RAD, PI_2, RAD_TO_DEG } from './maths/misc/const.mjs';\nexport { isPow2, log2, nextPow2 } from './maths/misc/pow2.mjs';\nexport { squaredDistanceToLineSegment } from './maths/misc/squaredDistanceToLineSegment.mjs';\nexport { ObservablePoint } from './maths/point/ObservablePoint.mjs';\nexport { Point } from './maths/point/Point.mjs';\nexport { Circle } from './maths/shapes/Circle.mjs';\nexport { Ellipse } from './maths/shapes/Ellipse.mjs';\nexport { Polygon } from './maths/shapes/Polygon.mjs';\nexport { Rectangle } from './maths/shapes/Rectangle.mjs';\nexport { RoundedRectangle } from './maths/shapes/RoundedRectangle.mjs';\nexport { Triangle } from './maths/shapes/Triangle.mjs';\nexport { PrepareBase } from './prepare/PrepareBase.mjs';\nexport { PrepareQueue } from './prepare/PrepareQueue.mjs';\nexport { PrepareSystem } from './prepare/PrepareSystem.mjs';\nexport { PrepareUpload } from './prepare/PrepareUpload.mjs';\nexport { GlBatchAdaptor } from './rendering/batcher/gl/GlBatchAdaptor.mjs';\nexport { BatchGeometry } from './rendering/batcher/gpu/BatchGeometry.mjs';\nexport { generateGPULayout } from './rendering/batcher/gpu/generateGPULayout.mjs';\nexport { generateLayout } from './rendering/batcher/gpu/generateLayout.mjs';\nexport { getTextureBatchBindGroup } from './rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nexport { GpuBatchAdaptor } from './rendering/batcher/gpu/GpuBatchAdaptor.mjs';\nexport { Batch, Batcher } from './rendering/batcher/shared/Batcher.mjs';\nexport { BatcherPipe } from './rendering/batcher/shared/BatcherPipe.mjs';\nexport { BatchTextureArray } from './rendering/batcher/shared/BatchTextureArray.mjs';\nexport { MAX_TEXTURES } from './rendering/batcher/shared/const.mjs';\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram } from './rendering/high-shader/compileHighShaderToProgram.mjs';\nexport { compileHighShader, compileHighShaderGl } from './rendering/high-shader/compiler/compileHighShader.mjs';\nexport { addBits } from './rendering/high-shader/compiler/utils/addBits.mjs';\nexport { compileHooks, findHooksRx } from './rendering/high-shader/compiler/utils/compileHooks.mjs';\nexport { compileInputs } from './rendering/high-shader/compiler/utils/compileInputs.mjs';\nexport { compileOutputs } from './rendering/high-shader/compiler/utils/compileOutputs.mjs';\nexport { formatShader } from './rendering/high-shader/compiler/utils/formatShader.mjs';\nexport { injectBits } from './rendering/high-shader/compiler/utils/injectBits.mjs';\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate } from './rendering/high-shader/defaultProgramTemplate.mjs';\nexport { colorBit, colorBitGl } from './rendering/high-shader/shader-bits/colorBit.mjs';\nexport { generateTextureBatchBit, generateTextureBatchBitGl } from './rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl } from './rendering/high-shader/shader-bits/globalUniformsBit.mjs';\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 } from './rendering/high-shader/shader-bits/localUniformBit.mjs';\nexport { roundPixelsBit, roundPixelsBitGl } from './rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nexport { textureBit, textureBitGl } from './rendering/high-shader/shader-bits/textureBit.mjs';\nexport { AlphaMask } from './rendering/mask/alpha/AlphaMask.mjs';\nexport { AlphaMaskPipe } from './rendering/mask/alpha/AlphaMaskPipe.mjs';\nexport { ColorMask } from './rendering/mask/color/ColorMask.mjs';\nexport { ColorMaskPipe } from './rendering/mask/color/ColorMaskPipe.mjs';\nexport { MaskEffectManager, MaskEffectManagerClass } from './rendering/mask/MaskEffectManager.mjs';\nexport { ScissorMask } from './rendering/mask/scissor/ScissorMask.mjs';\nexport { StencilMask } from './rendering/mask/stencil/StencilMask.mjs';\nexport { StencilMaskPipe } from './rendering/mask/stencil/StencilMaskPipe.mjs';\nexport { addMaskBounds } from './rendering/mask/utils/addMaskBounds.mjs';\nexport { addMaskLocalBounds, getMatrixRelativeToParent } from './rendering/mask/utils/addMaskLocalBounds.mjs';\nexport { autoDetectRenderer } from './rendering/renderers/autoDetectRenderer.mjs';\nexport { BUFFER_TYPE } from './rendering/renderers/gl/buffer/const.mjs';\nexport { GlBuffer } from './rendering/renderers/gl/buffer/GlBuffer.mjs';\nexport { GlBufferSystem } from './rendering/renderers/gl/buffer/GlBufferSystem.mjs';\nexport { CLEAR } from './rendering/renderers/gl/const.mjs';\nexport { GlContextSystem } from './rendering/renderers/gl/context/GlContextSystem.mjs';\nexport { GlGeometrySystem } from './rendering/renderers/gl/geometry/GlGeometrySystem.mjs';\nexport { getGlTypeFromFormat } from './rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs';\nexport { GlBackBufferSystem } from './rendering/renderers/gl/GlBackBufferSystem.mjs';\nexport { GlColorMaskSystem } from './rendering/renderers/gl/GlColorMaskSystem.mjs';\nexport { GlEncoderSystem } from './rendering/renderers/gl/GlEncoderSystem.mjs';\nexport { GlRenderTarget } from './rendering/renderers/gl/GlRenderTarget.mjs';\nexport { GlStencilSystem } from './rendering/renderers/gl/GlStencilSystem.mjs';\nexport { GlUboSystem } from './rendering/renderers/gl/GlUboSystem.mjs';\nexport { GlRenderTargetAdaptor } from './rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs';\nexport { GlRenderTargetSystem } from './rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs';\nexport { batchSamplersUniformGroup } from './rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs';\nexport { generateShaderSyncCode } from './rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs';\nexport { GlProgram } from './rendering/renderers/gl/shader/GlProgram.mjs';\nexport { GlProgramData, IGLUniformData } from './rendering/renderers/gl/shader/GlProgramData.mjs';\nexport { GlShaderSystem } from './rendering/renderers/gl/shader/GlShaderSystem.mjs';\nexport { GlUniformGroupSystem } from './rendering/renderers/gl/shader/GlUniformGroupSystem.mjs';\nexport { migrateFragmentFromV7toV8 } from './rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs';\nexport { compileShader } from './rendering/renderers/gl/shader/program/compileShader.mjs';\nexport { defaultValue } from './rendering/renderers/gl/shader/program/defaultValue.mjs';\nexport { ensureAttributes } from './rendering/renderers/gl/shader/program/ensureAttributes.mjs';\nexport { extractAttributesFromGlProgram } from './rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs';\nexport { generateProgram } from './rendering/renderers/gl/shader/program/generateProgram.mjs';\nexport { getMaxFragmentPrecision } from './rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs';\nexport { getTestContext } from './rendering/renderers/gl/shader/program/getTestContext.mjs';\nexport { getUboData } from './rendering/renderers/gl/shader/program/getUboData.mjs';\nexport { getUniformData } from './rendering/renderers/gl/shader/program/getUniformData.mjs';\nexport { logProgramError } from './rendering/renderers/gl/shader/program/logProgramError.mjs';\nexport { mapSize } from './rendering/renderers/gl/shader/program/mapSize.mjs';\nexport { mapGlToVertexFormat, mapType } from './rendering/renderers/gl/shader/program/mapType.mjs';\nexport { addProgramDefines } from './rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs';\nexport { ensurePrecision } from './rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs';\nexport { insertVersion } from './rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs';\nexport { setProgramName } from './rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs';\nexport { stripVersion } from './rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs';\nexport { WGSL_TO_STD40_SIZE, createUboElementsSTD40 } from './rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs';\nexport { createUboSyncFunctionSTD40 } from './rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs';\nexport { generateArraySyncSTD40 } from './rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs';\nexport { generateUniformsSync } from './rendering/renderers/gl/shader/utils/generateUniformsSync.mjs';\nexport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS } from './rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs';\nexport { GlStateSystem } from './rendering/renderers/gl/state/GlStateSystem.mjs';\nexport { mapWebGLBlendModesToPixi } from './rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs';\nexport { GL_FORMATS, GL_TARGETS, GL_TYPES, GL_WRAP_MODES } from './rendering/renderers/gl/texture/const.mjs';\nexport { GlTexture } from './rendering/renderers/gl/texture/GlTexture.mjs';\nexport { GlTextureSystem } from './rendering/renderers/gl/texture/GlTextureSystem.mjs';\nexport { glUploadBufferImageResource } from './rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs';\nexport { glUploadCompressedTextureResource } from './rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs';\nexport { glUploadImageResource } from './rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs';\nexport { glUploadVideoResource } from './rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs';\nexport { applyStyleParams } from './rendering/renderers/gl/texture/utils/applyStyleParams.mjs';\nexport { getSupportedGlCompressedTextureFormats } from './rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs';\nexport { mapFormatToGlFormat } from './rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs';\nexport { mapFormatToGlInternalFormat } from './rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs';\nexport { mapFormatToGlType } from './rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs';\nexport { compareModeToGlCompare, mipmapScaleModeToGlFilter, scaleModeToGlFilter, wrapModeToGlAddress } from './rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs';\nexport { unpremultiplyAlpha } from './rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs';\nexport { WebGLRenderer } from './rendering/renderers/gl/WebGLRenderer.mjs';\nexport { BindGroupSystem } from './rendering/renderers/gpu/BindGroupSystem.mjs';\nexport { GpuBufferSystem } from './rendering/renderers/gpu/buffer/GpuBufferSystem.mjs';\nexport { GpuReadBuffer } from './rendering/renderers/gpu/buffer/GpuReadBuffer.mjs';\nexport { UboBatch } from './rendering/renderers/gpu/buffer/UboBatch.mjs';\nexport { GpuColorMaskSystem } from './rendering/renderers/gpu/GpuColorMaskSystem.mjs';\nexport { GpuDeviceSystem } from './rendering/renderers/gpu/GpuDeviceSystem.mjs';\nexport { GpuEncoderSystem } from './rendering/renderers/gpu/GpuEncoderSystem.mjs';\nexport { GpuStencilSystem } from './rendering/renderers/gpu/GpuStencilSystem.mjs';\nexport { GpuUboSystem } from './rendering/renderers/gpu/GpuUboSystem.mjs';\nexport { GpuUniformBatchPipe } from './rendering/renderers/gpu/GpuUniformBatchPipe.mjs';\nexport { PipelineSystem } from './rendering/renderers/gpu/pipeline/PipelineSystem.mjs';\nexport { calculateProjection } from './rendering/renderers/gpu/renderTarget/calculateProjection.mjs';\nexport { GpuRenderTarget } from './rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs';\nexport { GpuRenderTargetAdaptor } from './rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs';\nexport { GpuRenderTargetSystem } from './rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs';\nexport { BindGroup } from './rendering/renderers/gpu/shader/BindGroup.mjs';\nexport { GpuProgram } from './rendering/renderers/gpu/shader/GpuProgram.mjs';\nexport { GpuShaderSystem } from './rendering/renderers/gpu/shader/GpuShaderSystem.mjs';\nexport { WGSL_ALIGN_SIZE_DATA, createUboElementsWGSL } from './rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs';\nexport { createUboSyncFunctionWGSL } from './rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs';\nexport { extractAttributesFromGpuProgram } from './rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs';\nexport { extractStructAndGroups } from './rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs';\nexport { generateArraySyncWGSL } from './rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs';\nexport { generateGpuLayoutGroups } from './rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs';\nexport { generateLayoutHash } from './rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs';\nexport { removeStructAndGroupDuplicates } from './rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs';\nexport { GpuBlendModesToPixi } from './rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs';\nexport { GpuStateSystem } from './rendering/renderers/gpu/state/GpuStateSystem.mjs';\nexport { GpuStencilModesToPixi } from './rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs';\nexport { GpuTextureSystem } from './rendering/renderers/gpu/texture/GpuTextureSystem.mjs';\nexport { gpuUploadBufferImageResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs';\nexport { blockDataMap, gpuUploadCompressedTextureResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs';\nexport { gpuUploadImageResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs';\nexport { gpuUploadVideoResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs';\nexport { getSupportedGPUCompressedTextureFormats } from './rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs';\nexport { GpuMipmapGenerator } from './rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs';\nexport { WebGPURenderer } from './rendering/renderers/gpu/WebGPURenderer.mjs';\nexport { BackgroundSystem } from './rendering/renderers/shared/background/BackgroundSystem.mjs';\nexport { BlendModePipe } from './rendering/renderers/shared/blendModes/BlendModePipe.mjs';\nexport { Buffer } from './rendering/renderers/shared/buffer/Buffer.mjs';\nexport { BufferResource } from './rendering/renderers/shared/buffer/BufferResource.mjs';\nexport { BufferUsage } from './rendering/renderers/shared/buffer/const.mjs';\nexport { fastCopy } from './rendering/renderers/shared/buffer/utils/fastCopy.mjs';\nexport { ExtractSystem } from './rendering/renderers/shared/extract/ExtractSystem.mjs';\nexport { GenerateTextureSystem } from './rendering/renderers/shared/extract/GenerateTextureSystem.mjs';\nexport { DRAW_MODES } from './rendering/renderers/shared/geometry/const.mjs';\nexport { Geometry } from './rendering/renderers/shared/geometry/Geometry.mjs';\nexport { buildSimpleUvs, buildUvs } from './rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nexport { ensureIsBuffer } from './rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs';\nexport { getAttributeInfoFromFormat } from './rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nexport { getGeometryBounds } from './rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs';\nexport { transformVertices } from './rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nexport { InstructionSet } from './rendering/renderers/shared/instructions/InstructionSet.mjs';\nexport { GlobalUniformSystem } from './rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs';\nexport { isRenderingToScreen } from './rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs';\nexport { RenderTarget } from './rendering/renderers/shared/renderTarget/RenderTarget.mjs';\nexport { RenderTargetSystem } from './rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs';\nexport { viewportFromFrame } from './rendering/renderers/shared/renderTarget/viewportFromFrame.mjs';\nexport { ShaderStage } from './rendering/renderers/shared/shader/const.mjs';\nexport { Shader } from './rendering/renderers/shared/shader/Shader.mjs';\nexport { UboSystem } from './rendering/renderers/shared/shader/UboSystem.mjs';\nexport { UniformGroup } from './rendering/renderers/shared/shader/UniformGroup.mjs';\nexport { createUboSyncFunction } from './rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs';\nexport { getDefaultUniformValue } from './rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs';\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL } from './rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs';\nexport { uniformParsers } from './rendering/renderers/shared/shader/utils/uniformParsers.mjs';\nexport { HelloSystem } from './rendering/renderers/shared/startup/HelloSystem.mjs';\nexport { BLEND_TO_NPM, STENCIL_MODES } from './rendering/renderers/shared/state/const.mjs';\nexport { getAdjustedBlendModeBlend } from './rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nexport { State } from './rendering/renderers/shared/state/State.mjs';\nexport { AbstractRenderer } from './rendering/renderers/shared/system/AbstractRenderer.mjs';\nexport { SharedRenderPipes, SharedSystems } from './rendering/renderers/shared/system/SharedSystems.mjs';\nexport { SystemRunner } from './rendering/renderers/shared/system/SystemRunner.mjs';\nexport { CanvasPool, CanvasPoolClass } from './rendering/renderers/shared/texture/CanvasPool.mjs';\nexport { DEPRECATED_SCALE_MODES, DEPRECATED_WRAP_MODES, MSAA_QUALITY, SCALE_MODES, WRAP_MODES } from './rendering/renderers/shared/texture/const.mjs';\nexport { RenderTexture } from './rendering/renderers/shared/texture/RenderTexture.mjs';\nexport { BufferImageSource } from './rendering/renderers/shared/texture/sources/BufferSource.mjs';\nexport { CanvasSource } from './rendering/renderers/shared/texture/sources/CanvasSource.mjs';\nexport { CompressedSource } from './rendering/renderers/shared/texture/sources/CompressedSource.mjs';\nexport { ImageSource } from './rendering/renderers/shared/texture/sources/ImageSource.mjs';\nexport { TextureSource } from './rendering/renderers/shared/texture/sources/TextureSource.mjs';\nexport { VideoSource } from './rendering/renderers/shared/texture/sources/VideoSource.mjs';\nexport { Texture } from './rendering/renderers/shared/texture/Texture.mjs';\nexport { TextureGCSystem } from './rendering/renderers/shared/texture/TextureGCSystem.mjs';\nexport { TextureMatrix } from './rendering/renderers/shared/texture/TextureMatrix.mjs';\nexport { TexturePool, TexturePoolClass } from './rendering/renderers/shared/texture/TexturePool.mjs';\nexport { TextureStyle } from './rendering/renderers/shared/texture/TextureStyle.mjs';\nexport { TextureUvs } from './rendering/renderers/shared/texture/TextureUvs.mjs';\nexport { generateUID } from './rendering/renderers/shared/texture/utils/generateUID.mjs';\nexport { getCanvasTexture, hasCachedCanvasTexture } from './rendering/renderers/shared/texture/utils/getCanvasTexture.mjs';\nexport { getSupportedCompressedTextureFormats } from './rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs';\nexport { getSupportedTextureFormats, nonCompressedFormats } from './rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs';\nexport { autoDetectSource, resourceToTexture, textureFrom } from './rendering/renderers/shared/texture/utils/textureFrom.mjs';\nexport { createIdFromString } from './rendering/renderers/shared/utils/createIdFromString.mjs';\nexport { parseFunctionBody } from './rendering/renderers/shared/utils/parseFunctionBody.mjs';\nexport { ViewSystem } from './rendering/renderers/shared/view/ViewSystem.mjs';\nexport { RendererType } from './rendering/renderers/types.mjs';\nexport { Bounds } from './scene/container/bounds/Bounds.mjs';\nexport { _getGlobalBoundsRecursive, getFastGlobalBounds } from './scene/container/bounds/getFastGlobalBounds.mjs';\nexport { _getGlobalBounds, getGlobalBounds, updateTransformBackwards } from './scene/container/bounds/getGlobalBounds.mjs';\nexport { getLocalBounds, getParent } from './scene/container/bounds/getLocalBounds.mjs';\nexport { getGlobalRenderableBounds } from './scene/container/bounds/getRenderableBounds.mjs';\nexport { boundsPool, matrixPool } from './scene/container/bounds/utils/matrixAndBoundsPool.mjs';\nexport { childrenHelperMixin } from './scene/container/container-mixins/childrenHelperMixin.mjs';\nexport { effectsMixin } from './scene/container/container-mixins/effectsMixin.mjs';\nexport { findMixin } from './scene/container/container-mixins/findMixin.mjs';\nexport { measureMixin } from './scene/container/container-mixins/measureMixin.mjs';\nexport { onRenderMixin } from './scene/container/container-mixins/onRenderMixin.mjs';\nexport { sortMixin } from './scene/container/container-mixins/sortMixin.mjs';\nexport { toLocalGlobalMixin } from './scene/container/container-mixins/toLocalGlobalMixin.mjs';\nexport { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_TRANSFORM, UPDATE_VISIBLE } from './scene/container/Container.mjs';\nexport { CustomRenderPipe } from './scene/container/CustomRenderPipe.mjs';\nexport { RenderContainer } from './scene/container/RenderContainer.mjs';\nexport { RenderGroup } from './scene/container/RenderGroup.mjs';\nexport { RenderGroupPipe } from './scene/container/RenderGroupPipe.mjs';\nexport { RenderGroupSystem } from './scene/container/RenderGroupSystem.mjs';\nexport { assignWithIgnore } from './scene/container/utils/assignWithIgnore.mjs';\nexport { buildInstructions, collectAllRenderables } from './scene/container/utils/buildInstructions.mjs';\nexport { checkChildrenDidChange } from './scene/container/utils/checkChildrenDidChange.mjs';\nexport { collectRenderGroups } from './scene/container/utils/collectRenderGroups.mjs';\nexport { definedProps } from './scene/container/utils/definedProps.mjs';\nexport { executeInstructions } from './scene/container/utils/executeInstructions.mjs';\nexport { mixColors, mixStandardAnd32BitColors } from './scene/container/utils/mixColors.mjs';\nexport { mixHexColors } from './scene/container/utils/mixHexColors.mjs';\nexport { multiplyHexColors } from './scene/container/utils/multiplyHexColors.mjs';\nexport { updateLocalTransform } from './scene/container/utils/updateLocalTransform.mjs';\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren } from './scene/container/utils/updateRenderGroupTransforms.mjs';\nexport { updateWorldTransform } from './scene/container/utils/updateWorldTransform.mjs';\nexport { validateRenderables } from './scene/container/utils/validateRenderables.mjs';\nexport { GlGraphicsAdaptor } from './scene/graphics/gl/GlGraphicsAdaptor.mjs';\nexport { color32BitToUniform, colorToUniform } from './scene/graphics/gpu/colorToUniform.mjs';\nexport { GpuGraphicsAdaptor } from './scene/graphics/gpu/GpuGraphicsAdaptor.mjs';\nexport { BatchableGraphics } from './scene/graphics/shared/BatchableGraphics.mjs';\nexport { buildAdaptiveBezier } from './scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs';\nexport { buildAdaptiveQuadratic } from './scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs';\nexport { buildArc } from './scene/graphics/shared/buildCommands/buildArc.mjs';\nexport { buildArcTo } from './scene/graphics/shared/buildCommands/buildArcTo.mjs';\nexport { buildArcToSvg } from './scene/graphics/shared/buildCommands/buildArcToSvg.mjs';\nexport { buildCircle } from './scene/graphics/shared/buildCommands/buildCircle.mjs';\nexport { buildLine } from './scene/graphics/shared/buildCommands/buildLine.mjs';\nexport { buildPolygon } from './scene/graphics/shared/buildCommands/buildPolygon.mjs';\nexport { buildRectangle } from './scene/graphics/shared/buildCommands/buildRectangle.mjs';\nexport { buildTriangle } from './scene/graphics/shared/buildCommands/buildTriangle.mjs';\nexport { closePointEps, curveEps } from './scene/graphics/shared/const.mjs';\nexport { FillGradient } from './scene/graphics/shared/fill/FillGradient.mjs';\nexport { FillPattern } from './scene/graphics/shared/fill/FillPattern.mjs';\nexport { Graphics } from './scene/graphics/shared/Graphics.mjs';\nexport { GraphicsContext } from './scene/graphics/shared/GraphicsContext.mjs';\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem } from './scene/graphics/shared/GraphicsContextSystem.mjs';\nexport { GraphicsPipe } from './scene/graphics/shared/GraphicsPipe.mjs';\nexport { GraphicsPath } from './scene/graphics/shared/path/GraphicsPath.mjs';\nexport { roundedShapeArc, roundedShapeQuadraticCurve } from './scene/graphics/shared/path/roundShape.mjs';\nexport { ShapePath } from './scene/graphics/shared/path/ShapePath.mjs';\nexport { SVGParser } from './scene/graphics/shared/svg/SVGParser.mjs';\nexport { SVGToGraphicsPath } from './scene/graphics/shared/svg/SVGToGraphicsPath.mjs';\nexport { buildContextBatches } from './scene/graphics/shared/utils/buildContextBatches.mjs';\nexport { buildGeometryFromPath } from './scene/graphics/shared/utils/buildGeometryFromPath.mjs';\nexport { convertFillInputToFillStyle } from './scene/graphics/shared/utils/convertFillInputToFillStyle.mjs';\nexport { getOrientationOfPoints } from './scene/graphics/shared/utils/getOrientationOfPoints.mjs';\nexport { triangulateWithHoles } from './scene/graphics/shared/utils/triangulateWithHoles.mjs';\nexport { MeshPlane } from './scene/mesh-plane/MeshPlane.mjs';\nexport { PlaneGeometry } from './scene/mesh-plane/PlaneGeometry.mjs';\nexport { MeshRope } from './scene/mesh-simple/MeshRope.mjs';\nexport { MeshSimple } from './scene/mesh-simple/MeshSimple.mjs';\nexport { RopeGeometry } from './scene/mesh-simple/RopeGeometry.mjs';\nexport { GlMeshAdaptor } from './scene/mesh/gl/GlMeshAdaptor.mjs';\nexport { GpuMeshAdapter } from './scene/mesh/gpu/GpuMeshAdapter.mjs';\nexport { BatchableMesh } from './scene/mesh/shared/BatchableMesh.mjs';\nexport { getTextureDefaultMatrix } from './scene/mesh/shared/getTextureDefaultMatrix.mjs';\nexport { Mesh } from './scene/mesh/shared/Mesh.mjs';\nexport { MeshGeometry } from './scene/mesh/shared/MeshGeometry.mjs';\nexport { MeshPipe } from './scene/mesh/shared/MeshPipe.mjs';\nexport { AnimatedSprite } from './scene/sprite-animated/AnimatedSprite.mjs';\nexport { NineSliceGeometry } from './scene/sprite-nine-slice/NineSliceGeometry.mjs';\nexport { NineSlicePlane, NineSliceSprite } from './scene/sprite-nine-slice/NineSliceSprite.mjs';\nexport { NineSliceSpritePipe } from './scene/sprite-nine-slice/NineSliceSpritePipe.mjs';\nexport { tilingBit, tilingBitGl } from './scene/sprite-tiling/shader/tilingBit.mjs';\nexport { TilingSpriteShader } from './scene/sprite-tiling/shader/TilingSpriteShader.mjs';\nexport { TilingSprite } from './scene/sprite-tiling/TilingSprite.mjs';\nexport { TilingSpritePipe } from './scene/sprite-tiling/TilingSpritePipe.mjs';\nexport { applyMatrix } from './scene/sprite-tiling/utils/applyMatrix.mjs';\nexport { QuadGeometry } from './scene/sprite-tiling/utils/QuadGeometry.mjs';\nexport { setPositions } from './scene/sprite-tiling/utils/setPositions.mjs';\nexport { setUvs } from './scene/sprite-tiling/utils/setUvs.mjs';\nexport { BatchableSprite } from './scene/sprite/BatchableSprite.mjs';\nexport { Sprite } from './scene/sprite/Sprite.mjs';\nexport { SpritePipe } from './scene/sprite/SpritePipe.mjs';\nexport { AbstractBitmapFont } from './scene/text-bitmap/AbstractBitmapFont.mjs';\nexport { bitmapFontTextParser } from './scene/text-bitmap/asset/bitmapFontTextParser.mjs';\nexport { bitmapFontXMLParser } from './scene/text-bitmap/asset/bitmapFontXMLParser.mjs';\nexport { bitmapFontXMLStringParser } from './scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs';\nexport { bitmapFontCachePlugin, loadBitmapFont } from './scene/text-bitmap/asset/loadBitmapFont.mjs';\nexport { BitmapFont } from './scene/text-bitmap/BitmapFont.mjs';\nexport { BitmapFontManager } from './scene/text-bitmap/BitmapFontManager.mjs';\nexport { BitmapText } from './scene/text-bitmap/BitmapText.mjs';\nexport { BitmapTextPipe } from './scene/text-bitmap/BitmapTextPipe.mjs';\nexport { DynamicBitmapFont } from './scene/text-bitmap/DynamicBitmapFont.mjs';\nexport { getBitmapTextLayout } from './scene/text-bitmap/utils/getBitmapTextLayout.mjs';\nexport { resolveCharacters } from './scene/text-bitmap/utils/resolveCharacters.mjs';\nexport { HTMLText } from './scene/text-html/HTMLText.mjs';\nexport { HTMLTextPipe } from './scene/text-html/HTMLTextPipe.mjs';\nexport { HTMLTextRenderData, nssvg, nsxhtml } from './scene/text-html/HTMLTextRenderData.mjs';\nexport { HTMLTextStyle } from './scene/text-html/HtmlTextStyle.mjs';\nexport { HTMLTextSystem } from './scene/text-html/HTMLTextSystem.mjs';\nexport { extractFontFamilies } from './scene/text-html/utils/extractFontFamilies.mjs';\nexport { FontStylePromiseCache, getFontCss } from './scene/text-html/utils/getFontCss.mjs';\nexport { getSVGUrl } from './scene/text-html/utils/getSVGUrl.mjs';\nexport { getTemporaryCanvasFromImage } from './scene/text-html/utils/getTemporaryCanvasFromImage.mjs';\nexport { loadFontAsBase64 } from './scene/text-html/utils/loadFontAsBase64.mjs';\nexport { loadFontCSS } from './scene/text-html/utils/loadFontCSS.mjs';\nexport { loadSVGImage } from './scene/text-html/utils/loadSVGImage.mjs';\nexport { measureHtmlText } from './scene/text-html/utils/measureHtmlText.mjs';\nexport { textStyleToCSS } from './scene/text-html/utils/textStyleToCSS.mjs';\nexport { AbstractText, ensureOptions } from './scene/text/AbstractText.mjs';\nexport { CanvasTextMetrics } from './scene/text/canvas/CanvasTextMetrics.mjs';\nexport { CanvasTextPipe } from './scene/text/canvas/CanvasTextPipe.mjs';\nexport { CanvasTextSystem } from './scene/text/canvas/CanvasTextSystem.mjs';\nexport { fontStringFromTextStyle } from './scene/text/canvas/utils/fontStringFromTextStyle.mjs';\nexport { getCanvasFillStyle } from './scene/text/canvas/utils/getCanvasFillStyle.mjs';\nexport { SdfShader } from './scene/text/sdfShader/SdfShader.mjs';\nexport { localUniformMSDFBit, localUniformMSDFBitGl } from './scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs';\nexport { mSDFBit, mSDFBitGl } from './scene/text/sdfShader/shader-bits/mSDFBit.mjs';\nexport { Text } from './scene/text/Text.mjs';\nexport { TextStyle } from './scene/text/TextStyle.mjs';\nexport { ensureTextStyle } from './scene/text/utils/ensureTextStyle.mjs';\nexport { generateTextStyleKey } from './scene/text/utils/generateTextStyleKey.mjs';\nexport { getPo2TextureFromSource } from './scene/text/utils/getPo2TextureFromSource.mjs';\nexport { Spritesheet } from './spritesheet/Spritesheet.mjs';\nexport { spritesheetAsset } from './spritesheet/spritesheetAsset.mjs';\nexport { UPDATE_PRIORITY } from './ticker/const.mjs';\nexport { Ticker } from './ticker/Ticker.mjs';\nexport { TickerListener } from './ticker/TickerListener.mjs';\nexport { detectVideoAlphaMode } from './utils/browser/detectVideoAlphaMode.mjs';\nexport { isMobile } from './utils/browser/isMobile.mjs';\nexport { isSafari } from './utils/browser/isSafari.mjs';\nexport { isWebGLSupported } from './utils/browser/isWebGLSupported.mjs';\nexport { isWebGPUSupported } from './utils/browser/isWebGPUSupported.mjs';\nexport { unsafeEvalSupported } from './utils/browser/unsafeEvalSupported.mjs';\nexport { getCanvasBoundingBox } from './utils/canvas/getCanvasBoundingBox.mjs';\nexport { DATA_URI } from './utils/const.mjs';\nexport { default as EventEmitter } from 'eventemitter3';\nexport { removeItems } from './utils/data/removeItems.mjs';\nexport { resetUids, uid } from './utils/data/uid.mjs';\nexport { updateQuadBounds } from './utils/data/updateQuadBounds.mjs';\nexport { ViewableBuffer } from './utils/data/ViewableBuffer.mjs';\nexport { deprecation, v8_0_0 } from './utils/logging/deprecation.mjs';\nexport { logDebugTexture } from './utils/logging/logDebugTexture.mjs';\nexport { logRenderGroupScene, logScene } from './utils/logging/logScene.mjs';\nexport { warn } from './utils/logging/warn.mjs';\nexport { NOOP } from './utils/misc/NOOP.mjs';\nexport { Transform } from './utils/misc/Transform.mjs';\nexport { getResolutionOfUrl } from './utils/network/getResolutionOfUrl.mjs';\nexport { path } from './utils/path.mjs';\nexport { Pool } from './utils/pool/Pool.mjs';\nexport { BigPool, PoolGroupClass } from './utils/pool/PoolGroup.mjs';\nexport { VERSION, sayHello } from './utils/sayHello.mjs';\nexport { default as earcut } from 'earcut';\n\n\"use strict\";\nextensions.add(browserExt, webworkerExt);\n\nexport { browserExt, extensions, webworkerExt };\n//# sourceMappingURL=index.mjs.map\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck - we dynamically create the other index files, so these will throw errors if we don't ignore them\n\nimport { browserExt } from './environment-browser/browserExt';\nimport { webworkerExt } from './environment-webworker/webworkerExt';\nimport { extensions } from './extensions/Extensions';\nimport './rendering/init';\nimport './spritesheet/init';\n\nexport * from './accessibility';\nexport * from './advanced-blend-modes';\nexport * from './app';\nexport * from './assets';\nexport * from './color';\nexport * from './compressed-textures';\nexport * from './culling';\nexport * from './environment';\nexport * from './environment-browser';\nexport * from './environment-webworker';\nexport * from './events';\nexport * from './extensions';\nexport * from './filters';\nexport * from './maths';\nexport * from './prepare';\nexport * from './rendering';\nexport * from './scene';\nexport * from './spritesheet';\nexport * from './ticker';\nexport * from './utils';\n\nextensions.add(browserExt, webworkerExt);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst browserExt = {\n  extension: {\n    type: ExtensionType.Environment,\n    name: \"browser\",\n    priority: -1\n  },\n  test: () => true,\n  load: async () => {\n    await import('./browserAll.mjs');\n  }\n};\n\nexport { browserExt };\n//# sourceMappingURL=browserExt.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the browser environment.\n * @memberof environment\n */\nexport const browserExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'browser',\n        priority: -1,\n    },\n    test: () => true,\n    load: async () =>\n    {\n        await import('./browserAll');\n    },\n};\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst webworkerExt = {\n  extension: {\n    type: ExtensionType.Environment,\n    name: \"webworker\",\n    priority: 0\n  },\n  test: () => typeof self !== \"undefined\" && self.WorkerGlobalScope !== void 0,\n  load: async () => {\n    await import('./webworkerAll.mjs');\n  }\n};\n\nexport { webworkerExt };\n//# sourceMappingURL=webworkerExt.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the webworker environment.\n * @memberof environment\n */\nexport const webworkerExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'webworker',\n        priority: 0,\n    },\n    test: () => typeof self !== 'undefined' && self.WorkerGlobalScope !== undefined,\n    load: async () =>\n    {\n        await import('./webworkerAll');\n    },\n};\n","import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\nimport { autoDetectRenderer } from '../rendering/renderers/autoDetectRenderer.mjs';\nimport { Container } from '../scene/container/Container.mjs';\nimport { deprecation, v8_0_0 } from '../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _Application = class _Application {\n  /** @ignore */\n  constructor(...args) {\n    /** The root display container that's rendered. */\n    this.stage = new Container();\n    if (args[0] !== void 0) {\n      deprecation(v8_0_0, \"Application constructor options are deprecated, please use Application.init() instead.\");\n    }\n  }\n  /**\n   * @param options - The optional application and renderer parameters.\n   */\n  async init(options) {\n    options = { ...options };\n    this.renderer = await autoDetectRenderer(options);\n    _Application._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  /** Render the current stage. */\n  render() {\n    this.renderer.render({ container: this.stage });\n  }\n  /**\n   * Reference to the renderer's canvas element.\n   * @readonly\n   * @member {HTMLCanvasElement}\n   */\n  get canvas() {\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer's canvas element.\n   * @member {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   */\n  get view() {\n    deprecation(v8_0_0, \"Application.view is deprecated, please use Application.canvas instead.\");\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @readonly\n   */\n  get screen() {\n    return this.renderer.screen;\n  }\n  /**\n   * Destroys the application and all of its resources.\n   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n   * @param {object|boolean} [options=false] - The options for destroying the stage.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n   * called as well. `options` will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true,\n   * it should destroy the texture of the child sprite.\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   *  If options.children is set to true,\n   * it should destroy the texture source of the child sprite.\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true,\n   * it should destroy the context of the child graphics.\n   */\n  destroy(rendererDestroyOptions = false, options = false) {\n    const plugins = _Application._plugins.slice(0);\n    plugins.reverse();\n    plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    });\n    this.stage.destroy(options);\n    this.stage = null;\n    this.renderer.destroy(rendererDestroyOptions);\n    this.renderer = null;\n  }\n};\n/**\n * Collection of installed plugins.\n * @alias _plugins\n */\n_Application._plugins = [];\nlet Application = _Application;\nextensions.handleByList(ExtensionType.Application, Application._plugins);\n\nexport { Application };\n//# sourceMappingURL=Application.mjs.map\n","import { extensions, ExtensionType } from '../extensions/Extensions';\nimport { autoDetectRenderer } from '../rendering/renderers/autoDetectRenderer';\nimport { Container } from '../scene/container/Container';\nimport { deprecation, v8_0_0 } from '../utils/logging/deprecation';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { AutoDetectOptions } from '../rendering/renderers/autoDetectRenderer';\nimport type { RendererDestroyOptions } from '../rendering/renderers/shared/system/AbstractRenderer';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { DestroyOptions } from '../scene/container/destroyTypes';\n\n/**\n * The app module provides a set of classes to use as a starting point when building applications.\n *\n * <aside>This module has a mixin for <code>TickerPlugin</code> and <code>ResizePlugin</code>.\n * These will need to be imported if you are managing your own renderer.</aside>\n *\n * ```js\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * await app.init();\n *\n * // don't forget to add the canvas to the DOM\n * document.body.appendChild(app.canvas);\n * ```\n * @namespace app\n */\n\n/**\n * Any plugin that's usable for Application should contain these methods.\n * @example\n * import { ApplicationPlugin } from 'pixi.js';\n *\n * const plugin: ApplicationPlugin = {\n *    init: (options: Partial<ApplicationOptions>) =>\n *    {\n *       // handle init here, use app options if needed\n *    },\n *    destroy: () =>\n *    {\n *       // handle destruction code here\n *    }\n * }\n * @memberof app\n * @see {@link app.ApplicationOptions}\n * @ignore\n */\nexport interface ApplicationPlugin\n{\n    /**\n     * Called when Application is constructed, scoped to Application instance.\n     * Passes in `options` as the only argument, which are Application `init()` options.\n     * @param {object} options - Application options.\n     */\n    init(options: Partial<ApplicationOptions>): void;\n    /** Called when destroying Application, scoped to Application instance. */\n    destroy(): void;\n}\n\n/**\n * Application options supplied to the {@link app.Application#init} method.\n * @memberof app\n * @example\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * await app.init({\n *    autoStart: false,\n *    resizeTo: window,\n *    sharedTicker: true,\n * });\n */\nexport interface ApplicationOptions extends AutoDetectOptions, PixiMixins.ApplicationOptions { }\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Application extends PixiMixins.Application { }\n\n/**\n * Convenience class to create a new PixiJS application.\n *\n * This class automatically creates the renderer, ticker and root container.\n * @example\n * import { Application, Sprite } from 'pixi.js';\n *\n * // Create the application\n * const app = new Application();\n *\n * await app.init({ width: 800, height: 600 });\n *\n * // Add the view to the DOM\n * document.body.appendChild(app.canvas);\n *\n * // ex, add display objects\n * app.stage.addChild(Sprite.from('something.png'));\n * @memberof app\n */\nexport class Application<R extends Renderer = Renderer>\n{\n    /**\n     * Collection of installed plugins.\n     * @alias _plugins\n     */\n    public static _plugins: ApplicationPlugin[] = [];\n\n    /** The root display container that's rendered. */\n    public stage: Container = new Container();\n\n    /**\n     * WebGL renderer if available, otherwise CanvasRenderer.\n     * @member {Renderer}\n     */\n    public renderer: R;\n\n    /** Create new Application instance */\n    constructor();\n\n    /** @deprecated since 8.0.0 */\n    constructor(options?: Partial<ApplicationOptions>);\n\n    /** @ignore */\n    constructor(...args: [Partial<ApplicationOptions>] | [])\n    {\n        // #if _DEBUG\n        if (args[0] !== undefined)\n        {\n            deprecation(v8_0_0, 'Application constructor options are deprecated, please use Application.init() instead.');\n        }\n        // #endif\n    }\n\n    /**\n     * @param options - The optional application and renderer parameters.\n     */\n    public async init(options?: Partial<ApplicationOptions>)\n    {\n        // The default options\n        options = { ...options };\n\n        this.renderer = await autoDetectRenderer(options as ApplicationOptions) as R;\n\n        // install plugins here\n        Application._plugins.forEach((plugin) =>\n        {\n            plugin.init.call(this, options);\n        });\n    }\n\n    /** Render the current stage. */\n    public render(): void\n    {\n        this.renderer.render({ container: this.stage });\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @readonly\n     * @member {HTMLCanvasElement}\n     */\n    get canvas(): R['canvas']\n    {\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @member {HTMLCanvasElement}\n     * @deprecated since 8.0.0\n     */\n    get view(): R['canvas']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Application.view is deprecated, please use Application.canvas instead.');\n        // #endif\n\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n     * @readonly\n     */\n    get screen(): Rectangle\n    {\n        return this.renderer.screen;\n    }\n\n    /**\n     * Destroys the application and all of its resources.\n     * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n     * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n     * @param {object|boolean} [options=false] - The options for destroying the stage.\n     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n     * called as well. `options` will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n     * If options.children is set to true,\n     * it should destroy the texture of the child sprite.\n     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n     *  If options.children is set to true,\n     * it should destroy the texture source of the child sprite.\n     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n     * If options.children is set to true,\n     * it should destroy the context of the child graphics.\n     */\n    public destroy(rendererDestroyOptions: RendererDestroyOptions = false, options: DestroyOptions = false): void\n    {\n        // Destroy plugins in the opposite order\n        // which they were constructed\n        const plugins = Application._plugins.slice(0);\n\n        plugins.reverse();\n        plugins.forEach((plugin) =>\n        {\n            plugin.destroy.call(this);\n        });\n\n        this.stage.destroy(options);\n        this.stage = null;\n\n        this.renderer.destroy(rendererDestroyOptions);\n        this.renderer = null;\n    }\n}\n\nextensions.handleByList(ExtensionType.Application, Application._plugins);\n","import { autoDetectEnvironment } from '../../environment/autoDetectEnvironment.mjs';\nimport { isWebGLSupported } from '../../utils/browser/isWebGLSupported.mjs';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported.mjs';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer.mjs';\n\n\"use strict\";\nconst renderPriority = [\"webgl\", \"webgpu\", \"canvas\"];\nasync function autoDetectRenderer(options) {\n  let preferredOrder = [];\n  if (options.preference) {\n    preferredOrder.push(options.preference);\n    renderPriority.forEach((item) => {\n      if (item !== options.preference) {\n        preferredOrder.push(item);\n      }\n    });\n  } else {\n    preferredOrder = renderPriority.slice();\n  }\n  let RendererClass;\n  await autoDetectEnvironment(\n    options.manageImports ?? true\n  );\n  let finalOptions = {};\n  for (let i = 0; i < preferredOrder.length; i++) {\n    const rendererType = preferredOrder[i];\n    if (rendererType === \"webgpu\" && await isWebGPUSupported()) {\n      const { WebGPURenderer } = await import('./gpu/WebGPURenderer.mjs');\n      RendererClass = WebGPURenderer;\n      finalOptions = { ...options, ...options.webgpu };\n      break;\n    } else if (rendererType === \"webgl\" && isWebGLSupported(\n      options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n    )) {\n      const { WebGLRenderer } = await import('./gl/WebGLRenderer.mjs');\n      RendererClass = WebGLRenderer;\n      finalOptions = { ...options, ...options.webgl };\n      break;\n    } else if (rendererType === \"canvas\") {\n      finalOptions = { ...options };\n      break;\n    }\n  }\n  delete finalOptions.webgpu;\n  delete finalOptions.webgl;\n  const renderer = new RendererClass();\n  await renderer.init(finalOptions);\n  return renderer;\n}\n\nexport { autoDetectRenderer };\n//# sourceMappingURL=autoDetectRenderer.mjs.map\n","import { autoDetectEnvironment } from '../../environment/autoDetectEnvironment';\nimport { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer';\n\nimport type { WebGLOptions } from './gl/WebGLRenderer';\nimport type { WebGPUOptions } from './gpu/WebGPURenderer';\nimport type { Renderer } from './types';\n\n/**\n * Options for {@link rendering.autoDetectRenderer}.\n * @memberof rendering\n */\nexport interface AutoDetectOptions extends WebGLOptions, WebGPUOptions\n{\n    /** The preferred renderer type. WebGPU is recommended as its generally faster than WebGL. */\n    preference?: 'webgl' | 'webgpu'// | 'canvas';\n    /**\n     * Whether to manage the dynamic imports of the renderer code. It is true by default, this means\n     * PixiJS will load all the default pixi systems and extensions. If you set this to false, then\n     * you as the dev will need to manually import the systems and extensions you need.\n     */\n    manageImports?: boolean;\n    /** Optional WebGPUOptions to pass only to WebGPU renderer. */\n    webgpu?: Partial<WebGPUOptions>;\n    /** Optional WebGLOptions to pass only to the WebGL renderer */\n    webgl?: Partial<WebGLOptions>;\n}\n\nconst renderPriority = ['webgl', 'webgpu', 'canvas'];\n\n/**\n * Automatically determines the most appropriate renderer for the current environment.\n *\n * The function will prioritize the WebGL renderer as it is the most tested safe API to use.\n * In the near future as WebGPU becomes more stable and ubiquitous, it will be prioritized over WebGL.\n *\n * The selected renderer's code is then dynamically imported to optimize\n * performance and minimize the initial bundle size.\n *\n * To maximize the benefits of dynamic imports, it's recommended to use a modern bundler\n * that supports code splitting. This will place the renderer code in a separate chunk,\n * which is loaded only when needed.\n * @example\n *\n * // create a renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   antialias: true,\n * });\n *\n * // custom for each renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   webgpu:{\n *     antialias: true,\n *     backgroundColor: 'red'\n *   },\n *   webgl:{\n *     antialias: true,\n *     backgroundColor: 'green'\n *   }\n *  });\n * @param options - A partial configuration object based on the `AutoDetectOptions` type.\n * @returns A Promise that resolves to an instance of the selected renderer.\n * @memberof rendering\n */\nexport async function autoDetectRenderer(options: Partial<AutoDetectOptions>): Promise<Renderer>\n{\n    let preferredOrder: string[] = [];\n\n    if (options.preference)\n    {\n        preferredOrder.push(options.preference);\n\n        renderPriority.forEach((item) =>\n        {\n            if (item !== options.preference)\n            {\n                preferredOrder.push(item);\n            }\n        });\n    }\n    else\n    {\n        preferredOrder = renderPriority.slice();\n    }\n\n    let RendererClass: new () => Renderer;\n\n    await autoDetectEnvironment(\n        options.manageImports ?? true,\n    );\n\n    let finalOptions: Partial<AutoDetectOptions> = {};\n\n    for (let i = 0; i < preferredOrder.length; i++)\n    {\n        const rendererType = preferredOrder[i];\n\n        if (rendererType === 'webgpu' && (await isWebGPUSupported()))\n        {\n            const { WebGPURenderer } = await import('./gpu/WebGPURenderer');\n\n            RendererClass = WebGPURenderer;\n\n            finalOptions = { ...options, ...options.webgpu };\n\n            break;\n        }\n        else if (\n            rendererType === 'webgl'\n            && isWebGLSupported(\n                options.failIfMajorPerformanceCaveat\n                    ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n            )\n        )\n        {\n            const { WebGLRenderer } = await import('./gl/WebGLRenderer');\n\n            RendererClass = WebGLRenderer;\n\n            finalOptions = { ...options, ...options.webgl };\n\n            break;\n        }\n        else if (rendererType === 'canvas')\n        {\n            finalOptions = { ...options };\n\n            break;\n        }\n    }\n\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n\n    const renderer = new RendererClass();\n\n    await renderer.init(finalOptions);\n\n    return renderer;\n}\n","import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst environments = [];\nextensions.handleByNamedList(ExtensionType.Environment, environments);\nasync function autoDetectEnvironment(manageImports) {\n  if (!manageImports)\n    return;\n  for (let i = 0; i < environments.length; i++) {\n    const env = environments[i];\n    if (env.value.test()) {\n      await env.value.load();\n      return;\n    }\n  }\n}\n\nexport { autoDetectEnvironment };\n//# sourceMappingURL=autoDetectEnvironment.mjs.map\n","import { extensions, ExtensionType } from '../extensions/Extensions';\n\nconst environments: { name: string; value: { test: () => boolean; load: () => Promise<boolean> } }[] = [];\n\nextensions.handleByNamedList(ExtensionType.Environment, environments);\n\n/**\n * Automatically detects the environment and loads the appropriate extensions.\n * @param manageImports - whether to add the default imports to the bundle\n * @memberof environment\n */\nexport async function autoDetectEnvironment(manageImports: boolean): Promise<void>\n{\n    if (!manageImports) return;\n\n    for (let i = 0; i < environments.length; i++)\n    {\n        const env = environments[i];\n\n        if (env.value.test())\n        {\n            await env.value.load();\n\n            return;\n        }\n    }\n}\n","import { DOMAdapter } from '../../environment/adapter.mjs';\nimport { AbstractRenderer } from '../../rendering/renderers/shared/system/AbstractRenderer.mjs';\n\n\"use strict\";\nlet _isWebGLSupported;\nfunction isWebGLSupported(failIfMajorPerformanceCaveat) {\n  if (_isWebGLSupported !== void 0)\n    return _isWebGLSupported;\n  _isWebGLSupported = (() => {\n    const contextOptions = {\n      stencil: true,\n      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n    };\n    try {\n      if (!DOMAdapter.get().getWebGLRenderingContext()) {\n        return false;\n      }\n      const canvas = DOMAdapter.get().createCanvas();\n      let gl = canvas.getContext(\"webgl\", contextOptions);\n      const success = !!gl?.getContextAttributes()?.stencil;\n      if (gl) {\n        const loseContext = gl.getExtension(\"WEBGL_lose_context\");\n        if (loseContext) {\n          loseContext.loseContext();\n        }\n      }\n      gl = null;\n      return success;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGLSupported;\n}\n\nexport { isWebGLSupported };\n//# sourceMappingURL=isWebGLSupported.mjs.map\n","import { DOMAdapter } from '../../environment/adapter';\nimport { AbstractRenderer } from '../../rendering/renderers/shared/system/AbstractRenderer';\n\nlet _isWebGLSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGL support.\n * @param failIfMajorPerformanceCaveat - whether to fail if there is a major performance caveat, defaults to false\n * @memberof utils\n * @function isWebGLSupported\n * @returns {boolean} Is WebGL supported.\n */\nexport function isWebGLSupported(\n    failIfMajorPerformanceCaveat?: boolean\n): boolean\n{\n    if (_isWebGLSupported !== undefined) return _isWebGLSupported;\n\n    _isWebGLSupported = ((): boolean =>\n    {\n        const contextOptions = {\n            stencil: true,\n            failIfMajorPerformanceCaveat:\n                failIfMajorPerformanceCaveat\n                ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat,\n        };\n\n        try\n        {\n            if (!DOMAdapter.get().getWebGLRenderingContext())\n            {\n                return false;\n            }\n\n            const canvas = DOMAdapter.get().createCanvas();\n            let gl = canvas.getContext('webgl', contextOptions);\n\n            const success = !!gl?.getContextAttributes()?.stencil;\n\n            if (gl)\n            {\n                const loseContext = gl.getExtension('WEBGL_lose_context');\n\n                if (loseContext)\n                {\n                    loseContext.loseContext();\n                }\n            }\n\n            gl = null;\n\n            return success;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGLSupported;\n}\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nlet _isWebGPUSupported;\nasync function isWebGPUSupported(options = {}) {\n  if (_isWebGPUSupported !== void 0)\n    return _isWebGPUSupported;\n  _isWebGPUSupported = await (async () => {\n    const gpu = DOMAdapter.get().getNavigator().gpu;\n    if (!gpu) {\n      return false;\n    }\n    try {\n      const adapter = await navigator.gpu.requestAdapter(options);\n      await adapter.requestDevice();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGPUSupported;\n}\n\nexport { isWebGPUSupported };\n//# sourceMappingURL=isWebGPUSupported.mjs.map\n","import { DOMAdapter } from '../../environment/adapter';\n\nlet _isWebGPUSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGPU support.\n * @param options - The options for requesting a GPU adapter.\n * @memberof utils\n * @function isWebGPUSupported\n * @returns Is WebGPU supported.\n */\nexport async function isWebGPUSupported(options: GPURequestAdapterOptions = {}): Promise<boolean>\n{\n    if (_isWebGPUSupported !== undefined) return _isWebGPUSupported;\n\n    _isWebGPUSupported = await (async (): Promise<boolean> =>\n    {\n        const gpu = DOMAdapter.get().getNavigator().gpu;\n\n        if (!gpu)\n        {\n            return false;\n        }\n\n        try\n        {\n            const adapter = await navigator.gpu.requestAdapter(options) as GPUAdapter;\n\n            // TODO and one of these!\n            await adapter.requestDevice();\n\n            return true;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGPUSupported;\n}\n","import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\nimport { BackgroundLoader } from './BackgroundLoader.mjs';\nimport { Cache } from './cache/Cache.mjs';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray.mjs';\nimport { detectAvif } from './detections/parsers/detectAvif.mjs';\nimport { detectDefaults } from './detections/parsers/detectDefaults.mjs';\nimport { detectMp4 } from './detections/parsers/detectMp4.mjs';\nimport { detectOgv } from './detections/parsers/detectOgv.mjs';\nimport { detectWebm } from './detections/parsers/detectWebm.mjs';\nimport { detectWebp } from './detections/parsers/detectWebp.mjs';\nimport { Loader } from './loader/Loader.mjs';\nimport { loadJson } from './loader/parsers/loadJson.mjs';\nimport { loadTxt } from './loader/parsers/loadTxt.mjs';\nimport { loadWebFont } from './loader/parsers/loadWebFont.mjs';\nimport { loadSvg } from './loader/parsers/textures/loadSVG.mjs';\nimport { loadTextures } from './loader/parsers/textures/loadTextures.mjs';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures.mjs';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl.mjs';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl.mjs';\nimport { Resolver } from './resolver/Resolver.mjs';\nimport { convertToList } from './utils/convertToList.mjs';\nimport { isSingleItem } from './utils/isSingleItem.mjs';\n\n\"use strict\";\nclass AssetsClass {\n  constructor() {\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver();\n    this.loader = new Loader();\n    this.cache = Cache;\n    this._backgroundLoader = new BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Assets manager with\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      warn(\"[Assets]AssetManager already initialized, did you load before calling this Assets.init()?\");\n      return;\n    }\n    this._initialized = true;\n    if (options.defaultSearchParams) {\n      this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n    }\n    if (options.basePath) {\n      this.resolver.basePath = options.basePath;\n    }\n    if (options.bundleIdentifier) {\n      this.resolver.setBundleIdentifier(options.bundleIdentifier);\n    }\n    if (options.manifest) {\n      let manifest = options.manifest;\n      if (typeof manifest === \"string\") {\n        manifest = await this.load(manifest);\n      }\n      this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1;\n    const resolution = typeof resolutionPref === \"number\" ? [resolutionPref] : resolutionPref;\n    const formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    });\n    if (options.preferences) {\n      this.setPreferences(options.preferences);\n    }\n  }\n  /**\n   * Allows you to specify how to resolve any assets load requests.\n   * There are a few ways to add things here as shown below:\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Simple\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n   * const bunny = await Assets.load('bunnyBooBoo');\n   *\n   * // Multiple keys:\n   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n   *\n   * const bunny = await Assets.load('burger');\n   * const bunny2 = await Assets.load('chicken');\n   *\n   * // passing options to to the object\n   * Assets.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * // Multiple assets\n   *\n   * // The following all do the same thing:\n   *\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});\n   *\n   * Assets.add({\n   *     alias: 'bunnyBooBoo',\n   *     src: [\n   *         'bunny.png',\n   *         'bunny.webp',\n   *    ],\n   * });\n   *\n   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n   * @param assets - the unresolved assets to add to the resolver\n   */\n  add(assets) {\n    this.resolver.add(assets);\n  }\n  async load(urls, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const singleAsset = isSingleItem(urls);\n    const urlArray = convertToList(urls).map((url) => {\n      if (typeof url !== \"string\") {\n        const aliases = this.resolver.getAlias(url);\n        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {\n          this.add(url);\n        }\n        return Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      if (!this.resolver.hasKey(url))\n        this.add({ alias: url, src: url });\n      return url;\n    });\n    const resolveResults = this.resolver.resolve(urlArray);\n    const out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * Assets.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const assets = await Assets.loadBundle('animals');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle('load-screen');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle('game-screen');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */\n  async loadBundle(bundleIds, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    let singleAsset = false;\n    if (typeof bundleIds === \"string\") {\n      singleAsset = true;\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const out = {};\n    const keys = Object.keys(resolveResults);\n    let count = 0;\n    let total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    };\n    const promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      total += Object.keys(resolveResult).length;\n      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    await Promise.all(promises);\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your inital load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.backgroundLoad('bunny.png');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */\n  async backgroundLoad(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof urls === \"string\") {\n      urls = [urls];\n    }\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: 'load-screen',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle('load-screen');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */\n  async backgroundLoadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof bundleIds === \"string\") {\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */\n  reset() {\n    this.resolver.reset();\n    this.loader.reset();\n    this.cache.reset();\n    this._initialized = false;\n  }\n  get(keys) {\n    if (typeof keys === \"string\") {\n      return Cache.get(keys);\n    }\n    const assets = {};\n    for (let i = 0; i < keys.length; i++) {\n      assets[i] = Cache.get(keys[i]);\n    }\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = [...new Set(Object.values(resolveResults))];\n    this._backgroundLoader.active = false;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = true;\n    const out = {};\n    resolveArray.forEach((resolveResult) => {\n      const asset = loadedAssets[resolveResult.src];\n      const keys = [resolveResult.src];\n      if (resolveResult.alias) {\n        keys.push(...resolveResult.alias);\n      }\n      keys.forEach((key) => {\n        out[key] = asset;\n      });\n      Cache.set(keys, asset);\n    });\n    return out;\n  }\n  /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n   *\n   * await Assets.unload('http://some.url.com/image.png')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload(['thumper', 'chicko']);\n   * @param urls - the urls to unload\n   */\n  async unload(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const urlArray = convertToList(urls).map((url) => typeof url !== \"string\" ? url.src : url);\n    const resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle({\n   *     'thumper': 'http://some.url.com/thumper.png',\n   * })\n   *\n   * const assets = await Assets.loadBundle('thumper');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle('thumper');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */\n  async unloadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    bundleIds = convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache.remove(resolveResult2.src);\n    });\n    await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    if (options.preferredFormats) {\n      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];\n    }\n    for (const detection of options.detections) {\n      if (options.skipDetections || await detection.test()) {\n        formats = await detection.add(formats);\n      } else if (!options.skipDetections) {\n        formats = await detection.remove(formats);\n      }\n    }\n    formats = formats.filter((format, index) => formats.indexOf(format) === index);\n    return formats;\n  }\n  /** All the detection parsers currently added to the Assets class. */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      if (!parser.config)\n        return;\n      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nextensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n  cacheTextureArray,\n  detectDefaults,\n  detectAvif,\n  detectWebp,\n  detectMp4,\n  detectOgv,\n  detectWebm,\n  loadJson,\n  loadTxt,\n  loadWebFont,\n  loadSvg,\n  loadTextures,\n  loadVideoTextures,\n  resolveTextureUrl,\n  resolveJsonUrl\n);\nconst assetKeyMap = {\n  loader: ExtensionType.LoadParser,\n  resolver: ExtensionType.ResolveParser,\n  cache: ExtensionType.CacheParser,\n  detection: ExtensionType.DetectionParser\n};\nextensions.handle(ExtensionType.Asset, (extension) => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(\n    ref[key],\n    // Allow the function to optionally define it's own\n    // ExtensionMetadata, the use cases here is priority for LoaderParsers\n    { extension: ref[key].extension ?? type }\n  )));\n}, (extension) => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));\n});\n\nexport { Assets, AssetsClass };\n//# sourceMappingURL=Assets.mjs.map\n","/* eslint-disable max-len */\nimport { extensions, ExtensionType } from '../extensions/Extensions';\nimport { warn } from '../utils/logging/warn';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray';\nimport { detectAvif } from './detections/parsers/detectAvif';\nimport { detectDefaults } from './detections/parsers/detectDefaults';\nimport { detectMp4 } from './detections/parsers/detectMp4';\nimport { detectOgv } from './detections/parsers/detectOgv';\nimport { detectWebm } from './detections/parsers/detectWebm';\nimport { detectWebp } from './detections/parsers/detectWebp';\nimport { Loader } from './loader/Loader';\nimport { loadJson } from './loader/parsers/loadJson';\nimport { loadTxt } from './loader/parsers/loadTxt';\nimport { loadWebFont } from './loader/parsers/loadWebFont';\nimport { loadSvg } from './loader/parsers/textures/loadSVG';\nimport { type LoadTextureConfig, loadTextures } from './loader/parsers/textures/loadTextures';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nimport type { AssetExtension } from './AssetExtension';\nimport type { FormatDetectionParser } from './detections/types';\nimport type { LoadSVGConfig } from './loader/parsers/textures/loadSVG';\nimport type { BundleIdentifierOptions } from './resolver/Resolver';\nimport type { ArrayOr, AssetsBundle, AssetsManifest, ResolvedAsset, UnresolvedAsset } from './types';\n\n/**\n * Callback for when progress on asset loading is made.\n * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n * of the assets loaded.\n * @memberof assets\n * @callback ProgressCallback\n * @param {number} progress - The percentage (0.0 - 1.0) of the assets loaded.\n * @returns {void}\n * @example\n * (progress) => console.log(progress * 100 + '%')\n */\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Extensible preferences that can be used, for instance, when configuring loaders.\n * @since 7.2.0\n * @memberof assets\n */\nexport interface AssetsPreferences extends LoadTextureConfig, LoadSVGConfig, PixiMixins.AssetsPreferences {}\n\n/**\n * Initialization options object for the Assets Class.\n * @memberof assets\n */\nexport interface AssetInitOptions\n{\n    // basic...\n    /** a base path for any assets loaded */\n    basePath?: string;\n\n    /** a default URL parameter string to append to all assets loaded */\n    defaultSearchParams?: string | Record<string, any>;\n\n    /**\n     * a manifest to tell the asset loader upfront what all your assets are\n     * this can be the manifest object itself, or a URL to the manifest.\n     */\n    manifest?: string | AssetsManifest;\n    /**\n     * optional preferences for which textures preferences you have when resolving assets\n     * for example you might set the resolution to 0.5 if the user is on a rubbish old phone\n     * or you might set the resolution to 2 if the user is on a retina display\n     */\n    texturePreference?: {\n        /** the resolution order you prefer, can be an array (priority order - first is prefered) or a single resolutions  */\n        resolution?: number | number[];\n        /**\n         * the formats you prefer, by default this will be:\n         * ['avif', 'webp', 'png', 'jpg', 'jpeg', 'webm', 'mp4', 'm4v', 'ogv']\n         */\n        format?: ArrayOr<string>;\n    };\n\n    /**\n     * If true, don't attempt to detect whether browser has preferred formats available.\n     * May result in increased performance as it skips detection step.\n     */\n    skipDetections?: boolean;\n\n    /** advanced - override how bundlesIds are generated */\n    bundleIdentifier?: BundleIdentifierOptions;\n\n    /** Optional loader preferences */\n    preferences?: Partial<AssetsPreferences>;\n}\n\n/**\n * A one stop shop for all Pixi resource management!\n * Super modern and easy to use, with enough flexibility to customize and do what you need!\n * @namespace assets\n *\n * Use the singleton class [Assets]{@link assets.Assets} to easily load and manage all your assets.\n *\n * ```typescript\n * import { Assets, Texture } from 'pixi.js';\n *\n * const bunnyTexture = await Assets.load<Texture>('bunny.png');\n * const sprite = new Sprite(bunnyTexture);\n * ```\n *\n * Check out the sections below for more information on how to deal with assets.\n *\n * <details id=\"assets-loading\">\n *\n * <summary>Asset Loading</summary>\n *\n * Do not be afraid to load things multiple times - under the hood, it will **NEVER** load anything more than once.\n *\n * *For example:*\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * promise1 = Assets.load('bunny.png')\n * promise2 = Assets.load('bunny.png')\n *\n * // promise1 === promise2\n * ```\n *\n * Here both promises will be the same. Once resolved... Forever resolved! It makes for really easy resource management!\n *\n * Out of the box Pixi supports the following files:\n * - Textures (**_avif_**, **_webp_**, **_png_**, **_jpg_**, **_gif_**, **_svg_**) via {@link assets.loadTextures}, {@link assets.loadSvg}\n * - Video Textures (**_mp4_**, **_m4v_**, **_webm_**, **_ogg_**, **_ogv_**, **_h264_**, **_avi_**, **_mov_**) via {@link assets.loadVideoTextures}\n * - Sprite sheets (**_json_**) via {@link assets.spritesheetAsset}\n * - Bitmap fonts (**_xml_**, **_fnt_**, **_txt_**) via {@link assets.loadBitmapFont}\n * - Web fonts (**_ttf_**, **_woff_**, **_woff2_**) via {@link assets.loadWebFont}\n * - JSON files (**_json_**) via {@link assets.loadJson}\n * - Text Files (**_txt_**) via {@link assets.loadTxt}\n * <br/>\n * More types can be added fairly easily by creating additional {@link assets.LoaderParser LoaderParsers}.\n * </details>\n *\n * <details id=\"textures\">\n *\n * <summary>Textures</summary>\n *\n * - Textures are loaded as ImageBitmap on a worker thread where possible. Leading to much less janky load + parse times.\n * - By default, we will prefer to load AVIF and WebP image files if you specify them.\n * But if the browser doesn't support AVIF or WebP we will fall back to png and jpg.\n * - Textures can also be accessed via `Texture.from()` (see {@link core.from|Texture.from})\n * and now use this asset manager under the hood!\n * - Don't worry if you set preferences for textures that don't exist\n * (for example you prefer 2x resolutions images but only 1x is available for that texture,\n * the Assets manager will pick that up as a fallback automatically)\n *\n * #### Sprite sheets\n * - It's hard to know what resolution a sprite sheet is without loading it first, to address this\n * there is a naming convention we have added that will let Pixi understand the image format and resolution\n * of the spritesheet via its file name: `my-spritesheet{resolution}.{imageFormat}.json`\n * <br><br>For example:\n *   - `my-spritesheet@2x.webp.json`* // 2x resolution, WebP sprite sheet*\n *   - `my-spritesheet@0.5x.png.json`* // 0.5x resolution, png sprite sheet*\n * - This is optional! You can just load a sprite sheet as normal.\n * This is only useful if you have a bunch of different res / formatted spritesheets.\n * </details>\n *\n * <details id=\"fonts\">\n *\n * <summary>Fonts</summary>\n *\n * Web fonts will be loaded with all weights.\n * It is possible to load only specific weights by doing the following:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Load specific weights..\n * await Assets.load({\n *     data: {\n *         weights: ['normal'], // Only loads the weight\n *     },\n *     src: `outfit.woff2`,\n * });\n *\n * // Load everything...\n * await Assets.load(`outfit.woff2`);\n * ```\n * </details>\n *\n * <details id=\"background-loading\">\n *\n * <summary>Background Loading</summary>\n *\n * Background loading will load stuff for you passively behind the scenes. To minimize jank,\n * it will only load one asset at a time. As soon as a developer calls `Assets.load(...)` the\n * background loader is paused and requested assets are loaded as a priority.\n * Don't worry if something is in there that's already loaded, it will just get skipped!\n *\n * You still need to call `Assets.load(...)` to get an asset that has been loaded in the background.\n * It's just that this promise will resolve instantly if the asset\n * has already been loaded.\n * </details>\n *\n * <details id=\"manifests-and-bundles\">\n *\n * <summary>Manifest and Bundles</summary>\n *\n * - {@link assets.AssetsManifest Manifest} is a descriptor that contains a list of all assets and their properties.\n * - {@link assets.AssetsBundle Bundles} are a way to group assets together.\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Manifest Example\n * const manifest = {\n *     bundles: [\n *         {\n *             name: 'load-screen',\n *             assets: [\n *                 {\n *                     alias: 'background',\n *                     src: 'sunset.png',\n *                 },\n *                 {\n *                     alias: 'bar',\n *                     src: 'load-bar.{png,webp}',\n *                 },\n *             ],\n *         },\n *         {\n *             name: 'game-screen',\n *             assets: [\n *                 {\n *                     alias: 'character',\n *                     src: 'robot.png',\n *                 },\n *                 {\n *                     alias: 'enemy',\n *                     src: 'bad-guy.png',\n *                 },\n *             ],\n *         },\n *     ]\n * };\n *\n * await Assets.init({ manifest });\n *\n * // Load a bundle...\n * loadScreenAssets = await Assets.loadBundle('load-screen');\n * // Load another bundle...\n * gameScreenAssets = await Assets.loadBundle('game-screen');\n * ```\n * </details>\n */\n\n/**\n * The global Assets class, it's a singleton so you don't need to instantiate it.\n *\n * **The `Assets` class has four main responsibilities:**\n * 1. Allows users to map URLs to keys and resolve them according to the user's browser capabilities\n * 2. Loads the resources and transforms them into assets that developers understand.\n * 3. Caches the assets and provides a way to access them.\n * 4. Allow developers to unload assets and clear the cache.\n *\n *\n * **It also has a few advanced features:**\n * 1. Allows developers to provide a {@link assets.Manifest} upfront of all assets and help manage\n * them via {@link assets.AssetsBundles Bundles}.\n * 2. Allows users to background load assets. Shortening (or eliminating) load times and improving UX. With this feature,\n * in-game loading bars can be a thing of the past!\n * @example\n * import { Assets } from 'pixi.js';\n *\n * const bunny = await Assets.load('bunny.png');\n * @memberof assets\n * @class Assets\n */\nexport class AssetsClass\n{\n    /** the resolver to map various urls */\n    public resolver: Resolver;\n    /** The loader, loads stuff! */\n    public loader: Loader;\n    /**\n     * The global cache of all assets within PixiJS\n     * @type {assets.Cache}\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private readonly _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Best practice is to call this function before any loading commences\n     * Initiating is the best time to add any customization to the way things are loaded.\n     *\n     * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n     * @param options - options to initialize the Assets manager with\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            warn('[Assets]AssetManager already initialized, did you load before calling this Assets.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.defaultSearchParams)\n        {\n            this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        }\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.bundleIdentifier)\n        {\n            this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<AssetsManifest>(manifest);\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        const formats = await this._detectFormats({\n            preferredFormats: options.texturePreference?.format,\n            skipDetections: options.skipDetections,\n            detections: this._detections\n        });\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n\n        if (options.preferences)\n        {\n            this.setPreferences(options.preferences);\n        }\n    }\n\n    /**\n     * Allows you to specify how to resolve any assets load requests.\n     * There are a few ways to add things here as shown below:\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Simple\n     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n     * const bunny = await Assets.load('bunnyBooBoo');\n     *\n     * // Multiple keys:\n     * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n     *\n     * const bunny = await Assets.load('burger');\n     * const bunny2 = await Assets.load('chicken');\n     *\n     * // passing options to to the object\n     * Assets.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * // Multiple assets\n     *\n     * // The following all do the same thing:\n     *\n     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});\n     *\n     * Assets.add({\n     *     alias: 'bunnyBooBoo',\n     *     src: [\n     *         'bunny.png',\n     *         'bunny.webp',\n     *    ],\n     * });\n     *\n     * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n     * @param assets - the unresolved assets to add to the resolver\n     */\n    public add(assets: (ArrayOr<UnresolvedAsset>)): void\n    {\n        this.resolver.add(assets);\n    }\n\n    /**\n     * Loads your assets! You pass in a key or URL and it will return a promise that\n     * resolves to the loaded asset. If multiple assets a requested, it will return a hash of assets.\n     *\n     * Don't worry about loading things multiple times, behind the scenes assets are only ever loaded\n     * once and the same promise reused behind the scenes so you can safely call this function multiple\n     * times with the same key and it will always return the same asset.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * Assets.add('thumper', 'bunny.png');\n     * Assets.add('chicko', 'chicken.png');\n     *\n     * // Load multiple assets:\n     * const textures = await Assets.load(['thumper', 'chicko']); // => {thumper: Texture, chicko: Texture}\n     * @param urls - the urls to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage\n     * (0.0 - 1.0) of the assets loaded.\n     * @returns - the assets that were loaded, either a single asset or a hash of assets\n     */\n    public async load<T = any>(\n        urls: string | UnresolvedAsset,\n        onProgress?: ProgressCallback,\n    ): Promise<T>;\n    public async load<T = any>(\n        urls: string[] | UnresolvedAsset[],\n        onProgress?: ProgressCallback,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        urls: ArrayOr<string> | ArrayOr<UnresolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray: string[] = convertToList<UnresolvedAsset | string>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    const aliases = this.resolver.getAlias(url);\n\n                    if (aliases.some((alias) => !this.resolver.hasKey(alias)))\n                    {\n                        this.add(url);\n                    }\n\n                    return Array.isArray(aliases) ? aliases[0] : aliases;\n                }\n\n                // if it hasn't been added, add it now\n                if (!this.resolver.hasKey(url)) this.add({ alias: url, src: url });\n\n                return url;\n            }) as string[];\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can load them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * Assets.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const assets = await Assets.loadBundle('animals');\n     * @param bundleId - the id of the bundle to add\n     * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Bundles are a way to load multiple assets at once.\n     * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n     * you can also add bundles via `addBundle`\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * await Assets.init({ manifest });\n     *\n     * // Load a bundle...\n     * loadScreenAssets = await Assets.loadBundle('load-screen');\n     * // Load another bundle...\n     * gameScreenAssets = await Assets.loadBundle('game-screen');\n     * @param bundleIds - the bundle id or ids to load\n     * @param onProgress - Optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n     * of the assets loaded. Do not use this function to detect when assets are complete and available,\n     * instead use the Promise returned by this function.\n     * @returns all the bundles assets or a hash of assets for each bundle specified\n     */\n    public async loadBundle(bundleIds: ArrayOr<string>, onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = () =>\n        {\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n\n            total += Object.keys(resolveResult).length;\n\n            return this._mapLoadToResolve(resolveResult, _onProgress)\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n     * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n     *\n     * An example of this might be that you would background load game assets after your inital load.\n     * then when you got to actually load your game screen assets when a player goes to the game - the loading\n     * would already have stared or may even be complete, saving you having to show an interim load bar.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.backgroundLoad('bunny.png');\n     *\n     * // later on in your app...\n     * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n     * @param urls - the url / urls you want to background load\n     */\n    public async backgroundLoad(urls: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n     * this can only be used if the loader has been initiated with a manifest\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [\n     *             {\n     *                 name: 'load-screen',\n     *                 assets: [...],\n     *             },\n     *             ...\n     *         ],\n     *     },\n     * });\n     *\n     * Assets.backgroundLoadBundle('load-screen');\n     *\n     * // Later on in your app...\n     * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n     * @param bundleIds - the bundleId / bundleIds you want to background load\n     */\n    public async backgroundLoadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. If the asset has not yet been loaded,\n     * it will return undefined. So it's on you! When in doubt just use `Assets.load` instead.\n     * (Remember, the loader will never load things more than once!)\n     * @param keys - The key or keys for the assets that you want to access\n     * @returns - The assets or hash of assets requested\n     */\n    public get<T = any>(keys: string): T;\n    public get<T = any>(keys: string[]): Record<string, T>;\n    public get<T = any>(keys: ArrayOr<string>): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param onProgress - the progress callback\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolvedAsset | Record<string, ResolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = [...new Set(Object.values(resolveResults))] as ResolvedAsset[];\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load<T>(resolveArray, onProgress);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            keys.forEach((key) =>\n            {\n                out[key] = asset;\n            });\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n     * this will make sure to destroy any assets and release them from memory.\n     * Once unloaded, you will need to load the asset again.\n     *\n     * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n     *\n     * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n     * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * await Assets.unload('http://some.url.com/image.png')\n     *\n     * // myImageTexture will be destroyed now.\n     *\n     * // Unload multiple assets:\n     * const textures = await Assets.unload(['thumper', 'chicko']);\n     * @param urls - the urls to unload\n     */\n    public async unload(\n        urls: ArrayOr<string> | ResolvedAsset | ResolvedAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | ResolvedAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Bundles are a way to manage multiple assets at once.\n     * this will unload all files in a bundle.\n     *\n     * once a bundle has been unloaded, you need to load it again to have access to the assets.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle({\n     *     'thumper': 'http://some.url.com/thumper.png',\n     * })\n     *\n     * const assets = await Assets.loadBundle('thumper');\n     *\n     * // Now to unload...\n     *\n     * await Assets.unloadBundle('thumper');\n     *\n     * // All assets in the assets object will now have been destroyed and purged from the cache\n     * @param bundleIds - the bundle id or ids to unload\n     */\n    public async unloadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolvedAsset | Record<string, ResolvedAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /**\n     * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n     * the users preferred formats order.\n     * @param options - the options to use when detecting formats\n     * @param options.preferredFormats - the preferred formats to use\n     * @param options.skipDetections - if we should skip the detections altogether\n     * @param options.detections - the detections to use\n     * @returns - the detected formats\n     */\n    private async _detectFormats(options: {\n        preferredFormats: string | string[],\n        skipDetections: boolean,\n        detections: FormatDetectionParser[]\n    }): Promise<string[]>\n    {\n        let formats: string[] = [];\n\n        // set preferred formats\n        if (options.preferredFormats)\n        {\n            formats = Array.isArray(options.preferredFormats)\n                ? options.preferredFormats : [options.preferredFormats];\n        }\n\n        // we should add any formats that are supported by the browser\n        for (const detection of options.detections)\n        {\n            if (options.skipDetections || await detection.test())\n            {\n                formats = await detection.add(formats);\n            }\n            else if (!options.skipDetections)\n            {\n                formats = await detection.remove(formats);\n            }\n        }\n\n        // remove any duplicates\n        formats = formats.filter((format, index) => formats.indexOf(format) === index);\n\n        return formats;\n    }\n\n    /** All the detection parsers currently added to the Assets class. */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n\n    /**\n     * General setter for preferences. This is a helper function to set preferences on all parsers.\n     * @param preferences - the preferences to set\n     */\n    public setPreferences(preferences: Partial<AssetsPreferences>): void\n    {\n        // Find matching config keys in loaders with preferences\n        // and set the values\n        this.loader.parsers.forEach((parser) =>\n        {\n            if (!parser.config) return;\n\n            (Object.keys(parser.config) as (keyof AssetsPreferences)[])\n                .filter((key) => key in preferences)\n                .forEach((key) =>\n                {\n                    parser.config[key] = preferences[key];\n                });\n        });\n    }\n}\n\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n    cacheTextureArray,\n\n    detectDefaults,\n    detectAvif,\n    detectWebp,\n    detectMp4,\n    detectOgv,\n    detectWebm,\n\n    loadJson,\n    loadTxt,\n    loadWebFont,\n    loadSvg,\n    loadTextures,\n    loadVideoTextures,\n\n    resolveTextureUrl,\n    resolveJsonUrl\n);\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n","\"use strict\";\nclass BackgroundLoader {\n  /**\n   * @param loader\n   * @param verbose - should the loader log to the console\n   */\n  constructor(loader, verbose = false) {\n    this._loader = loader;\n    this._assetList = [];\n    this._isLoading = false;\n    this._maxConcurrent = 1;\n    this.verbose = verbose;\n  }\n  /**\n   * Adds an array of assets to load.\n   * @param assetUrls - assets to load\n   */\n  add(assetUrls) {\n    assetUrls.forEach((a) => {\n      this._assetList.push(a);\n    });\n    if (this.verbose) {\n      console.log(\"[BackgroundLoader] assets: \", this._assetList);\n    }\n    if (this._isActive && !this._isLoading) {\n      void this._next();\n    }\n  }\n  /**\n   * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n   *\n   * The max assets it will try to load at one time will be 4.\n   */\n  async _next() {\n    if (this._assetList.length && this._isActive) {\n      this._isLoading = true;\n      const toLoad = [];\n      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n      for (let i = 0; i < toLoadAmount; i++) {\n        toLoad.push(this._assetList.pop());\n      }\n      await this._loader.load(toLoad);\n      this._isLoading = false;\n      void this._next();\n    }\n  }\n  /**\n   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n   * @returns whether the class is active\n   */\n  get active() {\n    return this._isActive;\n  }\n  set active(value) {\n    if (this._isActive === value)\n      return;\n    this._isActive = value;\n    if (value && !this._isLoading) {\n      void this._next();\n    }\n  }\n}\n\nexport { BackgroundLoader };\n//# sourceMappingURL=BackgroundLoader.mjs.map\n","import type { Loader } from './loader/Loader';\nimport type { ResolvedAsset } from './types';\n\n/**\n * Quietly Loads assets in the background.\n * @memberof assets\n */\nexport class BackgroundLoader\n{\n    /** Whether or not the loader should continue loading. */\n    private _isActive: boolean;\n\n    /** Assets to load. */\n    private readonly _assetList: ResolvedAsset[];\n\n    /** Whether or not the loader is loading. */\n    private _isLoading: boolean;\n\n    /** Number of assets to load at a time. */\n    private readonly _maxConcurrent: number;\n\n    /** Should the loader log to the console. */\n    public verbose: boolean;\n    private readonly _loader: Loader;\n\n    /**\n     * @param loader\n     * @param verbose - should the loader log to the console\n     */\n    constructor(loader: Loader, verbose = false)\n    {\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n\n    /**\n     * Adds an array of assets to load.\n     * @param assetUrls - assets to load\n     */\n    public add(assetUrls: ResolvedAsset[]): void\n    {\n        assetUrls.forEach((a) =>\n        {\n            this._assetList.push(a);\n        });\n\n        if (this.verbose)\n        {\n            // eslint-disable-next-line no-console\n            console.log('[BackgroundLoader] assets: ', this._assetList);\n        }\n\n        if (this._isActive && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n\n    /**\n     * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n     *\n     * The max assets it will try to load at one time will be 4.\n     */\n    private async _next(): Promise<void>\n    {\n        if (this._assetList.length && this._isActive)\n        {\n            this._isLoading = true;\n\n            const toLoad = [];\n\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n\n            for (let i = 0; i < toLoadAmount; i++)\n            {\n                toLoad.push(this._assetList.pop());\n            }\n\n            await this._loader.load(toLoad);\n\n            this._isLoading = false;\n\n            void this._next();\n        }\n    }\n\n    /**\n     * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n     * @returns whether the class is active\n     */\n    get active(): boolean\n    {\n        return this._isActive;\n    }\n\n    set active(value: boolean)\n    {\n        if (this._isActive === value) return;\n\n        this._isActive = value;\n\n        if (value && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\n\n\"use strict\";\nconst cacheTextureArray = {\n  extension: ExtensionType.CacheParser,\n  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n  getCacheableAssets: (keys, asset) => {\n    const out = {};\n    keys.forEach((key) => {\n      asset.forEach((item, i) => {\n        out[key + (i === 0 ? \"\" : i + 1)] = item;\n      });\n    });\n    return out;\n  }\n};\n\nexport { cacheTextureArray };\n//# sourceMappingURL=cacheTextureArray.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nimport type { CacheParser } from '../CacheParser';\n\n/**\n * Returns an object of textures from an array of textures to be cached\n * @memberof assets\n */\nexport const cacheTextureArray: CacheParser<Texture[]> = {\n    extension: ExtensionType.CacheParser,\n\n    test: (asset: any[]) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n\n    getCacheableAssets: (keys: string[], asset: Texture[]) =>\n    {\n        const out: Record<string, Texture> = {};\n\n        keys.forEach((key: string) =>\n        {\n            asset.forEach((item: Texture, i: number) =>\n            {\n                out[key + (i === 0 ? '' : i + 1)] = item;\n            });\n        });\n\n        return out;\n    }\n};\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testImageFormat } from '../utils/testImageFormat.mjs';\n\n\"use strict\";\nconst detectAvif = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 1\n  },\n  test: async () => testImageFormat(\n    // eslint-disable-next-line max-len\n    \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=\"\n  ),\n  add: async (formats) => [...formats, \"avif\"],\n  remove: async (formats) => formats.filter((f) => f !== \"avif\")\n};\n\nexport { detectAvif };\n//# sourceMappingURL=detectAvif.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the AVIF image format.\n * @memberof assets\n */\nexport const detectAvif: FormatDetectionParser = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 1,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        // eslint-disable-next-line max-len\n        'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A='\n    ),\n    add: async (formats) => [...formats, 'avif'],\n    remove: async (formats) => formats.filter((f) => f !== 'avif'),\n};\n","\"use strict\";\nasync function testImageFormat(imageData) {\n  if (\"Image\" in globalThis) {\n    return new Promise((resolve) => {\n      const image = new Image();\n      image.onload = () => {\n        resolve(true);\n      };\n      image.onerror = () => {\n        resolve(false);\n      };\n      image.src = imageData;\n    });\n  }\n  if (\"createImageBitmap\" in globalThis && \"fetch\" in globalThis) {\n    try {\n      const blob = await (await fetch(imageData)).blob();\n      await createImageBitmap(blob);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport { testImageFormat };\n//# sourceMappingURL=testImageFormat.mjs.map\n","export async function testImageFormat(imageData: string): Promise<boolean>\n{\n    // Some browsers currently do not support createImageBitmap with Blob, so new Image() is preferred when exist.\n    // See https://caniuse.com/createimagebitmap for more information.\n\n    if ('Image' in globalThis)\n    {\n        return new Promise<boolean>((resolve) =>\n        {\n            const image = new Image();\n\n            image.onload = () =>\n            {\n                resolve(true);\n            };\n            image.onerror = () =>\n            {\n                resolve(false);\n            };\n            image.src = imageData;\n        });\n    }\n\n    if ('createImageBitmap' in globalThis && 'fetch' in globalThis)\n    {\n        try\n        {\n            const blob = await (await fetch(imageData)).blob();\n\n            await createImageBitmap(blob);\n        }\n        catch (e)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst imageFormats = [\"png\", \"jpg\", \"jpeg\"];\nconst detectDefaults = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: -1\n  },\n  test: () => Promise.resolve(true),\n  add: async (formats) => [...formats, ...imageFormats],\n  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))\n};\n\nexport { detectDefaults };\n//# sourceMappingURL=detectDefaults.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { FormatDetectionParser } from '../types';\n\nconst imageFormats = ['png', 'jpg', 'jpeg'];\n\n/**\n * Adds some default image formats to the detection parser\n * @memberof assets\n */\nexport const detectDefaults = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: -1,\n    },\n    test: (): Promise<boolean> => Promise.resolve(true),\n    add: async (formats) => [...formats, ...imageFormats],\n    remove: async (formats) => formats.filter((f) => !imageFormats.includes(f)),\n} as FormatDetectionParser;\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testVideoFormat } from '../utils/testVideoFormat.mjs';\n\n\"use strict\";\nconst detectMp4 = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat(\"video/mp4\"),\n  add: async (formats) => [...formats, \"mp4\", \"m4v\"],\n  remove: async (formats) => formats.filter((f) => f !== \"mp4\" && f !== \"m4v\")\n};\n\nexport { detectMp4 };\n//# sourceMappingURL=detectMp4.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the MP4 video format.\n * @memberof assets\n */\nexport const detectMp4 = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/mp4'),\n    add: async (formats) => [...formats, 'mp4', 'm4v'],\n    remove: async (formats) => formats.filter((f) => f !== 'mp4' && f !== 'm4v'),\n} as FormatDetectionParser;\n","\"use strict\";\nconst inWorker = \"WorkerGlobalScope\" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;\nfunction testVideoFormat(mimeType) {\n  if (inWorker) {\n    return false;\n  }\n  const video = document.createElement(\"video\");\n  return video.canPlayType(mimeType) !== \"\";\n}\n\nexport { testVideoFormat };\n//# sourceMappingURL=testVideoFormat.mjs.map\n","const inWorker = 'WorkerGlobalScope' in globalThis\n    && globalThis instanceof (globalThis as any).WorkerGlobalScope;\n\nexport function testVideoFormat(mimeType: string): boolean\n{\n    if (inWorker)\n    {\n        return false;\n    }\n\n    const video = document.createElement('video');\n\n    return video.canPlayType(mimeType) !== '';\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testVideoFormat } from '../utils/testVideoFormat.mjs';\n\n\"use strict\";\nconst detectOgv = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat(\"video/ogg\"),\n  add: async (formats) => [...formats, \"ogv\"],\n  remove: async (formats) => formats.filter((f) => f !== \"ogv\")\n};\n\nexport { detectOgv };\n//# sourceMappingURL=detectOgv.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the OGV video format.\n * @memberof assets\n */\nexport const detectOgv = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/ogg'),\n    add: async (formats) => [...formats, 'ogv'],\n    remove: async (formats) => formats.filter((f) => f !== 'ogv'),\n} as FormatDetectionParser;\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testVideoFormat } from '../utils/testVideoFormat.mjs';\n\n\"use strict\";\nconst detectWebm = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat(\"video/webm\"),\n  add: async (formats) => [...formats, \"webm\"],\n  remove: async (formats) => formats.filter((f) => f !== \"webm\")\n};\n\nexport { detectWebm };\n//# sourceMappingURL=detectWebm.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebM video format.\n * @memberof assets\n */\nexport const detectWebm = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/webm'),\n    add: async (formats) => [...formats, 'webm'],\n    remove: async (formats) => formats.filter((f) => f !== 'webm'),\n} as FormatDetectionParser;\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testImageFormat } from '../utils/testImageFormat.mjs';\n\n\"use strict\";\nconst detectWebp = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testImageFormat(\n    \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=\"\n  ),\n  add: async (formats) => [...formats, \"webp\"],\n  remove: async (formats) => formats.filter((f) => f !== \"webp\")\n};\n\nexport { detectWebp };\n//# sourceMappingURL=detectWebp.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebP image format.\n * @memberof assets\n */\nexport const detectWebp = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA='\n    ),\n    add: async (formats) => [...formats, 'webp'],\n    remove: async (formats) => formats.filter((f) => f !== 'webp'),\n} as FormatDetectionParser;\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\n\"use strict\";\nclass Loader {\n  constructor() {\n    this._parsers = [];\n    this._parsersValidated = false;\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => {\n        this._parsersValidated = false;\n        target[key] = value;\n        return true;\n      }\n    });\n    /** Cache loading promises that ae currently active */\n    this.promiseCache = {};\n  }\n  /** function used for testing */\n  reset() {\n    this._parsersValidated = false;\n    this.promiseCache = {};\n  }\n  /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    result.promise = (async () => {\n      let asset = null;\n      let parser = null;\n      if (data.loadParser) {\n        parser = this._parserHash[data.loadParser];\n        if (!parser) {\n          warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n        }\n      }\n      if (!parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser) {\n          warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n          return null;\n        }\n      }\n      asset = await parser.load(url, data, this);\n      result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        if (parser2.parse) {\n          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {\n            asset = await parser2.parse(asset, data, this) || asset;\n            result.parser = parser2;\n          }\n        }\n      }\n      return asset;\n    })();\n    return result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    if (!this._parsersValidated) {\n      this._validateParsers();\n    }\n    let count = 0;\n    const assets = {};\n    const singleAsset = isSingleItem(assetsToLoadIn);\n    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({\n      alias: [item],\n      src: item\n    }));\n    const total = assetsToLoad.length;\n    const promises = assetsToLoad.map(async (asset) => {\n      const url = path.toAbsolute(asset.src);\n      if (!assets[asset.src]) {\n        try {\n          if (!this.promiseCache[url]) {\n            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n          }\n          assets[asset.src] = await this.promiseCache[url].promise;\n          if (onProgress)\n            onProgress(++count / total);\n        } catch (e) {\n          delete this.promiseCache[url];\n          delete assets[asset.src];\n          throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n      }\n    });\n    await Promise.all(promises);\n    return singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load('cool.png');\n   *\n   * await Loader.unload('cool.png');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */\n  async unload(assetsToUnloadIn) {\n    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({\n      alias: [item],\n      src: item\n    }));\n    const promises = assetsToUnload.map(async (asset) => {\n      const url = path.toAbsolute(asset.src);\n      const loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        delete this.promiseCache[url];\n        await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n      }\n    });\n    await Promise.all(promises);\n  }\n  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n  _validateParsers() {\n    this._parsersValidated = true;\n    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {\n      if (!parser.name) {\n        warn(`[Assets] loadParser should have a name`);\n      } else if (hash[parser.name]) {\n        warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n      }\n      return { ...hash, [parser.name]: parser };\n    }, {});\n  }\n}\n\nexport { Loader };\n//# sourceMappingURL=Loader.mjs.map\n","import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type { ResolvedAsset } from '../types';\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { PromiseAndParser } from './types';\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Loader\n{\n    private readonly _parsers: LoaderParser[] = [];\n    private _parserHash: Record<string, LoaderParser>;\n\n    private _parsersValidated = false;\n\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    public parsers = new Proxy(this._parsers, {\n        set: (target, key, value) =>\n        {\n            this._parsersValidated = false;\n\n            target[key as any as number] = value;\n\n            return true;\n        }\n    });\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this._parsersValidated = false;\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: ResolvedAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            let parser: LoaderParser = null;\n\n            // first check to see if the user has specified a parser\n            if (data.loadParser)\n            {\n                // they have? lovely, lets use it\n                parser = this._parserHash[data.loadParser];\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n                    // #endif\n                }\n            }\n\n            // no parser specified, so lets try and find one using the tests\n            if (!parser)\n            {\n                for (let i = 0; i < this.parsers.length; i++)\n                {\n                    const parserX = this.parsers[i];\n\n                    if (parserX.load && parserX.test?.(url, data, this))\n                    {\n                        parser = parserX;\n                        break;\n                    }\n                }\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n                    // #endif\n\n                    return null;\n                }\n            }\n\n            asset = await parser.load(url, data, this);\n            result.parser = parser;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads one or more assets using the parsers added to the Loader.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     *\n     * // Multiple assets:\n     * const assets = await Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - For multiple asset loading only, an optional function that is called\n     * when progress on asset loading is made. The function is passed a single parameter, `progress`,\n     * which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function\n     * to detect when assets are complete and available, instead use the Promise returned by this function.\n     */\n    public async load<T = any>(\n        assetsToLoadIn: string | ResolvedAsset,\n        onProgress?: (progress: number) => void,\n    ): Promise<T>;\n    public async load<T = any>(\n        assetsToLoadIn: string[] | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        assetsToLoadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._parsersValidated)\n        {\n            this._validateParsers();\n        }\n\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<ResolvedAsset>(assetsToLoadIn, (item) => ({\n            alias: [item],\n            src: item,\n        }));\n\n        const total = assetsToLoad.length;\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            if (!assets[asset.src])\n            {\n                try\n                {\n                    if (!this.promiseCache[url])\n                    {\n                        this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                    }\n\n                    assets[asset.src] = await this.promiseCache[url].promise;\n\n                    // Only progress if nothing goes wrong\n                    if (onProgress) onProgress(++count / total);\n                }\n                catch (e)\n                {\n                    // Delete eventually registered file and promises from internal cache\n                    // so they can be eligible for another loading attempt\n                    delete this.promiseCache[url];\n                    delete assets[asset.src];\n\n                    // Stop further execution\n                    throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<ResolvedAsset>(assetsToUnloadIn, (item) => ({\n            alias: [item],\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                delete this.promiseCache[url];\n\n                await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n    private _validateParsers()\n    {\n        this._parsersValidated = true;\n\n        this._parserHash = this._parsers\n            .filter((parser) => parser.name)\n            .reduce((hash, parser) =>\n            {\n                if (!parser.name)\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] loadParser should have a name`);\n                    // #endif\n                }\n                else if (hash[parser.name])\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n                    // #endif\n                }\n\n                return { ...hash, [parser.name]: parser };\n            }, {} as Record<string, LoaderParser>);\n    }\n}\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { checkDataUrl } from '../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from './LoaderParser.mjs';\n\n\"use strict\";\nconst validJSONExtension = \".json\";\nconst validJSONMIME = \"application/json\";\nconst loadJson = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: \"loadJson\",\n  test(url) {\n    return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n  },\n  async load(url) {\n    const response = await DOMAdapter.get().fetch(url);\n    const json = await response.json();\n    return json;\n  }\n};\n\nexport { loadJson };\n//# sourceMappingURL=loadJson.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validJSONExtension = '.json';\nconst validJSONMIME = 'application/json';\n\n/**\n * A simple loader plugin for loading json data\n * @memberof assets\n */\nexport const loadJson = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadJson',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n    },\n\n    async load<T>(url: string): Promise<T>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const json = await response.json();\n\n        return json as T;\n    },\n} as LoaderParser;\n","\"use strict\";\nfunction checkDataUrl(url, mimes) {\n  if (Array.isArray(mimes)) {\n    for (const mime of mimes) {\n      if (url.startsWith(`data:${mime}`))\n        return true;\n    }\n    return false;\n  }\n  return url.startsWith(`data:${mimes}`);\n}\n\nexport { checkDataUrl };\n//# sourceMappingURL=checkDataUrl.mjs.map\n","export function checkDataUrl(url: string, mimes: string | string[]): boolean\n{\n    if (Array.isArray(mimes))\n    {\n        for (const mime of mimes)\n        {\n            if (url.startsWith(`data:${mime}`)) return true;\n        }\n\n        return false;\n    }\n\n    return url.startsWith(`data:${mimes}`);\n}\n","import { path } from '../../utils/path.mjs';\n\n\"use strict\";\nfunction checkExtension(url, extension) {\n  const tempURL = url.split(\"?\")[0];\n  const ext = path.extname(tempURL).toLowerCase();\n  if (Array.isArray(extension)) {\n    return extension.includes(ext);\n  }\n  return ext === extension;\n}\n\nexport { checkExtension };\n//# sourceMappingURL=checkExtension.mjs.map\n","import { path } from '../../utils/path';\n\nexport function checkExtension(url: string, extension: string | string[]): boolean\n{\n    const tempURL = url.split('?')[0];\n    const ext = path.extname(tempURL).toLowerCase();\n\n    if (Array.isArray(extension))\n    {\n        return extension.includes(ext);\n    }\n\n    return ext === extension;\n}\n\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { checkDataUrl } from '../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from './LoaderParser.mjs';\n\n\"use strict\";\nconst validTXTExtension = \".txt\";\nconst validTXTMIME = \"text/plain\";\nconst loadTxt = {\n  name: \"loadTxt\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  test(url) {\n    return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n  },\n  async load(url) {\n    const response = await DOMAdapter.get().fetch(url);\n    const txt = await response.text();\n    return txt;\n  }\n};\n\nexport { loadTxt };\n//# sourceMappingURL=loadTxt.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validTXTExtension = '.txt';\nconst validTXTMIME = 'text/plain';\n\n/**\n * A simple loader plugin for loading text data\n * @memberof assets\n */\nexport const loadTxt = {\n\n    name: 'loadTxt',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n    },\n\n    async load(url: string): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const txt = await response.text();\n\n        return txt;\n    },\n} as LoaderParser;\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\nimport { path } from '../../../utils/path.mjs';\nimport { Cache } from '../../cache/Cache.mjs';\nimport { checkDataUrl } from '../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from './LoaderParser.mjs';\n\n\"use strict\";\nconst validWeights = [\n  \"normal\",\n  \"bold\",\n  \"100\",\n  \"200\",\n  \"300\",\n  \"400\",\n  \"500\",\n  \"600\",\n  \"700\",\n  \"800\",\n  \"900\"\n];\nconst validFontExtensions = [\".ttf\", \".otf\", \".woff\", \".woff2\"];\nconst validFontMIMEs = [\n  \"font/ttf\",\n  \"font/otf\",\n  \"font/woff\",\n  \"font/woff2\"\n];\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\nfunction getFontFamilyName(url) {\n  const ext = path.extname(url);\n  const name = path.basename(url, ext);\n  const nameWithSpaces = name.replace(/(-|_)/g, \" \");\n  const nameTokens = nameWithSpaces.toLowerCase().split(\" \").map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n  let valid = nameTokens.length > 0;\n  for (const token of nameTokens) {\n    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {\n      valid = false;\n      break;\n    }\n  }\n  let fontFamilyName = nameTokens.join(\" \");\n  if (!valid) {\n    fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, \"\\\\$&\")}\"`;\n  }\n  return fontFamilyName;\n}\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\nfunction encodeURIWhenNeeded(uri) {\n  if (validURICharactersRegex.test(uri)) {\n    return uri;\n  }\n  return encodeURI(uri);\n}\nconst loadWebFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: \"loadWebFont\",\n  test(url) {\n    return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n  },\n  async load(url, options) {\n    const fonts = DOMAdapter.get().getFontFaceSet();\n    if (fonts) {\n      const fontFaces = [];\n      const name = options.data?.family ?? getFontFamilyName(url);\n      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? [\"normal\"];\n      const data = options.data ?? {};\n      for (let i = 0; i < weights.length; i++) {\n        const weight = weights[i];\n        const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n          ...data,\n          weight\n        });\n        await font.load();\n        fonts.add(font);\n        fontFaces.push(font);\n      }\n      Cache.set(`${name}-and-url`, {\n        url,\n        fontFaces\n      });\n      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n    }\n    warn(\"[loadWebFont] FontFace API is not supported. Skipping loading font\");\n    return null;\n  },\n  unload(font) {\n    (Array.isArray(font) ? font : [font]).forEach((t) => {\n      Cache.remove(t.family);\n      DOMAdapter.get().getFontFaceSet().delete(t);\n    });\n  }\n};\n\nexport { getFontFamilyName, loadWebFont };\n//# sourceMappingURL=loadWebFont.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { path } from '../../../utils/path';\nimport { Cache } from '../../cache/Cache';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { ResolvedAsset } from '../../types';\nimport type { LoaderParser } from './LoaderParser';\n\nconst validWeights = [\n    'normal', 'bold',\n    '100', '200', '300', '400', '500', '600', '700', '800', '900',\n];\nconst validFontExtensions = ['.ttf', '.otf', '.woff', '.woff2'];\nconst validFontMIMEs = [\n    'font/ttf',\n    'font/otf',\n    'font/woff',\n    'font/woff2',\n];\n\n/**\n * Data for loading a font\n * @memberof assets\n */\nexport type LoadFontData = {\n    /** Font family name */\n    family: string;\n    /** A set of optional descriptors passed as an object. It can contain any of the descriptors available for @font-face: */\n    display: string;\n    /**\n     * The featureSettings property of the FontFace interface retrieves or sets infrequently used\n     * font features that are not available from a font's variant properties.\n     */\n    featureSettings: string;\n    /** The stretch property of the FontFace interface retrieves or sets how the font stretches. */\n    stretch: string;\n    /** The style property of the FontFace interface retrieves or sets the font's style. */\n    style: string;\n    /**\n     * The unicodeRange property of the FontFace interface retrieves or sets the range of\n     * unicode code points encompassing the font.\n     */\n    unicodeRange: string;\n    /** The variant property of the FontFace interface programmatically retrieves or sets font variant values. */\n    variant: string;\n    /** The weight property of the FontFace interface retrieves or sets the weight of the font. */\n    weights: string[];\n};\n\n/**\n * RegExp for matching CSS <ident-token>. It doesn't consider escape and non-ASCII characters, but enough for us.\n * @see {@link https://www.w3.org/TR/css-syntax-3/#ident-token-diagram}\n */\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\n\n/**\n * Return font face name from a file name\n * Ex.: 'fonts/titan-one.woff' turns into 'Titan One'\n * @param url - File url\n * @memberof assets\n */\nexport function getFontFamilyName(url: string): string\n{\n    const ext = path.extname(url);\n    const name = path.basename(url, ext);\n\n    // Replace dashes by white spaces\n    const nameWithSpaces = name.replace(/(-|_)/g, ' ');\n\n    // Upper case first character of each word\n    const nameTokens = nameWithSpaces.toLowerCase()\n        .split(' ')\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n\n    let valid = nameTokens.length > 0;\n\n    for (const token of nameTokens)\n    {\n        if (!token.match(CSS_IDENT_TOKEN_REGEX))\n        {\n            valid = false;\n            break;\n        }\n    }\n\n    let fontFamilyName = nameTokens.join(' ');\n\n    if (!valid)\n    {\n        fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, '\\\\$&')}\"`;\n    }\n\n    return fontFamilyName;\n}\n\n// See RFC 3986 Chapter 2. Characters\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\n\n/**\n * Encode URI only when it contains invalid characters.\n * @param uri - URI to encode.\n */\nfunction encodeURIWhenNeeded(uri: string)\n{\n    if (validURICharactersRegex.test(uri))\n    {\n        return uri;\n    }\n\n    return encodeURI(uri);\n}\n\n/**\n * A loader plugin for handling web fonts\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *   alias: 'font',\n *   src: 'fonts/titan-one.woff',\n *   data: {\n *     family: 'Titan One',\n *     weights: ['normal', 'bold'],\n *   }\n * })\n * @memberof assets\n */\nexport const loadWebFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadWebFont',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n    },\n\n    async load(url: string, options?: ResolvedAsset<LoadFontData>): Promise<FontFace | FontFace[]>\n    {\n        const fonts = DOMAdapter.get().getFontFaceSet();\n\n        if (fonts)\n        {\n            const fontFaces: FontFace[] = [];\n            const name = options.data?.family ?? getFontFamilyName(url);\n            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ['normal'];\n            const data = options.data ?? {};\n\n            for (let i = 0; i < weights.length; i++)\n            {\n                const weight = weights[i];\n\n                const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n                    ...data,\n                    weight,\n                });\n\n                await font.load();\n\n                fonts.add(font);\n\n                fontFaces.push(font);\n            }\n\n            Cache.set(`${name}-and-url`, {\n                url,\n                fontFaces,\n            });\n\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n\n        // #if _DEBUG\n        warn('[loadWebFont] FontFace API is not supported. Skipping loading font');\n        // #endif\n\n        return null;\n    },\n\n    unload(font: FontFace | FontFace[]): void\n    {\n        (Array.isArray(font) ? font : [font])\n            .forEach((t) =>\n            {\n                Cache.remove(t.family);\n                DOMAdapter.get().getFontFaceSet().delete(t);\n            });\n    }\n} as LoaderParser<FontFace | FontFace[]>;\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validSVGExtension = \".svg\";\nconst validSVGMIME = \"image/svg+xml\";\nconst loadSvg = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: \"loadSVG\",\n  config: {\n    crossOrigin: \"anonymous\",\n    parseAsGraphicsContext: false\n  },\n  test(url) {\n    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n  },\n  async load(url, asset, loader) {\n    if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {\n      return loadAsGraphics(url);\n    }\n    return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n  },\n  unload(asset) {\n    asset.destroy(true);\n  }\n};\nasync function loadAsTexture(url, asset, loader, crossOrigin) {\n  const response = await DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const blobUrl = URL.createObjectURL(blob);\n  const image = new Image();\n  image.src = blobUrl;\n  image.crossOrigin = crossOrigin;\n  await image.decode();\n  URL.revokeObjectURL(blobUrl);\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n  const width = asset.data?.width ?? image.width;\n  const height = asset.data?.height ?? image.height;\n  canvas.width = width * resolution;\n  canvas.height = height * resolution;\n  context.drawImage(image, 0, 0, width * resolution, height * resolution);\n  const { parseAsGraphicsContext: _p, ...rest } = asset.data;\n  const base = new ImageSource({\n    resource: canvas,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    resolution,\n    ...rest\n  });\n  return createTexture(base, loader, url);\n}\nasync function loadAsGraphics(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const svgSource = await response.text();\n  const context = new GraphicsContext();\n  context.svg(svgSource);\n  return context;\n}\n\nexport { loadSvg };\n//# sourceMappingURL=loadSVG.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { type LoaderParser, LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\n\n/**\n * Configuration for the [loadSVG]{@link assets.loadSVG} plugin.\n * @see assets.loadSVG\n * @memberof assets\n */\nexport interface LoadSVGConfig\n{\n    /**\n     * The crossOrigin value to use for loading the SVG as an image.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n    /**\n     * When set to `true`, loading and decoding images will happen with `new Image()`,\n     * @default false\n     */\n    parseAsGraphicsContext: boolean;\n}\n\n/**\n * Regular expression for SVG XML document.\n * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n * @readonly\n */\nconst validSVGExtension = '.svg';\nconst validSVGMIME = 'image/svg+xml';\n\n/**\n * A simple loader plugin for loading json data\n * @memberof assets\n */\nexport const loadSvg = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadSVG',\n\n    config: {\n        crossOrigin: 'anonymous',\n        parseAsGraphicsContext: false,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n    },\n\n    async load(\n        url: string,\n        asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n        loader: Loader\n    ): Promise<Texture | GraphicsContext>\n    {\n        if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext)\n        {\n            return loadAsGraphics(url);\n        }\n\n        return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n    },\n\n    unload(asset: Texture | GraphicsContext): void\n    {\n        asset.destroy(true);\n    }\n\n} as LoaderParser<Texture | GraphicsContext, TextureSourceOptions, LoadSVGConfig>;\n\nasync function loadAsTexture(\n    url: string,\n    asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n    loader: Loader,\n    crossOrigin: HTMLImageElement['crossOrigin']\n): Promise<Texture>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const blobUrl = URL.createObjectURL(blob);\n\n    const image = new Image();\n\n    image.src = blobUrl;\n    image.crossOrigin = crossOrigin;\n    await image.decode();\n\n    URL.revokeObjectURL(blobUrl);\n\n    // convert to canvas...\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n\n    const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n\n    const width = asset.data?.width ?? image.width;\n    const height = asset.data?.height ?? image.height;\n\n    canvas.width = width * resolution;\n    canvas.height = height * resolution;\n\n    context.drawImage(image, 0, 0, width * resolution, height * resolution);\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { parseAsGraphicsContext: _p, ...rest } = asset.data;\n    const base = new ImageSource({\n        resource: canvas,\n        alphaMode: 'premultiply-alpha-on-upload',\n        resolution,\n        ...rest,\n    });\n\n    return createTexture(base, loader, url);\n}\n\nasync function loadAsGraphics(url: string): Promise<GraphicsContext>\n{\n    const response = await DOMAdapter.get().fetch(url);\n    const svgSource = await response.text();\n\n    const context = new GraphicsContext();\n\n    context.svg(svgSource);\n\n    return context;\n}\n","import { Resolver } from '../../assets/resolver/Resolver.mjs';\n\n\"use strict\";\nfunction getResolutionOfUrl(url, defaultValue = 1) {\n  const resolution = Resolver.RETINA_PREFIX?.exec(url);\n  if (resolution) {\n    return parseFloat(resolution[1]);\n  }\n  return defaultValue;\n}\n\nexport { getResolutionOfUrl };\n//# sourceMappingURL=getResolutionOfUrl.mjs.map\n","import { Resolver } from '../../assets/resolver/Resolver';\n\n/**\n * get the resolution / device pixel ratio of an asset by looking for the prefix\n * used by spritesheets and image urls\n * @memberof utils\n * @function getResolutionOfUrl\n * @param {string} url - the image path\n * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.\n * @returns {number} resolution / device pixel ratio of an asset\n */\nexport function getResolutionOfUrl(url: string, defaultValue = 1): number\n{\n    const resolution = Resolver.RETINA_PREFIX?.exec(url);\n\n    if (resolution)\n    {\n        return parseFloat(resolution[1]);\n    }\n\n    return defaultValue;\n}\n","import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\nimport { Cache } from '../../../../cache/Cache.mjs';\n\n\"use strict\";\nfunction createTexture(source, loader, url) {\n  source.label = url;\n  source._sourceOrigin = url;\n  const texture = new Texture({\n    source,\n    label: url\n  });\n  const unload = () => {\n    delete loader.promiseCache[url];\n    if (Cache.has(url)) {\n      Cache.remove(url);\n    }\n  };\n  texture.source.once(\"destroy\", () => {\n    if (loader.promiseCache[url]) {\n      warn(\"[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.\");\n      unload();\n    }\n  });\n  texture.once(\"destroy\", () => {\n    if (!source.destroyed) {\n      warn(\"[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.\");\n      unload();\n    }\n  });\n  return texture;\n}\n\nexport { createTexture };\n//# sourceMappingURL=createTexture.mjs.map\n","import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { Cache } from '../../../../cache/Cache';\n\nimport type { TextureSource } from '../../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Loader } from '../../../Loader';\n\n/**\n * Creates a texture from a source and adds it to the cache.\n * @param source - source of the texture\n * @param loader - loader\n * @param url - url of the texture\n * @ignore\n */\nexport function createTexture(source: TextureSource, loader: Loader, url: string)\n{\n    source.label = url;\n    source._sourceOrigin = url;\n\n    const texture = new Texture({\n        source,\n        label: url,\n    });\n\n    const unload = () =>\n    {\n        delete loader.promiseCache[url];\n\n        if (Cache.has(url))\n        {\n            Cache.remove(url);\n        }\n    };\n\n    // remove the promise from the loader and the url from the cache when the texture is destroyed\n    texture.source.once('destroy', () =>\n    {\n        if (loader.promiseCache[url])\n        {\n            // #if _DEBUG\n            warn('[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! '\n           + 'Use Assets.unload() instead of destroying the TextureSource.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    texture.once('destroy', () =>\n    {\n        if (!source.destroyed)\n        {\n            // #if _DEBUG\n            warn('[Assets] A Texture managed by Assets was destroyed instead of unloaded! '\n             + 'Use Assets.unload() instead of destroying the Texture.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    return texture;\n}\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { WorkerManager } from '../../workers/WorkerManager.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validImageExtensions = [\".jpeg\", \".jpg\", \".png\", \".webp\", \".avif\"];\nconst validImageMIMEs = [\n  \"image/jpeg\",\n  \"image/png\",\n  \"image/webp\",\n  \"image/avif\"\n];\nasync function loadImageBitmap(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  if (!response.ok) {\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  }\n  const imageBlob = await response.blob();\n  const imageBitmap = await createImageBitmap(imageBlob);\n  return imageBitmap;\n}\nconst loadTextures = {\n  name: \"loadTextures\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  config: {\n    preferWorkers: true,\n    preferCreateImageBitmap: true,\n    crossOrigin: \"anonymous\"\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {\n        src = await WorkerManager.loadImageBitmap(url);\n      } else {\n        src = await loadImageBitmap(url);\n      }\n    } else {\n      src = await new Promise((resolve) => {\n        src = new Image();\n        src.crossOrigin = this.config.crossOrigin;\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n        }\n      });\n    }\n    const base = new ImageSource({\n      resource: src,\n      alphaMode: \"premultiply-alpha-on-upload\",\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      ...asset.data\n    });\n    return createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\nexport { loadImageBitmap, loadTextures };\n//# sourceMappingURL=loadTextures.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { WorkerManager } from '../../workers/WorkerManager';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Configuration for the [loadTextures]{@link assets.loadTextures} plugin.\n * @see assets.loadTextures\n * @memberof assets\n */\nexport interface LoadTextureConfig\n{\n    /**\n     * When set to `true`, loading and decoding images will happen with Worker thread,\n     * if available on the browser. This is much more performant as network requests\n     * and decoding can be expensive on the CPU. However, not all environments support\n     * Workers, in some cases it can be helpful to disable by setting to `false`.\n     * @default true\n     */\n    preferWorkers: boolean;\n    /**\n     * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n     * otherwise it will use `new Image()`.\n     * @default true\n     */\n    preferCreateImageBitmap: boolean;\n    /**\n     * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n}\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n * @ignore\n */\nexport async function loadImageBitmap(url: string): Promise<ImageBitmap>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n    const imageBitmap = await createImageBitmap(imageBlob);\n\n    return imageBitmap;\n}\n\n/**\n * A simple plugin to load our textures!\n * This makes use of imageBitmaps where available.\n * We load the `ImageBitmap` on a different thread using workers if possible.\n * We can then use the `ImageBitmap` as a source for a Pixi texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * Which can be found [here]{@link assets.LoadTextureConfig}\n * ```js\n * // Set the config\n * import { loadTextures } from 'pixi.js';\n *\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap,\n *    // we'll also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @memberof assets\n */\nexport const loadTextures = {\n\n    name: 'loadTextures',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: 'anonymous',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: ResolvedAsset<TextureSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url);\n            }\n            else\n            {\n                src = await loadImageBitmap(url);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve) =>\n            {\n                src = new Image();\n                src.crossOrigin = this.config.crossOrigin;\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                }\n            });\n        }\n\n        const base = new ImageSource({\n            resource: src,\n            alphaMode: 'premultiply-alpha-on-upload',\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, TextureSourceOptions, LoadTextureConfig>;\n","import WorkerInstance from '../../../_virtual/checkImageBitmap.worker.mjs';\nimport WorkerInstance$1 from '../../../_virtual/loadImageBitmap.worker.mjs';\n\n\"use strict\";\nlet UUID = 0;\nlet MAX_WORKERS;\nclass WorkerManagerClass {\n  constructor() {\n    this._initialized = false;\n    this._createdWorkers = 0;\n    this._workerPool = [];\n    this._queue = [];\n    this._resolveHash = {};\n  }\n  isImageBitmapSupported() {\n    if (this._isImageBitmapSupported !== void 0)\n      return this._isImageBitmapSupported;\n    this._isImageBitmapSupported = new Promise((resolve) => {\n      const { worker } = new WorkerInstance();\n      worker.addEventListener(\"message\", (event) => {\n        worker.terminate();\n        WorkerInstance.revokeObjectURL();\n        resolve(event.data);\n      });\n    });\n    return this._isImageBitmapSupported;\n  }\n  loadImageBitmap(src) {\n    return this._run(\"loadImageBitmap\", [src]);\n  }\n  async _initWorkers() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n  }\n  _getWorker() {\n    if (MAX_WORKERS === void 0) {\n      MAX_WORKERS = navigator.hardwareConcurrency || 4;\n    }\n    let worker = this._workerPool.pop();\n    if (!worker && this._createdWorkers < MAX_WORKERS) {\n      this._createdWorkers++;\n      worker = new WorkerInstance$1().worker;\n      worker.addEventListener(\"message\", (event) => {\n        this._complete(event.data);\n        this._returnWorker(event.target);\n        this._next();\n      });\n    }\n    return worker;\n  }\n  _returnWorker(worker) {\n    this._workerPool.push(worker);\n  }\n  _complete(data) {\n    if (data.error !== void 0) {\n      this._resolveHash[data.uuid].reject(data.error);\n    } else {\n      this._resolveHash[data.uuid].resolve(data.data);\n    }\n    this._resolveHash[data.uuid] = null;\n  }\n  async _run(id, args) {\n    await this._initWorkers();\n    const promise = new Promise((resolve, reject) => {\n      this._queue.push({ id, arguments: args, resolve, reject });\n    });\n    this._next();\n    return promise;\n  }\n  _next() {\n    if (!this._queue.length)\n      return;\n    const worker = this._getWorker();\n    if (!worker) {\n      return;\n    }\n    const toDo = this._queue.pop();\n    const id = toDo.id;\n    this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n    worker.postMessage({\n      data: toDo.arguments,\n      uuid: UUID++,\n      id\n    });\n  }\n}\nconst WorkerManager = new WorkerManagerClass();\n\nexport { WorkerManager };\n//# sourceMappingURL=WorkerManager.mjs.map\n","import CheckImageBitmapWorker from 'worker:./checkImageBitmap.worker.ts';\nimport LoadImageBitmapWorker from 'worker:./loadImageBitmap.worker.ts';\n\nlet UUID = 0;\nlet MAX_WORKERS: number;\n\ntype LoadImageBitmapResult = {\n    data?: ImageBitmap,\n    error?: Error,\n    uuid: number,\n    id: string,\n};\n\nclass WorkerManagerClass\n{\n    public worker: Worker;\n    private _resolveHash: {\n        [key: string]: {\n            resolve: (...param: any[]) => void;\n            reject: (...param: any[]) => void;\n        }\n    };\n    private readonly _workerPool: Worker[];\n    private readonly _queue: {\n        id: string;\n        arguments: any[];\n        resolve: (...param: any[]) => void;\n        reject: (...param: any[]) => void;\n    }[];\n    private _initialized = false;\n    private _createdWorkers = 0;\n    private _isImageBitmapSupported?: Promise<boolean>;\n\n    constructor()\n    {\n        this._workerPool = [];\n        this._queue = [];\n\n        this._resolveHash = {};\n    }\n\n    public isImageBitmapSupported(): Promise<boolean>\n    {\n        if (this._isImageBitmapSupported !== undefined) return this._isImageBitmapSupported;\n\n        this._isImageBitmapSupported = new Promise((resolve) =>\n        {\n            const { worker } = new CheckImageBitmapWorker();\n\n            worker.addEventListener('message', (event: MessageEvent<boolean>) =>\n            {\n                worker.terminate();\n                CheckImageBitmapWorker.revokeObjectURL();\n                resolve(event.data);\n            });\n        });\n\n        return this._isImageBitmapSupported;\n    }\n\n    public loadImageBitmap(src: string): Promise<ImageBitmap>\n    {\n        return this._run('loadImageBitmap', [src]) as Promise<ImageBitmap>;\n    }\n\n    private async _initWorkers()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n    }\n\n    private _getWorker(): Worker\n    {\n        if (MAX_WORKERS === undefined)\n        {\n            MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        }\n        let worker = this._workerPool.pop();\n\n        if (!worker && this._createdWorkers < MAX_WORKERS)\n        {\n            // only create as many as MAX_WORKERS allows..\n            this._createdWorkers++;\n            worker = new LoadImageBitmapWorker().worker;\n\n            worker.addEventListener('message', (event: MessageEvent) =>\n            {\n                this._complete(event.data);\n\n                this._returnWorker(event.target as Worker);\n                this._next();\n            });\n        }\n\n        return worker;\n    }\n\n    private _returnWorker(worker: Worker)\n    {\n        this._workerPool.push(worker);\n    }\n\n    private _complete(data: LoadImageBitmapResult): void\n    {\n        if (data.error !== undefined)\n        {\n            this._resolveHash[data.uuid].reject(data.error);\n        }\n        else\n        {\n            this._resolveHash[data.uuid].resolve(data.data);\n        }\n\n        this._resolveHash[data.uuid] = null;\n    }\n\n    private async _run(id: string, args: any[]): Promise<any>\n    {\n        await this._initWorkers();\n        // push into the queue...\n\n        const promise = new Promise((resolve, reject) =>\n        {\n            this._queue.push({ id, arguments: args, resolve, reject });\n        });\n\n        this._next();\n\n        return promise;\n    }\n\n    private _next(): void\n    {\n        // nothing to do\n        if (!this._queue.length) return;\n\n        const worker = this._getWorker();\n\n        // no workers available...\n        if (!worker)\n        {\n            return;\n        }\n\n        const toDo = this._queue.pop();\n\n        const id = toDo.id;\n\n        this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: UUID++,\n            id,\n        });\n    }\n}\n\nconst WorkerManager = new WorkerManagerClass();\n\nexport {\n    WorkerManager,\n};\n","const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    const WHITE_PNG = \\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\\\";\\n    async function checkImageBitmap() {\\n      try {\\n        if (typeof createImageBitmap !== \\\"function\\\")\\n          return false;\\n        const response = await fetch(WHITE_PNG);\\n        const imageBlob = await response.blob();\\n        const imageBitmap = await createImageBitmap(imageBlob);\\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\\n      } catch (e) {\\n        return false;\\n      }\\n    }\\n    void checkImageBitmap().then((result) => {\\n      self.postMessage(result);\\n    });\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=checkImageBitmap.worker.mjs.map\n","const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    async function loadImageBitmap(url) {\\n      const response = await fetch(url);\\n      if (!response.ok) {\\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\\n      }\\n      const imageBlob = await response.blob();\\n      const imageBitmap = await createImageBitmap(imageBlob);\\n      return imageBitmap;\\n    }\\n    self.onmessage = async (event) => {\\n      try {\\n        const imageBitmap = await loadImageBitmap(event.data.data[0]);\\n        self.postMessage({\\n          data: imageBitmap,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        }, [imageBitmap]);\\n      } catch (e) {\\n        self.postMessage({\\n          error: e,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        });\\n      }\\n    };\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=loadImageBitmap.worker.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource.mjs';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validVideoExtensions = [\".mp4\", \".m4v\", \".webm\", \".ogg\", \".ogv\", \".h264\", \".avi\", \".mov\"];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\nfunction crossOrigin(element, url, crossorigin) {\n  if (crossorigin === void 0 && !url.startsWith(\"data:\")) {\n    element.crossOrigin = determineCrossOrigin(url);\n  } else if (crossorigin !== false) {\n    element.crossOrigin = typeof crossorigin === \"string\" ? crossorigin : \"anonymous\";\n  }\n}\nfunction preloadVideo(element) {\n  return new Promise((resolve, reject) => {\n    element.addEventListener(\"canplaythrough\", loaded);\n    element.addEventListener(\"error\", error);\n    element.load();\n    function loaded() {\n      cleanup();\n      resolve();\n    }\n    function error(err) {\n      cleanup();\n      reject(err);\n    }\n    function cleanup() {\n      element.removeEventListener(\"canplaythrough\", loaded);\n      element.removeEventListener(\"error\", error);\n    }\n  });\n}\nfunction determineCrossOrigin(url, loc = globalThis.location) {\n  if (url.startsWith(\"data:\")) {\n    return \"\";\n  }\n  loc = loc || globalThis.location;\n  const parsedUrl = new URL(url, document.baseURI);\n  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {\n    return \"anonymous\";\n  }\n  return \"\";\n}\nconst loadVideoTextures = {\n  name: \"loadVideo\",\n  extension: {\n    type: ExtensionType.LoadParser\n  },\n  config: null,\n  test(url) {\n    const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n    const isValidExtension = checkExtension(url, validVideoExtensions);\n    return isValidDataUrl || isValidExtension;\n  },\n  async load(url, asset, loader) {\n    const options = {\n      ...VideoSource.defaultOptions,\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n      ...asset.data\n    };\n    const videoElement = document.createElement(\"video\");\n    const attributeMap = {\n      preload: options.autoLoad !== false ? \"auto\" : void 0,\n      \"webkit-playsinline\": options.playsinline !== false ? \"\" : void 0,\n      playsinline: options.playsinline !== false ? \"\" : void 0,\n      muted: options.muted === true ? \"\" : void 0,\n      loop: options.loop === true ? \"\" : void 0,\n      autoplay: options.autoPlay !== false ? \"\" : void 0\n    };\n    Object.keys(attributeMap).forEach((key) => {\n      const value = attributeMap[key];\n      if (value !== void 0)\n        videoElement.setAttribute(key, value);\n    });\n    if (options.muted === true) {\n      videoElement.muted = true;\n    }\n    crossOrigin(videoElement, url, options.crossorigin);\n    const sourceElement = document.createElement(\"source\");\n    let mime;\n    if (url.startsWith(\"data:\")) {\n      mime = url.slice(5, url.indexOf(\";\"));\n    } else if (!url.startsWith(\"blob:\")) {\n      const ext = url.split(\"?\")[0].slice(url.lastIndexOf(\".\") + 1).toLowerCase();\n      mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n    }\n    sourceElement.src = url;\n    if (mime) {\n      sourceElement.type = mime;\n    }\n    return new Promise((resolve) => {\n      const onCanPlay = async () => {\n        const base = new VideoSource({ ...options, resource: videoElement });\n        videoElement.removeEventListener(\"canplay\", onCanPlay);\n        if (asset.data.preload) {\n          await preloadVideo(videoElement);\n        }\n        resolve(createTexture(base, loader, url));\n      };\n      videoElement.addEventListener(\"canplay\", onCanPlay);\n      videoElement.appendChild(sourceElement);\n    });\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\nexport { crossOrigin, determineCrossOrigin, loadVideoTextures, preloadVideo };\n//# sourceMappingURL=loadVideoTextures.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { VideoSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validVideoExtensions = ['.mp4', '.m4v', '.webm', '.ogg', '.ogv', '.h264', '.avi', '.mov'];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\n\n/**\n * Set cross origin based detecting the url and the crossorigin\n * @param element - Element to apply crossOrigin\n * @param url - URL to check\n * @param crossorigin - Cross origin value to use\n * @memberof assets\n */\nexport function crossOrigin(element: HTMLImageElement | HTMLVideoElement, url: string, crossorigin?: boolean | string): void\n{\n    if (crossorigin === undefined && !url.startsWith('data:'))\n    {\n        element.crossOrigin = determineCrossOrigin(url);\n    }\n    else if (crossorigin !== false)\n    {\n        element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n    }\n}\n\n/**\n * Preload a video element\n * @param element - Video element to preload\n */\nexport function preloadVideo(element: HTMLVideoElement): Promise<void>\n{\n    return new Promise((resolve, reject) =>\n    {\n        element.addEventListener('canplaythrough', loaded);\n        element.addEventListener('error', error);\n\n        element.load();\n\n        function loaded(): void\n        {\n            cleanup();\n            resolve();\n        }\n\n        function error(err: ErrorEvent): void\n        {\n            cleanup();\n            reject(err);\n        }\n\n        function cleanup(): void\n        {\n            element.removeEventListener('canplaythrough', loaded);\n            element.removeEventListener('error', error);\n        }\n    });\n}\n\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n * Nipped from the resource loader!\n * @ignore\n * @param url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @returns The crossOrigin value to use (or empty string for none).\n * @memberof assets\n */\nexport function determineCrossOrigin(url: string, loc: Location = globalThis.location): string\n{\n    // data: and javascript: urls are considered same-origin\n    if (url.startsWith('data:'))\n    {\n        return '';\n    }\n\n    // default is window.location\n    loc = loc || globalThis.location;\n\n    const parsedUrl = new URL(url, document.baseURI);\n\n    // if cross origin\n    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol)\n    {\n        return 'anonymous';\n    }\n\n    return '';\n}\n\n/**\n * A simple plugin to load video textures.\n *\n * You can pass VideoSource options to the loader via the .data property of the asset descriptor\n * when using Asset.load().\n * ```js\n * // Set the data\n * const texture = await Assets.load({\n *     src: './assets/city.mp4',\n *     data: {\n *         preload: true,\n *         autoPlay: true,\n *     },\n * });\n * ```\n * @memberof assets\n */\nexport const loadVideoTextures = {\n\n    name: 'loadVideo',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n    },\n\n    config: null,\n\n    test(url: string): boolean\n    {\n        const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n        const isValidExtension = checkExtension(url, validVideoExtensions);\n\n        return isValidDataUrl || isValidExtension;\n    },\n\n    async load(url: string, asset: ResolvedAsset<VideoSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        // --- Merge default and provided options ---\n        const options: VideoSourceOptions = {\n            ...VideoSource.defaultOptions,\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n            ...asset.data,\n        };\n\n        // --- Create and configure HTMLVideoElement ---\n        const videoElement = document.createElement('video');\n\n        // Set attributes based on options\n        const attributeMap = {\n            preload: options.autoLoad !== false ? 'auto' : undefined,\n            'webkit-playsinline': options.playsinline !== false ? '' : undefined,\n            playsinline: options.playsinline !== false ? '' : undefined,\n            muted: options.muted === true ? '' : undefined,\n            loop: options.loop === true ? '' : undefined,\n            autoplay: options.autoPlay !== false ? '' : undefined\n        };\n\n        Object.keys(attributeMap).forEach((key) =>\n        {\n            const value = attributeMap[key as keyof typeof attributeMap];\n\n            if (value !== undefined) videoElement.setAttribute(key, value);\n        });\n\n        if (options.muted === true)\n        {\n            videoElement.muted = true;\n        }\n\n        crossOrigin(videoElement, url, options.crossorigin); // Assume crossOrigin is globally available\n\n        // --- Set up source and MIME type ---\n        const sourceElement = document.createElement('source');\n\n        // Determine MIME type\n        let mime: string | undefined;\n\n        if (url.startsWith('data:'))\n        {\n            mime = url.slice(5, url.indexOf(';'));\n        }\n        else if (!url.startsWith('blob:'))\n        {\n            const ext = url.split('?')[0].slice(url.lastIndexOf('.') + 1).toLowerCase();\n\n            mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n        }\n\n        sourceElement.src = url;\n\n        if (mime)\n        {\n            sourceElement.type = mime;\n        }\n\n        // this promise will make sure that video is ready to play - as in we have a valid width, height and it can be\n        // uploaded to the GPU. Our textures are kind of dumb now, and don't want to handle resizing right now.\n        return new Promise((resolve) =>\n        {\n            const onCanPlay = async () =>\n            {\n                const base = new VideoSource({ ...options, resource: videoElement });\n\n                videoElement.removeEventListener('canplay', onCanPlay);\n\n                if (asset.data.preload)\n                {\n                    await preloadVideo(videoElement);\n                }\n\n                resolve(createTexture(base, loader, url));\n            };\n\n            videoElement.addEventListener('canplay', onCanPlay);\n            videoElement.appendChild(sourceElement);\n        });\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, VideoSourceOptions, null>;\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Resolver } from '../Resolver.mjs';\nimport { resolveTextureUrl } from './resolveTextureUrl.mjs';\n\n\"use strict\";\nconst resolveJsonUrl = {\n  extension: ExtensionType.ResolveParser,\n  test: (value) => Resolver.RETINA_PREFIX.test(value) && value.endsWith(\".json\"),\n  parse: resolveTextureUrl.parse\n};\n\nexport { resolveJsonUrl };\n//# sourceMappingURL=resolveJsonUrl.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Resolver } from '../Resolver';\nimport { resolveTextureUrl } from './resolveTextureUrl';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a json urls resolution for spritesheets\n * e.g. `assets/spritesheet@1x.json`\n * @memberof assets\n */\nexport const resolveJsonUrl = {\n    extension: ExtensionType.ResolveParser,\n    test: (value: string): boolean =>\n        Resolver.RETINA_PREFIX.test(value) && value.endsWith('.json'),\n    parse: resolveTextureUrl.parse,\n} as ResolveURLParser;\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { loadTextures } from '../../loader/parsers/textures/loadTextures.mjs';\nimport { Resolver } from '../Resolver.mjs';\n\n\"use strict\";\nconst resolveTextureUrl = {\n  extension: ExtensionType.ResolveParser,\n  test: loadTextures.test,\n  parse: (value) => ({\n    resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n    format: value.split(\".\").pop(),\n    src: value\n  })\n};\n\nexport { resolveTextureUrl };\n//# sourceMappingURL=resolveTextureUrl.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { loadTextures } from '../../loader/parsers/textures/loadTextures';\nimport { Resolver } from '../Resolver';\n\nimport type { UnresolvedAsset } from '../../types';\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a texture url\n * @memberof assets\n */\nexport const resolveTextureUrl = {\n    extension: ExtensionType.ResolveParser,\n    test: loadTextures.test,\n    parse: (value: string): UnresolvedAsset =>\n        ({\n            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n            format: value.split('.').pop(),\n            src: value,\n        }),\n} as ResolveURLParser;\n","import { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { Container } from '../container/Container.mjs';\nimport { NineSliceGeometry } from './NineSliceGeometry.mjs';\n\n\"use strict\";\nconst _NineSliceSprite = class _NineSliceSprite extends Container {\n  /**\n   * @param {scene.NineSliceSpriteOptions|Texture} options - Options to use\n   * @param options.texture - The texture to use on the NineSliceSprite.\n   * @param options.leftWidth - Width of the left vertical bar (A)\n   * @param options.topHeight - Height of the top horizontal bar (C)\n   * @param options.rightWidth - Width of the right vertical bar (B)\n   * @param options.bottomHeight - Height of the bottom horizontal bar (D)\n   * @param options.width - Width of the NineSliceSprite,\n   * setting this will actually modify the vertices and not the UV's of this plane.\n   * @param options.height - Height of the NineSliceSprite,\n   * setting this will actually modify the vertices and not UV's of this plane.\n   */\n  constructor(options) {\n    if (options instanceof Texture) {\n      options = { texture: options };\n    }\n    const {\n      width,\n      height,\n      leftWidth,\n      rightWidth,\n      topHeight,\n      bottomHeight,\n      texture,\n      roundPixels,\n      ...rest\n    } = options;\n    super({\n      label: \"NineSliceSprite\",\n      ...rest\n    });\n    this._roundPixels = 0;\n    this.renderPipeId = \"nineSliceSprite\";\n    this.batched = true;\n    this._didSpriteUpdate = true;\n    this.bounds = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\n    this._leftWidth = leftWidth ?? texture?.defaultBorders?.left ?? NineSliceGeometry.defaultOptions.leftWidth;\n    this._topHeight = topHeight ?? texture?.defaultBorders?.top ?? NineSliceGeometry.defaultOptions.topHeight;\n    this._rightWidth = rightWidth ?? texture?.defaultBorders?.right ?? NineSliceGeometry.defaultOptions.rightWidth;\n    this._bottomHeight = bottomHeight ?? texture?.defaultBorders?.bottom ?? NineSliceGeometry.defaultOptions.bottomHeight;\n    this.bounds.maxX = this._width = width ?? texture.width ?? NineSliceGeometry.defaultOptions.width;\n    this.bounds.maxY = this._height = height ?? texture.height ?? NineSliceGeometry.defaultOptions.height;\n    this.allowChildren = false;\n    this.texture = texture ?? _NineSliceSprite.defaultOptions.texture;\n    this.roundPixels = roundPixels ?? false;\n  }\n  /** The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */\n  get width() {\n    return this._width;\n  }\n  set width(value) {\n    this.bounds.maxX = this._width = value;\n    this.onViewUpdate();\n  }\n  /** The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */\n  get height() {\n    return this._height;\n  }\n  set height(value) {\n    this.bounds.maxY = this._height = value;\n    this.onViewUpdate();\n  }\n  /** The width of the left column (a) of the NineSliceSprite. */\n  get leftWidth() {\n    return this._leftWidth;\n  }\n  set leftWidth(value) {\n    this._leftWidth = value;\n    this.onViewUpdate();\n  }\n  /** The width of the right column (b) of the NineSliceSprite. */\n  get topHeight() {\n    return this._topHeight;\n  }\n  set topHeight(value) {\n    this._topHeight = value;\n    this.onViewUpdate();\n  }\n  /** The width of the right column (b) of the NineSliceSprite. */\n  get rightWidth() {\n    return this._rightWidth;\n  }\n  set rightWidth(value) {\n    this._rightWidth = value;\n    this.onViewUpdate();\n  }\n  /** The width of the right column (b) of the NineSliceSprite. */\n  get bottomHeight() {\n    return this._bottomHeight;\n  }\n  set bottomHeight(value) {\n    this._bottomHeight = value;\n    this.onViewUpdate();\n  }\n  /** The texture that the NineSliceSprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /**\n   *  Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /** The original width of the texture */\n  get originalWidth() {\n    return this._texture.width;\n  }\n  /** The original height of the texture */\n  get originalHeight() {\n    return this._texture.height;\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didSpriteUpdate = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    if (this.renderGroup) {\n      this.renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.bounds;\n    if (point.x >= bounds.minX && point.x <= bounds.maxX) {\n      if (point.y >= bounds.minY && point.y <= bounds.maxY) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this.bounds = null;\n  }\n};\n/** The default options, used to override the initial values of any options passed in the constructor. */\n_NineSliceSprite.defaultOptions = {\n  /** @default Texture.EMPTY */\n  texture: Texture.EMPTY\n};\nlet NineSliceSprite = _NineSliceSprite;\nclass NineSlicePlane extends NineSliceSprite {\n  constructor(...args) {\n    let options = args[0];\n    if (options instanceof Texture) {\n      deprecation(v8_0_0, \"NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}\");\n      options = {\n        texture: options,\n        leftWidth: args[1],\n        topHeight: args[2],\n        rightWidth: args[3],\n        bottomHeight: args[4]\n      };\n    }\n    deprecation(v8_0_0, \"NineSlicePlane is deprecated. Use NineSliceSprite instead.\");\n    super(options);\n  }\n}\n\nexport { NineSlicePlane, NineSliceSprite };\n//# sourceMappingURL=NineSliceSprite.mjs.map\n","import { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { Container } from '../container/Container';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { Point } from '../../maths/point/Point';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds, BoundsData } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Constructor options used for `NineSliceSprite` instances.\n * ```js\n * const nineSliceSprite = new NineSliceSprite({\n *    texture: Texture.from('button.png'),\n *    leftWidth: 20,\n *    topHeight: 20,\n *    rightWidth: 20,\n *    bottomHeight: 20,\n * });\n * ```\n * @see {@link scene.NineSliceSprite}\n * @memberof scene\n */\nexport interface NineSliceSpriteOptions extends ContainerOptions\n{\n    /** The texture to use on the NineSliceSprite. */\n    texture: Texture;\n    /** Width of the left vertical bar (A) */\n    leftWidth?: number;\n    /** Height of the top horizontal bar (C) */\n    topHeight?: number;\n    /** Width of the right vertical bar (B) */\n    rightWidth?: number;\n    /** Height of the bottom horizontal bar (D) */\n    bottomHeight?: number;\n    /** Width of the NineSliceSprite, setting this will actually modify the vertices and not the UV's of this plane. */\n    width?: number;\n    /** Height of the NineSliceSprite, setting this will actually modify the vertices and not UV's of this plane. */\n    height?: number;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The NineSliceSprite allows you to stretch a texture using 9-slice scaling. The corners will remain unscaled (useful\n * for buttons with rounded corners for example) and the other areas will be scaled horizontally and or vertically\n *\n * <pre>\n *      A                          B\n *    +---+----------------------+---+\n *  C | 1 |          2           | 3 |\n *    +---+----------------------+---+\n *    |   |                      |   |\n *    | 4 |          5           | 6 |\n *    |   |                      |   |\n *    +---+----------------------+---+\n *  D | 7 |          8           | 9 |\n *    +---+----------------------+---+\n *  When changing this objects width and/or height:\n *     areas 1 3 7 and 9 will remain unscaled.\n *     areas 2 and 8 will be stretched horizontally\n *     areas 4 and 6 will be stretched vertically\n *     area 5 will be stretched both horizontally and vertically\n * </pre>\n * @example\n * import { NineSliceSprite, Texture } from 'pixi.js';\n *\n * const plane9 = new NineSliceSprite(Texture.from('BoxWithRoundedCorners.png'), 15, 15, 15, 15);\n * @memberof scene\n */\nexport class NineSliceSprite extends Container implements View\n{\n    /** The default options, used to override the initial values of any options passed in the constructor. */\n    public static defaultOptions: NineSliceSpriteOptions = {\n        /** @default Texture.EMPTY */\n        texture: Texture.EMPTY,\n    };\n\n    public _roundPixels: 0 | 1 = 0;\n    public readonly renderPipeId = 'nineSliceSprite';\n    public _texture: Texture;\n\n    public batched = true;\n\n    private _leftWidth: number;\n    private _topHeight: number;\n    private _rightWidth: number;\n    private _bottomHeight: number;\n    private _width: number;\n    private _height: number;\n\n    public _didSpriteUpdate = true;\n\n    public bounds: BoundsData = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\n\n    /**\n     * @param {scene.NineSliceSpriteOptions|Texture} options - Options to use\n     * @param options.texture - The texture to use on the NineSliceSprite.\n     * @param options.leftWidth - Width of the left vertical bar (A)\n     * @param options.topHeight - Height of the top horizontal bar (C)\n     * @param options.rightWidth - Width of the right vertical bar (B)\n     * @param options.bottomHeight - Height of the bottom horizontal bar (D)\n     * @param options.width - Width of the NineSliceSprite,\n     * setting this will actually modify the vertices and not the UV's of this plane.\n     * @param options.height - Height of the NineSliceSprite,\n     * setting this will actually modify the vertices and not UV's of this plane.\n     */\n    constructor(options: NineSliceSpriteOptions | Texture)\n    {\n        if ((options instanceof Texture))\n        {\n            options = { texture: options };\n        }\n\n        const {\n            width,\n            height,\n            leftWidth,\n            rightWidth,\n            topHeight,\n            bottomHeight,\n            texture,\n            roundPixels,\n            ...rest\n        } = options;\n\n        super({\n            label: 'NineSliceSprite',\n            ...rest\n        });\n\n        this._leftWidth = leftWidth ?? texture?.defaultBorders?.left ?? NineSliceGeometry.defaultOptions.leftWidth;\n        this._topHeight = topHeight ?? texture?.defaultBorders?.top ?? NineSliceGeometry.defaultOptions.topHeight;\n        this._rightWidth = rightWidth ?? texture?.defaultBorders?.right ?? NineSliceGeometry.defaultOptions.rightWidth;\n        this._bottomHeight = bottomHeight\n                            ?? texture?.defaultBorders?.bottom\n                            ?? NineSliceGeometry.defaultOptions.bottomHeight;\n        this.bounds.maxX = this._width = width ?? texture.width ?? NineSliceGeometry.defaultOptions.width;\n        this.bounds.maxY = this._height = height ?? texture.height ?? NineSliceGeometry.defaultOptions.height;\n\n        this.allowChildren = false;\n        this.texture = texture ?? NineSliceSprite.defaultOptions.texture;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /** The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */\n    get width(): number\n    {\n        return this._width;\n    }\n\n    set width(value: number)\n    {\n        this.bounds.maxX = this._width = value;\n        this.onViewUpdate();\n    }\n\n    /** The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */\n    get height(): number\n    {\n        return this._height;\n    }\n\n    set height(value: number)\n    {\n        this.bounds.maxY = this._height = value;\n        this.onViewUpdate();\n    }\n\n    /** The width of the left column (a) of the NineSliceSprite. */\n    get leftWidth(): number\n    {\n        return this._leftWidth;\n    }\n\n    set leftWidth(value: number)\n    {\n        this._leftWidth = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The width of the right column (b) of the NineSliceSprite. */\n    get topHeight(): number\n    {\n        return this._topHeight;\n    }\n\n    set topHeight(value: number)\n    {\n        this._topHeight = value;\n        this.onViewUpdate();\n    }\n\n    /** The width of the right column (b) of the NineSliceSprite. */\n    get rightWidth(): number\n    {\n        return this._rightWidth;\n    }\n\n    set rightWidth(value: number)\n    {\n        this._rightWidth = value;\n        this.onViewUpdate();\n    }\n\n    /** The width of the right column (b) of the NineSliceSprite. */\n    get bottomHeight(): number\n    {\n        return this._bottomHeight;\n    }\n\n    set bottomHeight(value: number)\n    {\n        this._bottomHeight = value;\n        this.onViewUpdate();\n    }\n\n    /** The texture that the NineSliceSprite is using. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /** The original width of the texture */\n    get originalWidth()\n    {\n        return this._texture.width;\n    }\n\n    /** The original height of the texture */\n    get originalHeight()\n    {\n        return this._texture.height;\n    }\n\n    public onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n        this._didSpriteUpdate = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.bounds;\n\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: Point)\n    {\n        const bounds = this.bounds;\n\n        if (point.x >= bounds.minX && point.x <= bounds.maxX)\n        {\n            if (point.y >= bounds.minY && point.y <= bounds.maxY)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this.bounds as null) = null;\n    }\n}\n\n/**\n * Please use the `NineSliceSprite` class instead.\n * @deprecated since 8.0.0\n * @memberof scene\n */\nexport class NineSlicePlane extends NineSliceSprite\n{\n    constructor(options: NineSliceSpriteOptions | Texture);\n    /** @deprecated since 8.0.0 */\n    constructor(texture: Texture, leftWidth: number, topHeight: number, rightWidth: number, bottomHeight: number);\n    constructor(...args: [NineSliceSpriteOptions | Texture] | [Texture, number, number, number, number])\n    {\n        let options = args[0];\n\n        if (options instanceof Texture)\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}');\n            // #endif\n\n            options = {\n                texture: options,\n                leftWidth: args[1],\n                topHeight: args[2],\n                rightWidth: args[3],\n                bottomHeight: args[4],\n            };\n        }\n\n        // #if _DEBUG\n        deprecation(v8_0_0, 'NineSlicePlane is deprecated. Use NineSliceSprite instead.');\n        // #endif\n\n        super(options);\n    }\n}\n","import { AbstractText, ensureOptions } from './AbstractText.mjs';\nimport { CanvasTextMetrics } from './canvas/CanvasTextMetrics.mjs';\nimport { TextStyle } from './TextStyle.mjs';\n\n\"use strict\";\nclass Text extends AbstractText {\n  constructor(...args) {\n    const options = ensureOptions(args, \"Text\");\n    super(options, TextStyle);\n    this.renderPipeId = \"text\";\n  }\n  _updateBounds() {\n    const bounds = this._bounds;\n    const padding = this._style.padding;\n    const anchor = this._anchor;\n    const canvasMeasurement = CanvasTextMetrics.measureText(\n      this._text,\n      this._style\n    );\n    const { width, height } = canvasMeasurement;\n    bounds.minX = -anchor._x * width - padding;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height - padding;\n    bounds.maxY = bounds.minY + height;\n  }\n}\n\nexport { Text };\n//# sourceMappingURL=Text.mjs.map\n","import { AbstractText, ensureOptions } from './AbstractText';\nimport { CanvasTextMetrics } from './canvas/CanvasTextMetrics';\nimport { TextStyle } from './TextStyle';\n\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { TextOptions, TextString } from './AbstractText';\nimport type { TextStyleOptions } from './TextStyle';\n\n/**\n * A Text Object will create a line or multiple lines of text.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and givae the `wordWrapWidth` property a value.\n *\n * The primary advantage of this class over BitmapText is that you have great control over the style of the text,\n * which you can change at runtime.\n *\n * The primary disadvantages is that each piece of text has it's own texture, which can use more memory.\n * When text changes, this texture has to be re-generated and re-uploaded to the GPU, taking up time.\n * @example\n * import { Text } from 'pixi.js';\n *\n * const text = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n * @memberof scene\n */\nexport class Text\n    extends AbstractText<TextStyle, TextStyleOptions>\n    implements View\n{\n    public readonly renderPipeId: string = 'text';\n\n    /**\n     * @param {text.TextOptions} options - The options of the text.\n     */\n    constructor(options?: TextOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(text?: TextString, options?: Partial<TextStyle>);\n    constructor(...args: [TextOptions?] | [TextString, Partial<TextStyle>])\n    {\n        const options = ensureOptions(args, 'Text');\n\n        super(options, TextStyle);\n    }\n\n    protected _updateBounds()\n    {\n        const bounds = this._bounds;\n        const padding = this._style.padding;\n        const anchor = this._anchor;\n\n        const canvasMeasurement = CanvasTextMetrics.measureText(\n            this._text,\n            this._style\n        );\n\n        const { width, height } = canvasMeasurement;\n\n        bounds.minX = (-anchor._x * width) - padding;\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = (-anchor._y * height) - padding;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n","import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { Bounds } from '../container/bounds/Bounds.mjs';\nimport { Container } from '../container/Container.mjs';\n\n\"use strict\";\nclass AbstractText extends Container {\n  constructor(options, styleClass) {\n    const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n    super({\n      ...rest\n    });\n    this.batched = true;\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * @default 1\n     */\n    this.resolution = null;\n    this._didTextUpdate = true;\n    this._roundPixels = 0;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n    this._styleClass = styleClass;\n    this.text = text ?? \"\";\n    this.style = style;\n    this.resolution = resolution ?? null;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor)\n      this.anchor = anchor;\n    this.roundPixels = roundPixels ?? false;\n    if (width)\n      this.width = width;\n    if (height)\n      this.height = height;\n  }\n  /**\n   * The anchor sets the origin point of the text.\n   * The default is `(0,0)`, this means the text's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Text } from 'pixi.js';\n   *\n   * const text = new Text('hello world');\n   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   *  Whether or not to round the x/y position of the text.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /** Set the copy for the text object. To split a line you can use '\\n'. */\n  set text(value) {\n    value = value.toString();\n    if (this._text === value)\n      return;\n    this._text = value;\n    this.onViewUpdate();\n  }\n  get text() {\n    return this._text;\n  }\n  get style() {\n    return this._style;\n  }\n  /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n   * @type {\n   * text.TextStyle |\n   * Partial<text.TextStyle> |\n   * text.TextStyleOptions |\n   * text.HTMLTextStyle |\n   * Partial<text.HTMLTextStyle> |\n   * text.HTMLTextStyleOptions\n   * }\n   */\n  set style(style) {\n    style = style || {};\n    this._style?.off(\"update\", this.onViewUpdate, this);\n    if (style instanceof this._styleClass) {\n      this._style = style;\n    } else {\n      this._style = new this._styleClass(style);\n    }\n    this._style.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The local bounds of the Text.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this.bounds.width;\n  }\n  set width(value) {\n    this._setWidth(value, this.bounds.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this.bounds.height;\n  }\n  set height(value) {\n    this._setHeight(value, this.bounds.height);\n  }\n  /**\n   * Retrieves the size of the Text as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Text.\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    out.width = Math.abs(this.scale.x) * this.bounds.width;\n    out.height = Math.abs(this.scale.y) * this.bounds.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Text to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== \"object\") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, this.bounds.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, this.bounds.height);\n    }\n  }\n  /**\n   * Adds the bounds of this text to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this.bounds;\n    bounds.addFrame(\n      _bounds.minX,\n      _bounds.minY,\n      _bounds.maxX,\n      _bounds.maxY\n    );\n  }\n  /**\n   * Checks if the text contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const width = this.bounds.maxX;\n    const height = this.bounds.maxY;\n    const x1 = -width * this.anchor.x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (point.y >= y1 && point.y <= y1 + height)\n        return true;\n    }\n    return false;\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._boundsDirty = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    this._didTextUpdate = true;\n    if (this.renderGroup) {\n      this.renderGroup.onChildViewUpdate(this);\n    }\n  }\n  _getKey() {\n    return `${this.text}:${this._style.styleKey}`;\n  }\n  /**\n   * Destroys this text renderable and optionally its style texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n   * @param {boolean} [options.style=false] - Should it destroy the style of the text\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this.owner = null;\n    this._bounds = null;\n    this._anchor = null;\n    if (typeof options === \"boolean\" ? options : options?.style) {\n      this._style.destroy(options);\n    }\n    this._style = null;\n    this._text = null;\n  }\n}\nfunction ensureOptions(args, name) {\n  let options = args[0] ?? {};\n  if (typeof options === \"string\" || args[1]) {\n    deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n    options = {\n      text: options,\n      style: args[1]\n    };\n  }\n  return options;\n}\n\nexport { AbstractText, ensureOptions };\n//# sourceMappingURL=AbstractText.mjs.map\n","import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { Bounds } from '../container/bounds/Bounds';\nimport { Container } from '../container/Container';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../text-html/HtmlTextStyle';\nimport type { TextStyle, TextStyleOptions } from './TextStyle';\n\n/**\n * A string or number that can be used as text.\n * @memberof text\n */\nexport type TextString = string | number | { toString: () => string };\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * @memberof text\n * @see text.TextStyle\n * @see text.HTMLTextStyle\n */\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * @memberof text\n * @see text.TextStyleOptions\n * @see text.HTMLTextStyleOptions\n */\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n\n/**\n * Options for the {@link scene.Text} class.\n * @example\n * const text = new Text({\n *    text: 'Hello Pixi!',\n *    style: {\n *       fontFamily: 'Arial',\n *       fontSize: 24,\n *    fill: 0xff1010,\n *    align: 'center',\n *  }\n * });\n * @memberof text\n */\nexport interface TextOptions<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends ContainerOptions\n{\n    /** The anchor point of the text. */\n    anchor?: PointData | number;\n    /** The copy for the text object. To split a line you can use '\\n'. */\n    text?: TextString;\n    /** The resolution of the text. */\n    resolution?: number;\n    /**\n     * The text style\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    style?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * An abstract Text class, used by all text type in Pixi. This includes Canvas, HTML, and Bitmap Text.\n * @see scene.Text\n * @see scene.BitmapText\n * @see scene.HTMLText\n * @memberof scene\n */\nexport abstract class AbstractText<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends Container implements View\n{\n    public abstract readonly renderPipeId: string;\n    public batched = true;\n    public _anchor: ObservablePoint;\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * @default 1\n     */\n    public resolution: number = null;\n\n    public _style: TEXT_STYLE;\n    public _didTextUpdate = true;\n    public _roundPixels: 0 | 1 = 0;\n\n    protected _bounds: Bounds = new Bounds();\n    protected _boundsDirty = true;\n    protected _text: string;\n    private readonly _styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE;\n\n    constructor(\n        options: TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>,\n        styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE\n    )\n    {\n        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n\n        super({\n            ...rest\n        });\n\n        this._styleClass = styleClass;\n\n        this.text = text ?? '';\n\n        this.style = style;\n\n        this.resolution = resolution ?? null;\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                },\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width) this.width = width;\n        if (height) this.height = height;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Text } from 'pixi.js';\n     *\n     * const text = new Text('hello world');\n     * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the text.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    set text(value: TextString)\n    {\n        // check its a string\n        value = value.toString();\n\n        if (this._text === value) return;\n\n        this._text = value as string;\n        this.onViewUpdate();\n    }\n\n    get text(): string\n    {\n        return this._text;\n    }\n\n    get style(): TEXT_STYLE\n    {\n        return this._style;\n    }\n\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     *\n     * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    set style(style: TEXT_STYLE | Partial<TEXT_STYLE> | TEXT_STYLE_OPTIONS)\n    {\n        style = style || {};\n\n        this._style?.off('update', this.onViewUpdate, this);\n\n        if (style instanceof this._styleClass)\n        {\n            this._style = style as TEXT_STYLE;\n        }\n        else\n        {\n            this._style = new this._styleClass(style as TEXT_STYLE_OPTIONS);\n        }\n\n        this._style.on('update', this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n\n    /**\n     * The local bounds of the Text.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this.bounds.width);\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this.bounds.height);\n    }\n\n    /**\n     * Retrieves the size of the Text as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Text.\n     */\n    public override getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Text to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        let convertedWidth: number;\n        let convertedHeight: number;\n\n        if (typeof value !== 'object')\n        {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        }\n        else\n        {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n\n        if (convertedWidth !== undefined)\n        {\n            this._setWidth(convertedWidth, this.bounds.width);\n        }\n\n        if (convertedHeight !== undefined)\n        {\n            this._setHeight(convertedHeight, this.bounds.height);\n        }\n    }\n\n    /**\n     * Adds the bounds of this text to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.bounds;\n\n        bounds.addFrame(\n            _bounds.minX,\n            _bounds.minY,\n            _bounds.maxX,\n            _bounds.maxY,\n        );\n    }\n\n    /**\n     * Checks if the text contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const width = this.bounds.maxX;\n        const height = this.bounds.maxY;\n\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    public onViewUpdate()\n    {\n        this._didChangeId += 1 << 12;\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        this._didTextUpdate = true;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    public _getKey(): string\n    {\n        // TODO add a dirty flag...\n        return `${this.text}:${this._style.styleKey}`;\n    }\n\n    protected abstract _updateBounds(): void;\n\n    /**\n     * Destroys this text renderable and optionally its style texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n     * @param {boolean} [options.style=false] - Should it destroy the style of the text\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        super.destroy(options);\n\n        (this as any).owner = null;\n        this._bounds = null;\n        this._anchor = null;\n\n        if (typeof options === 'boolean' ? options : options?.style)\n        {\n            this._style.destroy(options);\n        }\n\n        this._style = null;\n        this._text = null;\n    }\n}\n\nexport function ensureOptions<\n    TEXT_STYLE extends TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions\n>(\n    args: any[],\n    name: string\n): TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>\n{\n    let options = (args[0] ?? {}) as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n\n    // @deprecated\n    if (typeof options === 'string' || args[1])\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n        // #endif\n\n        options = {\n            text: options,\n            style: args[1],\n        } as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n    }\n\n    return options;\n}\n","import { Application } from \"pixi.js\";\nimport { Minigame, MinigameDelegate } from \"./minigames/minigame\";\nimport { FlingMinigame } from \"./minigames/final/flingMinigame\";\nimport { TypingMinigame } from \"./minigames/typingMinigame\";\nimport { RhythmMinigame } from \"./minigames/rhythmMinigame\";\nimport { ScrubMinigame } from \"./minigames/final/scrubMinigame\";\nimport { ShakingMinigame } from \"./minigames/shakingMinigame\";\nimport { ShoppingMinigame } from \"./minigames/final/shoppingMinigame\";\nimport { backgroundLoadMinigameAssets } from \"./minigames/assets\";\nimport { BalancingMinigame } from \"./minigames/balancingMinigame\";\nimport {\n  Interlude,\n  InterludeDelegate,\n  backgroundLoadInterludeAssets,\n} from \"./interlude/interlude\";\nimport { CheckpointOneMinigame } from \"./minigames/final/checkpointOneMinigame\";\nimport { CheckpointTwoMinigame } from \"./minigames/final/checkpointTwoMinigame\";\nimport { CheckpointThreeMinigame } from \"./minigames/final/checkpointThreeMinigame\";\n\nconst MINIGAMES_POOL = new URLSearchParams(window.location.search).get(\"quick\")\n  ? [Minigame]\n  : [\n      TypingMinigame,\n      BalancingMinigame,\n      ShoppingMinigame,\n      ShakingMinigame,\n      RhythmMinigame,\n      ScrubMinigame,\n      FlingMinigame,\n    ];\n\n/** Controls the flow of the game. */\nexport class Controller implements MinigameDelegate, InterludeDelegate {\n  private completedMinigamePhases = 0;\n\n  private minigameQueue: Minigame[] = [];\n  private minigameLoseCount = 0;\n\n  private currentMinigame?: Minigame;\n\n  constructor(private readonly app: Application) {}\n\n  preload() {\n    backgroundLoadInterludeAssets();\n    backgroundLoadMinigameAssets();\n  }\n\n  start() {\n    const intro = new Interlude(this.app, this, 0);\n    intro.start();\n  }\n\n  onMinigameEnd(passed: boolean) {\n    this.currentMinigame!.detach();\n    if (!passed) {\n      this.minigameLoseCount++;\n    } else {\n      this.minigameLoseCount = 0;\n    }\n\n    if (this.minigameLoseCount > 1) {\n      // Player has run out of chances to proceed to the next phase.\n      console.log(\"You lose!\");\n      return;\n    }\n\n    if (this.minigameQueue.length === 0) {\n      this.completedMinigamePhases++;\n      this.minigameLoseCount = 0;\n    }\n\n    if (this.completedMinigamePhases >= 3) {\n      // Trigger end game loop.\n      this.startNextInterlude();\n      return;\n    }\n\n    if (this.minigameQueue.length === 0) {\n      // Trigger check point and go around again.\n      this.currentMinigame =\n        this.completedMinigamePhases === 1\n          ? new CheckpointOneMinigame(\n              this.app,\n              this,\n              this.completedMinigamePhases,\n            )\n          : new CheckpointTwoMinigame(\n              this.app,\n              this,\n              this.completedMinigamePhases,\n            );\n      this.currentMinigame.attach(); // No await.\n      this.populateMinigameQueue();\n    } else {\n      this.startNextMinigame();\n    }\n  }\n\n  onInterludeEnd() {\n    if (this.completedMinigamePhases === 3) {\n      this.currentMinigame = new CheckpointThreeMinigame(\n        this.app,\n        this,\n        this.completedMinigamePhases,\n      );\n      this.currentMinigame.attach(); // No await.\n\n      return;\n    }\n\n    if (this.completedMinigamePhases > 3) {\n      console.log(\"The end!\");\n      return;\n    }\n\n    this.populateMinigameQueue();\n    this.startNextMinigame();\n  }\n\n  private populateMinigameQueue() {\n    // Reset the current queue.\n    this.minigameQueue.length = 0;\n    for (let i = 0; i < MINIGAMES_POOL.length; i++) {\n      const minigame = new MINIGAMES_POOL[i](\n        this.app,\n        this,\n        this.completedMinigamePhases,\n      );\n      this.minigameQueue.push(minigame);\n    }\n  }\n\n  private startNextMinigame() {\n    this.currentMinigame = this.minigameQueue.shift();\n    this.currentMinigame.attach(); // No await.\n  }\n\n  private startNextInterlude() {\n    const interlude = new Interlude(\n      this.app,\n      this,\n      this.completedMinigamePhases,\n    );\n    interlude.start();\n  }\n}\n","import { Application, Container, Graphics, Ticker } from \"pixi.js\";\n\nexport interface MinigameDelegate {\n  onMinigameEnd: (passed: boolean) => void;\n}\n\nconst CLOCK_PADDING = 16;\nconst CLOCK_RADIUS = 16;\n\n/** Base class for all minigames to extend. */\nexport class Minigame {\n  protected container: Container;\n  /**\n   * How long this minigame should go for before timing out\n   * and failing the player. In milliseconds. Set to\n   * undefined for a minigame with no time limit.\n   */\n  protected lifetime = 10_000;\n  protected cumulativeMS = 0;\n  protected ticker: Ticker;\n\n  private clock: Graphics;\n  private clockArc: Graphics;\n  protected succeedOnTimeout: boolean = false;\n\n  constructor(\n    protected readonly app: Application,\n    protected readonly delegate: MinigameDelegate,\n    /** Uses zero indexing (0 === first week). */\n    protected readonly week: number,\n  ) {\n    this.container = new Container();\n\n    this.clock = new Graphics();\n    this.clock.zIndex = 9999998;\n    this.clockArc = new Graphics();\n    this.clockArc.zIndex = 9999999;\n    this.clock.fillStyle = \"#f0cfbb\";\n    this.clock.circle(\n      CLOCK_PADDING + CLOCK_RADIUS,\n      this.app.screen.height - CLOCK_PADDING - CLOCK_RADIUS,\n      CLOCK_RADIUS,\n    );\n    this.clock.fill();\n  }\n\n  async attach() {\n    this.ticker = new Ticker();\n    if (this.lifetime !== undefined) {\n      this.ticker.add(() => void this.onTick());\n      this.app.stage.addChild(this.clock);\n    }\n    this.ticker.start();\n\n    await this.populateContainer();\n    this.app.stage.addChild(this.container);\n  }\n\n  detach() {\n    this.ticker?.destroy();\n    this.ticker = null;\n    this.app.stage.removeChild(this.container);\n    if (this.lifetime !== undefined) {\n      this.app.stage.removeChild(this.clock);\n      this.app.stage.removeChild(this.clockArc);\n    }\n  }\n\n  protected async populateContainer() {\n    const square = new Graphics();\n    const x = (this.app.screen.width - 100) * Math.random();\n    const y = (this.app.screen.height - 100) * Math.random();\n\n    square.rect(x, y, 100, 100);\n    square.fill(0xde3249);\n    square.eventMode = \"static\";\n    square.on(\"pointerdown\", () => {\n      square.removeFromParent();\n      this.finishMinigame(true);\n    });\n    this.container.addChild(square);\n  }\n\n  // It's recommended to not use `this.ticker()` for these final promises.\n  // Create your own.\n  protected async finishMinigame(\n    passed: boolean,\n    pendingPromises?: Promise<void>,\n  ) {\n    this.ticker.stop();\n    await pendingPromises;\n    // Show the player they've won or lost.\n    this.delegate.onMinigameEnd(passed);\n  }\n\n  private onTick() {\n    this.cumulativeMS += this.ticker.elapsedMS;\n\n    this.clockArc.removeFromParent();\n    this.clockArc = new Graphics();\n    this.clockArc.zIndex = 9999999;\n    const percentage = this.cumulativeMS / this.lifetime;\n    const start = -Math.PI / 2 + percentage * 2 * Math.PI;\n    const x = CLOCK_PADDING + CLOCK_RADIUS;\n    const y = this.app.screen.height - CLOCK_PADDING - CLOCK_RADIUS;\n\n    this.clockArc.arc(x, y, CLOCK_RADIUS - 2, start, -Math.PI / 2);\n    this.clockArc.lineTo(x, y);\n    this.clockArc.fill(\"#A0484C\");\n    this.app.stage.addChild(this.clockArc);\n\n    if (this.cumulativeMS > this.lifetime) {\n      this.delegate.onMinigameEnd(this.succeedOnTimeout);\n    }\n  }\n}\n","import {\n  Assets,\n  Sprite,\n  Container,\n  FederatedMouseEvent,\n  Point,\n  Ticker,\n  TickerCallback,\n} from \"pixi.js\";\nimport { ProgressBar } from \"@pixi/ui\";\nimport { MINIGAME_ASSET_ALIASES } from \"../assets\";\nimport { Minigame } from \"../minigame\";\n\nconst POPUP_ASSETS = [\n  MINIGAME_ASSET_ALIASES.POPUP_1,\n  MINIGAME_ASSET_ALIASES.POPUP_2,\n  MINIGAME_ASSET_ALIASES.POPUP_3,\n  MINIGAME_ASSET_ALIASES.POPUP_4,\n  MINIGAME_ASSET_ALIASES.POPUP_5,\n];\n\nexport class FlingMinigame extends Minigame {\n  private dragTarget?: Container;\n  private dragListener = (e: FederatedMouseEvent) => void this.onDragMove(e);\n  private dragTargetVelocity = new Point(0, 0);\n  private timeToNextPopup = 0;\n  private readonly velocityInfo: Record<string, Point> = {};\n  private readonly tickerCallbacks: Record<string, TickerCallback<this>[]> = {};\n  private spawnedPopups = 0;\n  private popupsOnScreen = 0;\n  private learningTime = 0;\n\n  lifetime = 20_000;\n\n  private async addPopup() {\n    const popupAssetId =\n      POPUP_ASSETS[Math.floor(POPUP_ASSETS.length * Math.random())];\n    const square = new Sprite(await Assets.load(popupAssetId));\n    square.label = String(this.spawnedPopups++);\n    const { screen } = this.app;\n    const aspectRatio = square.height / square.width;\n    square.width = screen.width * 0.3;\n    square.height = square.width * aspectRatio;\n    square.anchor = 0.5;\n\n    const x = screen.width * 0.2 + Math.random() * (screen.width * 0.6);\n    const y = screen.height * 0.2 + Math.random() * (screen.height * 0.6);\n    square.position = new Point(x, y);\n    this.velocityInfo[square.label] = new Point(0, 0);\n\n    square.eventMode = \"static\";\n    square.cursor = \"pointer\";\n    square.on(\"pointerdown\", () => this.onDragStart(square));\n\n    const checkSquarePos = () => {\n      const squarePos = square.getGlobalPosition();\n      if (\n        squarePos.x < 0 ||\n        squarePos.x > this.app.screen.width ||\n        squarePos.y < 0 ||\n        squarePos.y > this.app.screen.height\n      ) {\n        this.popupsOnScreen--;\n        // Clean up ticker.\n        const tickerCallbacks = this.tickerCallbacks[square.label];\n        if (tickerCallbacks) {\n          tickerCallbacks.forEach((callback) => {\n            this.app.ticker.remove(callback);\n          });\n        }\n\n        square.removeFromParent();\n      }\n    };\n    const handleSquarePhysics = (time: Ticker) =>\n      this.handlePhysics(time, square);\n\n    this.app.ticker.add(checkSquarePos);\n    this.app.ticker.add(handleSquarePhysics);\n\n    this.tickerCallbacks[square.label] = [checkSquarePos, handleSquarePhysics];\n\n    this.popupsOnScreen++;\n    this.container.addChild(square);\n  }\n\n  protected override async populateContainer() {\n    const bgAsset = await Assets.load(\n      [\n        MINIGAME_ASSET_ALIASES.BLOG_POST_1,\n        MINIGAME_ASSET_ALIASES.BLOG_POST_2,\n        MINIGAME_ASSET_ALIASES.BLOG_POST_3,\n      ][this.week],\n    );\n\n    const bg = new Sprite(bgAsset);\n    bg.width = this.app.screen.width;\n    bg.height = this.app.screen.height;\n    bg.zIndex = -1;\n    this.container.addChild(bg);\n\n    const progressBar = new ProgressBar({\n      bg: new Sprite(\n        await Assets.load(MINIGAME_ASSET_ALIASES.LEARNING_PROGRESS_CONTAINER),\n      ),\n      fill: new Sprite(await Assets.load(MINIGAME_ASSET_ALIASES.PROGRESS_BAR)),\n      progress: 0,\n      fillPaddings: {\n        top: 75,\n        bottom: 0,\n        right: 0,\n        left: 228,\n      },\n    });\n    const aspectRatio = progressBar.width / progressBar.height;\n    progressBar.height = 48;\n    progressBar.width = aspectRatio * 48;\n    progressBar.x = 16;\n    progressBar.y = 16;\n    this.container.addChild(progressBar);\n\n    for (let i = 0; i < 3 + this.week; i++) {\n      this.addPopup();\n    }\n\n    this.container.eventMode = \"static\";\n    this.container.hitArea = this.app.screen;\n    this.container.on(\"pointerup\", () => this.onDragEnd());\n    this.container.on(\"pointerupoutside\", () => this.onDragEnd());\n    this.ticker.add(\n      (ticker: Ticker) => void this.processPopups(ticker, progressBar),\n    );\n  }\n\n  private async processPopups(ticker: Ticker, progressBar: ProgressBar) {\n    if (this.popupsOnScreen < 1) {\n      this.learningTime += ticker.deltaMS;\n    }\n    this.timeToNextPopup -= ticker.deltaMS;\n\n    const goal = this.lifetime * 0.3;\n    const minTime = [1000, 700, 500][this.week];\n    if (this.learningTime > goal) {\n      this.finishMinigame(true);\n      return;\n    }\n    progressBar.progress = (this.learningTime / goal) * 100;\n    if (this.timeToNextPopup <= 0) {\n      await this.addPopup();\n      this.timeToNextPopup = minTime + Math.random() * 2000;\n    }\n  }\n\n  private handlePhysics(time: Ticker, object: Container) {\n    if (this.dragTarget === object) return;\n\n    const vel = this.velocityInfo[object.label];\n    const adjustedVel = vel;\n    adjustedVel.x = vel.x * time.deltaTime;\n    adjustedVel.y = vel.y * time.deltaTime;\n\n    object.position.add(vel.multiplyScalar(time.deltaTime), object.position);\n  }\n\n  private onDragStart(object: Container) {\n    if (!!this.dragTarget) return;\n\n    this.velocityInfo[object.label] = new Point(0, 0);\n    this.dragTarget = object;\n    this.container.on(\"pointermove\", this.dragListener);\n  }\n\n  private onDragEnd() {\n    if (!this.dragTarget) return;\n\n    this.container.off(\"pointermove\", this.dragListener);\n\n    this.velocityInfo[this.dragTarget.label] = this.dragTargetVelocity;\n    this.dragTargetVelocity = new Point(0, 0);\n\n    this.dragTarget = undefined;\n  }\n\n  private onDragMove(event: FederatedMouseEvent) {\n    if (!this.dragTarget) return;\n\n    const previousPos = this.dragTarget.position.clone();\n    this.dragTarget.position = event.getLocalPosition(this.dragTarget.parent);\n\n    this.dragTargetVelocity = this.dragTarget.position.subtract(previousPos);\n  }\n}\n","import { Container, NineSliceSprite, Texture, Graphics, Sprite } from 'pixi.js';\nimport { getSpriteView } from './utils/helpers/view.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass ProgressBar extends Container {\n  /**\n   * Creates a ProgressBar.\n   * @param options - Options.\n   * @param { Sprite | Graphics | string } options.bg - Background of the ProgressBar.\n   * @param { Sprite | Graphics | string } options.fill - Fill of the ProgressBar.\n   * @param { FillPaddings } options.fillPaddings - Fill offsets.\n   * @param { number } options.fillPaddings.top - Fill top offset.\n   * @param { number } options.fillPaddings.right - Fill right offset.\n   * @param { number } options.fillPaddings.bottom - Fill bottom offset.\n   * @param { number } options.fillPaddings.left - Fill left offset.\n   * @param { NineSliceSprite } options.nineSliceSprite - NineSliceSprite values for bg and fill.\n   * @param { Array } options.nineSliceSprite.bg - NineSliceSprite config for bg ([number, number, number, number]).\n   * @param { Array } options.nineSliceSprite.fill - NineSliceSprite config fill ([number, number, number, number]).\n   * @param { number } options.progress - Initial progress value.\n   */\n  constructor(options) {\n    super();\n    __publicField(this, \"bg\");\n    __publicField(this, \"fill\");\n    __publicField(this, \"fillMask\");\n    __publicField(this, \"progressStart\", 0);\n    __publicField(this, \"_progress\", 0);\n    __publicField(this, \"options\");\n    /** Container, that holds all inner views. */\n    __publicField(this, \"innerView\");\n    /** Container, given as a constructor parameter that is a button view. */\n    __publicField(this, \"_view\");\n    this.options = options;\n    this.innerView = new Container();\n    this.addChild(this.innerView);\n    if (options?.bg && options?.fill) {\n      this.init(options);\n    }\n  }\n  /**\n   * Initialize ProgressBar.\n   * @param root0\n   * @param root0.bg - Background texture.\n   * @param root0.fill - Fill texture.\n   * @param root0.fillPaddings - Fill offset.\n   * @param root0.progress - Initial progress value.\n   */\n  init({ bg, fill, fillPaddings, progress }) {\n    this.setBackground(bg);\n    this.setFill(fill, fillPaddings);\n    this.progress = progress;\n  }\n  /**\n   * Set bg.\n   * @param bg\n   */\n  setBackground(bg) {\n    if (this.bg) {\n      this.bg.destroy();\n    }\n    if (this.options?.nineSliceSprite) {\n      if (typeof bg === \"string\") {\n        this.bg = new NineSliceSprite({\n          texture: Texture.from(bg),\n          leftWidth: this.options.nineSliceSprite.bg[0],\n          topHeight: this.options.nineSliceSprite.bg[1],\n          rightWidth: this.options.nineSliceSprite.bg[2],\n          bottomHeight: this.options.nineSliceSprite.bg[3]\n        });\n      } else {\n        console.warn(\"NineSliceSprite can not be used with views set as Container.\");\n      }\n    }\n    if (bg instanceof Graphics) {\n      this.bg = bg;\n    }\n    if (!this.bg && (typeof bg === \"string\" || bg instanceof Sprite)) {\n      this.bg = getSpriteView(bg);\n    }\n    this.innerView.addChildAt(this.bg, 0);\n  }\n  /**\n   * Set fill.\n   * @param fill\n   * @param fillPadding\n   */\n  setFill(fill, fillPadding) {\n    if (this.fill) {\n      this.fill.destroy();\n    }\n    if (this.bg instanceof Sprite && fill === this.bg) {\n      console.warn(\"Can not use same Sprite instance for bg and fill.\");\n      return;\n    }\n    if (this.options?.nineSliceSprite) {\n      if (typeof fill === \"string\") {\n        this.fill = new NineSliceSprite({\n          texture: Texture.from(fill),\n          leftWidth: this.options.nineSliceSprite.fill[0],\n          topHeight: this.options.nineSliceSprite.fill[1],\n          rightWidth: this.options.nineSliceSprite.fill[2],\n          bottomHeight: this.options.nineSliceSprite.fill[3]\n        });\n      } else {\n        console.warn(\"NineSliceSprite can not be used with views set as Container.\");\n      }\n    }\n    if (!this.fill) {\n      if (fill instanceof Graphics) {\n        this.fill = fill;\n      } else {\n        this.fill = getSpriteView(fill);\n      }\n    }\n    this.innerView.addChildAt(this.fill, 1);\n    const offsetX = fillPadding?.left ?? 0;\n    const offsetY = fillPadding?.top ?? 0;\n    this.fill.x = offsetX;\n    this.fill.y = offsetY;\n    if (this.fillMask) {\n      this.fill.mask = null;\n      this.fillMask.destroy();\n    }\n    const leftWidth = this.fill.width / 2;\n    const rightWidth = this.fill.width / 2;\n    const topHeight = this.fill.height / 2;\n    const bottomHeight = this.fill.height / 2;\n    let texture = Texture.WHITE;\n    if (this.fill instanceof Sprite && this.fill.texture) {\n      texture = this.fill.texture;\n    }\n    this.fillMask = new NineSliceSprite({ texture, leftWidth, topHeight, rightWidth, bottomHeight });\n    this.fillMask.position.copyFrom(this.fill);\n    this.addChild(this.fillMask);\n    this.fill.mask = this.fillMask;\n  }\n  validate(progress) {\n    progress = Math.round(progress);\n    if (progress < 0) {\n      return 0;\n    }\n    if (progress > 100) {\n      return 100;\n    }\n    return progress;\n  }\n  /** Set current progress percentage value. */\n  set progress(progress) {\n    this._progress = this.validate(progress);\n    if (!this.fill)\n      return;\n    if (this.fillMask) {\n      this.fill.mask = null;\n      this.fillMask.width = this.fill.width / 100 * (this._progress - this.progressStart);\n      this.fillMask.x = this.progressStart / 100 * this.fill.width + this.fill.x;\n      this.fillMask.height = this.fill.height;\n      this.fill.mask = this.fillMask;\n    }\n  }\n  /** Return current progress percentage value. */\n  get progress() {\n    return this._progress;\n  }\n  /**\n   * Sets width of a ProgressBars background and fill.\n   * If nineSliceSprite is set, then width will be set to nineSliceSprite.\n   * If nineSliceSprite is not set, then width will control components width as Container.\n   * @param width - Width value.\n   */\n  set width(width) {\n    if (this.options?.nineSliceSprite) {\n      if (this.bg) {\n        this.bg.width = width;\n      }\n      if (this.fill) {\n        const leftPadding = this.options.fillPaddings?.left ?? 0;\n        const rightPadding = this.options.fillPaddings?.right ?? 0;\n        this.fill.width = width - leftPadding - rightPadding;\n        this.fillMask.width = width - leftPadding - rightPadding;\n      }\n      this.progress = this._progress;\n    } else {\n      super.width = width;\n    }\n  }\n  /** Gets width of a ProgressBar. */\n  get width() {\n    return super.width;\n  }\n  /**\n   * Sets height of a ProgressBars background and fill.\n   * If nineSliceSprite is set, then height will be set to nineSliceSprite.\n   * If nineSliceSprite is not set, then height will control components height as Container.\n   * @param height - Height value.\n   */\n  set height(height) {\n    if (this.options?.nineSliceSprite) {\n      if (this.bg) {\n        this.bg.height = height;\n      }\n      if (this.fill) {\n        const topPadding = this.options.fillPaddings?.top ?? 0;\n        const bottomPadding = this.options.fillPaddings?.bottom ?? 0;\n        this.fill.height = height - topPadding - bottomPadding;\n        this.fillMask.height = height - topPadding - bottomPadding;\n      }\n      this.progress = this._progress;\n    } else {\n      super.height = height;\n    }\n  }\n  /** Gets height of a ProgressBar. */\n  get height() {\n    return super.height;\n  }\n}\n\nexport { ProgressBar };\n//# sourceMappingURL=ProgressBar.mjs.map\n","import { Container, Graphics, NineSliceSprite as PixiNineSliceSprite, Sprite, Texture } from 'pixi.js';\nimport { getSpriteView } from './utils/helpers/view';\n\ntype FillPaddings = {\n    top?: number;\n    right?: number;\n    bottom?: number;\n    left?: number;\n};\n\nexport type ProgressBarViewType = Sprite | Graphics | string;\nexport type NineSliceSprite = {\n    bg: [number, number, number, number],\n    fill: [number, number, number, number]\n};\n\nexport type ProgressBarOptions = {\n    bg: ProgressBarViewType;\n    fill: ProgressBarViewType;\n    fillPaddings?: FillPaddings;\n    nineSliceSprite?: NineSliceSprite,\n    progress?: number;\n};\n\n/**\n * Creates a ProgressBar.\n * @example\n * new ProgressBar({\n *     bg: 'slider_bg.png',\n *     fill: 'slider.png',\n *     progress: 50,\n * });\n */\nexport class ProgressBar extends Container\n{\n    protected bg!: Sprite | PixiNineSliceSprite | Graphics;\n    protected fill!: Sprite | PixiNineSliceSprite | Graphics;\n    protected fillMask!: PixiNineSliceSprite | Graphics;\n    protected progressStart = 0;\n    protected _progress = 0;\n\n    protected options: ProgressBarOptions;\n\n    /** Container, that holds all inner views. */\n    innerView: Container;\n\n    /** Container, given as a constructor parameter that is a button view. */\n    protected _view: Container;\n\n    /**\n     * Creates a ProgressBar.\n     * @param options - Options.\n     * @param { Sprite | Graphics | string } options.bg - Background of the ProgressBar.\n     * @param { Sprite | Graphics | string } options.fill - Fill of the ProgressBar.\n     * @param { FillPaddings } options.fillPaddings - Fill offsets.\n     * @param { number } options.fillPaddings.top - Fill top offset.\n     * @param { number } options.fillPaddings.right - Fill right offset.\n     * @param { number } options.fillPaddings.bottom - Fill bottom offset.\n     * @param { number } options.fillPaddings.left - Fill left offset.\n     * @param { NineSliceSprite } options.nineSliceSprite - NineSliceSprite values for bg and fill.\n     * @param { Array } options.nineSliceSprite.bg - NineSliceSprite config for bg ([number, number, number, number]).\n     * @param { Array } options.nineSliceSprite.fill - NineSliceSprite config fill ([number, number, number, number]).\n     * @param { number } options.progress - Initial progress value.\n     */\n    constructor(options?: ProgressBarOptions)\n    {\n        super();\n\n        this.options = options;\n\n        this.innerView = new Container();\n        this.addChild(this.innerView);\n\n        if (options?.bg && options?.fill)\n        {\n            this.init(options);\n        }\n    }\n\n    /**\n     * Initialize ProgressBar.\n     * @param root0\n     * @param root0.bg - Background texture.\n     * @param root0.fill - Fill texture.\n     * @param root0.fillPaddings - Fill offset.\n     * @param root0.progress - Initial progress value.\n     */\n    init({ bg, fill, fillPaddings, progress }: ProgressBarOptions)\n    {\n        this.setBackground(bg);\n\n        this.setFill(fill, fillPaddings);\n\n        this.progress = progress;\n    }\n\n    /**\n     * Set bg.\n     * @param bg\n     */\n    setBackground(bg: ProgressBarViewType)\n    {\n        if (this.bg)\n        {\n            this.bg.destroy();\n        }\n\n        if (this.options?.nineSliceSprite)\n        {\n            if (typeof bg === 'string')\n            {\n                this.bg = new PixiNineSliceSprite({\n                    texture: Texture.from(bg),\n                    leftWidth: this.options.nineSliceSprite.bg[0],\n                    topHeight: this.options.nineSliceSprite.bg[1],\n                    rightWidth: this.options.nineSliceSprite.bg[2],\n                    bottomHeight: this.options.nineSliceSprite.bg[3],\n                });\n            }\n            else\n            {\n                console.warn('NineSliceSprite can not be used with views set as Container.');\n            }\n        }\n\n        if (bg instanceof Graphics)\n        {\n            this.bg = bg;\n        }\n\n        if (!this.bg && (typeof bg === 'string' || bg instanceof Sprite))\n        {\n            this.bg = getSpriteView(bg);\n        }\n\n        this.innerView.addChildAt(this.bg, 0);\n    }\n\n    /**\n     * Set fill.\n     * @param fill\n     * @param fillPadding\n     */\n    setFill(fill: ProgressBarViewType, fillPadding?: FillPaddings)\n    {\n        if (this.fill)\n        {\n            this.fill.destroy();\n        }\n\n        // in case if user is trying to use same instance for bg and fill\n        if (this.bg instanceof Sprite && fill === this.bg)\n        {\n            console.warn('Can not use same Sprite instance for bg and fill.');\n\n            return;\n        }\n\n        if (this.options?.nineSliceSprite)\n        {\n            if (typeof fill === 'string')\n            {\n                this.fill = new PixiNineSliceSprite({\n                    texture: Texture.from(fill),\n                    leftWidth: this.options.nineSliceSprite.fill[0],\n                    topHeight: this.options.nineSliceSprite.fill[1],\n                    rightWidth: this.options.nineSliceSprite.fill[2],\n                    bottomHeight: this.options.nineSliceSprite.fill[3],\n                });\n            }\n            else\n            {\n                console.warn('NineSliceSprite can not be used with views set as Container.');\n            }\n        }\n\n        if (!this.fill)\n        {\n            if (fill instanceof Graphics)\n            {\n                this.fill = fill;\n            }\n            else\n            {\n                this.fill = getSpriteView(fill);\n            }\n        }\n\n        this.innerView.addChildAt(this.fill, 1);\n\n        const offsetX = fillPadding?.left ?? 0;\n        const offsetY = fillPadding?.top ?? 0;\n\n        this.fill.x = offsetX;\n        this.fill.y = offsetY;\n\n        if (this.fillMask)\n        {\n            this.fill.mask = null;\n            this.fillMask.destroy();\n        }\n\n        const leftWidth = this.fill.width / 2;\n        const rightWidth = this.fill.width / 2;\n        const topHeight = this.fill.height / 2;\n        const bottomHeight = this.fill.height / 2;\n\n        let texture: Texture = Texture.WHITE;\n\n        if (this.fill instanceof Sprite && this.fill.texture)\n        {\n            texture = this.fill.texture;\n        }\n\n        this.fillMask = new PixiNineSliceSprite({ texture, leftWidth, topHeight, rightWidth, bottomHeight });\n        this.fillMask.position.copyFrom(this.fill);\n\n        this.addChild(this.fillMask);\n        this.fill.mask = this.fillMask;\n    }\n\n    protected validate(progress: number): number\n    {\n        progress = Math.round(progress);\n\n        if (progress < 0)\n        {\n            return 0;\n        }\n\n        if (progress > 100)\n        {\n            return 100;\n        }\n\n        return progress;\n    }\n\n    /** Set current progress percentage value. */\n    set progress(progress: number)\n    {\n        this._progress = this.validate(progress);\n\n        if (!this.fill) return;\n\n        if (this.fillMask)\n        {\n            this.fill.mask = null;\n            this.fillMask.width = (this.fill.width / 100 * (this._progress - this.progressStart));\n            this.fillMask.x = (this.progressStart / 100 * this.fill.width) + this.fill.x;\n            this.fillMask.height = this.fill.height;\n            this.fill.mask = this.fillMask;\n        }\n    }\n\n    /** Return current progress percentage value. */\n    get progress(): number\n    {\n        return this._progress;\n    }\n\n    /**\n     * Sets width of a ProgressBars background and fill.\n     * If nineSliceSprite is set, then width will be set to nineSliceSprite.\n     * If nineSliceSprite is not set, then width will control components width as Container.\n     * @param width - Width value.\n     */\n    override set width(width: number)\n    {\n        if (this.options?.nineSliceSprite)\n        {\n            if (this.bg)\n            {\n                this.bg.width = width;\n            }\n\n            if (this.fill)\n            {\n                const leftPadding = this.options.fillPaddings?.left ?? 0;\n                const rightPadding = this.options.fillPaddings?.right ?? 0;\n\n                this.fill.width = width - leftPadding - rightPadding;\n                this.fillMask.width = width - leftPadding - rightPadding;\n            }\n\n            this.progress = this._progress;\n        }\n        else\n        {\n            super.width = width;\n        }\n    }\n\n    /** Gets width of a ProgressBar. */\n    override get width(): number\n    {\n        return super.width;\n    }\n\n    /**\n     * Sets height of a ProgressBars background and fill.\n     * If nineSliceSprite is set, then height will be set to nineSliceSprite.\n     * If nineSliceSprite is not set, then height will control components height as Container.\n     * @param height - Height value.\n     */\n    override set height(height: number)\n    {\n        if (this.options?.nineSliceSprite)\n        {\n            if (this.bg)\n            {\n                this.bg.height = height;\n            }\n\n            if (this.fill)\n            {\n                const topPadding = this.options.fillPaddings?.top ?? 0;\n                const bottomPadding = this.options.fillPaddings?.bottom ?? 0;\n\n                this.fill.height = height - topPadding - bottomPadding;\n                this.fillMask.height = height - topPadding - bottomPadding;\n            }\n\n            this.progress = this._progress;\n        }\n        else\n        {\n            super.height = height;\n        }\n    }\n\n    /** Gets height of a ProgressBar. */\n    override get height(): number\n    {\n        return super.height;\n    }\n}\n","import { Sprite } from 'pixi.js';\n\nfunction getView(view) {\n  if (typeof view === \"string\") {\n    return Sprite.from(view);\n  }\n  return view;\n}\nfunction getSpriteView(view) {\n  if (typeof view === \"string\") {\n    return Sprite.from(view);\n  }\n  return view;\n}\n\nexport { getSpriteView, getView };\n//# sourceMappingURL=view.mjs.map\n","import { Container, Sprite } from 'pixi.js';\n\nexport function getView(view: string | Container): Container\n{\n    if (typeof view === 'string')\n    {\n        return Sprite.from(view);\n    }\n\n    return view;\n}\n\nexport function getSpriteView(view: string | Sprite): Sprite\n{\n    if (typeof view === 'string')\n    {\n        return Sprite.from(view);\n    }\n\n    return view;\n}\n","import { Assets } from \"pixi.js\";\n\nexport enum MINIGAME_ASSET_ALIASES {\n  /* Typing minigame */\n  PHONE_SCREEN = \"phone-screen\",\n  /* Bath minigame */\n  BATH_BG_1 = \"bath-bg-1\",\n  BATH_DIRT_1 = \"bath-dirt-1\",\n  BATH_DIRT_2 = \"bath-dirt-2\",\n  BATH_DIRT_3 = \"bath-dirt-3\",\n  BATH_DIRT_4 = \"bath-dirt-4\",\n  BATH_MC_1 = \"bath-mc-1\",\n  BATH_MC_2 = \"bath-mc-2\",\n  BATH_MC_3 = \"bath-mc-3\",\n  /* Shopping minigame */\n  SHOPPING_BACKGROUND = \"shopping-background\",\n  SHOPPING_PHONE = \"shopping-phone\",\n  BASKET = \"basket\",\n  SECURITY_ON = \"security-on\",\n  SECURITY_OFF = \"security-off\",\n  TILL = \"till\",\n  /* Checkpoint sprites */\n  CHECKPOINT_1_1 = \"check-1-1\",\n  CHECKPOINT_1_2 = \"check-1-2\",\n  CHECKPOINT_1_3 = \"check-1-3\",\n  CHECKPOINT_1_4 = \"check-1-4\",\n  ROOMBA = \"roomba\",\n  CHECKPOINT_2_1 = \"check-2-1\",\n  CHECKPOINT_2_2 = \"check-2-2\",\n  CHECKPOINT_2_3 = \"check-2-3\",\n  CHECKPOINT_2_4 = \"check-2-4\",\n  CHECKPOINT_2_5 = \"check-2-5\",\n  RABBIT = \"rabbit\",\n  CHECKPOINT_3_1 = \"check-3-1\",\n  CHECKPOINT_3_2 = \"check-3-2\",\n  CHECKPOINT_3_3 = \"check-3-3\",\n  CHECKPOINT_3_4 = \"check-3-4\",\n  CHECKPOINT_3_5 = \"check-3-5\",\n  BAR = \"bar\",\n  /* Common sprites */\n  BANANA = \"banana\",\n  MILK = \"milk\",\n  PEANUT_BUTTER = \"peanut-butter\",\n  PROTEIN = \"protein\",\n  STRAWBERRIES = \"strawberries\",\n  YOGHURT = \"yoghurt\",\n  PROGRESS_BAR = \"progress-bar\",\n  /* Browser game sprites */\n  BLOG_POST_1 = \"blog-post-1\",\n  BLOG_POST_2 = \"blog-post-2\",\n  BLOG_POST_3 = \"blog-post-3\",\n  POPUP_1 = \"popup-1\",\n  POPUP_2 = \"popup-2\",\n  POPUP_3 = \"popup-3\",\n  POPUP_4 = \"popup-4\",\n  POPUP_5 = \"popup-5\",\n  LEARNING_PROGRESS_CONTAINER = \"learning-progress-container\",\n  PROGRESS = \"progress\",\n  BLENDERPROG = \"blenderProgress\",\n  BLENDERFILL = \"barFill\",\n  BLENDER = \"blender\",\n  BALANCE_BG = \"balancebg\",\n  BALANCE_C1 = \"balancec1\",\n  BALANCE_C2 = \"balancec2\",\n  BALANCE_C3 = \"balancec3\",\n}\n\nconst MINIGAME_ASSET_FILENAMES = {\n  [MINIGAME_ASSET_ALIASES.PHONE_SCREEN]: getAssetPath(\"phonescreen.png\"),\n  [MINIGAME_ASSET_ALIASES.SHOPPING_BACKGROUND]: getAssetPath(\n    \"shopping_background.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.SHOPPING_PHONE]: getAssetPath(\"shopping_phone.png\"),\n  [MINIGAME_ASSET_ALIASES.BASKET]: getAssetPath(\"basket.png\"),\n  [MINIGAME_ASSET_ALIASES.SECURITY_ON]: getAssetPath(\"security_on.png\"),\n  [MINIGAME_ASSET_ALIASES.SECURITY_OFF]: getAssetPath(\"security_off.png\"),\n  [MINIGAME_ASSET_ALIASES.TILL]: getAssetPath(\"till.png\"),\n  [MINIGAME_ASSET_ALIASES.BANANA]: getAssetPath(\"banana.png\"),\n  [MINIGAME_ASSET_ALIASES.MILK]: getAssetPath(\"milk.png\"),\n  [MINIGAME_ASSET_ALIASES.PEANUT_BUTTER]: getAssetPath(\"peanutbutter.png\"),\n  [MINIGAME_ASSET_ALIASES.PROTEIN]: getAssetPath(\"protein.png\"),\n  [MINIGAME_ASSET_ALIASES.STRAWBERRIES]: getAssetPath(\"strawberries.png\"),\n  [MINIGAME_ASSET_ALIASES.YOGHURT]: getAssetPath(\"yoghurt.png\"),\n  [MINIGAME_ASSET_ALIASES.BATH_BG_1]: getAssetPath(\"bath_bg_1.png\"),\n  [MINIGAME_ASSET_ALIASES.BATH_DIRT_1]: getAssetPath(\"bath_dirt_1.png\"),\n  [MINIGAME_ASSET_ALIASES.BATH_DIRT_2]: getAssetPath(\"bath_dirt_2.png\"),\n  [MINIGAME_ASSET_ALIASES.BATH_DIRT_3]: getAssetPath(\"bath_dirt_3.png\"),\n  [MINIGAME_ASSET_ALIASES.BATH_DIRT_4]: getAssetPath(\"bath_dirt_4.png\"),\n  [MINIGAME_ASSET_ALIASES.BATH_MC_1]: getAssetPath(\"bath_mc_1.png\"),\n  [MINIGAME_ASSET_ALIASES.BATH_MC_2]: getAssetPath(\"bath_mc_2.png\"),\n  [MINIGAME_ASSET_ALIASES.BATH_MC_3]: getAssetPath(\"bath_mc_3.png\"),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_1_1]: getAssetPath(\n    \"checkpoints/check1.1.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_1_2]: getAssetPath(\n    \"checkpoints/check1.2.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_1_3]: getAssetPath(\n    \"checkpoints/check1.3.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_1_4]: getAssetPath(\n    \"checkpoints/check1.4.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.ROOMBA]: getAssetPath(\"checkpoints/roomba.png\"),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_2_1]: getAssetPath(\n    \"checkpoints/check2.1.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_2_2]: getAssetPath(\n    \"checkpoints/check2.2.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_2_3]: getAssetPath(\n    \"checkpoints/check2.3.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_2_4]: getAssetPath(\n    \"checkpoints/check2.4.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_2_5]: getAssetPath(\n    \"checkpoints/check2.5.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.RABBIT]: getAssetPath(\n    \"checkpoints/rabbit-flying.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_3_1]: getAssetPath(\n    \"checkpoints/check-3.1.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_3_2]: getAssetPath(\n    \"checkpoints/check-3.2.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_3_3]: getAssetPath(\n    \"checkpoints/check-3.3.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_3_4]: getAssetPath(\n    \"checkpoints/check-3.4.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.CHECKPOINT_3_5]: getAssetPath(\n    \"checkpoints/check-3.5.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.BAR]: getAssetPath(\"checkpoints/bar.png\"),\n  [MINIGAME_ASSET_ALIASES.BLOG_POST_1]: getAssetPath(\"blog_post_1.png\"),\n  [MINIGAME_ASSET_ALIASES.BLOG_POST_2]: getAssetPath(\"blog_post_2.png\"),\n  [MINIGAME_ASSET_ALIASES.BLOG_POST_3]: getAssetPath(\"blog_post_3.png\"),\n  [MINIGAME_ASSET_ALIASES.POPUP_1]: getAssetPath(\"popup_1.png\"),\n  [MINIGAME_ASSET_ALIASES.POPUP_2]: getAssetPath(\"popup_2.png\"),\n  [MINIGAME_ASSET_ALIASES.POPUP_3]: getAssetPath(\"popup_3.png\"),\n  [MINIGAME_ASSET_ALIASES.POPUP_4]: getAssetPath(\"popup_4.png\"),\n  [MINIGAME_ASSET_ALIASES.POPUP_5]: getAssetPath(\"popup_5.png\"),\n  [MINIGAME_ASSET_ALIASES.LEARNING_PROGRESS_CONTAINER]: getAssetPath(\n    \"progress_learning.png\",\n  ),\n  [MINIGAME_ASSET_ALIASES.PROGRESS_BAR]: getAssetPath(\"progress_bar.png\"),\n  [MINIGAME_ASSET_ALIASES.PROGRESS]: getAssetPath(\"progress.png\"),\n  [MINIGAME_ASSET_ALIASES.BLENDERPROG]: getAssetPath(\"progress_blender.png\"),\n  [MINIGAME_ASSET_ALIASES.BLENDERFILL]: getAssetPath(\"progress_bar.png\"),\n  [MINIGAME_ASSET_ALIASES.BLENDER]: getAssetPath(\"blender.png\"),\n  [MINIGAME_ASSET_ALIASES.BALANCE_BG]: getAssetPath(\"balance_background.png\"),\n  [MINIGAME_ASSET_ALIASES.BALANCE_C1]: getAssetPath(\"balance_character-1.png\"),\n\n};\n\nfunction getAssetPath(filename: string) {\n  return `./assets/sprites/minigames/${filename}`;\n}\n\nexport function backgroundLoadMinigameAssets() {\n  const aliases = Object.keys(MINIGAME_ASSET_FILENAMES);\n  aliases.forEach((alias) => {\n    Assets.add({\n      alias,\n      src: MINIGAME_ASSET_FILENAMES[alias],\n    });\n  });\n\n  Assets.backgroundLoad(aliases);\n}\n","import { Trie, TrieNode } from \"@datastructures-js/trie\";\nimport { KeyboardMinigame } from \"./keyboardMinigame\";\nimport { Assets, Point, Sprite, Text, TextStyle } from \"pixi.js\";\nimport { MINIGAME_ASSET_ALIASES } from \"./assets\";\n\n// TODO: Update this list later.\nconst ALL_WORDS = [\"act\", \"ale\", \"all\", \"and\", \"ball\", \"bang\", \"bat\"];\n\nexport class TypingMinigame extends KeyboardMinigame {\n  private trie = new Trie();\n  private currentNode?: TrieNode;\n  private remainingWords = new Set(ALL_WORDS);\n\n  protected override async populateContainer() {\n    const phonescreenTexture = await Assets.load(\n      MINIGAME_ASSET_ALIASES.PHONE_SCREEN,\n    );\n\n    const phonescreen = new Sprite(phonescreenTexture);\n    phonescreen.anchor = 0.5;\n    const aspectRatio = phonescreen.width / phonescreen.height;\n    phonescreen.height = this.app.screen.height;\n    phonescreen.width = phonescreen.height * aspectRatio;\n    phonescreen.position = new Point(\n      this.app.screen.width / 2,\n      this.app.screen.height / 2,\n    );\n\n    this.container.addChild(phonescreen);\n\n    ALL_WORDS.forEach((word) => {\n      this.trie.insert(word);\n\n      const text = new Text({\n        label: word,\n        text: word,\n        style: new TextStyle({ fill: \"#de3249\" }),\n      });\n\n      const x = (this.app.screen.width - 100) * Math.random() + 50;\n      const y = (this.app.screen.height - 100) * Math.random() + 50;\n      text.position = new Point(x, y);\n\n      this.container.addChild(text);\n    });\n\n    this.trie.insert(\"\");\n    this.currentNode = this.trie.find(\"\");\n  }\n\n  protected override onKeyDown(key: string) {\n    if (!this.currentNode.hasChild(key)) {\n      // No words match the current string. Reset the search from the beginning.\n      this.currentNode = this.trie.find(\"\");\n      // Try match the key that was just pressed, for a smoother gameplay experience.\n      // Note this means we don't support any one-letter words.\n      if (this.currentNode.hasChild(key)) {\n        this.currentNode = this.currentNode.getChild(key);\n      }\n      return;\n    }\n\n    this.currentNode = this.currentNode.getChild(key);\n    if (this.currentNode.isEndOfWord()) {\n      const word = this.getString(this.currentNode);\n      const text = this.container.getChildByLabel(word);\n      text.alpha = 0.2;\n\n      this.remainingWords.delete(word);\n      if (this.remainingWords.size === 0) {\n        this.finishMinigame(true);\n      }\n    }\n  }\n\n  private getString(node: TrieNode) {\n    let string = \"\";\n    let infiniteLoopPreventer = 999999;\n    while (!node.isRoot() && infiniteLoopPreventer-- > 0) {\n      string = node.getChar() + string;\n      node = node.getParent();\n    }\n    return string;\n  }\n}\n","const { Trie } = require('./src/trie');\nconst { TrieNode } = require('./src/trieNode');\n\nexports.TrieNode = TrieNode\nexports.Trie = Trie;\n","/**\n * datastructures-js/trie\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst { TrieNode } = require('./trieNode');\n\n/**\n * @class Trie\n */\nclass Trie {\n  constructor() {\n    this._root = new TrieNode('');\n    this._wordsCount = 0;\n    this._nodesCount = 1; // root node\n  }\n\n  /**\n   * Inserts a word into the trie\n   * @public\n   * @param {any} value\n   * @returns {Trie}\n   */\n  insert(value) {\n    if (value === undefined || value === null) {\n      return this;\n    }\n\n    const word = value.toString();\n    let currentNode = this._root;\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentNode.hasChild(word[i])) {\n        currentNode.addChild(word[i]);\n        this._nodesCount += 1;\n      }\n      currentNode = currentNode.getChild(word[i]);\n    }\n\n    if (!currentNode.isEndOfWord()) {\n      currentNode.setEndOfWord(true);\n      this._wordsCount += 1;\n    }\n\n    return this;\n  }\n\n  /**\n   * Checks if a word exists in the trie\n   * @public\n   * @param {any} value\n   * @returns {boolean}\n   */\n  has(value) {\n    if (value === undefined || value === null) {\n      return false;\n    }\n\n    const word = value.toString();\n    let currentNode = this._root;\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentNode.hasChild(word[i])) {\n        return false;\n      }\n      currentNode = currentNode.getChild(word[i]);\n    }\n\n    if (!currentNode.isEndOfWord()) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Finds a word in the trie and returns its last char node\n   * @public\n   * @param {any} value\n   * @returns {TrieNode}\n   */\n  find(value) {\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    const word = value.toString();\n    let currentNode = this._root;\n\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentNode.hasChild(word[i])) {\n        return null;\n      }\n      currentNode = currentNode.getChild(word[i]);\n    }\n\n    if (!currentNode.isEndOfWord()) {\n      return null;\n    }\n\n    return currentNode;\n  }\n\n  /**\n   * Removes a word from the trie\n   * @public\n   * @param {string} word\n   * @returns {string | null}\n   */\n  remove(value) {\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    const word = value.toString();\n    let currentNode = this._root;\n\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentNode.hasChild(word[i])) {\n        return null;\n      }\n      currentNode = currentNode.getChild(word[i]);\n    }\n\n    if (!currentNode.isEndOfWord()) {\n      return null;\n    }\n\n    if (currentNode.childrenCount() > 0 || word === '') {\n      currentNode.setEndOfWord(false);\n      this._wordsCount -= 1;\n      return word;\n    }\n\n    do {\n      currentNode.getParent().removeChild(currentNode.getChar());\n      this._nodesCount -= 1;\n      currentNode = currentNode.getParent();\n    } while (\n      currentNode.isLeaf()\n      && !currentNode.isEndOfWord()\n      && !currentNode.isRoot()\n    );\n\n    this._wordsCount -= 1;\n    return word;\n  }\n\n  /**\n   * Traverse the trie and pass words to a callback\n   * @public\n   * @param {function} cb\n   */\n  forEach(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('Trie.forEach expects a callback function');\n    }\n\n    const forEachRecursive = (node = this._root, word = '') => {\n      if (node.isEndOfWord()) {\n        cb(word);\n      }\n\n      node.children().forEach((child) => {\n        forEachRecursive(child, word + child.getChar());\n      });\n    };\n\n    return forEachRecursive();\n  }\n\n  /**\n   * Converts the trie into an array of words\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    const result = [];\n    this.forEach((word) => result.push(word));\n    return result;\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  nodesCount() {\n    return this._nodesCount;\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  wordsCount() {\n    return this._wordsCount;\n  }\n\n  /**\n   * Clears the trie\n   * @public\n   */\n  clear() {\n    this._root = new TrieNode('');\n    this._nodesCount = 1;\n    this._wordsCount = 0;\n  }\n\n  /**\n   * Converts an existing list into a trie\n   * @public\n   * @static\n   * @returns {Trie}\n   */\n  static fromArray(values) {\n    const trie = new Trie();\n    values.forEach((value) => trie.insert(value));\n    return trie;\n  }\n}\n\nexports.Trie = Trie;\n","/**\n * datastructures-js/trie\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n *\n * @class TrieNode\n */\nclass TrieNode {\n  constructor(char) {\n    this._char = char;\n    this._isEndOfWord = false;\n    this._parent = null;\n    this._children = new Map();\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isRoot() {\n    return this._char === '';\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isLeaf() {\n    return this._children.size === 0;\n  }\n\n  /**\n   * @public\n   * @returns {string}\n   */\n  getChar() {\n    return this._char;\n  }\n\n  /**\n   * @internal\n   * @param {TrieNode} parentNode\n   */\n  setParent(parentNode) {\n    this._parent = parentNode;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {TrieNode}\n   */\n  getParent() {\n    return this._parent;\n  }\n\n  /**\n   * @internal\n   * @param {boolean} isEndOfWord\n   */\n  setEndOfWord(isEndOfWord) {\n    this._isEndOfWord = isEndOfWord;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isEndOfWord() {\n    return this._isEndOfWord;\n  }\n\n  /**\n   * @internal\n   * @param {string} char\n   */\n  addChild(char) {\n    const childNode = new TrieNode(char);\n    childNode.setParent(this);\n    this._children.set(char, childNode);\n    return this;\n  }\n\n  /**\n   * @internal\n   * @param {string} char\n   * @return {boolean}\n   */\n  removeChild(char) {\n    return this._children.delete(char);\n  }\n\n  /**\n   * @public\n   * @param {string} char\n   * @return {TrieNode}\n   */\n  getChild(char) {\n    return this._children.get(char) || null;\n  }\n\n  /**\n   * @public\n   * @param {string} char\n   * @return {boolean}\n   */\n  hasChild(char) {\n    return this._children.has(char);\n  }\n\n  /**\n   * @internal\n   * @return {Map}\n   */\n  children() {\n    return this._children;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  childrenCount() {\n    return this._children.size;\n  }\n}\n\nexports.TrieNode = TrieNode;\n","import { TextStyle, Text } from \"pixi.js\";\nimport { Minigame } from \"./minigame\";\n\nexport class KeyboardMinigame extends Minigame {\n  private keyDownListener = (e: KeyboardEvent) => void this.onKeyDown(e.key, e);\n\n  override async attach() {\n    await super.attach();\n    window.addEventListener(\"keydown\", this.keyDownListener);\n  }\n\n  override detach() {\n    window.removeEventListener(\"keydown\", this.keyDownListener);\n    super.detach();\n  }\n\n  protected override async populateContainer() {\n    const text = new Text({\n      label: \"text\",\n      text: Math.floor(Math.random() * 10).toString(),\n      style: new TextStyle({ fill: \"#de3249\" }),\n    });\n\n    this.container.addChild(text);\n  }\n\n  protected onKeyDown(key: string, e: KeyboardEvent) {\n    console.log(key, \"pressed\");\n    const text = this.container.getChildByLabel(\"text\");\n    if (!text || !(text instanceof Text)) {\n      this.finishMinigame(false);\n    }\n    this.finishMinigame(key === (text as Text).text);\n  }\n}\n","import { TextStyle, Text } from \"pixi.js\";\nimport { KeyboardMinigame } from \"./keyboardMinigame\";\n\nexport class RhythmMinigame extends KeyboardMinigame {\n  //private keyDownListener = (e: KeyboardEvent) => void this.onKeyDown(e.key);\n  protected text: Text | null = null;\n  private waitingForPress: boolean = false;\n\n  protected override async populateContainer() {\n    this.text = new Text({\n      label: \"text\",\n      text: \"3\",\n      style: new TextStyle({ fill: \"#de3249\" }),\n    });\n    this.container.addChild(this.text);\n\n    this.countdown();\n  }\n\n  async countdown() {\n    await this.waitFor(1000);\n    this.text.text = \"2\";\n    await this.waitFor(1000);\n    this.text.text = \"1\";\n    await this.waitFor(1000);\n    this.text.text = \"NOW\";\n    this.waitingForPress = true;\n    await this.waitFor(500);\n    this.waitingForPress = false;\n  }\n\n  async waitFor(time: number) {\n    return new Promise((resolve) => setTimeout(resolve, time));\n  }\n\n  protected override onKeyDown(key: string) {\n    console.log(key, \"pressed\");\n    if (this.waitingForPress == true) {\n      this.finishMinigame(true);\n      this.waitingForPress = false;\n    } else {\n      this.finishMinigame(false);\n    }\n  }\n}\n","import { Sprite, Point, Assets, Rectangle } from \"pixi.js\";\nimport { Minigame } from \"../minigame\";\nimport { MINIGAME_ASSET_ALIASES } from \"../assets\";\n\ninterface DirtySpotDelegate {\n  isPointerDown(): boolean;\n  markCleaned(spot: DirtySpot): void;\n}\n\nconst DIRT_ASSETS = [\n  MINIGAME_ASSET_ALIASES.BATH_DIRT_1,\n  MINIGAME_ASSET_ALIASES.BATH_DIRT_2,\n  MINIGAME_ASSET_ALIASES.BATH_DIRT_3,\n  MINIGAME_ASSET_ALIASES.BATH_DIRT_4,\n];\n\nconst DIRT_SIZE = 50;\n\nclass DirtySpot {\n  private health = 100;\n\n  constructor(private readonly delegate: DirtySpotDelegate) {}\n\n  async getObject(area: Rectangle) {\n    const dirtAssetId =\n      DIRT_ASSETS[Math.floor(DIRT_ASSETS.length * Math.random())];\n    const dirtAsset = await Assets.load(dirtAssetId);\n    const spot = new Sprite(dirtAsset);\n    const x = area.x + area.width * Math.random();\n    const y = area.y + area.height * Math.random();\n    spot.width = DIRT_SIZE;\n    spot.height = DIRT_SIZE;\n    spot.anchor = 0.5;\n    spot.position = new Point(x, y);\n\n    spot.eventMode = \"static\";\n    spot.on(\"mousemove\", (event) => {\n      if (!this.delegate.isPointerDown()) return;\n\n      this.health = Math.max(this.health - event.movement.magnitude() * 0.3, 0);\n      spot.alpha = 0.15 + 0.7 * (this.health / 100);\n      if (this.health === 0) {\n        this.delegate.markCleaned(this);\n        spot.removeFromParent();\n      }\n    });\n\n    return spot;\n  }\n}\n\nexport class ScrubMinigame extends Minigame implements DirtySpotDelegate {\n  private pointerDown = false;\n  private remainingDirtySpots: Set<DirtySpot> = new Set();\n  protected override lifetime = 15_000;\n\n  override async attach() {\n    await super.attach();\n    // Sometimes attach gets called before canvas sets it's own cursor state.\n    // Only update the cursor _after_ this to make sure we don't get overriden.\n    await new Promise((resolve) => void setTimeout(resolve, 200));\n    this.app.canvas.style.cursor = `url('./assets/sprites/minigames/loofa.png'), auto`;\n  }\n\n  override detach() {\n    super.detach();\n\n    this.app.canvas.style.cursor = \"auto\";\n  }\n\n  protected override async populateContainer() {\n    const bgAsset = await Assets.load(MINIGAME_ASSET_ALIASES.BATH_BG_1);\n    const characterAssetId = [\n      MINIGAME_ASSET_ALIASES.BATH_MC_1,\n      MINIGAME_ASSET_ALIASES.BATH_MC_2,\n      MINIGAME_ASSET_ALIASES.BATH_MC_3,\n    ][this.week];\n    const numSpots = 3 + 2 * this.week;\n    const characterAsset = await Assets.load(characterAssetId);\n\n    const { screen } = this.app;\n\n    const bg = new Sprite(bgAsset);\n    bg.width = this.app.screen.width;\n    bg.height = this.app.screen.height;\n    bg.zIndex = -1;\n    this.container.addChild(bg);\n\n    const mc = new Sprite(characterAsset);\n    const heightScale = [0.8, 0.9, 1][this.week];\n    const characterSize = {\n      width: screen.height * heightScale * (mc.width / mc.height),\n      height: screen.height * heightScale,\n    };\n    mc.width = characterSize.width;\n    mc.height = characterSize.height;\n    mc.anchor = 0.5;\n    mc.x = screen.width / 2;\n    mc.y = screen.height / 2;\n    this.container.addChild(mc);\n\n    const torsoRatio = [0.5, 0.4, 0.35][this.week];\n    const dirtableSize = {\n      width: characterSize.width * torsoRatio,\n      height: characterSize.height * torsoRatio,\n    };\n    const dirtableArea = new Rectangle(\n      screen.width / 2 - dirtableSize.width / 2,\n      screen.height / 2 - dirtableSize.height / 2,\n      dirtableSize.width,\n      dirtableSize.height,\n    );\n    for (let i = 0; i < numSpots; i++) {\n      const spot = new DirtySpot(this);\n      this.remainingDirtySpots.add(spot);\n      this.container.addChild(await spot.getObject(dirtableArea));\n    }\n\n    this.container.eventMode = \"static\";\n    this.container.hitArea = this.app.screen;\n    this.container\n      .on(\"pointerdown\", () => (this.pointerDown = true))\n      .on(\"pointerup\", () => (this.pointerDown = false))\n      .on(\"pointerupoutside\", () => (this.pointerDown = false));\n  }\n\n  isPointerDown() {\n    return this.pointerDown;\n  }\n\n  markCleaned(spot: DirtySpot) {\n    this.remainingDirtySpots.delete(spot);\n    if (this.remainingDirtySpots.size === 0) {\n      this.finishMinigame(true);\n    }\n  }\n}\n","import {\n  Graphics,\n  FederatedMouseEvent,\n  Texture,\n  Assets,\n  Point,\n  Text,\n  Sprite,\n  TextStyle,\n} from \"pixi.js\";\nimport { ProgressBar } from '@pixi/ui';\nimport { Minigame } from \"./minigame\";\nimport { MINIGAME_ASSET_ALIASES } from \"./assets\";\n\n\nexport class ShakingMinigame extends Minigame{\n\n    protected dragObject: Sprite | null = null;\n    private dragListener = (e: FederatedMouseEvent) => void this.onDrag(e);\n    private vel: Point;\n    private score: number = 0;\n    private scoreText: Text | null = null;\n    private prog: ProgressBar;\n    private scoreToPass: number;\n\n\n    \n    override async attach() {\n        super.attach();\n        this.scoreToPass = 3000;\n\n        this.container.eventMode = 'static';\n        this.container.hitArea = this.app.screen;\n        this.container.on('pointerup', ()=> void this.onDragEnd());\n        this.container.on('pointerupoutside', ()=> void this.onDragEnd());\n    }\n    \n\n\n    protected override async populateContainer() {\n        const shakeAble = new Sprite(await Assets.load(MINIGAME_ASSET_ALIASES.BLENDER));\n        const x = (this.app.screen.width - 100) * Math.random();\n        const y = (this.app.screen.height - 100) * Math.random();\n\n        const loadSprite = new Sprite(await Assets.load(MINIGAME_ASSET_ALIASES.BLENDERFILL));\n        const progSprite = new Sprite(await Assets.load(MINIGAME_ASSET_ALIASES.BLENDERPROG));\n\n        this.prog = new ProgressBar({\n            bg: progSprite,\n            fill: loadSprite,\n            fillPaddings: {\n                top: 75,\n                bottom: 0,\n                right: 0,\n                left: 228\n                \n            },\n            progress: 0\n        });\n        \n        var aspect = this.prog.height / this.prog.width;\n        this.prog.width = this.app.screen.width / 6;\n        this.prog.height = this.prog.width * aspect;\n        //shakeAble.rect(0, 0, 60, 60);\n        //shakeAble.fill(0xde3249);\n        //shakeAble.scale.set(10);\n        aspect = shakeAble.height / shakeAble.width;\n        shakeAble.width = this.app.screen.width / 4;\n        shakeAble.height = shakeAble.width * aspect;\n        shakeAble.anchor = 0.5;\n        shakeAble.position = new Point(this.app.screen.width / 2, this.app.screen.height / 2);\n\n        \n        shakeAble.eventMode = 'static';\n        shakeAble.on('pointerdown', () => { \n            this.dragObject = shakeAble;\n            this.container.on(\"pointermove\", this.dragListener);\n            \n        });\n        this.container.addChild(shakeAble);\n        this.container.addChild(this.prog);\n        \n        \n    }\n    \n    \n\n    private onDragEnd() {\n        if (this.dragObject)\n        {\n            console.log(\"ENDED\");\n            this.container.off('pointermove', this.dragListener);\n            this.dragObject = null;\n        }\n    }\n\n    private onDrag(event: FederatedMouseEvent) {\n        if (!this.dragObject) return;\n\n        const previousPos = this.dragObject.position.clone();\n        this.dragObject.position = event.getLocalPosition(this.dragObject.parent);\n\n        this.vel = this.dragObject.position.subtract(previousPos);\n        this.score += Math.floor((Math.abs(this.vel.x) + Math.abs(this.vel.y))/10);\n        //console.log(this.score);\n        //this.scoreText.text = this.score;\n        this.prog.progress = (this.score/this.scoreToPass)*100;\n        if (this.score > this.scoreToPass) {\n            this.finishMinigame(true);\n        }\n    }\n}","import {\r\n  Assets,\r\n  BoundsData,\r\n  Container,\r\n  FederatedMouseEvent,\r\n  Point,\r\n  Polygon,\r\n  Rectangle,\r\n  Sprite,\r\n  Ticker,\r\n} from \"pixi.js\";\r\nimport { Minigame } from \"../minigame\";\r\nimport { MINIGAME_ASSET_ALIASES } from \"../assets\";\r\nimport { devPreviewHitArea } from \"../../util/devHelpers\";\r\n\r\n/* This needs to match up 1:1 with the strings in `minigames/assets.ts`. */\r\nenum GroceryItemType {\r\n  BANANA = \"banana\",\r\n  MILK = \"milk\",\r\n  PEANUT_BUTTER = \"peanut-butter\",\r\n  PROTEIN = \"protein\",\r\n  STRAWBERRIES = \"strawberries\",\r\n  YOGHURT = \"yoghurt\",\r\n}\r\n\r\ntype GroceryItem = {\r\n  type: GroceryItemType;\r\n  originalPosition: Point;\r\n  sprite: Sprite;\r\n};\r\n\r\nexport class ShoppingMinigame extends Minigame {\r\n  private dragTarget?: GroceryItem;\r\n\r\n  private readonly shoppingList: Record<GroceryItemType, number> = {\r\n    [GroceryItemType.BANANA]: 0,\r\n    [GroceryItemType.MILK]: 0,\r\n    [GroceryItemType.PEANUT_BUTTER]: 0,\r\n    [GroceryItemType.PROTEIN]: 0,\r\n    [GroceryItemType.STRAWBERRIES]: 0,\r\n    [GroceryItemType.YOGHURT]: 0,\r\n  };\r\n  private readonly shelves: Record<string, GroceryItem> = {};\r\n  private timeUntilNextStockMs = 0;\r\n\r\n  private basket: Container;\r\n  private collectedItemCount = 0;\r\n\r\n  private securityIsWatching = false;\r\n  private timeUntilNextSecurityToggleMs = 0;\r\n\r\n  private dragListener = (e: FederatedMouseEvent) => void this.onDragMove(e);\r\n\r\n  // Maps some ID to the elapsed percentage (from 0~1) for this ease.\r\n  private easeMap: Record<string, number> = {};\r\n\r\n  protected override async populateContainer() {\r\n    const appDimensions = this.app.screen;\r\n\r\n    this.container.eventMode = \"static\";\r\n    this.container.hitArea = appDimensions;\r\n    this.container.on(\"pointerup\", () => this.onDragEnd());\r\n    this.container.on(\"pointerupoutside\", () => this.onDragEnd());\r\n\r\n    this.container.addChild(await this.constructBackground(appDimensions));\r\n\r\n    this.basket = await this.constructBasket(appDimensions);\r\n    this.basket.on(\"pointerup\", () => this.onBasketDrop());\r\n    this.container.addChild(this.basket);\r\n\r\n    if (this.week >= 1) {\r\n      const security = await this.constructSecurity(appDimensions);\r\n      this.ticker.add(\r\n        (time) => void this.periodicallyToggleSecurity(time, security),\r\n      );\r\n      this.container.addChild(security);\r\n    }\r\n\r\n    const allItems = [\r\n      GroceryItemType.BANANA,\r\n      GroceryItemType.MILK,\r\n      GroceryItemType.PEANUT_BUTTER,\r\n      GroceryItemType.PROTEIN,\r\n      GroceryItemType.STRAWBERRIES,\r\n      GroceryItemType.YOGHURT,\r\n    ];\r\n    for (let i = 0; i < 5; i++) {\r\n      const randomItem = allItems[Math.floor(Math.random() * allItems.length)];\r\n      this.shoppingList[randomItem]++;\r\n    }\r\n    // TODO: Display this graphically.\r\n    console.log(\r\n      \"Your shopping list is:\",\r\n      Object.keys(this.shoppingList)\r\n        .map((item) => `${item}: ${this.shoppingList[item]}`)\r\n        .join(\", \"),\r\n    );\r\n\r\n    const allPositions = [\r\n      new Point(appDimensions.width * 0.1, appDimensions.height * 0.15),\r\n      new Point(appDimensions.width * 0.3, appDimensions.height * 0.15),\r\n      new Point(appDimensions.width * 0.5, appDimensions.height * 0.15),\r\n      new Point(appDimensions.width * 0.1, appDimensions.height * 0.4),\r\n      new Point(appDimensions.width * 0.3, appDimensions.height * 0.4),\r\n      new Point(appDimensions.width * 0.5, appDimensions.height * 0.4),\r\n      new Point(appDimensions.width * 0.7, appDimensions.height * 0.4),\r\n    ];\r\n    this.ticker.add(\r\n      (time) =>\r\n        void this.periodicallyAddItems(time, allPositions, appDimensions),\r\n    );\r\n  }\r\n\r\n  private onDragStart(item: GroceryItem) {\r\n    if (!!this.dragTarget) return;\r\n\r\n    this.dragTarget = item;\r\n    this.container.on(\"pointermove\", this.dragListener);\r\n  }\r\n\r\n  private onDragEnd() {\r\n    if (!this.dragTarget) return;\r\n\r\n    this.container.off(\"pointermove\", this.dragListener);\r\n    this.dragTarget = undefined;\r\n  }\r\n\r\n  private onBasketDrop() {\r\n    if (!this.dragTarget) return;\r\n\r\n    if (this.securityIsWatching) {\r\n      const ticker = new Ticker();\r\n      const item = this.dragTarget.sprite;\r\n      const originalPosition = this.dragTarget.originalPosition.clone();\r\n      ticker.add((time) =>\r\n        this.easeToPos(\r\n          time,\r\n          item.position,\r\n          originalPosition,\r\n          1000,\r\n          item,\r\n          `caughtredhanded${stringifyPoint(originalPosition)}`,\r\n        ),\r\n      );\r\n      ticker.start();\r\n      return;\r\n    }\r\n\r\n    const item = this.dragTarget.sprite;\r\n    // Prevent drag and drop for this item.\r\n    item.eventMode = \"none\";\r\n    const collectedItemPosition = this.basket.position.clone();\r\n    collectedItemPosition.y -= item.height / 2;\r\n    collectedItemPosition.x += this.basket.width / 2 - item.width * 0.6;\r\n    // Stack the items from left to right\r\n    collectedItemPosition.x += item.width * 0.3 * (this.collectedItemCount % 5);\r\n    item.zIndex = this.collectedItemCount;\r\n    const ticker = new Ticker();\r\n    ticker.add((time) =>\r\n      this.easeToPos(\r\n        time,\r\n        item.position,\r\n        collectedItemPosition,\r\n        1000,\r\n        item,\r\n        `collected${this.collectedItemCount}`,\r\n      ),\r\n    );\r\n    ticker.start();\r\n\r\n    delete this.shelves[stringifyPoint(this.dragTarget.originalPosition)];\r\n    this.shoppingList[this.dragTarget.type]--;\r\n    this.collectedItemCount++;\r\n\r\n    if (\r\n      Object.values(this.shoppingList).filter((remaining) => remaining > 0)\r\n        .length === 0\r\n    ) {\r\n      this.finishMinigame(true);\r\n    }\r\n  }\r\n\r\n  private onDragMove(event: FederatedMouseEvent) {\r\n    if (!this.dragTarget) return;\r\n\r\n    this.dragTarget.sprite.position = event.getLocalPosition(\r\n      this.dragTarget.sprite.parent,\r\n    );\r\n  }\r\n\r\n  private async periodicallyToggleSecurity(time: Ticker, security: Sprite) {\r\n    this.timeUntilNextSecurityToggleMs -= time.deltaMS;\r\n    if (this.timeUntilNextSecurityToggleMs > 0) return;\r\n\r\n    this.timeUntilNextSecurityToggleMs = 2000;\r\n\r\n    this.securityIsWatching = !this.securityIsWatching;\r\n    security.texture = this.securityIsWatching\r\n      ? await Assets.load(MINIGAME_ASSET_ALIASES.SECURITY_ON)\r\n      : await Assets.load(MINIGAME_ASSET_ALIASES.SECURITY_OFF);\r\n  }\r\n\r\n  private async periodicallyAddItems(\r\n    time: Ticker,\r\n    allPositions: Point[],\r\n    appDimensions: Rectangle,\r\n  ) {\r\n    this.timeUntilNextStockMs -= time.deltaMS;\r\n    if (this.timeUntilNextStockMs > 0) return;\r\n\r\n    this.timeUntilNextStockMs = 400;\r\n\r\n    // Find an item that needs to be purchased which is not already accounted\r\n    // for by stock on the shelves.\r\n    const currentlyOnShelf: Record<GroceryItemType, number> = {\r\n      [GroceryItemType.BANANA]: 0,\r\n      [GroceryItemType.MILK]: 0,\r\n      [GroceryItemType.PEANUT_BUTTER]: 0,\r\n      [GroceryItemType.PROTEIN]: 0,\r\n      [GroceryItemType.STRAWBERRIES]: 0,\r\n      [GroceryItemType.YOGHURT]: 0,\r\n    };\r\n    Object.values(this.shelves).forEach(\r\n      (item) => void currentlyOnShelf[item.type]++,\r\n    );\r\n    const requiredUnstockedItems = [];\r\n    Object.keys(this.shoppingList).forEach((item) => {\r\n      for (\r\n        let i = 0;\r\n        i < this.shoppingList[item] - currentlyOnShelf[item];\r\n        i++\r\n      ) {\r\n        requiredUnstockedItems.push(item);\r\n      }\r\n    });\r\n\r\n    if (requiredUnstockedItems.length === 0) return;\r\n\r\n    // Look for a free spot on the shelves.\r\n    const availablePositions = allPositions.filter(\r\n      (position) =>\r\n        !Object.keys(this.shelves).includes(stringifyPoint(position)),\r\n    );\r\n\r\n    if (availablePositions.length === 0) return;\r\n\r\n    // Choose an item to add, and a shelf position to place it.\r\n    const itemType =\r\n      requiredUnstockedItems[\r\n        Math.floor(Math.random() * requiredUnstockedItems.length)\r\n      ];\r\n    const position =\r\n      availablePositions[Math.floor(Math.random() * availablePositions.length)];\r\n\r\n    const itemSprite = await this.constructItem(\r\n      itemType,\r\n      position,\r\n      appDimensions,\r\n    );\r\n    const item = {\r\n      type: itemType,\r\n      originalPosition: position,\r\n      sprite: itemSprite,\r\n    };\r\n    itemSprite.on(\"pointerdown\", () => this.onDragStart(item));\r\n\r\n    this.container.addChild(itemSprite);\r\n\r\n    this.shelves[stringifyPoint(position)] = item;\r\n  }\r\n\r\n  private async constructBackground(appDimensions: Rectangle) {\r\n    const texture = await Assets.load(\r\n      MINIGAME_ASSET_ALIASES.SHOPPING_BACKGROUND,\r\n    );\r\n    const background = new Sprite(texture);\r\n    background.setSize(appDimensions);\r\n    background.zIndex = -1;\r\n\r\n    return background;\r\n  }\r\n\r\n  private async constructBasket(appDimensions: Rectangle) {\r\n    const texture = await Assets.load(MINIGAME_ASSET_ALIASES.BASKET);\r\n    const basket = new Sprite(texture);\r\n    const aspectRatio = basket.width / basket.height;\r\n    basket.height = appDimensions.height * 0.4;\r\n    basket.width = basket.height * aspectRatio;\r\n    basket.anchor = new Point(0, 1);\r\n    basket.position = new Point(\r\n      appDimensions.width * 0.05,\r\n      appDimensions.height * 1.05,\r\n    );\r\n    basket.zIndex = 99999;\r\n    // minY because we've set the anchor to be at the bottom left corner.\r\n    const { maxX: boundsWidth, minY: boundsHeight } = basket.bounds;\r\n    const hitArea = new Polygon(\r\n      new Point(0, boundsHeight),\r\n      new Point(0, boundsHeight * 0.89),\r\n      new Point(boundsWidth * 0.06, boundsHeight * 0.89),\r\n      new Point(boundsWidth * 0.17, 0),\r\n      new Point(boundsWidth * 0.83, 0),\r\n      new Point(boundsWidth * 0.94, boundsHeight * 0.89),\r\n      new Point(boundsWidth, boundsHeight * 0.89),\r\n      new Point(boundsWidth, boundsHeight),\r\n    );\r\n    devPreviewHitArea(basket, hitArea);\r\n    basket.hitArea = hitArea;\r\n    basket.eventMode = \"static\";\r\n\r\n    return basket;\r\n  }\r\n\r\n  private async constructSecurity(appDimensions: Rectangle) {\r\n    const texture = await Assets.load(MINIGAME_ASSET_ALIASES.SECURITY_OFF);\r\n    // Cache the other texture.\r\n    await Assets.load(MINIGAME_ASSET_ALIASES.SECURITY_ON);\r\n    const security = new Sprite(texture);\r\n    const aspectRatio = security.width / security.height;\r\n    security.height = appDimensions.height * 0.3;\r\n    security.width = security.height * aspectRatio;\r\n    security.anchor = new Point(1, 0);\r\n    security.position = new Point(\r\n      appDimensions.width,\r\n      appDimensions.height * 0.05,\r\n    );\r\n    security.zIndex = 1;\r\n\r\n    return security;\r\n  }\r\n\r\n  private async constructItem(\r\n    itemType: GroceryItemType,\r\n    position: Point,\r\n    appDimensions: Rectangle,\r\n  ) {\r\n    const texture = await Assets.load(itemType);\r\n    const item = new Sprite(texture);\r\n    const aspectRatio = item.width / item.height;\r\n    item.height = appDimensions.height * 0.2;\r\n    item.width = item.height * aspectRatio;\r\n    item.anchor = 0.5;\r\n    item.position = position;\r\n    const hitArea = getHitAreaForItem(itemType, item.bounds);\r\n    devPreviewHitArea(item, hitArea);\r\n    item.hitArea = hitArea;\r\n    item.eventMode = \"static\";\r\n\r\n    return item;\r\n  }\r\n\r\n  private async easeToPos(\r\n    ticker: Ticker,\r\n    startPos: Point,\r\n    endPos: Point,\r\n    timeToArriveMs: number,\r\n    object: Container,\r\n    id: string,\r\n  ) {\r\n    this.easeMap[id] = Math.min(\r\n      (this.easeMap[id] ?? 0) + ticker.deltaMS / timeToArriveMs,\r\n      1,\r\n    );\r\n\r\n    const ease = (f: number) => Math.sqrt(1 - Math.pow(f - 1, 2)); // https://easings.net/#easeOutCirc\r\n    const directionVector = endPos.subtract(startPos);\r\n    object.position = startPos\r\n      .clone()\r\n      .add(directionVector.multiplyScalar(ease(this.easeMap[id])));\r\n\r\n    if (this.easeMap[id] === 1) {\r\n      this.easeMap[id] = 0;\r\n      ticker.destroy();\r\n    }\r\n  }\r\n}\r\n\r\nfunction getHitAreaForItem(type: GroceryItemType, bounds: BoundsData) {\r\n  const left = bounds.minX;\r\n  const top = bounds.minY;\r\n  const width = bounds.maxX - left;\r\n  const height = bounds.maxY - top;\r\n  function relativePoint(x: number, y: number) {\r\n    return new Point(left + width * x, top + height * y);\r\n  }\r\n  switch (type) {\r\n    case GroceryItemType.BANANA:\r\n      return new Polygon(\r\n        relativePoint(0.09, 0.31),\r\n        relativePoint(0.02, 0.46),\r\n        relativePoint(0, 0.7),\r\n        relativePoint(0.18, 0.91),\r\n        relativePoint(0.4, 1),\r\n        relativePoint(0.58, 0.99),\r\n        relativePoint(0.72, 0.92),\r\n        relativePoint(0.81, 0.86),\r\n        relativePoint(0.93, 0.7),\r\n        relativePoint(0.98, 0.5),\r\n        relativePoint(0.98, 0.42),\r\n        relativePoint(0.94, 0.2),\r\n        relativePoint(1, 0.12),\r\n        relativePoint(0.97, 0.04),\r\n        relativePoint(0.84, 0),\r\n        relativePoint(0.8, 0.04),\r\n        relativePoint(0.82, 0.13),\r\n        relativePoint(0.64, 0.33),\r\n        relativePoint(0.45, 0.39),\r\n      );\r\n    case GroceryItemType.MILK:\r\n      return new Polygon(\r\n        relativePoint(0.11, 0),\r\n        relativePoint(0.11, 0.16),\r\n        relativePoint(0.0, 0.34),\r\n        relativePoint(0.0, 0.85),\r\n        relativePoint(0.13, 0.94),\r\n        relativePoint(0.75, 1),\r\n        relativePoint(1, 0.86),\r\n        relativePoint(1, 0.34),\r\n        relativePoint(0.85, 0.14),\r\n        relativePoint(0.84, 0),\r\n      );\r\n    case GroceryItemType.PEANUT_BUTTER:\r\n      return new Polygon(\r\n        relativePoint(0.3, 0),\r\n        relativePoint(0.12, 0.05),\r\n        relativePoint(0.08, 0.1),\r\n        relativePoint(0.08, 0.28),\r\n        relativePoint(0.0, 0.4),\r\n        relativePoint(0.0, 0.75),\r\n        relativePoint(0.12, 0.93),\r\n        relativePoint(0.55, 1),\r\n        relativePoint(0.94, 0.97),\r\n        relativePoint(1, 0.86),\r\n        relativePoint(1, 0.6),\r\n        relativePoint(0.94, 0.35),\r\n        relativePoint(0.9, 0.3),\r\n        relativePoint(0.86, 0.06),\r\n        relativePoint(0.7, 0),\r\n      );\r\n    case GroceryItemType.PROTEIN:\r\n      return new Polygon(\r\n        relativePoint(0.3, 0),\r\n        relativePoint(0.12, 0.05),\r\n        relativePoint(0.08, 0.1),\r\n        relativePoint(0.08, 0.18),\r\n        relativePoint(0, 0.4),\r\n        relativePoint(0.02, 0.85),\r\n        relativePoint(0.08, 0.96),\r\n        relativePoint(0.55, 1),\r\n        relativePoint(0.87, 0.97),\r\n        relativePoint(0.99, 0.88),\r\n        relativePoint(1, 0.38),\r\n        relativePoint(0.96, 0.28),\r\n        relativePoint(0.89, 0.2),\r\n        relativePoint(0.89, 0.06),\r\n        relativePoint(0.73, 0),\r\n      );\r\n    case GroceryItemType.STRAWBERRIES:\r\n      return new Polygon(\r\n        relativePoint(0.28, 0),\r\n        relativePoint(0.12, 0.23),\r\n        relativePoint(0, 0.52),\r\n        relativePoint(0.03, 0.63),\r\n        relativePoint(0.38, 1),\r\n        relativePoint(0.47, 1),\r\n        relativePoint(0.6, 0.92),\r\n        relativePoint(0.9, 0.6),\r\n        relativePoint(0.98, 0.5),\r\n        relativePoint(1, 0.38),\r\n        relativePoint(0.96, 0.24),\r\n        relativePoint(0.83, 0),\r\n      );\r\n    case GroceryItemType.YOGHURT:\r\n      return new Polygon(\r\n        relativePoint(0.25, 0),\r\n        relativePoint(0, 0.1),\r\n        relativePoint(0, 0.16),\r\n        relativePoint(0.12, 0.82),\r\n        relativePoint(0.22, 0.94),\r\n        relativePoint(0.31, 0.99),\r\n        relativePoint(0.72, 1),\r\n        relativePoint(0.83, 0.95),\r\n        relativePoint(0.91, 0.82),\r\n        relativePoint(1, 0.18),\r\n        relativePoint(1, 0.08),\r\n        relativePoint(0.7, 0),\r\n      );\r\n    default:\r\n      return new Polygon();\r\n  }\r\n}\r\n\r\nfunction stringifyPoint(position: Point) {\r\n  return `x${position.x},y${position.y}`;\r\n}\r\n","import { Container, Graphics, Polygon } from \"pixi.js\";\r\n\r\n/**\r\n * Renders the polygon for a custom hit area. Only shows with the `dev` URL\r\n * param enabled.\r\n */\r\nexport function devPreviewHitArea(container: Container, hitArea: Polygon) {\r\n  if (!new URLSearchParams(window.location.search).get(\"dev\")) return;\r\n\r\n  const graphics = new Graphics();\r\n  graphics.poly(hitArea.points);\r\n  graphics.fill(0xde3249);\r\n  graphics.alpha = 0.3;\r\n  container.addChild(graphics);\r\n}\r\n","import { TextStyle, Text, Graphics, Point, Ticker, Sprite, Assets, assignWithIgnore } from \"pixi.js\";\nimport { KeyboardMinigame } from \"./keyboardMinigame\";\nimport { MINIGAME_ASSET_ALIASES } from \"./assets\";\n\nexport class BalancingMinigame extends KeyboardMinigame{\n   \n    private balancingObject: Sprite | null = null;\n    private pos: Point = new Point(1300, 1200);\n    private flag: boolean;\n    private currentForce: number = 0;\n    private forceAmount: number = 0.8;\n    protected override succeedOnTimeout: boolean = true;\n    \n    //temporary pos for the graphic instantiation\n    override async attach() {\n        super.attach();\n        \n        const texture = await Assets.load(\n            MINIGAME_ASSET_ALIASES.BALANCE_BG,\n         );\n        const background = new Sprite(texture);\n        background.setSize(this.app.screen);\n        background.zIndex = -1;\n        this.container.addChild(background);\n        this.ticker.add((time) => this.onUpdate(time))\n    }\n\n    protected override async populateContainer() {\n        this.pos = new Point(this.app.screen.height/6 * 5, this.app.screen.width/2);\n        this.balancingObject = new Sprite(await Assets.load(MINIGAME_ASSET_ALIASES.BALANCE_C1))\n        this.balancingObject.position = this.pos;\n        this.balancingObject.anchor = new Point(0.5,0.85);\n        \n        this.container.addChild(this.balancingObject);\n        \n    \n        \n        \n    }\n\n    protected override onKeyDown(key: string, e: KeyboardEvent): void {\n        if(e.repeat){return}\n        if (key == \"ArrowRight\") { \n            this.addRotForce(this.forceAmount);\n        }\n        if (key == \"ArrowLeft\") {\n            this.addRotForce(-this.forceAmount);\n         }\n    }\n\n    private addRotForce(amount: number) {\n        if (this.currentForce * amount > 0) {\n            this.currentForce += amount;\n        }\n        else {\n            this.currentForce = amount;\n        }\n        console.log(this.currentForce);\n        \n    }\n    \n    protected onUpdate(time: Ticker): void {\n        console.log(this.balancingObject.rotation);\n        const increment = this.currentForce * time.deltaTime* 0.1;\n        this.balancingObject.rotation += increment;\n        this.currentForce -= increment;\n        if (Math.abs(this.balancingObject.rotation) >= 2) {\n            this.finishMinigame(false);\n        }\n\n        \n\n        if (this.balancingObject.rotation >= 0) {\n            this.balancingObject.rotation += 0.003 + Math.abs(this.balancingObject.rotation)*0.008;\n        }\n        else {\n            this.balancingObject.rotation -= 0.003 + Math.abs(this.balancingObject.rotation)*0.008;\n            \n        }\n    }\n\n\n}","import { Application, Assets, Ticker } from \"pixi.js\";\nimport { getIntroFrames } from \"./frames/introFrames\";\nimport { getWeekThreeFrames } from \"./frames/weekThreeFrames\";\nimport { FrameData } from \"./frames/types\";\nimport { getOutroFrames } from \"./frames/outroFrames\";\n\nconst INTERLUDE_ASSET_PATHS = {\n  intro1: \"./assets/sprites/intro/opening-gym-panel-1.png\",\n  intro2: \"./assets/sprites/intro/opening-gym-panel-2.png\",\n  intro3: \"./assets/sprites/intro/opening-gym-panel-3.png\",\n  intro4: \"./assets/sprites/intro/exercise1.png\",\n  intro5: \"./assets/sprites/intro/exercise2.png\",\n  intro6: \"./assets/sprites/intro/exercise3.png\",\n  intro7: \"./assets/sprites/intro/exercise4.png\",\n  intro8: \"./assets/sprites/intro/exercise5.png\",\n  intro9: \"./assets/sprites/intro/exercise6.png\",\n  intro10: \"./assets/sprites/intro/gymconvo1.png\",\n  intro11: \"./assets/sprites/intro/gymconvo2.png\",\n  intro12: \"./assets/sprites/intro/gymconvo3.png\",\n  intro13: \"./assets/sprites/intro/gymconvo4.png\",\n  intro14: \"./assets/sprites/intro/gymconvo5.png\",\n  intro15: \"./assets/sprites/intro/gymconvo6.png\",\n  beforeComp1: \"./assets/sprites/beforecomp/before-comp-1.png\",\n  beforeComp2: \"./assets/sprites/beforecomp/before-comp-2.png\",\n  beforeComp3: \"./assets/sprites/beforecomp/before-comp-3.png\",\n  beforeComp4: \"./assets/sprites/beforecomp/before-comp-4.png\",\n  beforeComp5: \"./assets/sprites/beforecomp/before-comp-5.png\",\n  beforeComp6: \"./assets/sprites/beforecomp/lastday-gym-1.png\",\n  beforeComp7: \"./assets/sprites/beforecomp/lastday-gym-2.png\",\n  beforeComp8: \"./assets/sprites/beforecomp/lastday-gym-3.png\",\n  afterComp1: \"./assets/sprites/aftercomp/aftercomp1.png\",\n  afterComp2: \"./assets/sprites/aftercomp/aftercomp2.png\",\n  afterComp3: \"./assets/sprites/aftercomp/aftercomp3.png\",\n};\n\nexport function backgroundLoadInterludeAssets() {\n  const aliases = Object.keys(INTERLUDE_ASSET_PATHS);\n  aliases.forEach((alias) => {\n    Assets.add({\n      alias: alias,\n      src: INTERLUDE_ASSET_PATHS[alias],\n    });\n  });\n\n  Assets.backgroundLoad(aliases);\n}\n\nexport interface InterludeDelegate {\n  onInterludeEnd: () => void;\n}\n\nconst framesList = [\n  getIntroFrames,\n  () => [],\n  () => [],\n  getWeekThreeFrames,\n  getOutroFrames,\n];\n\nexport class Interlude {\n  private frames: FrameData[] = [];\n  private currentFrame = -1;\n\n  constructor(\n    private readonly app: Application,\n    private readonly delegate: InterludeDelegate,\n    private readonly week: number,\n  ) {}\n\n  async start() {\n    const getFrames = framesList[this.week];\n    if (getFrames !== undefined) {\n      this.frames = await getFrames(this.app);\n    }\n\n    this.showNextFrame();\n  }\n\n  private showNextFrame() {\n    this.currentFrame++;\n    if (this.currentFrame >= this.frames.length) {\n      this.delegate.onInterludeEnd();\n      return;\n    }\n\n    const { container, advanceMode, autoAdvanceMs } =\n      this.frames[this.currentFrame];\n    container.eventMode = \"static\";\n    if (advanceMode === \"click\") {\n      container.on(\"click\", () => {\n        this.app.stage.removeChild(container);\n        this.showNextFrame();\n      });\n    } else if (advanceMode === \"auto\") {\n      let remainingTime = autoAdvanceMs;\n      const ticker = new Ticker();\n      ticker.add((time) => {\n        remainingTime -= time.deltaMS;\n        if (remainingTime > 0) return;\n\n        this.app.stage.removeChild(container);\n        this.showNextFrame();\n        ticker.destroy();\n      });\n      ticker.start();\n    }\n\n    this.app.stage.addChild(container);\n  }\n}\n","import { Application, Rectangle } from \"pixi.js\";\nimport { FrameData, GetFrames } from \"./types\";\nimport { getRelativelyPositionedSpeech, spriteFrame } from \"./helpers\";\n\nexport const getIntroFrames: GetFrames = async (app: Application) => {\n  if (new URLSearchParams(window.location.search).get(\"skipIntro\")) return [];\n\n  const { screen } = app;\n\n  const allFrames: FrameData[] = [\n    await spriteFrame(app, \"intro1\", [getSpeech1(screen)]),\n    await spriteFrame(app, \"intro2\", [getSpeech1(screen), getSpeech2(screen)]),\n    await spriteFrame(app, \"intro3\", [\n      getSpeech1(screen),\n      getSpeech2(screen),\n      getSpeech3(screen),\n    ]),\n    await spriteFrame(app, \"intro4\", [], \"auto\"),\n    await spriteFrame(app, \"intro5\", [], \"auto\"),\n    await spriteFrame(app, \"intro6\", [], \"auto\"),\n    await spriteFrame(app, \"intro7\", [], \"auto\"),\n    await spriteFrame(app, \"intro8\", [], \"auto\"),\n    await spriteFrame(app, \"intro9\", [getSpeech4(screen)]),\n    await spriteFrame(app, \"intro10\", [getSpeech5(screen)]),\n    await spriteFrame(app, \"intro11\", [getSpeech5(screen), getSpeech6(screen)]),\n    await spriteFrame(app, \"intro12\", [\n      getSpeech5(screen),\n      getSpeech6(screen),\n      getSpeech7(screen),\n    ]),\n    await spriteFrame(app, \"intro13\", [], \"auto\", 1200),\n    await spriteFrame(app, \"intro14\", [getSpeech8(screen)]),\n    await spriteFrame(app, \"intro15\", [getSpeech8(screen), getSpeech9(screen)]),\n  ];\n\n  return allFrames;\n};\n\nfunction getSpeech1(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"These days I just feel so powerless.\",\n    screen,\n    { x: 0.465, y: 0.075, width: 0.11, height: 0.21 },\n  );\n}\n\nfunction getSpeech2(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"They say that the gym is a good place to get stronger.\",\n    screen,\n    { x: 0.345, y: 0.41, width: 0.225, height: 0.165 },\n  );\n}\n\nfunction getSpeech3(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"Ever since moving out I haven't been able to motivate myself to do anything. I've never exercised before, but there's not harm in trying, right?\",\n    screen,\n    { x: 0.65, y: 0.11, width: 0.3, height: 0.23 },\n  );\n}\n\nfunction getSpeech4(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"Nope, it's no good. Exercising is harder than it looks - it just makes me feel even weaker than I already did. Maybe there's no hope for me...\",\n    screen,\n    { x: 0.76, y: 0.495, width: 0.2, height: 0.435 },\n  );\n}\n\nfunction getSpeech5(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"Snap out of it! Rome wasn't built in a day, I just need to keep at it!\",\n    screen,\n    { x: 0.749, y: 0.32, width: 0.2, height: 0.12 },\n  );\n}\n\nfunction getSpeech6(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"I might not be able to see it now, but I need to keep going! If I can build up a good routine, with a healthy diet, surely some day, somehow, I can...!\",\n    screen,\n    { x: 0.09, y: 0.69, width: 0.36, height: 0.19 },\n  );\n}\n\nfunction getSpeech7(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    '\"Hey kiddo. Looks like you are struggling pretty hard over there! *snicker* I know just what you need-\"',\n    screen,\n    { x: 0.56, y: 0.545, width: 0.18, height: 0.17 },\n  );\n}\n\nfunction getSpeech8(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"No thanks. That seems super shady. I'm going to get stronger through my own hard work, just you watch.\",\n    screen,\n    { x: 0.84, y: 0.1, width: 0.12, height: 0.33 },\n    // { x: 0.73, y: 0.1, width: 0.2, height: 0.33 },\n  );\n}\n\nfunction getSpeech9(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"I need to do my best to prove just how powerful I can be!\",\n    screen,\n    { x: 0.779, y: 0.54, width: 0.175, height: 0.14 },\n  );\n}\n","import {\r\n  Application,\r\n  Assets,\r\n  Container,\r\n  Graphics,\r\n  Point,\r\n  Rectangle,\r\n  Sprite,\r\n  Text,\r\n  TextStyle,\r\n} from \"pixi.js\";\r\n\r\nexport async function spriteFrame(\r\n  app: Application,\r\n  assetAlias: string,\r\n  additionalObjects: Container[] = [],\r\n  advanceMode: \"auto\" | \"click\" = \"click\",\r\n  autoAdvanceMs = 400,\r\n) {\r\n  const frame = new Container();\r\n  frame.hitArea = app.screen;\r\n\r\n  const texture = await Assets.load(assetAlias);\r\n  const sprite = new Sprite(texture);\r\n  sprite.setSize(app.screen);\r\n  sprite.zIndex = -1;\r\n\r\n  frame.addChild(sprite, ...additionalObjects);\r\n\r\n  return { container: frame, advanceMode, autoAdvanceMs };\r\n}\r\n\r\nexport function getRelativelyPositionedSpeech(\r\n  content: string,\r\n  screen: Rectangle,\r\n  relativeBounds: { x: number; y: number; width: number; height: number },\r\n  drawBubble = true,\r\n) {\r\n  const { x, y, width, height } = relativeBounds;\r\n  const borderWidth = screen.height / 150;\r\n  const container = new Container();\r\n\r\n  const bubble = new Graphics();\r\n  bubble.rect(0, 0, screen.width * width, screen.height * height);\r\n  bubble.fill(0xffffff);\r\n  bubble.stroke({ color: 0x000000, width: screen.height / 100 });\r\n\r\n  if (drawBubble) {\r\n    container.addChild(bubble);\r\n  }\r\n\r\n  const textStyle = new TextStyle({\r\n    fontFamily: '\"Poppins\", sans-serif',\r\n    fontSize: screen.height / 40,\r\n    wordWrap: true,\r\n    wordWrapWidth: bubble.width - borderWidth * 4,\r\n  });\r\n  const text = new Text({\r\n    text: content,\r\n    style: textStyle,\r\n  });\r\n  text.zIndex = 1;\r\n  text.position = new Point(borderWidth * 2, borderWidth * 2);\r\n\r\n  container.addChild(text);\r\n  container.position = new Point(screen.width * x, screen.height * y);\r\n  return container;\r\n}\r\n","import { Application, Rectangle } from \"pixi.js\";\nimport { FrameData, GetFrames } from \"./types\";\nimport { getRelativelyPositionedSpeech, spriteFrame } from \"./helpers\";\n\nexport const getWeekThreeFrames: GetFrames = async (app: Application) => {\n  const { screen } = app;\n\n  const allFrames: FrameData[] = [\n    await spriteFrame(app, \"beforeComp1\", [getSpeech1(screen)]),\n    await spriteFrame(app, \"beforeComp2\", [getSpeech1(screen)], \"auto\", 800),\n    await spriteFrame(app, \"beforeComp3\", [getSpeech1(screen)], \"auto\", 800),\n    await spriteFrame(app, \"beforeComp4\", [\n      getSpeech1(screen),\n      getSpeech2(screen),\n    ]),\n    await spriteFrame(app, \"beforeComp5\", [\n      getSpeech1(screen),\n      getSpeech2(screen),\n      getSpeech3(screen),\n    ]),\n    await spriteFrame(app, \"beforeComp6\", [getSpeech4(screen)]),\n    await spriteFrame(app, \"beforeComp7\", [\n      getSpeech4(screen),\n      getSpeech5(screen),\n    ]),\n    await spriteFrame(app, \"beforeComp8\", [\n      getSpeech4(screen),\n      getSpeech5(screen),\n      getSpeech6(screen),\n    ]),\n  ];\n\n  return allFrames;\n};\n\nfunction getSpeech1(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\"It's been 3 weeks...\", screen, {\n    x: 0.28,\n    y: 0.07,\n    width: 0.095,\n    height: 0.12,\n  });\n}\n\nfunction getSpeech2(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"What's this? A powerlifting competition? Maybe with this-\",\n    screen,\n    { x: 0.315, y: 0.67, width: 0.11, height: 0.25 },\n  );\n}\n\nfunction getSpeech3(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"I can show that wolf how far I've come!\",\n    screen,\n    { x: 0.838, y: 0.57, width: 0.125, height: 0.122 },\n  );\n}\n\nfunction getSpeech4(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\"Today's the day.\", screen, {\n    x: 0.465,\n    y: 0.075,\n    width: 0.11,\n    height: 0.21,\n  });\n}\n\nfunction getSpeech5(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"I know I can win this competition. I've been training non-stop for it.\",\n    screen,\n    { x: 0.345, y: 0.41, width: 0.225, height: 0.165 },\n  );\n}\n\nfunction getSpeech6(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"It's time for me to blow the roof off the competition!\",\n    screen,\n    { x: 0.65, y: 0.11, width: 0.3, height: 0.23 },\n  );\n}\n","import { Application, Rectangle } from \"pixi.js\";\nimport { FrameData, GetFrames } from \"./types\";\nimport { getRelativelyPositionedSpeech, spriteFrame } from \"./helpers\";\n\nexport const getOutroFrames: GetFrames = async (app: Application) => {\n  const { screen } = app;\n\n  const allFrames: FrameData[] = [\n    await spriteFrame(app, \"afterComp1\", [getSpeech1(screen)]),\n    await spriteFrame(app, \"afterComp2\", [\n      getSpeech1(screen),\n      getSpeech2(screen),\n    ]),\n    await spriteFrame(app, \"afterComp3\", [\n      getSpeech1(screen),\n      getSpeech2(screen),\n      getSpeech3(screen),\n      getSpeech4(screen),\n    ]),\n    await spriteFrame(app, \"afterComp3\", [\n      getSpeech1(screen),\n      getSpeech2(screen),\n      getSpeech3(screen),\n      getSpeech4(screen),\n      getSpeech5(screen),\n    ]),\n  ];\n\n  return allFrames;\n};\n\nfunction getSpeech1(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"\\\"Sorry pal, you're disqualified. You can't just go breaking the fifth wall like that.\\\"\",\n    screen,\n    {\n      x: 0.07,\n      y: 0.69,\n      width: 0.215,\n      height: 0.2,\n    },\n  );\n}\n\nfunction getSpeech2(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"After all that... did I accomplish nothing? *sigh* Maybe I should pay mum a visit\",\n    screen,\n    { x: 0.668, y: 0.39, width: 0.27, height: 0.12 },\n  );\n}\n\nfunction getSpeech3(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    '\"Welcome home son, I\\'ve missed you. Help me bring in the groceries, would you?\"',\n    screen,\n    { x: 0.65, y: 0.78, width: 0.18, height: 0.14 },\n  );\n}\n\nfunction getSpeech4(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"In that moment it was clear. The power I could use for good meant so much more to me than any competition.\",\n    screen,\n    { x: 0.85, y: 0.57, width: 0.1, height: 0.365 },\n  );\n}\n\nfunction getSpeech5(screen: Rectangle) {\n  return getRelativelyPositionedSpeech(\n    \"Fin.\",\n    screen,\n    {\n      x: 0.92,\n      y: 0.93,\n      width: 0.05,\n      height: 0.05,\n    },\n    /* drawBubble= */ false,\n  );\n}\n","import { Assets, Point, Sprite, Ticker } from \"pixi.js\";\r\nimport { MINIGAME_ASSET_ALIASES } from \"../assets\";\r\nimport { CheckpointMinigame } from \"../checkpointMinigame\";\r\n\r\nexport class CheckpointOneMinigame extends CheckpointMinigame {\r\n  protected override chargeRate = 10;\r\n  protected override drainRate = 0.1;\r\n\r\n  protected override initialBackgroundAlias =\r\n    MINIGAME_ASSET_ALIASES.CHECKPOINT_1_1;\r\n\r\n  protected override async cacheAssets() {\r\n    await Assets.load([\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_1_1,\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_1_2,\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_1_3,\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_1_4,\r\n      MINIGAME_ASSET_ALIASES.ROOMBA,\r\n    ]);\r\n  }\r\n\r\n  protected override async updateBackground() {\r\n    if (this.chargeBar < 33) {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_1_1);\r\n    } else if (this.chargeBar < 66) {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_1_2);\r\n    } else if (this.chargeBar < 100) {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_1_3);\r\n    } else {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_1_4);\r\n    }\r\n  }\r\n\r\n  protected override async endContent() {\r\n    const { screen } = this.app;\r\n    const texture = await Assets.load(MINIGAME_ASSET_ALIASES.ROOMBA);\r\n    const roomba = new Sprite(texture);\r\n\r\n    const aspectRatio = roomba.width / roomba.height;\r\n    roomba.width = screen.width * 0.15;\r\n    roomba.height = roomba.width / aspectRatio;\r\n    roomba.anchor = new Point(0, 1);\r\n    roomba.position = new Point(-roomba.width, screen.height * 0.85);\r\n    roomba.zIndex = 1;\r\n\r\n    this.container.addChild(roomba);\r\n\r\n    const ticker = new Ticker();\r\n    ticker.autoStart = true;\r\n    await new Promise<void>((res) => {\r\n      ticker.add((time) => {\r\n        roomba.x += 8 * time.deltaTime;\r\n        if (roomba.x > screen.width) {\r\n          res();\r\n          ticker.destroy();\r\n        }\r\n      });\r\n    });\r\n    await new Promise((res) => setTimeout(res, 2000));\r\n  }\r\n}\r\n","import { Assets, Point, Sprite, Ticker } from \"pixi.js\";\nimport { KeyboardMinigame } from \"./keyboardMinigame\";\nimport { MINIGAME_ASSET_ALIASES } from \"./assets\";\n\n/** Minigame that plays at the end of each day. Generally just a button masher. */\nexport class CheckpointMinigame extends KeyboardMinigame {\n  // Checkpoints have no time limit.\n  protected override lifetime = undefined;\n\n  // Charge bar goes from 0 -> 100 but drains at some rate.\n  protected chargeBar = 0;\n  protected chargeRate = 10;\n  protected drainRate = 0.1;\n\n  protected background: Sprite;\n  protected initialBackgroundAlias = MINIGAME_ASSET_ALIASES.CHECKPOINT_1_1;\n  private initialBackgroundScale: Point;\n\n  private minigameComplete = false;\n\n  private bounceProgress = 0;\n\n  protected async populateContainer() {\n    const { screen } = this.app;\n    await this.cacheAssets();\n    const texture = await Assets.load(this.initialBackgroundAlias);\n    this.background = new Sprite(texture);\n    this.background.setSize(screen);\n    this.background.anchor = 0.5;\n    this.background.position = new Point(screen.width / 2, screen.height / 2);\n    this.initialBackgroundScale = this.background.scale.clone();\n    this.background.zIndex = -1;\n\n    this.container.addChild(this.background);\n\n    this.ticker.add(async (time) => {\n      if (this.chargeBar > 0 && this.chargeBar < 100) {\n        // Slowly drain.\n        this.chargeBar -= this.drainRate * time.deltaTime;\n      }\n\n      await this.updateBackground();\n\n      if (this.chargeBar === 100) {\n        this.finishCheckpoint();\n      }\n    });\n  }\n\n  protected async cacheAssets() {}\n\n  protected async updateBackground() {}\n\n  protected async changeBackgroundTexture(alias: MINIGAME_ASSET_ALIASES) {\n    this.background.texture = await Assets.load(alias);\n  }\n\n  protected async endContent() {}\n\n  protected override onKeyDown(key: string, e: KeyboardEvent) {\n    // Prevent holding down the key to win.\n    if (this.minigameComplete || key != \" \" || e.repeat) return;\n\n    this.chargeBar = Math.min(this.chargeBar + this.chargeRate, 100);\n\n    const ticker = new Ticker();\n    ticker.add((time) =>\n      this.bounce(\n        time,\n        this.initialBackgroundScale.clone().multiplyScalar(1.05),\n        150,\n      ),\n    );\n    ticker.start();\n  }\n\n  private finishCheckpoint() {\n    this.minigameComplete = true;\n    this.finishMinigame(true, this.endContent());\n  }\n\n  private async bounce(\n    ticker: Ticker,\n    peakScale: Point,\n    timeToFinishMs: number,\n  ) {\n    this.bounceProgress = Math.min(\n      this.bounceProgress + ticker.deltaMS / timeToFinishMs,\n      1,\n    );\n\n    const bounce = (f: number) => -Math.pow(1 - 2 * f, 2) + 1;\n    const directionVector = peakScale\n      .clone()\n      .subtract(this.initialBackgroundScale);\n    this.background.scale = this.initialBackgroundScale\n      .clone()\n      .add(directionVector.multiplyScalar(bounce(this.bounceProgress)));\n\n    if (this.bounceProgress === 1) {\n      this.bounceProgress = 0;\n      ticker.destroy();\n    }\n  }\n}\n","import { Assets, Point, Sprite, Ticker } from \"pixi.js\";\r\nimport { MINIGAME_ASSET_ALIASES } from \"../assets\";\r\nimport { CheckpointMinigame } from \"../checkpointMinigame\";\r\n\r\nexport class CheckpointTwoMinigame extends CheckpointMinigame {\r\n  protected override chargeRate = 8;\r\n  protected override drainRate = 0.2;\r\n\r\n  protected override initialBackgroundAlias =\r\n    MINIGAME_ASSET_ALIASES.CHECKPOINT_2_1;\r\n\r\n  protected override async cacheAssets() {\r\n    await Assets.load([\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_2_1,\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_2_2,\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_2_3,\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_2_4,\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_2_5,\r\n      MINIGAME_ASSET_ALIASES.RABBIT,\r\n    ]);\r\n  }\r\n\r\n  protected override async updateBackground() {\r\n    if (this.chargeBar < 33) {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_2_1);\r\n    } else if (this.chargeBar < 66) {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_2_2);\r\n    } else if (this.chargeBar < 100) {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_2_3);\r\n    } else {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_2_4);\r\n    }\r\n  }\r\n\r\n  protected override async endContent() {\r\n    const { screen } = this.app;\r\n    const texture = await Assets.load(MINIGAME_ASSET_ALIASES.RABBIT);\r\n    const rabbit = new Sprite(texture);\r\n\r\n    const aspectRatio = rabbit.width / rabbit.height;\r\n    rabbit.width = screen.width * 0.18;\r\n    rabbit.height = rabbit.width / aspectRatio;\r\n    rabbit.anchor = new Point(0, 1);\r\n    rabbit.position = new Point(screen.width * 0.2, screen.height * 0.65);\r\n    rabbit.zIndex = 1;\r\n\r\n    this.container.addChild(rabbit);\r\n\r\n    const ticker = new Ticker();\r\n    ticker.autoStart = true;\r\n    const destination = new Point(screen.width * 0.55, screen.height * 0.3);\r\n    const directionVector = destination\r\n      .clone()\r\n      .subtract(rabbit.position.clone());\r\n    await new Promise<void>((res) => {\r\n      ticker.add((time) => {\r\n        rabbit.position = rabbit.position.add(\r\n          directionVector.normalize().multiplyScalar(10 * time.deltaTime),\r\n        );\r\n        if (rabbit.position.x > destination.x) {\r\n          res();\r\n          ticker.destroy();\r\n        }\r\n      });\r\n    });\r\n\r\n    rabbit.removeFromParent();\r\n    await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_2_5);\r\n\r\n    await new Promise((res) => setTimeout(res, 2000));\r\n  }\r\n}\r\n","import { Assets, Point, Sprite, Ticker } from \"pixi.js\";\r\nimport { MINIGAME_ASSET_ALIASES } from \"../assets\";\r\nimport { CheckpointMinigame } from \"../checkpointMinigame\";\r\n\r\nexport class CheckpointThreeMinigame extends CheckpointMinigame {\r\n  protected override chargeRate = 6;\r\n  protected override drainRate = 0.25;\r\n\r\n  protected override initialBackgroundAlias =\r\n    MINIGAME_ASSET_ALIASES.CHECKPOINT_3_1;\r\n\r\n  protected override async cacheAssets() {\r\n    await Assets.load([\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_3_1,\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_3_2,\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_3_3,\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_3_4,\r\n      MINIGAME_ASSET_ALIASES.CHECKPOINT_3_5,\r\n      MINIGAME_ASSET_ALIASES.BAR,\r\n    ]);\r\n  }\r\n\r\n  protected override async updateBackground() {\r\n    if (this.chargeBar < 33) {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_3_1);\r\n    } else if (this.chargeBar < 66) {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_3_2);\r\n    } else if (this.chargeBar < 100) {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_3_3);\r\n    } else {\r\n      await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_3_4);\r\n    }\r\n  }\r\n\r\n  protected override async endContent() {\r\n    const { screen } = this.app;\r\n    const texture = await Assets.load(MINIGAME_ASSET_ALIASES.BAR);\r\n    const bar = new Sprite(texture);\r\n\r\n    const aspectRatio = bar.width / bar.height;\r\n    bar.width = screen.width * 0.64;\r\n    bar.height = bar.width / aspectRatio;\r\n    bar.anchor = new Point(0.5, 1);\r\n    bar.position = new Point(screen.width * 0.51, screen.height * 0.25);\r\n    bar.zIndex = 1;\r\n\r\n    this.container.addChild(bar);\r\n\r\n    let ticker = new Ticker();\r\n    ticker.autoStart = true;\r\n    await new Promise<void>((res) => {\r\n      ticker.add((time) => {\r\n        bar.y -= 25 * time.deltaTime;\r\n        if (bar.y < 0) {\r\n          res();\r\n          ticker.destroy();\r\n        }\r\n      });\r\n    });\r\n    await new Promise((res) => setTimeout(res, 300));\r\n\r\n    await this.changeBackgroundTexture(MINIGAME_ASSET_ALIASES.CHECKPOINT_3_5);\r\n    await new Promise((res) => setTimeout(res, 500));\r\n\r\n    bar.position = new Point(screen.width * 0.5, screen.height * 1.2);\r\n    bar.angle = -6;\r\n    bar.scale = bar.scale.clone().multiplyScalar(0.6);\r\n\r\n    ticker = new Ticker();\r\n    ticker.autoStart = true;\r\n    await new Promise<void>((res) => {\r\n      ticker.add((time) => {\r\n        bar.y -= 19 * time.deltaTime;\r\n        if (bar.y < -bar.width) {\r\n          res();\r\n          ticker.destroy();\r\n        }\r\n      });\r\n    });\r\n\r\n    await new Promise((res) => setTimeout(res, 2000));\r\n  }\r\n}\r\n","import { Howl } from \"howler\";\n\nexport class AudioController {\n  private tracks = new Map<string, Howl>();\n\n  preload() {\n    this.tracks.set(\n      \"titleScreen\",\n      new Howl({\n        src: [\"./assets/audio/titlescreen.mp3\"],\n        volume: 0.01,\n      }),\n    );\n\n    const allTracks = Array.from(this.tracks.values());\n    return Promise.all(\n      allTracks.map(\n        (howl: Howl) => new Promise((resolve) => howl.once(\"load\", resolve)),\n      ),\n    );\n  }\n\n  playTitleScreenMusic() {\n    this.tracks.get(\"titleScreen\")!.play();\n  }\n}\n","/*!\n *  howler.js v2.2.4\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create the global controller. All contained methods and properties apply\n   * to all sounds that are currently playing or will be in the future.\n   */\n  var HowlerGlobal = function() {\n    this.init();\n  };\n  HowlerGlobal.prototype = {\n    /**\n     * Initialize the global Howler object.\n     * @return {Howler}\n     */\n    init: function() {\n      var self = this || Howler;\n\n      // Create a global ID counter.\n      self._counter = 1000;\n\n      // Pool of unlocked HTML5 Audio objects.\n      self._html5AudioPool = [];\n      self.html5PoolSize = 10;\n\n      // Internal properties.\n      self._codecs = {};\n      self._howls = [];\n      self._muted = false;\n      self._volume = 1;\n      self._canPlayEvent = 'canplaythrough';\n      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;\n\n      // Public properties.\n      self.masterGain = null;\n      self.noAudio = false;\n      self.usingWebAudio = true;\n      self.autoSuspend = true;\n      self.ctx = null;\n\n      // Set to false to disable the auto audio unlocker.\n      self.autoUnlock = true;\n\n      // Setup the various state values for global tracking.\n      self._setup();\n\n      return self;\n    },\n\n    /**\n     * Get/set the global volume for all sounds.\n     * @param  {Float} vol Volume from 0.0 to 1.0.\n     * @return {Howler/Float}     Returns self or current volume.\n     */\n    volume: function(vol) {\n      var self = this || Howler;\n      vol = parseFloat(vol);\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        self._volume = vol;\n\n        // Don't update any of the nodes if we are muted.\n        if (self._muted) {\n          return self;\n        }\n\n        // When using Web Audio, we just need to adjust the master gain.\n        if (self.usingWebAudio) {\n          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n        }\n\n        // Loop through and change volume for all HTML5 audio nodes.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and change the volumes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node) {\n                sound._node.volume = sound._volume * vol;\n              }\n            }\n          }\n        }\n\n        return self;\n      }\n\n      return self._volume;\n    },\n\n    /**\n     * Handle muting and unmuting globally.\n     * @param  {Boolean} muted Is muted or not.\n     */\n    mute: function(muted) {\n      var self = this || Howler;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      self._muted = muted;\n\n      // With Web Audio, we just need to mute the master gain.\n      if (self.usingWebAudio) {\n        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);\n      }\n\n      // Loop through and mute all HTML5 Audio nodes.\n      for (var i=0; i<self._howls.length; i++) {\n        if (!self._howls[i]._webAudio) {\n          // Get all of the sounds in this Howl group.\n          var ids = self._howls[i]._getSoundIds();\n\n          // Loop through all sounds and mark the audio node as muted.\n          for (var j=0; j<ids.length; j++) {\n            var sound = self._howls[i]._soundById(ids[j]);\n\n            if (sound && sound._node) {\n              sound._node.muted = (muted) ? true : sound._muted;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Handle stopping all sounds globally.\n     */\n    stop: function() {\n      var self = this || Howler;\n\n      // Loop through all Howls and stop them.\n      for (var i=0; i<self._howls.length; i++) {\n        self._howls[i].stop();\n      }\n\n      return self;\n    },\n\n    /**\n     * Unload and destroy all currently loaded Howl objects.\n     * @return {Howler}\n     */\n    unload: function() {\n      var self = this || Howler;\n\n      for (var i=self._howls.length-1; i>=0; i--) {\n        self._howls[i].unload();\n      }\n\n      // Create a new AudioContext to make sure it is fully reset.\n      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {\n        self.ctx.close();\n        self.ctx = null;\n        setupAudioContext();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for codec support of specific extension.\n     * @param  {String} ext Audio file extention.\n     * @return {Boolean}\n     */\n    codecs: function(ext) {\n      return (this || Howler)._codecs[ext.replace(/^x-/, '')];\n    },\n\n    /**\n     * Setup various state values for global tracking.\n     * @return {Howler}\n     */\n    _setup: function() {\n      var self = this || Howler;\n\n      // Keeps track of the suspend/resume state of the AudioContext.\n      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';\n\n      // Automatically begin the 30-second suspend process\n      self._autoSuspend();\n\n      // Check if audio is available.\n      if (!self.usingWebAudio) {\n        // No audio is available on this system if noAudio is set to true.\n        if (typeof Audio !== 'undefined') {\n          try {\n            var test = new Audio();\n\n            // Check if the canplaythrough event is available.\n            if (typeof test.oncanplaythrough === 'undefined') {\n              self._canPlayEvent = 'canplay';\n            }\n          } catch(e) {\n            self.noAudio = true;\n          }\n        } else {\n          self.noAudio = true;\n        }\n      }\n\n      // Test to make sure audio isn't disabled in Internet Explorer.\n      try {\n        var test = new Audio();\n        if (test.muted) {\n          self.noAudio = true;\n        }\n      } catch (e) {}\n\n      // Check for supported codecs.\n      if (!self.noAudio) {\n        self._setupCodecs();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for browser support for various codecs and cache the results.\n     * @return {Howler}\n     */\n    _setupCodecs: function() {\n      var self = this || Howler;\n      var audioTest = null;\n\n      // Must wrap in a try/catch because IE11 in server mode throws an error.\n      try {\n        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;\n      } catch (err) {\n        return self;\n      }\n\n      if (!audioTest || typeof audioTest.canPlayType !== 'function') {\n        return self;\n      }\n\n      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');\n\n      // Opera version <33 has mixed MP3 support, so we need to check for and block it.\n      var ua = self._navigator ? self._navigator.userAgent : '';\n      var checkOpera = ua.match(/OPR\\/(\\d+)/g);\n      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);\n      var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;\n      var safariVersion = ua.match(/Version\\/(.*?) /);\n      var isOldSafari = (checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15);\n\n      self._codecs = {\n        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),\n        mpeg: !!mpegTest,\n        opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\n        ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        wav: !!(audioTest.canPlayType('audio/wav; codecs=\"1\"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),\n        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\n        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\n        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n        webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n        dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\n        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\n      };\n\n      return self;\n    },\n\n    /**\n     * Some browsers/devices will only allow audio to be played after a user interaction.\n     * Attempt to automatically unlock audio on the first user interaction.\n     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\n     * @return {Howler}\n     */\n    _unlockAudio: function() {\n      var self = this || Howler;\n\n      // Only run this if Web Audio is supported and it hasn't already been unlocked.\n      if (self._audioUnlocked || !self.ctx) {\n        return;\n      }\n\n      self._audioUnlocked = false;\n      self.autoUnlock = false;\n\n      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\n      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\n      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\n      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\n        self._mobileUnloaded = true;\n        self.unload();\n      }\n\n      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\n      // http://stackoverflow.com/questions/24119684\n      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\n\n      // Call this method on touch start to create and play a buffer,\n      // then check if the audio actually played to determine if\n      // audio has now been unlocked on iOS, Android, etc.\n      var unlock = function(e) {\n        // Create a pool of unlocked HTML5 Audio objects that can\n        // be used for playing sounds without user interaction. HTML5\n        // Audio objects must be individually unlocked, as opposed\n        // to the WebAudio API which only needs a single activation.\n        // This must occur before WebAudio setup or the source.onended\n        // event will not fire.\n        while (self._html5AudioPool.length < self.html5PoolSize) {\n          try {\n            var audioNode = new Audio();\n\n            // Mark this Audio object as unlocked to ensure it can get returned\n            // to the unlocked pool when released.\n            audioNode._unlocked = true;\n\n            // Add the audio node to the pool.\n            self._releaseHtml5Audio(audioNode);\n          } catch (e) {\n            self.noAudio = true;\n            break;\n          }\n        }\n\n        // Loop through any assigned audio nodes and unlock them.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and unlock the audio nodes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node && !sound._node._unlocked) {\n                sound._node._unlocked = true;\n                sound._node.load();\n              }\n            }\n          }\n        }\n\n        // Fix Android can not play in suspend state.\n        self._autoResume();\n\n        // Create an empty buffer.\n        var source = self.ctx.createBufferSource();\n        source.buffer = self._scratchBuffer;\n        source.connect(self.ctx.destination);\n\n        // Play the empty buffer.\n        if (typeof source.start === 'undefined') {\n          source.noteOn(0);\n        } else {\n          source.start(0);\n        }\n\n        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\n        if (typeof self.ctx.resume === 'function') {\n          self.ctx.resume();\n        }\n\n        // Setup a timeout to check that we are unlocked on the next event loop.\n        source.onended = function() {\n          source.disconnect(0);\n\n          // Update the unlocked state and prevent this check from happening again.\n          self._audioUnlocked = true;\n\n          // Remove the touch start listener.\n          document.removeEventListener('touchstart', unlock, true);\n          document.removeEventListener('touchend', unlock, true);\n          document.removeEventListener('click', unlock, true);\n          document.removeEventListener('keydown', unlock, true);\n\n          // Let all sounds know that audio has been unlocked.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('unlock');\n          }\n        };\n      };\n\n      // Setup a touch start listener to attempt an unlock in.\n      document.addEventListener('touchstart', unlock, true);\n      document.addEventListener('touchend', unlock, true);\n      document.addEventListener('click', unlock, true);\n      document.addEventListener('keydown', unlock, true);\n\n      return self;\n    },\n\n    /**\n     * Get an unlocked HTML5 Audio object from the pool. If none are left,\n     * return a new Audio object and throw a warning.\n     * @return {Audio} HTML5 Audio object.\n     */\n    _obtainHtml5Audio: function() {\n      var self = this || Howler;\n\n      // Return the next object from the pool if one exists.\n      if (self._html5AudioPool.length) {\n        return self._html5AudioPool.pop();\n      }\n\n      //.Check if the audio is locked and throw a warning.\n      var testPlay = new Audio().play();\n      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {\n        testPlay.catch(function() {\n          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');\n        });\n      }\n\n      return new Audio();\n    },\n\n    /**\n     * Return an activated HTML5 Audio object to the pool.\n     * @return {Howler}\n     */\n    _releaseHtml5Audio: function(audio) {\n      var self = this || Howler;\n\n      // Don't add audio to the pool if we don't know if it has been unlocked.\n      if (audio._unlocked) {\n        self._html5AudioPool.push(audio);\n      }\n\n      return self;\n    },\n\n    /**\n     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\n     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\n     * @return {Howler}\n     */\n    _autoSuspend: function() {\n      var self = this;\n\n      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      // Check if any sounds are playing.\n      for (var i=0; i<self._howls.length; i++) {\n        if (self._howls[i]._webAudio) {\n          for (var j=0; j<self._howls[i]._sounds.length; j++) {\n            if (!self._howls[i]._sounds[j]._paused) {\n              return self;\n            }\n          }\n        }\n      }\n\n      if (self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n      }\n\n      // If no sound has played after 30 seconds, suspend the context.\n      self._suspendTimer = setTimeout(function() {\n        if (!self.autoSuspend) {\n          return;\n        }\n\n        self._suspendTimer = null;\n        self.state = 'suspending';\n\n        // Handle updating the state of the audio context after suspending.\n        var handleSuspension = function() {\n          self.state = 'suspended';\n\n          if (self._resumeAfterSuspend) {\n            delete self._resumeAfterSuspend;\n            self._autoResume();\n          }\n        };\n\n        // Either the state gets suspended or it is interrupted.\n        // Either way, we need to update the state to suspended.\n        self.ctx.suspend().then(handleSuspension, handleSuspension);\n      }, 30000);\n\n      return self;\n    },\n\n    /**\n     * Automatically resume the Web Audio AudioContext when a new sound is played.\n     * @return {Howler}\n     */\n    _autoResume: function() {\n      var self = this;\n\n      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n        self._suspendTimer = null;\n      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {\n        self.ctx.resume().then(function() {\n          self.state = 'running';\n\n          // Emit to all Howls that the audio has resumed.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('resume');\n          }\n        });\n\n        if (self._suspendTimer) {\n          clearTimeout(self._suspendTimer);\n          self._suspendTimer = null;\n        }\n      } else if (self.state === 'suspending') {\n        self._resumeAfterSuspend = true;\n      }\n\n      return self;\n    }\n  };\n\n  // Setup the global audio controller.\n  var Howler = new HowlerGlobal();\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create an audio group controller.\n   * @param {Object} o Passed in properties for this group.\n   */\n  var Howl = function(o) {\n    var self = this;\n\n    // Throw an error if no source is provided.\n    if (!o.src || o.src.length === 0) {\n      console.error('An array of source files must be passed with any new Howl.');\n      return;\n    }\n\n    self.init(o);\n  };\n  Howl.prototype = {\n    /**\n     * Initialize a new Howl group object.\n     * @param  {Object} o Passed in properties for this group.\n     * @return {Howl}\n     */\n    init: function(o) {\n      var self = this;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!Howler.ctx) {\n        setupAudioContext();\n      }\n\n      // Setup user-defined default properties.\n      self._autoplay = o.autoplay || false;\n      self._format = (typeof o.format !== 'string') ? o.format : [o.format];\n      self._html5 = o.html5 || false;\n      self._muted = o.mute || false;\n      self._loop = o.loop || false;\n      self._pool = o.pool || 5;\n      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;\n      self._rate = o.rate || 1;\n      self._sprite = o.sprite || {};\n      self._src = (typeof o.src !== 'string') ? o.src : [o.src];\n      self._volume = o.volume !== undefined ? o.volume : 1;\n      self._xhr = {\n        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',\n        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,\n        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,\n      };\n\n      // Setup all other default properties.\n      self._duration = 0;\n      self._state = 'unloaded';\n      self._sounds = [];\n      self._endTimers = {};\n      self._queue = [];\n      self._playLock = false;\n\n      // Setup event listeners.\n      self._onend = o.onend ? [{fn: o.onend}] : [];\n      self._onfade = o.onfade ? [{fn: o.onfade}] : [];\n      self._onload = o.onload ? [{fn: o.onload}] : [];\n      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];\n      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];\n      self._onpause = o.onpause ? [{fn: o.onpause}] : [];\n      self._onplay = o.onplay ? [{fn: o.onplay}] : [];\n      self._onstop = o.onstop ? [{fn: o.onstop}] : [];\n      self._onmute = o.onmute ? [{fn: o.onmute}] : [];\n      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];\n      self._onrate = o.onrate ? [{fn: o.onrate}] : [];\n      self._onseek = o.onseek ? [{fn: o.onseek}] : [];\n      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];\n      self._onresume = [];\n\n      // Web Audio or HTML5 Audio?\n      self._webAudio = Howler.usingWebAudio && !self._html5;\n\n      // Automatically try to enable audio.\n      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {\n        Howler._unlockAudio();\n      }\n\n      // Keep track of this Howl group in the global controller.\n      Howler._howls.push(self);\n\n      // If they selected autoplay, add a play event to the load queue.\n      if (self._autoplay) {\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play();\n          }\n        });\n      }\n\n      // Load the source file unless otherwise specified.\n      if (self._preload && self._preload !== 'none') {\n        self.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Load the audio file.\n     * @return {Howler}\n     */\n    load: function() {\n      var self = this;\n      var url = null;\n\n      // If no audio is available, quit immediately.\n      if (Howler.noAudio) {\n        self._emit('loaderror', null, 'No audio support.');\n        return;\n      }\n\n      // Make sure our source is in an array.\n      if (typeof self._src === 'string') {\n        self._src = [self._src];\n      }\n\n      // Loop through the sources and pick the first one that is compatible.\n      for (var i=0; i<self._src.length; i++) {\n        var ext, str;\n\n        if (self._format && self._format[i]) {\n          // If an extension was specified, use that instead.\n          ext = self._format[i];\n        } else {\n          // Make sure the source is a string.\n          str = self._src[i];\n          if (typeof str !== 'string') {\n            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');\n            continue;\n          }\n\n          // Extract the file extension from the URL or base64 data URI.\n          ext = /^data:audio\\/([^;,]+);/i.exec(str);\n          if (!ext) {\n            ext = /\\.([^.]+)$/.exec(str.split('?', 1)[0]);\n          }\n\n          if (ext) {\n            ext = ext[1].toLowerCase();\n          }\n        }\n\n        // Log a warning if no extension was found.\n        if (!ext) {\n          console.warn('No file extension was found. Consider using the \"format\" property or specify an extension.');\n        }\n\n        // Check if this extension is available.\n        if (ext && Howler.codecs(ext)) {\n          url = self._src[i];\n          break;\n        }\n      }\n\n      if (!url) {\n        self._emit('loaderror', null, 'No codec support for selected audio sources.');\n        return;\n      }\n\n      self._src = url;\n      self._state = 'loading';\n\n      // If the hosting page is HTTPS and the source isn't,\n      // drop down to HTML5 Audio to avoid Mixed Content errors.\n      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {\n        self._html5 = true;\n        self._webAudio = false;\n      }\n\n      // Create a new sound object and add it to the pool.\n      new Sound(self);\n\n      // Load and decode the audio data for playback.\n      if (self._webAudio) {\n        loadBuffer(self);\n      }\n\n      return self;\n    },\n\n    /**\n     * Play a sound or resume previous playback.\n     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Number}          Sound ID.\n     */\n    play: function(sprite, internal) {\n      var self = this;\n      var id = null;\n\n      // Determine if a sprite, sound id or nothing was passed\n      if (typeof sprite === 'number') {\n        id = sprite;\n        sprite = null;\n      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {\n        // If the passed sprite doesn't exist, do nothing.\n        return null;\n      } else if (typeof sprite === 'undefined') {\n        // Use the default sound sprite (plays the full audio length).\n        sprite = '__default';\n\n        // Check if there is a single paused sound that isn't ended.\n        // If there is, play that sound. If not, continue as usual.\n        if (!self._playLock) {\n          var num = 0;\n          for (var i=0; i<self._sounds.length; i++) {\n            if (self._sounds[i]._paused && !self._sounds[i]._ended) {\n              num++;\n              id = self._sounds[i]._id;\n            }\n          }\n\n          if (num === 1) {\n            sprite = null;\n          } else {\n            id = null;\n          }\n        }\n      }\n\n      // Get the selected node, or get one from the pool.\n      var sound = id ? self._soundById(id) : self._inactiveSound();\n\n      // If the sound doesn't exist, do nothing.\n      if (!sound) {\n        return null;\n      }\n\n      // Select the sprite definition.\n      if (id && !sprite) {\n        sprite = sound._sprite || '__default';\n      }\n\n      // If the sound hasn't loaded, we must wait to get the audio's duration.\n      // We also need to wait to make sure we don't run into race conditions with\n      // the order of function calls.\n      if (self._state !== 'loaded') {\n        // Set the sprite value on this sound.\n        sound._sprite = sprite;\n\n        // Mark this sound as not ended in case another sound is played before this one loads.\n        sound._ended = false;\n\n        // Add the sound to the queue to be played on load.\n        var soundId = sound._id;\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play(soundId);\n          }\n        });\n\n        return soundId;\n      }\n\n      // Don't play the sound if an id was passed and it is already playing.\n      if (id && !sound._paused) {\n        // Trigger the play event, in order to keep iterating through queue.\n        if (!internal) {\n          self._loadQueue('play');\n        }\n\n        return sound._id;\n      }\n\n      // Make sure the AudioContext isn't suspended, and resume it if it is.\n      if (self._webAudio) {\n        Howler._autoResume();\n      }\n\n      // Determine how long to play for and where to start playing.\n      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\n      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);\n      var timeout = (duration * 1000) / Math.abs(sound._rate);\n      var start = self._sprite[sprite][0] / 1000;\n      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\n      sound._sprite = sprite;\n\n      // Mark the sound as ended instantly so that this async playback\n      // doesn't get grabbed by another call to play while this one waits to start.\n      sound._ended = false;\n\n      // Update the parameters of the sound.\n      var setParams = function() {\n        sound._paused = false;\n        sound._seek = seek;\n        sound._start = start;\n        sound._stop = stop;\n        sound._loop = !!(sound._loop || self._sprite[sprite][2]);\n      };\n\n      // End the sound instantly if seek is at the end.\n      if (seek >= stop) {\n        self._ended(sound);\n        return;\n      }\n\n      // Begin the actual playback.\n      var node = sound._node;\n      if (self._webAudio) {\n        // Fire this when the sound is ready to play to begin Web Audio playback.\n        var playWebAudio = function() {\n          self._playLock = false;\n          setParams();\n          self._refreshBuffer(sound);\n\n          // Setup the playback params.\n          var vol = (sound._muted || self._muted) ? 0 : sound._volume;\n          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n          sound._playStart = Howler.ctx.currentTime;\n\n          // Play the sound using the supported method.\n          if (typeof node.bufferSource.start === 'undefined') {\n            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\n          } else {\n            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\n          }\n\n          // Start a new timer if none is present.\n          if (timeout !== Infinity) {\n            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n          }\n\n          if (!internal) {\n            setTimeout(function() {\n              self._emit('play', sound._id);\n              self._loadQueue();\n            }, 0);\n          }\n        };\n\n        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {\n          playWebAudio();\n        } else {\n          self._playLock = true;\n\n          // Wait for the audio context to resume before playing.\n          self.once('resume', playWebAudio);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      } else {\n        // Fire this when the sound is ready to play to begin HTML5 Audio playback.\n        var playHtml5 = function() {\n          node.currentTime = seek;\n          node.muted = sound._muted || self._muted || Howler._muted || node.muted;\n          node.volume = sound._volume * Howler.volume();\n          node.playbackRate = sound._rate;\n\n          // Some browsers will throw an error if this is called without user interaction.\n          try {\n            var play = node.play();\n\n            // Support older browsers that don't support promises, and thus don't have this issue.\n            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {\n              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().\n              self._playLock = true;\n\n              // Set param values immediately.\n              setParams();\n\n              // Releases the lock and executes queued actions.\n              play\n                .then(function() {\n                  self._playLock = false;\n                  node._unlocked = true;\n                  if (!internal) {\n                    self._emit('play', sound._id);\n                  } else {\n                    self._loadQueue();\n                  }\n                })\n                .catch(function() {\n                  self._playLock = false;\n                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\n                    'on mobile devices and Chrome where playback was not within a user interaction.');\n\n                  // Reset the ended and paused values.\n                  sound._ended = true;\n                  sound._paused = true;\n                });\n            } else if (!internal) {\n              self._playLock = false;\n              setParams();\n              self._emit('play', sound._id);\n            }\n\n            // Setting rate before playing won't work in IE, so we set it again here.\n            node.playbackRate = sound._rate;\n\n            // If the node is still paused, then we can assume there was a playback issue.\n            if (node.paused) {\n              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\n                'on mobile devices and Chrome where playback was not within a user interaction.');\n              return;\n            }\n\n            // Setup the end timer on sprites or listen for the ended event.\n            if (sprite !== '__default' || sound._loop) {\n              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n            } else {\n              self._endTimers[sound._id] = function() {\n                // Fire ended on this audio node.\n                self._ended(sound);\n\n                // Clear this listener.\n                node.removeEventListener('ended', self._endTimers[sound._id], false);\n              };\n              node.addEventListener('ended', self._endTimers[sound._id], false);\n            }\n          } catch (err) {\n            self._emit('playerror', sound._id, err);\n          }\n        };\n\n        // If this is streaming audio, make sure the src is set and load again.\n        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {\n          node.src = self._src;\n          node.load();\n        }\n\n        // Play immediately if ready, or wait for the 'canplaythrough'e vent.\n        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);\n        if (node.readyState >= 3 || loadedNoReadyState) {\n          playHtml5();\n        } else {\n          self._playLock = true;\n          self._state = 'loading';\n\n          var listener = function() {\n            self._state = 'loaded';\n            \n            // Begin playback.\n            playHtml5();\n\n            // Clear this listener.\n            node.removeEventListener(Howler._canPlayEvent, listener, false);\n          };\n          node.addEventListener(Howler._canPlayEvent, listener, false);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      }\n\n      return sound._id;\n    },\n\n    /**\n     * Pause playback and save current position.\n     * @param  {Number} id The sound ID (empty to pause all in group).\n     * @return {Howl}\n     */\n    pause: function(id) {\n      var self = this;\n\n      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'pause',\n          action: function() {\n            self.pause(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be paused.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound && !sound._paused) {\n          // Reset the seek position.\n          sound._seek = self.seek(ids[i]);\n          sound._rateSeek = 0;\n          sound._paused = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound has been created.\n              if (!sound._node.bufferSource) {\n                continue;\n              }\n\n              if (typeof sound._node.bufferSource.stop === 'undefined') {\n                sound._node.bufferSource.noteOff(0);\n              } else {\n                sound._node.bufferSource.stop(0);\n              }\n\n              // Clean up the buffer source.\n              self._cleanBuffer(sound._node);\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.pause();\n            }\n          }\n        }\n\n        // Fire the pause event, unless `true` is passed as the 2nd argument.\n        if (!arguments[1]) {\n          self._emit('pause', sound ? sound._id : null);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Stop playback and reset to start.\n     * @param  {Number} id The sound ID (empty to stop all in group).\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Howl}\n     */\n    stop: function(id, internal) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to stop when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'stop',\n          action: function() {\n            self.stop(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be stopped.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          // Reset the seek position.\n          sound._seek = sound._start || 0;\n          sound._rateSeek = 0;\n          sound._paused = true;\n          sound._ended = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound's AudioBufferSourceNode has been created.\n              if (sound._node.bufferSource) {\n                if (typeof sound._node.bufferSource.stop === 'undefined') {\n                  sound._node.bufferSource.noteOff(0);\n                } else {\n                  sound._node.bufferSource.stop(0);\n                }\n\n                // Clean up the buffer source.\n                self._cleanBuffer(sound._node);\n              }\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.currentTime = sound._start || 0;\n              sound._node.pause();\n\n              // If this is a live stream, stop download once the audio is stopped.\n              if (sound._node.duration === Infinity) {\n                self._clearSound(sound._node);\n              }\n            }\n          }\n\n          if (!internal) {\n            self._emit('stop', sound._id);\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Mute/unmute a single sound or all sounds in this Howl group.\n     * @param  {Boolean} muted Set to true to mute and false to unmute.\n     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\n     * @return {Howl}\n     */\n    mute: function(muted, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to mute when capable.\n      if (self._state !== 'loaded'|| self._playLock) {\n        self._queue.push({\n          event: 'mute',\n          action: function() {\n            self.mute(muted, id);\n          }\n        });\n\n        return self;\n      }\n\n      // If applying mute/unmute to all sounds, update the group's value.\n      if (typeof id === 'undefined') {\n        if (typeof muted === 'boolean') {\n          self._muted = muted;\n        } else {\n          return self._muted;\n        }\n      }\n\n      // If no id is passed, get all ID's to be muted.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._muted = muted;\n\n          // Cancel active fade and set the volume to the end value.\n          if (sound._interval) {\n            self._stopFade(sound._id);\n          }\n\n          if (self._webAudio && sound._node) {\n            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);\n          } else if (sound._node) {\n            sound._node.muted = Howler._muted ? true : muted;\n          }\n\n          self._emit('mute', sound._id);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\n     *   volume() -> Returns the group's volume value.\n     *   volume(id) -> Returns the sound id's current volume.\n     *   volume(vol) -> Sets the volume of all sounds in this Howl group.\n     *   volume(vol, id) -> Sets the volume of passed sound id.\n     * @return {Howl/Number} Returns self or current volume.\n     */\n    volume: function() {\n      var self = this;\n      var args = arguments;\n      var vol, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // Return the value of the groups' volume.\n        return self._volume;\n      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {\n        // First check if this is an ID, and if not, assume it is a new volume.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          vol = parseFloat(args[0]);\n        }\n      } else if (args.length >= 2) {\n        vol = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the volume or return the current volume.\n      var sound;\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        // If the sound hasn't loaded, add it to the load queue to change volume when capable.\n        if (self._state !== 'loaded'|| self._playLock) {\n          self._queue.push({\n            event: 'volume',\n            action: function() {\n              self.volume.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group volume.\n        if (typeof id === 'undefined') {\n          self._volume = vol;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            sound._volume = vol;\n\n            // Stop currently running fades.\n            if (!args[2]) {\n              self._stopFade(id[i]);\n            }\n\n            if (self._webAudio && sound._node && !sound._muted) {\n              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n            } else if (sound._node && !sound._muted) {\n              sound._node.volume = vol * Howler.volume();\n            }\n\n            self._emit('volume', sound._id);\n          }\n        }\n      } else {\n        sound = id ? self._soundById(id) : self._sounds[0];\n        return sound ? sound._volume : 0;\n      }\n\n      return self;\n    },\n\n    /**\n     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id (omit to fade all sounds).\n     * @return {Howl}\n     */\n    fade: function(from, to, len, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to fade when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'fade',\n          action: function() {\n            self.fade(from, to, len, id);\n          }\n        });\n\n        return self;\n      }\n\n      // Make sure the to/from/len values are numbers.\n      from = Math.min(Math.max(0, parseFloat(from)), 1);\n      to = Math.min(Math.max(0, parseFloat(to)), 1);\n      len = parseFloat(len);\n\n      // Set the volume to the start position.\n      self.volume(from, id);\n\n      // Fade the volume of one or all sounds.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        // Create a linear fade or fall back to timeouts with HTML5 Audio.\n        if (sound) {\n          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\n          if (!id) {\n            self._stopFade(ids[i]);\n          }\n\n          // If we are using Web Audio, let the native methods do the actual fade.\n          if (self._webAudio && !sound._muted) {\n            var currentTime = Howler.ctx.currentTime;\n            var end = currentTime + (len / 1000);\n            sound._volume = from;\n            sound._node.gain.setValueAtTime(from, currentTime);\n            sound._node.gain.linearRampToValueAtTime(to, end);\n          }\n\n          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Starts the internal interval to fade a sound.\n     * @param  {Object} sound Reference to sound to fade.\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id to fade.\n     * @param  {Boolean} isGroup   If true, set the volume on the group.\n     */\n    _startFadeInterval: function(sound, from, to, len, id, isGroup) {\n      var self = this;\n      var vol = from;\n      var diff = to - from;\n      var steps = Math.abs(diff / 0.01);\n      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);\n      var lastTick = Date.now();\n\n      // Store the value being faded to.\n      sound._fadeTo = to;\n\n      // Update the volume value on each interval tick.\n      sound._interval = setInterval(function() {\n        // Update the volume based on the time since the last tick.\n        var tick = (Date.now() - lastTick) / len;\n        lastTick = Date.now();\n        vol += diff * tick;\n\n        // Round to within 2 decimal points.\n        vol = Math.round(vol * 100) / 100;\n\n        // Make sure the volume is in the right bounds.\n        if (diff < 0) {\n          vol = Math.max(to, vol);\n        } else {\n          vol = Math.min(to, vol);\n        }\n\n        // Change the volume.\n        if (self._webAudio) {\n          sound._volume = vol;\n        } else {\n          self.volume(vol, sound._id, true);\n        }\n\n        // Set the group's volume.\n        if (isGroup) {\n          self._volume = vol;\n        }\n\n        // When the fade is complete, stop it and fire event.\n        if ((to < from && vol <= to) || (to > from && vol >= to)) {\n          clearInterval(sound._interval);\n          sound._interval = null;\n          sound._fadeTo = null;\n          self.volume(to, sound._id);\n          self._emit('fade', sound._id);\n        }\n      }, stepLen);\n    },\n\n    /**\n     * Internal method that stops the currently playing fade when\n     * a new fade starts, volume is changed or the sound is stopped.\n     * @param  {Number} id The sound id.\n     * @return {Howl}\n     */\n    _stopFade: function(id) {\n      var self = this;\n      var sound = self._soundById(id);\n\n      if (sound && sound._interval) {\n        if (self._webAudio) {\n          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);\n        }\n\n        clearInterval(sound._interval);\n        sound._interval = null;\n        self.volume(sound._fadeTo, id);\n        sound._fadeTo = null;\n        self._emit('fade', id);\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   loop() -> Returns the group's loop value.\n     *   loop(id) -> Returns the sound id's loop value.\n     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\n     *   loop(loop, id) -> Sets the loop value of passed sound id.\n     * @return {Howl/Boolean} Returns self or current loop value.\n     */\n    loop: function() {\n      var self = this;\n      var args = arguments;\n      var loop, id, sound;\n\n      // Determine the values for loop and id.\n      if (args.length === 0) {\n        // Return the grou's loop value.\n        return self._loop;\n      } else if (args.length === 1) {\n        if (typeof args[0] === 'boolean') {\n          loop = args[0];\n          self._loop = loop;\n        } else {\n          // Return this sound's loop value.\n          sound = self._soundById(parseInt(args[0], 10));\n          return sound ? sound._loop : false;\n        }\n      } else if (args.length === 2) {\n        loop = args[0];\n        id = parseInt(args[1], 10);\n      }\n\n      // If no id is passed, get all ID's to be looped.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._loop = loop;\n          if (self._webAudio && sound._node && sound._node.bufferSource) {\n            sound._node.bufferSource.loop = loop;\n            if (loop) {\n              sound._node.bufferSource.loopStart = sound._start || 0;\n              sound._node.bufferSource.loopEnd = sound._stop;\n\n              // If playing, restart playback to ensure looping updates.\n              if (self.playing(ids[i])) {\n                self.pause(ids[i], true);\n                self.play(ids[i], true);\n              }\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   rate() -> Returns the first sound node's current playback rate.\n     *   rate(id) -> Returns the sound id's current playback rate.\n     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\n     *   rate(rate, id) -> Sets the playback rate of passed sound id.\n     * @return {Howl/Number} Returns self or the current playback rate.\n     */\n    rate: function() {\n      var self = this;\n      var args = arguments;\n      var rate, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current rate of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new rate value.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          rate = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        rate = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the playback rate or return the current value.\n      var sound;\n      if (typeof rate === 'number') {\n        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\n        if (self._state !== 'loaded' || self._playLock) {\n          self._queue.push({\n            event: 'rate',\n            action: function() {\n              self.rate.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group rate.\n        if (typeof id === 'undefined') {\n          self._rate = rate;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            // Keep track of our position when the rate changed and update the playback\n            // start position so we can properly adjust the seek position for time elapsed.\n            if (self.playing(id[i])) {\n              sound._rateSeek = self.seek(id[i]);\n              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;\n            }\n            sound._rate = rate;\n\n            // Change the playback rate.\n            if (self._webAudio && sound._node && sound._node.bufferSource) {\n              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);\n            } else if (sound._node) {\n              sound._node.playbackRate = rate;\n            }\n\n            // Reset the timers.\n            var seek = self.seek(id[i]);\n            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;\n            var timeout = (duration * 1000) / Math.abs(sound._rate);\n\n            // Start a new end timer if sound is already playing.\n            if (self._endTimers[id[i]] || !sound._paused) {\n              self._clearTimer(id[i]);\n              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n\n            self._emit('rate', sound._id);\n          }\n        }\n      } else {\n        sound = self._soundById(id);\n        return sound ? sound._rate : self._rate;\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   seek() -> Returns the first sound node's current seek position.\n     *   seek(id) -> Returns the sound id's current seek position.\n     *   seek(seek) -> Sets the seek position of the first sound node.\n     *   seek(seek, id) -> Sets the seek position of passed sound id.\n     * @return {Howl/Number} Returns self or the current seek position.\n     */\n    seek: function() {\n      var self = this;\n      var args = arguments;\n      var seek, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current position of the first node.\n        if (self._sounds.length) {\n          id = self._sounds[0]._id;\n        }\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new seek position.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else if (self._sounds.length) {\n          id = self._sounds[0]._id;\n          seek = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        seek = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // If there is no ID, bail out.\n      if (typeof id === 'undefined') {\n        return 0;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to seek when capable.\n      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {\n        self._queue.push({\n          event: 'seek',\n          action: function() {\n            self.seek.apply(self, args);\n          }\n        });\n\n        return self;\n      }\n\n      // Get the sound.\n      var sound = self._soundById(id);\n\n      if (sound) {\n        if (typeof seek === 'number' && seek >= 0) {\n          // Pause the sound and update position for restarting playback.\n          var playing = self.playing(id);\n          if (playing) {\n            self.pause(id, true);\n          }\n\n          // Move the position of the track and cancel timer.\n          sound._seek = seek;\n          sound._ended = false;\n          self._clearTimer(id);\n\n          // Update the seek position for HTML5 Audio.\n          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {\n            sound._node.currentTime = seek;\n          }\n\n          // Seek and emit when ready.\n          var seekAndEmit = function() {\n            // Restart the playback if the sound was playing.\n            if (playing) {\n              self.play(id, true);\n            }\n\n            self._emit('seek', id);\n          };\n\n          // Wait for the play lock to be unset before emitting (HTML5 Audio).\n          if (playing && !self._webAudio) {\n            var emitSeek = function() {\n              if (!self._playLock) {\n                seekAndEmit();\n              } else {\n                setTimeout(emitSeek, 0);\n              }\n            };\n            setTimeout(emitSeek, 0);\n          } else {\n            seekAndEmit();\n          }\n        } else {\n          if (self._webAudio) {\n            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;\n            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\n            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\n          } else {\n            return sound._node.currentTime;\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\n     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\n     * @return {Boolean} True if playing and false if not.\n     */\n    playing: function(id) {\n      var self = this;\n\n      // Check the passed sound ID (if any).\n      if (typeof id === 'number') {\n        var sound = self._soundById(id);\n        return sound ? !sound._paused : false;\n      }\n\n      // Otherwise, loop through all sounds and check if any are playing.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (!self._sounds[i]._paused) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Get the duration of this sound. Passing a sound id will return the sprite duration.\n     * @param  {Number} id The sound id to check. If none is passed, return full source duration.\n     * @return {Number} Audio duration in seconds.\n     */\n    duration: function(id) {\n      var self = this;\n      var duration = self._duration;\n\n      // If we pass an ID, get the sound and return the sprite length.\n      var sound = self._soundById(id);\n      if (sound) {\n        duration = self._sprite[sound._sprite][1] / 1000;\n      }\n\n      return duration;\n    },\n\n    /**\n     * Returns the current loaded state of this Howl.\n     * @return {String} 'unloaded', 'loading', 'loaded'\n     */\n    state: function() {\n      return this._state;\n    },\n\n    /**\n     * Unload and destroy the current Howl object.\n     * This will immediately stop all sound instances attached to this group.\n     */\n    unload: function() {\n      var self = this;\n\n      // Stop playing any active sounds.\n      var sounds = self._sounds;\n      for (var i=0; i<sounds.length; i++) {\n        // Stop the sound if it is currently playing.\n        if (!sounds[i]._paused) {\n          self.stop(sounds[i]._id);\n        }\n\n        // Remove the source or disconnect.\n        if (!self._webAudio) {\n          // Set the source to 0-second silence to stop any downloading (except in IE).\n          self._clearSound(sounds[i]._node);\n\n          // Remove any event listeners.\n          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);\n          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);\n          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);\n\n          // Release the Audio object back to the pool.\n          Howler._releaseHtml5Audio(sounds[i]._node);\n        }\n\n        // Empty out all of the nodes.\n        delete sounds[i]._node;\n\n        // Make sure all timers are cleared out.\n        self._clearTimer(sounds[i]._id);\n      }\n\n      // Remove the references in the global Howler object.\n      var index = Howler._howls.indexOf(self);\n      if (index >= 0) {\n        Howler._howls.splice(index, 1);\n      }\n\n      // Delete this sound from the cache (if no other Howl is using it).\n      var remCache = true;\n      for (i=0; i<Howler._howls.length; i++) {\n        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {\n          remCache = false;\n          break;\n        }\n      }\n\n      if (cache && remCache) {\n        delete cache[self._src];\n      }\n\n      // Clear global errors.\n      Howler.noAudio = false;\n\n      // Clear out `self`.\n      self._state = 'unloaded';\n      self._sounds = [];\n      self = null;\n\n      return null;\n    },\n\n    /**\n     * Listen to a custom event.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\n     * @return {Howl}\n     */\n    on: function(event, fn, id, once) {\n      var self = this;\n      var events = self['_on' + event];\n\n      if (typeof fn === 'function') {\n        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});\n      }\n\n      return self;\n    },\n\n    /**\n     * Remove a custom event. Call without parameters to remove all events.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to remove. Leave empty to remove all.\n     * @param  {Number}   id    (optional) Only remove events for this sound.\n     * @return {Howl}\n     */\n    off: function(event, fn, id) {\n      var self = this;\n      var events = self['_on' + event];\n      var i = 0;\n\n      // Allow passing just an event and ID.\n      if (typeof fn === 'number') {\n        id = fn;\n        fn = null;\n      }\n\n      if (fn || id) {\n        // Loop through event store and remove the passed function.\n        for (i=0; i<events.length; i++) {\n          var isId = (id === events[i].id);\n          if (fn === events[i].fn && isId || !fn && isId) {\n            events.splice(i, 1);\n            break;\n          }\n        }\n      } else if (event) {\n        // Clear out all events of this type.\n        self['_on' + event] = [];\n      } else {\n        // Clear out all events of every type.\n        var keys = Object.keys(self);\n        for (i=0; i<keys.length; i++) {\n          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {\n            self[keys[i]] = [];\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Listen to a custom event and remove it once fired.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @return {Howl}\n     */\n    once: function(event, fn, id) {\n      var self = this;\n\n      // Setup the event listener.\n      self.on(event, fn, id, 1);\n\n      return self;\n    },\n\n    /**\n     * Emit all events of a specific type and pass the sound id.\n     * @param  {String} event Event name.\n     * @param  {Number} id    Sound ID.\n     * @param  {Number} msg   Message to go with event.\n     * @return {Howl}\n     */\n    _emit: function(event, id, msg) {\n      var self = this;\n      var events = self['_on' + event];\n\n      // Loop through event store and fire all functions.\n      for (var i=events.length-1; i>=0; i--) {\n        // Only fire the listener if the correct ID is used.\n        if (!events[i].id || events[i].id === id || event === 'load') {\n          setTimeout(function(fn) {\n            fn.call(this, id, msg);\n          }.bind(self, events[i].fn), 0);\n\n          // If this event was setup with `once`, remove it.\n          if (events[i].once) {\n            self.off(event, events[i].fn, events[i].id);\n          }\n        }\n      }\n\n      // Pass the event type into load queue so that it can continue stepping.\n      self._loadQueue(event);\n\n      return self;\n    },\n\n    /**\n     * Queue of actions initiated before the sound has loaded.\n     * These will be called in sequence, with the next only firing\n     * after the previous has finished executing (even if async like play).\n     * @return {Howl}\n     */\n    _loadQueue: function(event) {\n      var self = this;\n\n      if (self._queue.length > 0) {\n        var task = self._queue[0];\n\n        // Remove this task if a matching event was passed.\n        if (task.event === event) {\n          self._queue.shift();\n          self._loadQueue();\n        }\n\n        // Run the task if no event type is passed.\n        if (!event) {\n          task.action();\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Fired when playback ends at the end of the duration.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _ended: function(sound) {\n      var self = this;\n      var sprite = sound._sprite;\n\n      // If we are using IE and there was network latency we may be clipping\n      // audio before it completes playing. Lets check the node to make sure it\n      // believes it has completed, before ending the playback.\n      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {\n        setTimeout(self._ended.bind(self, sound), 100);\n        return self;\n      }\n\n      // Should this sound loop?\n      var loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Fire the ended event.\n      self._emit('end', sound._id);\n\n      // Restart the playback for HTML5 Audio loop.\n      if (!self._webAudio && loop) {\n        self.stop(sound._id, true).play(sound._id);\n      }\n\n      // Restart this timer if on a Web Audio loop.\n      if (self._webAudio && loop) {\n        self._emit('play', sound._id);\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        sound._playStart = Howler.ctx.currentTime;\n\n        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);\n        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n      }\n\n      // Mark the node as paused.\n      if (self._webAudio && !loop) {\n        sound._paused = true;\n        sound._ended = true;\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        self._clearTimer(sound._id);\n\n        // Clean up the buffer source.\n        self._cleanBuffer(sound._node);\n\n        // Attempt to auto-suspend AudioContext if no sounds are still playing.\n        Howler._autoSuspend();\n      }\n\n      // When using a sprite, end the track.\n      if (!self._webAudio && !loop) {\n        self.stop(sound._id, true);\n      }\n\n      return self;\n    },\n\n    /**\n     * Clear the end timer for a sound playback.\n     * @param  {Number} id The sound ID.\n     * @return {Howl}\n     */\n    _clearTimer: function(id) {\n      var self = this;\n\n      if (self._endTimers[id]) {\n        // Clear the timeout or remove the ended listener.\n        if (typeof self._endTimers[id] !== 'function') {\n          clearTimeout(self._endTimers[id]);\n        } else {\n          var sound = self._soundById(id);\n          if (sound && sound._node) {\n            sound._node.removeEventListener('ended', self._endTimers[id], false);\n          }\n        }\n\n        delete self._endTimers[id];\n      }\n\n      return self;\n    },\n\n    /**\n     * Return the sound identified by this ID, or return null.\n     * @param  {Number} id Sound ID\n     * @return {Object}    Sound object or null.\n     */\n    _soundById: function(id) {\n      var self = this;\n\n      // Loop through all sounds and find the one with this ID.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (id === self._sounds[i]._id) {\n          return self._sounds[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Return an inactive sound from the pool or create a new one.\n     * @return {Sound} Sound playback object.\n     */\n    _inactiveSound: function() {\n      var self = this;\n\n      self._drain();\n\n      // Find the first inactive node to recycle.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          return self._sounds[i].reset();\n        }\n      }\n\n      // If no inactive node was found, create a new one.\n      return new Sound(self);\n    },\n\n    /**\n     * Drain excess inactive sounds from the pool.\n     */\n    _drain: function() {\n      var self = this;\n      var limit = self._pool;\n      var cnt = 0;\n      var i = 0;\n\n      // If there are less sounds than the max pool size, we are done.\n      if (self._sounds.length < limit) {\n        return;\n      }\n\n      // Count the number of inactive sounds.\n      for (i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          cnt++;\n        }\n      }\n\n      // Remove excess inactive sounds, going in reverse order.\n      for (i=self._sounds.length - 1; i>=0; i--) {\n        if (cnt <= limit) {\n          return;\n        }\n\n        if (self._sounds[i]._ended) {\n          // Disconnect the audio source when using Web Audio.\n          if (self._webAudio && self._sounds[i]._node) {\n            self._sounds[i]._node.disconnect(0);\n          }\n\n          // Remove sounds until we have the pool size.\n          self._sounds.splice(i, 1);\n          cnt--;\n        }\n      }\n    },\n\n    /**\n     * Get all ID's from the sounds pool.\n     * @param  {Number} id Only return one ID if one is passed.\n     * @return {Array}    Array of IDs.\n     */\n    _getSoundIds: function(id) {\n      var self = this;\n\n      if (typeof id === 'undefined') {\n        var ids = [];\n        for (var i=0; i<self._sounds.length; i++) {\n          ids.push(self._sounds[i]._id);\n        }\n\n        return ids;\n      } else {\n        return [id];\n      }\n    },\n\n    /**\n     * Load the sound back into the buffer source.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _refreshBuffer: function(sound) {\n      var self = this;\n\n      // Setup the buffer source for playback.\n      sound._node.bufferSource = Howler.ctx.createBufferSource();\n      sound._node.bufferSource.buffer = cache[self._src];\n\n      // Connect to the correct node.\n      if (sound._panner) {\n        sound._node.bufferSource.connect(sound._panner);\n      } else {\n        sound._node.bufferSource.connect(sound._node);\n      }\n\n      // Setup looping and playback rate.\n      sound._node.bufferSource.loop = sound._loop;\n      if (sound._loop) {\n        sound._node.bufferSource.loopStart = sound._start || 0;\n        sound._node.bufferSource.loopEnd = sound._stop || 0;\n      }\n      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);\n\n      return self;\n    },\n\n    /**\n     * Prevent memory leaks by cleaning up the buffer source after playback.\n     * @param  {Object} node Sound's audio node containing the buffer source.\n     * @return {Howl}\n     */\n    _cleanBuffer: function(node) {\n      var self = this;\n      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;\n\n      if (!node.bufferSource) {\n        return self;\n      }\n\n      if (Howler._scratchBuffer && node.bufferSource) {\n        node.bufferSource.onended = null;\n        node.bufferSource.disconnect(0);\n        if (isIOS) {\n          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}\n        }\n      }\n      node.bufferSource = null;\n\n      return self;\n    },\n\n    /**\n     * Set the source to a 0-second silence to stop any downloading (except in IE).\n     * @param  {Object} node Audio node to clear.\n     */\n    _clearSound: function(node) {\n      var checkIE = /MSIE |Trident\\//.test(Howler._navigator && Howler._navigator.userAgent);\n      if (!checkIE) {\n        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';\n      }\n    }\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Setup the sound object, which each node attached to a Howl group is contained in.\n   * @param {Object} howl The Howl parent group.\n   */\n  var Sound = function(howl) {\n    this._parent = howl;\n    this.init();\n  };\n  Sound.prototype = {\n    /**\n     * Initialize a new Sound object.\n     * @return {Sound}\n     */\n    init: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup the default parameters.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a unique ID for this sound.\n      self._id = ++Howler._counter;\n\n      // Add itself to the parent's pool.\n      parent._sounds.push(self);\n\n      // Create the new node.\n      self.create();\n\n      return self;\n    },\n\n    /**\n     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\n     * @return {Sound}\n     */\n    create: function() {\n      var self = this;\n      var parent = self._parent;\n      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;\n\n      if (parent._webAudio) {\n        // Create the gain node for controlling volume (the source will connect to this).\n        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);\n        self._node.paused = true;\n        self._node.connect(Howler.masterGain);\n      } else if (!Howler.noAudio) {\n        // Get an unlocked Audio object from the pool.\n        self._node = Howler._obtainHtml5Audio();\n\n        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\n        self._errorFn = self._errorListener.bind(self);\n        self._node.addEventListener('error', self._errorFn, false);\n\n        // Listen for 'canplaythrough' event to let us know the sound is ready.\n        self._loadFn = self._loadListener.bind(self);\n        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);\n\n        // Listen for the 'ended' event on the sound to account for edge-case where\n        // a finite sound has a duration of Infinity.\n        self._endFn = self._endListener.bind(self);\n        self._node.addEventListener('ended', self._endFn, false);\n\n        // Setup the new audio node.\n        self._node.src = parent._src;\n        self._node.preload = parent._preload === true ? 'auto' : parent._preload;\n        self._node.volume = volume * Howler.volume();\n\n        // Begin loading the source.\n        self._node.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Reset the parameters of this sound to the original state (for recycle).\n     * @return {Sound}\n     */\n    reset: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all of the parameters of this sound.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._rateSeek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a new ID so that it isn't confused with the previous sound.\n      self._id = ++Howler._counter;\n\n      return self;\n    },\n\n    /**\n     * HTML5 Audio error listener callback.\n     */\n    _errorListener: function() {\n      var self = this;\n\n      // Fire an error event and pass back the code.\n      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);\n\n      // Clear the event listener.\n      self._node.removeEventListener('error', self._errorFn, false);\n    },\n\n    /**\n     * HTML5 Audio canplaythrough listener callback.\n     */\n    _loadListener: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Round up the duration to account for the lower precision in HTML5 Audio.\n      parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n      // Setup a sprite if none is defined.\n      if (Object.keys(parent._sprite).length === 0) {\n        parent._sprite = {__default: [0, parent._duration * 1000]};\n      }\n\n      if (parent._state !== 'loaded') {\n        parent._state = 'loaded';\n        parent._emit('load');\n        parent._loadQueue();\n      }\n\n      // Clear the event listener.\n      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);\n    },\n\n    /**\n     * HTML5 Audio ended listener callback.\n     */\n    _endListener: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Only handle the `ended`` event if the duration is Infinity.\n      if (parent._duration === Infinity) {\n        // Update the parent duration to match the real audio duration.\n        // Round up the duration to account for the lower precision in HTML5 Audio.\n        parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n        // Update the sprite that corresponds to the real duration.\n        if (parent._sprite.__default[1] === Infinity) {\n          parent._sprite.__default[1] = parent._duration * 1000;\n        }\n\n        // Run the regular ended method.\n        parent._ended(self);\n      }\n\n      // Clear the event listener since the duration is now correct.\n      self._node.removeEventListener('ended', self._endFn, false);\n    }\n  };\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  var cache = {};\n\n  /**\n   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\n   * @param  {Howl} self\n   */\n  var loadBuffer = function(self) {\n    var url = self._src;\n\n    // Check if the buffer has already been cached and use it instead.\n    if (cache[url]) {\n      // Set the duration from the cache.\n      self._duration = cache[url].duration;\n\n      // Load the sound into this Howl.\n      loadSound(self);\n\n      return;\n    }\n\n    if (/^data:[^;]+;base64,/.test(url)) {\n      // Decode the base64 data URI without XHR, since some browsers don't support it.\n      var data = atob(url.split(',')[1]);\n      var dataView = new Uint8Array(data.length);\n      for (var i=0; i<data.length; ++i) {\n        dataView[i] = data.charCodeAt(i);\n      }\n\n      decodeAudioData(dataView.buffer, self);\n    } else {\n      // Load the buffer from the URL.\n      var xhr = new XMLHttpRequest();\n      xhr.open(self._xhr.method, url, true);\n      xhr.withCredentials = self._xhr.withCredentials;\n      xhr.responseType = 'arraybuffer';\n\n      // Apply any custom headers to the request.\n      if (self._xhr.headers) {\n        Object.keys(self._xhr.headers).forEach(function(key) {\n          xhr.setRequestHeader(key, self._xhr.headers[key]);\n        });\n      }\n\n      xhr.onload = function() {\n        // Make sure we get a successful response back.\n        var code = (xhr.status + '')[0];\n        if (code !== '0' && code !== '2' && code !== '3') {\n          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');\n          return;\n        }\n\n        decodeAudioData(xhr.response, self);\n      };\n      xhr.onerror = function() {\n        // If there is an error, switch to HTML5 Audio.\n        if (self._webAudio) {\n          self._html5 = true;\n          self._webAudio = false;\n          self._sounds = [];\n          delete cache[url];\n          self.load();\n        }\n      };\n      safeXhrSend(xhr);\n    }\n  };\n\n  /**\n   * Send the XHR request wrapped in a try/catch.\n   * @param  {Object} xhr XHR to send.\n   */\n  var safeXhrSend = function(xhr) {\n    try {\n      xhr.send();\n    } catch (e) {\n      xhr.onerror();\n    }\n  };\n\n  /**\n   * Decode audio data from an array buffer.\n   * @param  {ArrayBuffer} arraybuffer The audio data.\n   * @param  {Howl}        self\n   */\n  var decodeAudioData = function(arraybuffer, self) {\n    // Fire a load error if something broke.\n    var error = function() {\n      self._emit('loaderror', null, 'Decoding audio data failed.');\n    };\n\n    // Load the sound on success.\n    var success = function(buffer) {\n      if (buffer && self._sounds.length > 0) {\n        cache[self._src] = buffer;\n        loadSound(self, buffer);\n      } else {\n        error();\n      }\n    };\n\n    // Decode the buffer into an audio source.\n    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {\n      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);\n    } else {\n      Howler.ctx.decodeAudioData(arraybuffer, success, error);\n    }\n  }\n\n  /**\n   * Sound is now loaded, so finish setting everything up and fire the loaded event.\n   * @param  {Howl} self\n   * @param  {Object} buffer The decoded buffer sound source.\n   */\n  var loadSound = function(self, buffer) {\n    // Set the duration.\n    if (buffer && !self._duration) {\n      self._duration = buffer.duration;\n    }\n\n    // Setup a sprite if none is defined.\n    if (Object.keys(self._sprite).length === 0) {\n      self._sprite = {__default: [0, self._duration * 1000]};\n    }\n\n    // Fire the loaded event.\n    if (self._state !== 'loaded') {\n      self._state = 'loaded';\n      self._emit('load');\n      self._loadQueue();\n    }\n  };\n\n  /**\n   * Setup the audio context when available, or switch to HTML5 Audio mode.\n   */\n  var setupAudioContext = function() {\n    // If we have already detected that Web Audio isn't supported, don't run this step again.\n    if (!Howler.usingWebAudio) {\n      return;\n    }\n\n    // Check if we are using Web Audio and setup the AudioContext if we are.\n    try {\n      if (typeof AudioContext !== 'undefined') {\n        Howler.ctx = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Howler.ctx = new webkitAudioContext();\n      } else {\n        Howler.usingWebAudio = false;\n      }\n    } catch(e) {\n      Howler.usingWebAudio = false;\n    }\n\n    // If the audio context creation still failed, set using web audio to false.\n    if (!Howler.ctx) {\n      Howler.usingWebAudio = false;\n    }\n\n    // Check if a webview is being used on iOS8 or earlier (rather than the browser).\n    // If it is, disable Web Audio as it causes crashing.\n    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));\n    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n    var version = appVersion ? parseInt(appVersion[1], 10) : null;\n    if (iOS && version && version < 9) {\n      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());\n      if (Howler._navigator && !safari) {\n        Howler.usingWebAudio = false;\n      }\n    }\n\n    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\n    if (Howler.usingWebAudio) {\n      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);\n      Howler.masterGain.connect(Howler.ctx.destination);\n    }\n\n    // Re-run the setup on Howler.\n    Howler._setup();\n  };\n\n  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\n  if (typeof define === 'function' && define.amd) {\n    define([], function() {\n      return {\n        Howler: Howler,\n        Howl: Howl\n      };\n    });\n  }\n\n  // Add support for CommonJS libraries such as browserify.\n  if (typeof exports !== 'undefined') {\n    exports.Howler = Howler;\n    exports.Howl = Howl;\n  }\n\n  // Add to global in Node.js (for testing, etc).\n  if (typeof global !== 'undefined') {\n    global.HowlerGlobal = HowlerGlobal;\n    global.Howler = Howler;\n    global.Howl = Howl;\n    global.Sound = Sound;\n  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.\n    window.HowlerGlobal = HowlerGlobal;\n    window.Howler = Howler;\n    window.Howl = Howl;\n    window.Sound = Sound;\n  }\n})();\n\n\n/*!\n *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\n *  \n *  howler.js v2.2.4\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  // Setup default properties.\n  HowlerGlobal.prototype._pos = [0, 0, 0];\n  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Helper method to update the stereo panning position of all current Howls.\n   * Future Howls will not use this value unless explicitly set.\n   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @return {Howler/Number}     Self or current stereo panning value.\n   */\n  HowlerGlobal.prototype.stereo = function(pan) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Loop through all Howls and update their stereo panning.\n    for (var i=self._howls.length-1; i>=0; i--) {\n      self._howls[i].stereo(pan);\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the position of the listener in 3D cartesian space. Sounds using\n   * 3D position will be relative to the listener's position.\n   * @param  {Number} x The x-position of the listener.\n   * @param  {Number} y The y-position of the listener.\n   * @param  {Number} z The z-position of the listener.\n   * @return {Howler/Array}   Self or current listener position.\n   */\n  HowlerGlobal.prototype.pos = function(x, y, z) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._pos[1] : y;\n    z = (typeof z !== 'number') ? self._pos[2] : z;\n\n    if (typeof x === 'number') {\n      self._pos = [x, y, z];\n\n      if (typeof self.ctx.listener.positionX !== 'undefined') {\n        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\n      }\n    } else {\n      return self._pos;\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the listener is pointing in the 3D cartesian space.\n   * A front and up vector must be provided. The front is the direction the\n   * face of the listener is pointing, and up is the direction the top of the\n   * listener is pointing. Thus, these values are expected to be at right angles\n   * from each other.\n   * @param  {Number} x   The x-orientation of the listener.\n   * @param  {Number} y   The y-orientation of the listener.\n   * @param  {Number} z   The z-orientation of the listener.\n   * @param  {Number} xUp The x-orientation of the top of the listener.\n   * @param  {Number} yUp The y-orientation of the top of the listener.\n   * @param  {Number} zUp The z-orientation of the top of the listener.\n   * @return {Howler/Array}     Returns self or the current orientation vectors.\n   */\n  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    var or = self._orientation;\n    y = (typeof y !== 'number') ? or[1] : y;\n    z = (typeof z !== 'number') ? or[2] : z;\n    xUp = (typeof xUp !== 'number') ? or[3] : xUp;\n    yUp = (typeof yUp !== 'number') ? or[4] : yUp;\n    zUp = (typeof zUp !== 'number') ? or[5] : zUp;\n\n    if (typeof x === 'number') {\n      self._orientation = [x, y, z, xUp, yUp, zUp];\n\n      if (typeof self.ctx.listener.forwardX !== 'undefined') {\n        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\n      }\n    } else {\n      return or;\n    }\n\n    return self;\n  };\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core init.\n   * @param  {Function} _super Core init method.\n   * @return {Howl}\n   */\n  Howl.prototype.init = (function(_super) {\n    return function(o) {\n      var self = this;\n\n      // Setup user-defined default properties.\n      self._orientation = o.orientation || [1, 0, 0];\n      self._stereo = o.stereo || null;\n      self._pos = o.pos || null;\n      self._pannerAttr = {\n        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,\n        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,\n        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,\n        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',\n        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,\n        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',\n        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,\n        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1\n      };\n\n      // Setup event listeners.\n      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];\n      self._onpos = o.onpos ? [{fn: o.onpos}] : [];\n      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];\n\n      // Complete initilization with howler.js core's init function.\n      return _super.call(this, o);\n    };\n  })(Howl.prototype.init);\n\n  /**\n   * Get/set the stereo panning of the audio source for this sound or all in the group.\n   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Number}    Returns self or the current stereo panning value.\n   */\n  Howl.prototype.stereo = function(pan, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'stereo',\n        action: function() {\n          self.stereo(pan, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\n    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';\n\n    // Setup the group's stereo panning if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's stereo panning if no parameters are passed.\n      if (typeof pan === 'number') {\n        self._stereo = pan;\n        self._pos = [pan, 0, 0];\n      } else {\n        return self._stereo;\n      }\n    }\n\n    // Change the streo panning of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof pan === 'number') {\n          sound._stereo = pan;\n          sound._pos = [pan, 0, 0];\n\n          if (sound._node) {\n            // If we are falling back, make sure the panningModel is equalpower.\n            sound._pannerAttr.panningModel = 'equalpower';\n\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || !sound._panner.pan) {\n              setupPanner(sound, pannerType);\n            }\n\n            if (pannerType === 'spatial') {\n              if (typeof sound._panner.positionX !== 'undefined') {\n                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);\n                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);\n                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);\n              } else {\n                sound._panner.setPosition(pan, 0, 0);\n              }\n            } else {\n              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);\n            }\n          }\n\n          self._emit('stereo', sound._id);\n        } else {\n          return sound._stereo;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.\n   * @param  {Number} x  The x-position of the audio source.\n   * @param  {Number} y  The y-position of the audio source.\n   * @param  {Number} z  The z-position of the audio source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\n   */\n  Howl.prototype.pos = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change position when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'pos',\n        action: function() {\n          self.pos(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? 0 : y;\n    z = (typeof z !== 'number') ? -0.5 : z;\n\n    // Setup the group's spatial position if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial position if no parameters are passed.\n      if (typeof x === 'number') {\n        self._pos = [x, y, z];\n      } else {\n        return self._pos;\n      }\n    }\n\n    // Change the spatial position of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._pos = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || sound._panner.pan) {\n              setupPanner(sound, 'spatial');\n            }\n\n            if (typeof sound._panner.positionX !== 'undefined') {\n              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setPosition(x, y, z);\n            }\n          }\n\n          self._emit('pos', sound._id);\n        } else {\n          return sound._pos;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\n   * space. Depending on how direction the sound is, based on the `cone` attributes,\n   * a sound pointing away from the listener can be quiet or silent.\n   * @param  {Number} x  The x-orientation of the source.\n   * @param  {Number} y  The y-orientation of the source.\n   * @param  {Number} z  The z-orientation of the source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\n   */\n  Howl.prototype.orientation = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'orientation',\n        action: function() {\n          self.orientation(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._orientation[1] : y;\n    z = (typeof z !== 'number') ? self._orientation[2] : z;\n\n    // Setup the group's spatial orientation if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial orientation if no parameters are passed.\n      if (typeof x === 'number') {\n        self._orientation = [x, y, z];\n      } else {\n        return self._orientation;\n      }\n    }\n\n    // Change the spatial orientation of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._orientation = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner) {\n              // Make sure we have a position to setup the node with.\n              if (!sound._pos) {\n                sound._pos = self._pos || [0, 0, -0.5];\n              }\n\n              setupPanner(sound, 'spatial');\n            }\n\n            if (typeof sound._panner.orientationX !== 'undefined') {\n              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setOrientation(x, y, z);\n            }\n          }\n\n          self._emit('orientation', sound._id);\n        } else {\n          return sound._orientation;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the panner node's attributes for a sound or group of sounds.\n   * This method can optionall take 0, 1 or 2 arguments.\n   *   pannerAttr() -> Returns the group's values.\n   *   pannerAttr(id) -> Returns the sound id's values.\n   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\n   *   pannerAttr(o, id) -> Set's the values of passed sound id.\n   *\n   *   Attributes:\n   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      inside of which there will be no volume reduction.\n   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.\n   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the\n   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.\n   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from\n   *                     listener. Can be `linear`, `inverse` or `exponential.\n   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume\n   *                   will not be reduced any further.\n   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.\n   *                   This is simply a variable of the distance model and has a different effect depending on which model\n   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.\n   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a\n   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`\n   *                     with `inverse` and `exponential`.\n   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\n   *                     Can be `HRTF` or `equalpower`.\n   *\n   * @return {Howl/Object} Returns self or current panner attributes.\n   */\n  Howl.prototype.pannerAttr = function() {\n    var self = this;\n    var args = arguments;\n    var o, id, sound;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // Determine the values based on arguments.\n    if (args.length === 0) {\n      // Return the group's panner attribute values.\n      return self._pannerAttr;\n    } else if (args.length === 1) {\n      if (typeof args[0] === 'object') {\n        o = args[0];\n\n        // Set the grou's panner attribute values.\n        if (typeof id === 'undefined') {\n          if (!o.pannerAttr) {\n            o.pannerAttr = {\n              coneInnerAngle: o.coneInnerAngle,\n              coneOuterAngle: o.coneOuterAngle,\n              coneOuterGain: o.coneOuterGain,\n              distanceModel: o.distanceModel,\n              maxDistance: o.maxDistance,\n              refDistance: o.refDistance,\n              rolloffFactor: o.rolloffFactor,\n              panningModel: o.panningModel\n            };\n          }\n\n          self._pannerAttr = {\n            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,\n            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,\n            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,\n            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,\n            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,\n            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,\n            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,\n            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel\n          };\n        }\n      } else {\n        // Return this sound's panner attribute values.\n        sound = self._soundById(parseInt(args[0], 10));\n        return sound ? sound._pannerAttr : self._pannerAttr;\n      }\n    } else if (args.length === 2) {\n      o = args[0];\n      id = parseInt(args[1], 10);\n    }\n\n    // Update the values of the specified sounds.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      sound = self._soundById(ids[i]);\n\n      if (sound) {\n        // Merge the new values into the sound.\n        var pa = sound._pannerAttr;\n        pa = {\n          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,\n          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,\n          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,\n          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,\n          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,\n          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,\n          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,\n          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel\n        };\n\n        // Create a new panner node if one doesn't already exist.\n        var panner = sound._panner;\n        if (!panner) {\n          // Make sure we have a position to setup the node with.\n          if (!sound._pos) {\n            sound._pos = self._pos || [0, 0, -0.5];\n          }\n\n          // Create a new panner node.\n          setupPanner(sound, 'spatial');\n          panner = sound._panner\n        }\n\n        // Update the panner values or create a new panner if none exists.\n        panner.coneInnerAngle = pa.coneInnerAngle;\n        panner.coneOuterAngle = pa.coneOuterAngle;\n        panner.coneOuterGain = pa.coneOuterGain;\n        panner.distanceModel = pa.distanceModel;\n        panner.maxDistance = pa.maxDistance;\n        panner.refDistance = pa.refDistance;\n        panner.rolloffFactor = pa.rolloffFactor;\n        panner.panningModel = pa.panningModel;\n      }\n    }\n\n    return self;\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core Sound init.\n   * @param  {Function} _super Core Sound init method.\n   * @return {Sound}\n   */\n  Sound.prototype.init = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup user-defined default properties.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete initilization with howler.js core Sound's init function.\n      _super.call(this);\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      }\n    };\n  })(Sound.prototype.init);\n\n  /**\n   * Override the Sound.reset method to clean up properties from the spatial plugin.\n   * @param  {Function} _super Sound reset method.\n   * @return {Sound}\n   */\n  Sound.prototype.reset = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all spatial plugin properties on this sound.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      } else if (self._panner) {\n        // Disconnect the panner.\n        self._panner.disconnect(0);\n        self._panner = undefined;\n        parent._refreshBuffer(self);\n      }\n\n      // Complete resetting of the sound.\n      return _super.call(this);\n    };\n  })(Sound.prototype.reset);\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create a new panner node and save it on the sound.\n   * @param  {Sound} sound Specific sound to setup panning on.\n   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\n   */\n  var setupPanner = function(sound, type) {\n    type = type || 'spatial';\n\n    // Create the new panner node.\n    if (type === 'spatial') {\n      sound._panner = Howler.ctx.createPanner();\n      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\n      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\n      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\n      sound._panner.distanceModel = sound._pannerAttr.distanceModel;\n      sound._panner.maxDistance = sound._pannerAttr.maxDistance;\n      sound._panner.refDistance = sound._pannerAttr.refDistance;\n      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\n      sound._panner.panningModel = sound._pannerAttr.panningModel;\n\n      if (typeof sound._panner.positionX !== 'undefined') {\n        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);\n        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);\n        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\n      }\n\n      if (typeof sound._panner.orientationX !== 'undefined') {\n        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);\n        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);\n        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\n      }\n    } else {\n      sound._panner = Howler.ctx.createStereoPanner();\n      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);\n    }\n\n    sound._panner.connect(sound._node);\n\n    // Update the connections.\n    if (!sound._paused) {\n      sound._parent.pause(sound._id, true).play(sound._id, true);\n    }\n  };\n})();\n"],"names":["$21de405eafa0c0bb$var$_isWebGLSupported","$7cb4832c2de4c977$var$_isWebGPUSupported","$778464c1601fd395$var$MAX_WORKERS","t","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","MINIGAME_ASSET_ALIASES","GroceryItemType","HowlerGlobal1","Howler1","Howl1","Sound1","cache","loadBuffer","safeXhrSend","decodeAudioData","loadSound","setupAudioContext","_super","setupPanner","$6e1e16f555a84269$export$1a264e8727077b82","$8b679de7a6842c56$var$GroceryItemType","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$5c96a02c592fcff1$export$29e00dfd3077644b","decorators","target","key","desc","d","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","$fdaff9f788d94485$export$baf26146a414f24a","constructor","x","y","clone","copyFrom","p","copyTo","equals","toString","shared","$fdaff9f788d94485$var$tempPoint","$55a82579353c67d9$export$4617fb02663045ef","$1HooC","$55a82579353c67d9$var$tempPoints","Point","width","height","type","Number","left","right","top","bottom","isEmpty","EMPTY","copyFromBounds","bounds","minX","minY","maxX","maxY","rectangle","contains","strokeContains","strokeWidth","_x","_y","intersects","other","transform","x02","x12","y02","y12","x0","x1","y0","y1","lt","lb","rt","rb","Math","sign","b","apply","max","min","nx","ny","n00","n10","n01","n11","mx","my","m00","m10","m01","m11","pad","paddingX","paddingY","fit","x2","y2","ceil","resolution","eps","floor","enlarge","getBounds","out","$2726d886f4171354$export$4f037c6ec2da4eeb","$2726d886f4171354$export$cc3e2d3244e01b7f","ExtensionType2","$2726d886f4171354$var$normalizeExtension","ext","extension","ref","$2726d886f4171354$export$ba4241979983e013","defaultPriority","priority","_addHandlers","_removeHandlers","_queue","remove","extensions2","map","forEach","add","handlers","queue","push","handle","onAdd","onRemove","addHandlers","removeHandlers","handleByMap","name","handleByNamedList","findIndex","item","value","sort","index","splice","handleByList","list","includes","indexOf","$Gr8vk","Promise","all","then","resolve","$i9BKe","$7h8HJ","$lLQso","$jXXId","$fwGvo","$8xl7d","$aQPld","$hNatJ","extensions","AlphaMask","ColorMask","StencilMask","VideoSource","ImageSource","CanvasSource","BufferImageSource","$90469dbfa4a0e350$export$3c32667be409917c","$4rhnu","$jzlb7","$4vXk0","options","pipe","mask","renderMaskToTexture","Sprite","renderable","includeInBuild","measurable","reset","addBounds","skipUpdateTransform","addMaskBounds","addLocalBounds","localRoot","addMaskLocalBounds","containsPoint","point","hitTestFn","destroy","test","ExtensionType","MaskEffect","$2ddac34a8a6af484$export$3075603db8e6204c","$a32F4","$bLlTJ","$f8J9J","$eicwU","Container","Texture","texture","anchor","roundPixels","rest","label","renderPipeId","batched","_didSpriteUpdate","_bounds","_sourceBounds","_boundsDirty","_sourceBoundsDirty","_roundPixels","_anchor","ObservablePoint","_onUpdate","onViewUpdate","defaultAnchor","allowChildren","from","source","skipCache","currentTexture","_texture","dynamic","off","on","_updateBounds","sourceBounds","_updateSourceBounds","trim","addFrame","_didChangeId","didViewUpdate","renderGroup","onChildViewUpdate","updateQuadBounds","orig","destroyTextureSource","textureSource","abs","scale","_setWidth","_setHeight","getSize","setSize","convertedWidth","convertedHeight","$702ea64f2b15c76d$export$3755aaad3fd42e52","observer","_observer","$dd4e44a750d6d26c$export$5431306cf43de24a","$3vRz3","$2RwkA","$fM4Mk","$aGJhg","$kXq8E","$2coCi","$iA5fe","$jNN6Y","frame","defaultBorders","rotate","uid","uvs","x3","y3","Rectangle","noFrame","isTexture","TextureSource","_source","destroyed","updateUvs","update","emit","textureMatrix","_textureMatrix","TextureMatrix","nX","nY","nW","nH","w2","h2","cX","cY","groupD8","NW","uX","uY","destroySource","removeAllListeners","baseTexture","deprecation","v8_0_0","NOOP","WHITE","resource","Uint8Array","alphaMode","$28edd11f6c7e9f5f$var$has","prototype","hasOwnProperty","$28edd11f6c7e9f5f$var$prefix","$28edd11f6c7e9f5f$var$Events","$28edd11f6c7e9f5f$var$EE","fn","context","once","$28edd11f6c7e9f5f$var$addListener","emitter","event","TypeError","listener","evt","_events","_eventsCount","$28edd11f6c7e9f5f$var$clearEvent","$28edd11f6c7e9f5f$var$EventEmitter","create","__proto__","eventNames","events","names","slice","getOwnPropertySymbols","concat","listeners","l","ee","Array","listenerCount","a1","a2","a3","a4","a5","args","len","removeListener","undefined","j","addListener","prefixed","EventEmitter","$99d48e5a2f9844ff$export$b7bb6a2a8d203102","$eY4rt","$99d48e5a2f9844ff$var$ux","$99d48e5a2f9844ff$var$uy","$99d48e5a2f9844ff$var$vx","$99d48e5a2f9844ff$var$vy","$99d48e5a2f9844ff$var$rotationCayley","$99d48e5a2f9844ff$var$rotationMatrices","$99d48e5a2f9844ff$var$signum","$99d48e5a2f9844ff$var$init","row","_ux","_uy","_vx","_vy","k","mat","Matrix","E","SE","S","SW","W","N","NE","MIRROR_VERTICAL","MAIN_DIAGONAL","MIRROR_HORIZONTAL","REVERSE_DIAGONAL","ind","vX","vY","inv","rotation","rotationSecond","rotationFirst","sub","rotate180","isVertical","byDirection","dx","dy","matrixAppendRotationInv","matrix","tx","ty","append","$fd3f7bfaf4af3d85$export$5b12bf1653c0dd85","$aWW4e","array","fromArray","toArray","transpose","Float32Array","pos","newPos","applyInverse","translate","angle","cos","sin","c1","tx1","b1","d1","appendFrom","b2","c2","d2","setTransform","pivotX","pivotY","scaleX","scaleY","skewX","skewY","prepend","decompose","pivot","atan2","delta","PI_2","skew","sqrt","position","invert","isIdentity","identity","IDENTITY","$fd3f7bfaf4af3d85$var$identityMatrix","$fd3f7bfaf4af3d85$var$tempMatrix","$635707f32e142ac4$export$59ed0a0a5de1084b","$635707f32e142ac4$export$3f91627dc85c5d57","$635707f32e142ac4$export$870617f62e3187f1","PI","$aa9685d46d70e8a7$export$e2a22331486dcca0","$aa9685d46d70e8a7$var$uidCache","$86481ab6f435a4d7$export$dc79da96439604f0","$86481ab6f435a4d7$export$afd31d834b512e89","$86481ab6f435a4d7$var$warnings","version","message","ignoreDepth","stack","console","warn","split","join","groupCollapsed","groupEnd","$342f4d0330a1a110$export$5702a91a6f42969f","$288e2f2cc997a595$export$1872462350fcb7cd","buffer","format","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","uploadMethodId","Uint8ClampedArray","$50e6ce3cf0e8b717$export$8498e6a2e655d3d8","$NbSCN","$dr868","$aFPUT","$50e6ce3cf0e8b717$var$_TextureSource","_TextureSource","_resourceType","_resourceId","_resolution","pixelWidth","pixelHeight","sampleCount","mipLevelCount","autoGenerateMipmaps","dimension","antialias","_touched","_batchTick","_textureBindLocation","defaultOptions","autoGarbageCollect","resourceWidth","resourceHeight","dimensions","style","TextureStyle","definedProps","_refreshPOT","_style","_onStyleChange","addressMode","repeatMode","magFilter","minFilter","mipmapFilter","lodMinClamp","lodMaxClamp","resize","unload","naturalWidth","videoWidth","displayWidth","naturalHeight","videoHeight","displayHeight","newPixelWidth","round","newPixelHeight","updateMipmaps","wrapMode","scaleMode","isPowerOfTwo","isPow2","_resource","$445bbf816b14b66c$export$f0d90cf68bd426eb","$445bbf816b14b66c$export$eb50b9c078eb6ae7","$c5dcc841d9b9a11e$export$801feaffb936a09d","obj","result","$46d9af7c4b00e80a$export$1ce1d0c10d3de5d5","$46d9af7c4b00e80a$var$idHash","$46d9af7c4b00e80a$var$_TextureStyle","_TextureStyle","_maxAnisotropy","addressModeU","addressModeV","addressModeW","compare","maxAnisotropy","_sharedResourceId","_generateResourceId","bigKey","$46d9af7c4b00e80a$var$createResourceIdFromString","$707e20d60f27daa2$export$dbea3135e9da48cb","$707e20d60f27daa2$var$tempMat","clampMargin","mapCoord","uClampFrame","uClampOffset","_textureID","_updateID","clampOffset","isSimple","multiplyUvs","tex","texBase","margin","offset","$67aa708353891905$export$558ce66aa5723f1d","padding","sourceWidth","sourceHeight","$8a2b4ed6f59ce4dc$export$f8ede8d8bf091ab5","$8a2b4ed6f59ce4dc$export$e4801e7edc7582f","$8a2b4ed6f59ce4dc$export$83db162b74637ea","$8a2b4ed6f59ce4dc$export$42a852a2b6b56249","$a2eTA","$j1i7q","$236jP","$apXS2","$kkVML","$kEqoj","$ggvKl","$82jXu","$g5iYs","$1pFbO","$gIPW8","$8a2b4ed6f59ce4dc$var$defaultSkew","$8a2b4ed6f59ce4dc$var$defaultPivot","$8a2b4ed6f59ce4dc$var$defaultScale","_updateFlags","isRenderGroupRoot","didChange","relativeRenderGroupDepth","children","parent","updateTick","localTransform","relativeGroupTransform","groupTransform","_position","_scale","_pivot","_skew","_cx","_sx","_cy","_sy","_rotation","localColor","localAlpha","groupAlpha","groupColor","groupColorAlpha","localBlendMode","groupBlendMode","localDisplayStatus","globalDisplayStatus","_didLocalTransformChangeId","assignWithIgnore","effects","child","addChild","mixin","defineProperties","getOwnPropertyDescriptors","structureDidChange","removeChild","sortableChildren","sortDirty","_zIndex","depthOfChildModified","_updateSkew","renderGroupParent","onChildUpdate","isRenderGroup","enableRenderGroup","root","parentRenderGroup","RenderGroup","renderGroupChildren","childRenderGroup","addRenderGroupChild","_updateIsSimple","worldTransform","_worldTransform","RAD_TO_DEG","DEG_TO_RAD","getLocalBounds","localWidth","localHeight","size","updateTransform","opts","setFromMatrix","updateLocalTransform","sx","sy","px","py","alpha","tint","bgr","tempColor","Color","setValue","toBgrNumber","blendMode","visible","culled","isRenderable","removeFromParent","_mask","_filters","destroyChildren","oldChildren","removeChildren","childrenHelperMixin","toLocalGlobalMixin","onRenderMixin","measureMixin","effectsMixin","findMixin","sortMixin","cullingMixin","$f6a94f8017837c10$export$892596cec99bc70e","$erZA3","$lCM3s","extend","$f6a94f8017837c10$var$_Color","_Color","_value","_components","fill","_int","red","green","blue","_cloneSource","_isSourceEqual","_normalize","isArray","ArrayBuffer","isView","value1","value2","type1","every","keys1","keys","keys2","toRgba","g","toRgb","toRgbaString","toUint8RgbArray","_arrayRgb","_arrayRgba","toRgbArray","toNumber","toLittleEndianNumber","multiply","_temp","_refreshInt","premultiply","applyToRGB","toPremultiplied","toHex","hexString","substring","toHexa","alphaString","alphaValue","setAlpha","_clamp","int","match","HEX_PATTERN","exec","color","colord","isValid","rgba","isColorLike","h","$482ad42e73ee00b6$export$c8efe09109f9cb9e","$482ad42e73ee00b6$export$8b58be045bf06082","$482ad42e73ee00b6$var$r","grad","turn","rad","$482ad42e73ee00b6$var$t","$482ad42e73ee00b6$var$n","pow","$482ad42e73ee00b6$var$e","$482ad42e73ee00b6$var$u","isFinite","$482ad42e73ee00b6$var$a","$482ad42e73ee00b6$var$o","$482ad42e73ee00b6$var$i","$482ad42e73ee00b6$var$s","$482ad42e73ee00b6$var$h","u","o","$482ad42e73ee00b6$var$b","$482ad42e73ee00b6$var$g","$482ad42e73ee00b6$var$d","$482ad42e73ee00b6$var$f","$482ad42e73ee00b6$var$c","$482ad42e73ee00b6$var$l","$482ad42e73ee00b6$var$p","$482ad42e73ee00b6$var$v","$482ad42e73ee00b6$var$m","$482ad42e73ee00b6$var$y","string","parseInt","substr","object","$482ad42e73ee00b6$var$N","$482ad42e73ee00b6$var$M","$482ad42e73ee00b6$var$H","$482ad42e73ee00b6$var$$","$482ad42e73ee00b6$export$4d30ed660ff08d0","parsed","$482ad42e73ee00b6$var$x","brightness","isDark","isLight","toRgbString","toHsl","toHslString","toHsv","saturate","desaturate","grayscale","lighten","darken","hue","isEqual","$482ad42e73ee00b6$var$S","$4bf1f6e6e10c0717$export$2e2bcd8739ae039","f","white","bisque","cadetblue","chartreuse","chocolate","coral","antiquewhite","aqua","azure","whitesmoke","papayawhip","plum","blanchedalmond","black","gold","goldenrod","gainsboro","cornsilk","cornflowerblue","burlywood","aquamarine","beige","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkkhaki","darkgray","darkgreen","darkgrey","peachpuff","darkmagenta","darkred","darkorchid","darkorange","darkslateblue","gray","darkslategray","darkslategrey","deeppink","deepskyblue","wheat","firebrick","floralwhite","ghostwhite","darkviolet","magenta","dodgerblue","grey","honeydew","hotpink","blueviolet","forestgreen","lawngreen","indianred","indigo","fuchsia","brown","maroon","mediumblue","lightcoral","darkturquoise","lightcyan","ivory","lightyellow","lightsalmon","lightseagreen","linen","mediumaquamarine","lemonchiffon","lime","khaki","mediumseagreen","limegreen","mediumspringgreen","lightskyblue","lightblue","midnightblue","lightpink","mistyrose","moccasin","mintcream","lightslategray","lightslategrey","navajowhite","navy","mediumvioletred","powderblue","palegoldenrod","oldlace","paleturquoise","mediumturquoise","mediumorchid","rebeccapurple","lightsteelblue","mediumslateblue","thistle","tan","orchid","mediumpurple","purple","pink","skyblue","springgreen","palegreen","yellow","slateblue","lavenderblush","peru","palevioletred","violet","teal","slategray","slategrey","aliceblue","darkseagreen","darkolivegreen","greenyellow","seagreen","seashell","tomato","silver","sienna","lavender","lightgreen","orange","orangered","steelblue","royalblue","turquoise","yellowgreen","salmon","saddlebrown","sandybrown","rosybrown","darksalmon","lightgoldenrodyellow","snow","lightgrey","lightgray","dimgray","dimgrey","olivedrab","olive","toName","closest","toLowerCase","$b5b40e006e048a91$export$dce76d4f0fd249ed","cullArea","cullable","cullableChildren","$0d8e0eeab3189cd3$export$64cca9f0c2df174a","$33PVi","beginIndex","endIndex","end","range","removed","removeItems","RangeError","removeChildAt","getChildAt","setChildIndex","getChildIndex","addChildAt","currentIndex","swapChildren","child2","index1","index2","$cefc366e7023560b$export$8d47c0e1ce445404","arr","startIdx","removeCount","$1d59e812d2000ae8$export$eec5e288a9d02a7c","$aWIPo","$dZmDL","$61KiY","addEffect","effect","removeEffect","MaskEffectManager","returnMaskEffect","getMaskEffect","filters","filterArea","hasFilters","freeze","BigPool","FilterEffect","return","$573d66e12a5f4185$export$d66c06ffe23037ab","$f40a37c299623cb8$export$1eb319167fe02d04","_effectClasses","_tests","_initialized","maskClass","$9483424e2013bba4$export$8249372279066210","$5Xsoh","_poolsByClass","Map","prepopulate","Class","total","classPool","getPool","data","pool","ClassType","has","Pool","stats","_classType","ID","free","totalFree","used","totalUsed","totalSize","$ce33839780b5f2f3$export$14963ee5c8637e11","initialSize","_pool","_count","_index","$1ce16328dd0c7b09$export$468b0762e1bfbd64","getChildByName","deep","getChildByLabel","RegExp","found","getChildrenByLabel","$4a6a8e8422db6a2e$export$285e6e72e8e62f0","$7wtv9","$iskjc","$j68wk","$lK289","$4a6a8e8422db6a2e$var$tempMatrix","_localBoundsCacheId","_localBoundsCacheData","localBounds","Bounds","localBoundsCacheData","checkChildrenDidChange","skipUpdate","getGlobalBounds","$0b15abb3a529f09f$export$c4e9d269599ab4b4","$0b15abb3a529f09f$var$defaultMatrix","Infinity","_rectangle","clear","addRect","rect","addBoundsMask","applyMatrix","fitBounds","isPositive","addVertexData","vertexData","beginOffset","endOffset","localX","localY","$b2563854990e287d$export$f4412a6981d97baa","$b2563854990e287d$export$2022bc48a49dd6d2","$5tmC8","parentTransform","pooledMatrix","matrixPool","$b2563854990e287d$export$ca70956e64971628","parentBounds","preserveBounds","boundsPool","boundsArea","$aaa7ee585a7b6ebc$export$3849005ba4dacf72","$aaa7ee585a7b6ebc$export$9194656040c1dc42","$653ce529dcaa332d$export$ffaf4f504c4c5c9c","relativeMatrix","$653ce529dcaa332d$var$_getLocalBounds","rootContainer","isRoot","relativeTransform","$ffdcd240d931c2ea$export$c106dd0671a0fc2d","$ffdcd240d931c2ea$var$warnCount","$6ac8d139665df8ac$export$fd5aadbd3827bcf1","container","previousData","changeId","$63981d12ee78567e$export$2a5246d1114cb81d","_onRender","onRender","func","removeOnRender","addOnRender","$8864252dd84a6b69$export$eb4acdd9f4781aed","zIndex","sortChildren","$8864252dd84a6b69$var$sortChildren","$6a95391942e887de$export$38fa7a987602e8dd","getGlobalPosition","toGlobal","globalMatrix","updateTransformBackwards","toLocal","$5a621eb8e375b2c4$export$94d273f8d74f2a5","$dK5Jn","canBundle","_children","worldColorAlpha","worldColor","worldAlpha","childrenToUpdate","childrenRenderablesToUpdate","instructionSet","InstructionSet","_onRenderContainers","renderGroupChild","_removeRenderGroupChild","_removeChildFromUpdate","updateRenderable","renderPipes","runOnRender","$a69ff318b1fa7c86$export$2946bd01f10dd922","instructions","instructionSize","instruction","log","table","$83c57e61d47d996f$export$59d0441a278e5935","ignore","$cd1eadd0f2fb679c$export$12af48852c6ac574","$cd1eadd0f2fb679c$var$tempBounds","$6df4144b7f405909$export$7416ac774b1f1a33","$hUCK4","boundsToMask","tempMatrix","relativeMask","$6df4144b7f405909$export$1536bde1a0bf3cb9","$2625cf12b5a3b5e5$export$1e2a2c76374c2542","$e8890ea82735e7dd$export$abd85894695764cb","$adfc96265c7ca69d$export$ca65ccf5708c6a0c","$iCGeI","DOMAdapter","createCanvas","autoDensity","canvas","resizeCanvas","transparent","didResize","HTMLCanvasElement","OffscreenCanvas","$bfbe44ab70ab7a53$export$d988306fa84f7b44","$bfbe44ab70ab7a53$var$currentAdapter","$9OKiP","BrowserAdapter","adapter","$ed1c5172c2eee607$export$e467cc3399500025","document","createElement","getCanvasRenderingContext2D","CanvasRenderingContext2D","getWebGLRenderingContext","WebGLRenderingContext","getNavigator","navigator","getBaseUrl","baseURI","window","location","href","getFontFaceSet","fonts","fetch","url","parseXML","xml","parser","DOMParser","parseFromString","$ac4c5539d7b1f960$export$280e9a68c3ffd919","HTMLImageElement","getContext","drawImage","ImageBitmap","$4dc351acd421ceef$export$f3a17123d80000c5","$4J7WL","$7blVu","$4dc351acd421ceef$var$_VideoSource","_VideoSource","isReady","_autoUpdate","_isConnectedToTicker","_updateFPS","updateFPS","_msToNextUpdate","autoPlay","_videoFrameRequestCallback","bind","_videoFrameRequestCallbackHandle","_load","_resolve","_reject","_onCanPlay","_onCanPlayThrough","_onError","_onPlayStart","_onPlayStop","_onSeeked","autoLoad","load","updateFrame","elapsedMS","Ticker","playbackRate","requestVideoFrameCallback","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","complete","addEventListener","_isSourceReady","_mediaReady","preload","detectVideoAlphaMode","reject","preloadTimeoutMs","_preloadTimeout","setTimeout","ErrorEvent","removeEventListener","_isSourcePlaying","paused","ended","_configureAutoUpdate","clearTimeout","play","pause","src","autoUpdate","cancelVideoFrameCallback","HTMLVideoElement","VideoFrame","crossorigin","loop","muted","playsinline","MIME_TYPES","ogv","mov","m4v","$2bf8d15685054100$export$39c54bcc89dcee11","$cQMLP","$bJH8Y","$2bf8d15685054100$var$_Ticker","_Ticker","autoStart","deltaTime","lastTime","speed","started","_requestId","_maxElapsedMS","_minElapsedMS","_protected","_lastFrame","_head","TickerListener","deltaMS","targetFPMS","_tick","time","next","requestAnimationFrame","_requestIfNeeded","performance","now","_cancelIfNeeded","cancelAnimationFrame","_startIfPossible","start","UPDATE_PRIORITY","NORMAL","_addListener","addOnce","current","previous","connect","count","stop","currentTime","head","FPS","minFPS","fps","minFPMS","maxFPS","_shared","system","_system","$d091949369ecd400$export$688aaf132ba9b379","UPDATE_PRIORITY2","$44ffb68c45a667a2$export$579021a5759a260f","_destroyed","_fn","_context","_once","ticker","redirect","hard","$1603b82fc2121ba0$var$promise","$1603b82fc2121ba0$export$8df68d58aae31877","gl","video","video2","onloadeddata","onerror","autoplay","crossOrigin","createTexture","bindTexture","TEXTURE_2D","framebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","texImage2D","RGBA","UNSIGNED_BYTE","pixel","readPixels","deleteFramebuffer","deleteTexture","getExtension","loseContext","$2IhKp","$da9f248d33f9f2f1$var$sources","Cache","$da9f248d33f9f2f1$export$3b748ed6327ec85b","hasResource","$da9f248d33f9f2f1$export$688bcf31fbf7eb15","res","Source","$3d19110becfaeec3$export$94affb487e701bf2","$3CHiv","_parsers","_cache","_cacheMap","cacheableAssets","convertToList","parsers","getCacheableAssets","cacheableMap","entries","key2","cacheKeys","cachedAssets","val","cacheMap","delete","$93954259b3f62d4e$export$b01be8e180bf3d9b","input","forceTransform","$8PDkK","spritesheetAsset","$a322641177c54ad8$export$46dcda4f1cdd80fe","$iEtN5","$8kCsw","$5Oad7","$lzfZe","$58WFl","$a322641177c54ad8$var$validImages","Asset","asset","Spritesheet","$a322641177c54ad8$var$getCacheableAssets","ignoreMultiPack","textures","basePath","path","dirname","linkedSheets","assign","meta","related_multi_packs","resolver","tempURL","pop","parse","parseFloat","Resolver","RETINA_PREFIX","loader","LoadParser","LoaderParserPriority","Normal","testParse","extname","frames","imageTexture","imageFilename","lastIndexOf","imagePath","copySearchParams","image","assets","spritesheet","multiPacks","promises","itemUrl","filter","sp","_resolvedAsset","_sourceOrigin","$29ed14ceb032dea6$export$820ed6348c4f2750","LoaderParserPriority2","$23cc1cafdfe05125$export$8b4c839865b08288","$8F3vm","$4DmkB","_defaultBundleIdentifierOptions","connector","createBundleAssetId","bundleId","assetId","_bundleIdConnector","extractAssetIdFromBundle","assetBundleId","replace","_createBundleAssetId","_extractAssetIdFromBundle","_assetMap","_preferredOrder","_resolverHash","_bundles","setBundleIdentifier","bundleIdentifier","prefer","preferOrders","params","_basePath","rootPath","_rootPath","_manifest","_defaultSearchParams","setDefaultSearchParams","searchParams","encodeURIComponent","queryValues","getAlias","alias","addManifest","manifest","bundles","bundle","addBundle","assetNames","convertedAssets","ids","srcs","aliases","bundleAssetId","bundleIds","keyCheck","hasKey","assetArray","loadParser","srcsToUse","src2","createStringVariations","aliasesToUse","resolvedAssets","formattedAsset","_buildResolvedAsset","resolveBundle","singleAsset","isSingleItem","results","resolveUrl","preferredOrder","_getPreferredOrder","priorityKey","filteredAssets","hasBundle","preferred","find","preference","_appendDefaultSearchParams","paramConnector","assetData","toAbsolute","shift","$3c67d20d89e3898c$export$bb654e07daaf8c3a","$3c67d20d89e3898c$var$assertPath","path2","JSON","stringify","$3c67d20d89e3898c$var$removeUrlParams","re","toPosix","str","isUrl","isDataUrl","isBlobUrl","startsWith","hasProtocol","getProtocol","matchFile","matchProtocol","customBaseUrl","customRootUrl","baseUrl","rootUrl","rootname","isAbsolute","normalize","protocol","trailingSeparator","endsWith","$3c67d20d89e3898c$var$normalizeStringPosix","allowAboveRoot","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","segments","joined","arg","prevArg","joinExtensions","hasRoot","matchedSlash","proto","origpath","basename","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret","dir","base","sep","delimiter","$fde1bf5bcf60c2d9$export$738117acc6638004","tags","vars","$fde1bf5bcf60c2d9$var$processX","depth","$f373b2ad881b3255$export$16a80d27953452d4","$273b4a26d8a43536$export$f57b97ef8be10dda","targetUrl","sourceUrl","$9c38ec259f91df14$export$674d2eb4debbef0c","$9c38ec259f91df14$var$_Spritesheet","_Spritesheet","animations","metaResolution","_frames","_frameKeys","_batchIndex","_callback","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","sourceSize","trimmed","w","rotated","spriteSourceSize","borders","animName","frameName","callback","destroyBase","$453fded98f054a94$export$58ab3ed211eed562","$cJHPn","$hFYOq","$gtbjr","$453fded98f054a94$var$defaultRunners","$453fded98f054a94$var$_AbstractRenderer","_AbstractRenderer","config","runners","_initOptions","_systemsHash","combinedRunners","_addRunners","_addSystems","systems","_addPipes","renderPipeAdaptors","_unsafeEvalCheck","systemName","items","render","deprecated","renderTexture","view","renderTarget","_lastObjectRendered","clearColor","background","colorRgba","isRGBAArray","prerender","renderStart","renderEnd","postrender","desiredScreenWidth","desiredScreenHeight","screen","renderer","CLEAR","ALL","resolutionChange","lastObjectRendered","renderingToScreen","runnerIds","runnerId","SystemRunner","_addSystem","ClassRef","pipes","pipeAdaptors","adaptors","reduce","acc","adaptor","PipeClass","Adaptor","reverse","values","runner","generateTexture","textureGenerator","unsafeEvalSupported","failIfMajorPerformanceCaveat","$d88536e9c61409d6$var$unsafeEval","$d88536e9c61409d6$export$70c0711f29adc5cf","Function","$bdcaad22b468ed1b$export$6c4d37c7f376a1de","CLEAR2","$299af1a7d2dd4105$export$ff5f2fe687fe3979","_name","a0","a6","a7","removeAll","empty","$119fb8487ef4f791$export$f2f3ca33e4c65172","$ixM8g","$beJMG","$4rmMq","$1mKkK","$119fb8487ef4f791$export$e3e348c254036d55","batches","geometryData","vertices","indices","$119fb8487ef4f791$export$9b6a6c5b37fc8f49","geometry","BatchGeometry","$119fb8487ef4f791$var$_GraphicsContextSystem","_GraphicsContextSystem","_activeBatchers","_gpuContextHash","_graphicsDataContextHash","_needsContextNeedsRebuild","bezierSmoothness","_returnActiveBatchers","getContextRenderData","_initContextRenderData","updateGpuContext","gpuContext","_initContext","dirty","_cleanGraphicsContextData","buildContextBatches","batchMode","customShader","isBatchable","getGpuContext","graphicsData","vertexSize","indexSize","applyTransform","batcher","Batcher","ensureAttributeBuffer","ensureIndexBuffer","begin","batch","finish","indexBuffer","setDataWithSize","buffers","attributeBuffer","float32View","attributeSize","drawBatches","bindGroup","getTextureBatchBindGroup","onGraphicsContextUpdate","onGraphicsContextDestroy","WebGLSystem","WebGPUSystem","CanvasSystem","$21794e3cca2986f9$export$449e8d355fd68e43","$lvEAL","$1UZ6r","$cOnev","$21794e3cca2986f9$var$placeHolderBufferData","$21794e3cca2986f9$var$placeHolderIndexData","Geometry","Buffer","usage","BufferUsage","VERTEX","COPY_DST","shrinkToFit","attributes","aPosition","stride","aUV","aColor","aTextureIdAndRound","INDEX","$9841377a483d1ce7$export$a143d493d941bafc","_data","byteLength","mappedAtCreation","descriptor","static","STATIC","syncGPU","_updateSize","BYTES_PER_ELEMENT","oldData","sizeInBytes","$f4c8f2641f61e66f$export$f8deb2be8632fd10","BufferUsage2","$f72e7cebaee4d192$export$2db6c17465f94a2","$zwuDY","$dYcXX","topology","_layoutKey","instanceCount","attribute","ensureIsBuffer","onBufferUpdate","getAttribute","getIndex","getBuffer","getGeometryBounds","destroyBuffers","$c27f8a68b3d31b3f$export$e02adcb3cf335e03","$547d4a1f0305efcb$export$ca8be28ec6402f29","attributeId","byteSize","$24797d7b1c25d5bc$export$84c26df82650dc9b","$awcfo","$67Wkd","$24797d7b1c25d5bc$var$cachedGroups","$24797d7b1c25d5bc$var$generateTextureBatchBindGroup","bindGroupResources","bindIndex","MAX_TEXTURES","BindGroup","$6cadf620a92ebba7$export$6f452ee382def63c","resources","_dirty","setResource","_updateKey","keyParts","_key","currentResource","onResourceChange","getResource","_touch","tick","$7769f35d458fe19d$export$e09e7788b3f0275e","$71f140885a3d3890$export$704b12ddc1dacdd2","$aaUE3","$1tfR4","$eN26f","$bRzRK","$71f140885a3d3890$export$33b107562567fc47","action","gpuBindGroup","$71f140885a3d3890$var$BATCH_TICK","$71f140885a3d3890$var$_Batcher","_Batcher","batchIndex","_vertexSize","_elements","_batchPool","_batchPoolIndex","_textureBatchPool","_textureBatchPoolIndex","ViewableBuffer","elementSize","elementStart","_batchIndexStart","_batchIndexSize","batchableObject","indexStart","checkAndUpdateTexture","textureId","updateElement","packAttributes","uint32View","break","elements","textureBatch","BatchTextureArray","firstElement","getAdjustedBlendModeBlend","_resizeAttributeBuffer","_resizeIndexBuffer","f32","u32","iBuffer","element","adjustedBlendMode","blendModeChange","packIndex","_finishBatch","newSize","newArrayBuffer","fastCopy","rawBinaryData","newIndexBuffer","$d6aafa25b0389ff9$export$4fdbf0662aa3047a","sizeOrBuffer","int8View","_int8View","uint8View","_uint8View","int16View","_int16View","int32View","_int32View","float64View","_float64Array","Float64Array","bigUint64View","_bigUint64Array","BigUint64Array","uint16View","sizeOf","$3976cf47510ef1a5$export$c691b0c42debe682","sourceBuffer","destinationBuffer","lengthDouble","sourceFloat64View","destinationFloat64View","remainingBytes","sourceUint8View","destinationUint8View","$3b017cb7131d92fc$export$ab2fc5cf3fe899fe","$eE5Ke","BLEND_TO_NPM","$16526f00f7b0e2b9$export$8c0bd2ccaa4a8d5e","$16526f00f7b0e2b9$export$c250b85d73a91bdf","normal","STENCIL_MODES2","$a96c3003620e8697$export$aa760e0febf1a758","$2ba674c6e42be2fb$export$e3c00f31a053d231","$kVCUp","$9Co9Q","$xZ5a3","$dY2iR","$46SPq","$ei7YJ","$7DIxn","$iAUCq","$2E1jb","$2ba674c6e42be2fb$var$buildMap","buildRectangle","polygon","buildPolygon","triangle","buildTriangle","circle","buildCircle","ellipse","roundedRectangle","$2ba674c6e42be2fb$var$tempRect","$2ba674c6e42be2fb$var$addTextureToGeometryData","indexOffset","vertOffset","points","build","dw","dh","transformVertices","triangulate","textureUvs","graphicsBatch","BatchableGraphics","vertexOffset","isStroke","shapePath","hole","$2ba674c6e42be2fb$var$addShapePathToGeometryData","lastIndex","shapePrimitives","shape","close","closePath","buildLine","holeIndices","otherPoints","holeArrays","$2ba674c6e42be2fb$var$getHoleArrays","holePrimitives","holePrimitive","holePoints","holeBuilder","triangulateWithHoles","uvsOffset","buildUvs","buildSimpleUvs","$1606ccc0770732ec$export$2027711a0ff70dc2","verticesStride","verticesOffset","uvsStride","$1606ccc0770732ec$export$580e3d8462b9fe52","$74e682a1604b3625$export$cbe36b8a8d6e3d3","m","$3f80d08e0b9378c5$export$91d2a08bbf21546b","$1btgi","indicesOffset","graphics","positions","vertSize","rgb","argb","mixColors","wt","textureIdAndRound","gpuBuffer","$fa16342a035ea58b$export$72a85c3a80ccc403","$e39Qs","localBGRColor","parentBGRColor","mixHexColors","$5ef5460938e8160b$export$ff72adc46f6bc63c","color1","color2","ratio","r1","g1","r2","g2","$791ed7b81fe09d67$export$a3541b2d8ecbfcf2","rx","ry","radius","halfWidth","halfHeight","roundedRect","j1","j2","j3","j4","y22","x22","centerX","centerY","centerIndex","$9fc8551677af3cf1$export$45986ccf08e93b0b","$d1s7O","$168p3","$9fc8551677af3cf1$var$square","innerWeight","outerWeight","clockwise","verts","exx","eyy","eix","ix","eiy","iy","eox","ox","eoy","oy","$9fc8551677af3cf1$var$round","cx","cy","ex","ey","cx2p0x","cy2p0y","angle0","angle1","startAngle","angleDiff","segCount","angleInc","lineStyle","flipAlignment","closed","_verticesStride","_verticesOffset","_indicesOffset","closePointEps","alignment","orientation","getOrientationOfPoints","firstPoint","lastPoint","closedPath","midPointX","midPointY","unshift","indexCount","widthSquared","miterLimitSquared","miterLimit","perpX","perpY","perp1x","perp1y","dist","cap","dx0","dy0","dx1","dy1","dot","cross","pDist","imx","imy","omx","omy","insideWeight","smallerInsideSegmentSq","eps2","curveEps","$5f88c52b3933a72f$export$7159a7c43f12984","$5f88c52b3933a72f$export$51a946149243709","$19281094736c08bb$export$38856eae80d480e1","area","$7f823fd9a95a0bf4$export$4c2d12f7b210f357","$7f823fd9a95a0bf4$var$emptyArray","$0c79f6b53084d415$export$5a241bf9c2c3d94b","$2jYVZ","holes","triangles","$1b0c9f6ca9bef72e$var$earcut","dim","invSize","hasHoles","outerLen","outerNode","$1b0c9f6ca9bef72e$var$linkedList","prev","$1b0c9f6ca9bef72e$var$eliminateHoles","steiner","$1b0c9f6ca9bef72e$var$getLeftmost","leftmost","$1b0c9f6ca9bef72e$var$compareX","$1b0c9f6ca9bef72e$var$eliminateHole","bridge","$1b0c9f6ca9bef72e$var$findHoleBridge","hx","hy","qx","tanMin","$1b0c9f6ca9bef72e$var$pointInTriangle","$1b0c9f6ca9bef72e$var$locallyInside","$1b0c9f6ca9bef72e$var$area","bridgeReverse","$1b0c9f6ca9bef72e$var$splitPolygon","$1b0c9f6ca9bef72e$var$filterPoints","$1b0c9f6ca9bef72e$var$earcutLinked","ear","pass","$1b0c9f6ca9bef72e$var$indexCurve","z","$1b0c9f6ca9bef72e$var$zOrder","prevZ","nextZ","$1b0c9f6ca9bef72e$var$sortLinked","q","tail","numMerges","pSize","qSize","inSize","$1b0c9f6ca9bef72e$var$isEarHashed","ax","bx","ay","by","minZ","maxZ","$1b0c9f6ca9bef72e$var$isEar","$1b0c9f6ca9bef72e$var$removeNode","$1b0c9f6ca9bef72e$var$cureLocalIntersections","$1b0c9f6ca9bef72e$var$equals","$1b0c9f6ca9bef72e$var$intersects","$1b0c9f6ca9bef72e$var$splitEarcut","$1b0c9f6ca9bef72e$var$intersectsPolygon","$1b0c9f6ca9bef72e$var$middleInside","inside","last","$1b0c9f6ca9bef72e$var$signedArea","$1b0c9f6ca9bef72e$var$insertNode","again","p1","p2","q1","q2","o1","$1b0c9f6ca9bef72e$var$sign","o2","o3","o4","$1b0c9f6ca9bef72e$var$onSegment","num","$1b0c9f6ca9bef72e$var$Node","an","bp","sum","deviation","polygonArea","trianglesArea","flatten","holeIndex","$1d4b4832ec6feb5d$export$cbe813d11f2192b2","rectData","verticesIndex","$14f13b7de979604e$export$8eb75cb9f614d270","$339e160815705dba$export$722a6ea8c60ca86","$339e160815705dba$var$_FillGradient","_FillGradient","gradientStops","addColorStop","buildLinearGradient","defaultSize","defaultTextureSize","ctx","gradient","createLinearGradient","fillStyle","fillRect","$e9923e9fec04a606$export$3d1378c7410cd8e","$e9923e9fec04a606$var$repetitionMap","repeat","repetition","$1b5e4ef3a1ed4a4a$export$29d3e417456abdad","$8aC7P","GraphicsContext","_ownedContext","_didGraphicsUpdate","_callContextMethod","method","setFillStyle","setStrokeStyle","stroke","beginPath","cut","arc","arcTo","arcToSvg","bezierCurveTo","lineTo","moveTo","quadraticCurveTo","roundRect","poly","regularPoly","roundPoly","roundShape","filletRect","chamferRect","star","svg","restore","save","getTransform","resetTransform","rotateTransform","scaleTransform","translateTransform","strokeStyle","beginFill","endFill","defaultStrokeStyle","drawCircle","drawEllipse","drawPolygon","drawRect","drawRoundedRect","drawStar","$5d1287b36eb70f7f$export$cde35afe8b5f985","$c9xxq","$6ph3G","$6mQKv","$5d1287b36eb70f7f$var$tmpPoint","$5d1287b36eb70f7f$var$tempMatrix","$5d1287b36eb70f7f$var$_GraphicsContext","_GraphicsContext","_activePath","GraphicsPath","_transform","_fillStyle","defaultFillStyle","_strokeStyle","_stateStack","convertFillInputToFillStyle","onUpdate","lastInstruction","_initNextPathLocation","getLastPoint","holePath","addPath","endAngle","counterclockwise","xAxisRotation","largeArcFlag","sweepFlag","cp1x","cp1y","cp2x","cp2y","smoothness","radiusX","radiusY","transformedX","transformedY","cpx","cpy","sides","corner","useQuadratic","fillet","chamfer","innerRadius","SVGParser","state","hasHit","shapes","transformedPoint","holeShapes","$0663b1de1906f348$export$7e54506375634c19","$Zb4t5","$ein11","SVGToGraphicsPath","_shapePath","ShapePath","buildPath","bezierCurveToShort","currentX","currentY","quadraticCurveToShort","cpx1","cpy1","newGraphicsPath2D","cpx2","cpy2","$0663b1de1906f348$var$adjustTransform","currentMatrix","$af4e82628a1183ef$export$14a4a8042d02aa8d","$8DJYa","svgPath","commands","subpaths","currentSubPath","lastX","lastY","command","startX","startY","$64a59fcc91535eb3$var$segment","_","numbers","$64a59fcc91535eb3$var$number","$64a59fcc91535eb3$var$length","$664ff60a6792361f$export$148534a3c727230b","$h7nJT","$9hswb","$hbpIN","$7u40a","$lI2iN","$eRV6E","$aiLPr","$boMdH","$jjbCG","$9ad7k","$664ff60a6792361f$var$tempRectangle","graphicsPath2D","_currentPoly","_graphicsPath2D","startPoly","_ensurePoly","fromX","fromY","buildArc","buildArcTo","buildArcToSvg","currentPoly","buildAdaptiveBezier","smoothing","buildAdaptiveQuadratic","endPoly","drawShape","Circle","Polygon","internalAngle","roundedShapeQuadraticCurve","roundedShapeArc","maxFillet","inset","Ellipse","RoundedRectangle","lastShape","lx","ly","tempX","shapePrimitive","boundsRect","$f9e7c5f8c3846477$export$c89a927ffc67e6fa","distance","$985c1ca392a56bd1$export$80b0269ab108fa11","normx","normy","halfStrokeWidth","innerA","innerB","outerA","outerB","normalizedX","normalizedY","innerEllipse","outerEllipse","$11dc5aebdc9b56ee$export$7d31b617c820d435","$4sAiw","flat","il","xi","yi","xj","yj","halfStrokeWidthSqrd","iterationLength","distanceSqrd","squaredDistanceToLineSegment","pointsDesc","currentPoint","$95fee67952e97042$export$db32ff20ff695a","xx","yy","lenSq","param","$019041c7bdb3bf3e$export$d55ab2e3dc5a4263","$019041c7bdb3bf3e$var$isCornerWithinStroke","pX","pY","cornerX","cornerY","radius2","innerX","innerY","innerWidth","innerHeight","rightBound","bottomBound","$4a51fd8da05fe222$export$7dab5eac414ecba2","$hFzkv","sX","sY","eX","eY","distanceTolerance","$4a51fd8da05fe222$var$PATH_DISTANCE_EPSILON","GraphicsContextSystem","$4a51fd8da05fe222$var$recursive","x4","y4","level","x23","y23","x34","y34","x123","y123","x234","y234","x1234","y1234","d3","$39a9db3afcc2f789$export$d53ce9debfe7a6c2","$39a9db3afcc2f789$var$PATH_DISTANCE_EPSILON","$39a9db3afcc2f789$var$recursive","$4598c98f5bbae757$export$ed8eebdc6998f0f6","steps","cs","sn","$35a2eb588826e37c$export$d46b7933b415e02f","mm","dd","cc","tt","k1","k2","qy","$d859b1787749b4c9$export$71ccaa6dca53075e","$d859b1787749b4c9$var$TAU","$d859b1787749b4c9$var$out","ang1","ang2","$d859b1787749b4c9$var$mapToEllipse","cosPhi","sinPhi","out2","xp","yp","$d859b1787749b4c9$var$vectorAngle","ux","uy","vx","vy","acos","$d859b1787749b4c9$var$getArcCenter","pxp","pyp","rxSq","rySq","pxpSq","pypSq","radicant","centerXp","centerYp","vx1","vy1","lambda","outCurvePoint","curve","$d859b1787749b4c9$var$approxUnitArc","$9769dc3699a7c802$export$ae1f43bc280f09be","vecFrom","pp","sharpCorner","cRadius","pRadius","p3","v1","v2","asin","radDirection","drawDirection","halfAngle","lenOut","$9769dc3699a7c802$export$cf503f371c53af9e","pointLerp","numPoints","thisPoint","nextPoint","lastEdgeLength","lastOffsetDistance","nextEdgeLength","nextOffsetDistance","$ff733ce48c045e93$export$2cc2aaca18109aab","graphicsContext","div","innerHTML","querySelector","$ff733ce48c045e93$var$renderChildren","session","graphicsPath","f1","s1","$ff733ce48c045e93$var$parseStyle","useFill","useStroke","styleParts","stylePart","$ff733ce48c045e93$var$parseFloatAttribute","nodeName","pointsString","info","defaultValue","$ee0f76cca9221b48$export$816bdeacb94f608f","$gwwtL","$ktCpi","defaultStyle","fillStyleToParse","styleToMerge","temp","FillPattern","pattern","FillGradient","sourceStyle","$e3d5e55f90a865ef$export$8d075a36a73d54bc","$e3d5e55f90a865ef$var$_MeshGeometry","_MeshGeometry","shrinkBuffersToFit","$d33396e76d204642$export$a1f405faf7381142","$39gek","$d33396e76d204642$var$_NineSliceGeometry","_NineSliceGeometry","PlaneGeometry","verticesX","verticesY","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","updatePositions","scaleW","_uvw","_uvh","$049cc868daf00d34$export$967d831af31f69ce","$8jdbq","$049cc868daf00d34$var$_PlaneGeometry","_PlaneGeometry","MeshGeometry","sizeX","sizeY","totalSub","xpos","ypos","value3","value4","$3648baf7179c08cc$export$b12f6bdc825d944f","$fI0NC","$3648baf7179c08cc$var$contextSettings","willReadFrequently","$3648baf7179c08cc$var$_CanvasTextMetrics","_CanvasTextMetrics","experimentalLetterSpacingSupported","_experimentalLetterSpacingSupported","text","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","measureText","_canvas","wordWrap","textKey","styleKey","_measurementCache","font","fontStringFromTextStyle","measureFont","fontSize","ascent","__context","outputText","_wordWrap","lineWidth","_measureText","letterSpacing","_stroke","dropShadow","leading","useExperimentalLetterSpacing","experimentalLetterSpacing","textLetterSpacing","graphemeSegmenter","line","whiteSpace","collapseSpaces","_collapseSpaces","collapseNewlines","_collapseNewlines","canPrependSpaces","wordWrapWidth","tokens","_tokenize","token","_isNewline","_addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","_getFromCache","canBreakWords","breakWords","characters","wordWrapSplit","char","lastChar","nextChar","canBreakChars","characterWidth","isLastToken","newLine","_trimRight","_newlines","_nextChar","_breakingSpaces","_token","_char","_breakWords","_fonts","metrics","METRICS_STRING","BASELINE_SYMBOL","properties","actualBoundingBoxAscent","descent","actualBoundingBoxDescent","clearMetrics","__canvas","BASELINE_MULTIPLIER","HEIGHT_MULTIPLIER","Intl","Segmenter","segmenter","segment","$432516f32dcd2061$export$b7b5edb82ac3fc66","$432516f32dcd2061$var$genericFontFamilies","fontSizeString","fontFamilies","fontFamily","fontStyle","fontVariant","fontWeight","$d76c68b7f9f9bbea$export$1df879243bf2e42d","$6XitK","$d76c68b7f9f9bbea$var$_TextStyle","_TextStyle","$d76c68b7f9f9bbea$var$convertV7Tov8Style","oldStyle","defaults","defaultDropShadow","dropShadowAlpha","dropShadowAngle","blur","dropShadowBlur","dropShadowColor","dropShadowDistance","strokeThickness","gradientFill","fills","number","fillGradientStops","fullStyle","defaultTextStyle","align","_align","_dropShadow","_fontFamily","_fontSize","_fontStyle","_fontVariant","_fontWeight","_leading","_letterSpacing","_lineHeight","_padding","_trim","textBaseline","_textBaseline","_whiteSpace","_wordWrapWidth","_originalFill","_fill","_originalStroke","_generateKey","_styleKey","generateTextStyleKey","$9b4def45185a5f6c$export$8a3681e2b47964bb","$9b4def45185a5f6c$var$valuesToIterateForKeys","prop","$9b4def45185a5f6c$var$addFillStyleKey","SuppressedError","$3233927aa82734f9$var$t","$3233927aa82734f9$export$b4d10f6001c083c2","ShadowRoot","ShadyCSS","nativeShadow","Document","CSSStyleSheet","$3233927aa82734f9$var$s","Symbol","$3233927aa82734f9$var$o","WeakMap","$3233927aa82734f9$export$505d1e8739bad805","_$cssResult$","cssText","styleSheet","replaceSync","$3233927aa82734f9$export$8d80f9cac07cdb3","$3233927aa82734f9$export$dbf350e5966cf602","$3233927aa82734f9$export$2ca4a66ec4cecb90","adoptedStyleSheets","litNonce","setAttribute","textContent","appendChild","$3233927aa82734f9$export$ee69dfd951e24778","cssRules","is","$27fcf98b67c2a783$var$i","$27fcf98b67c2a783$var$e","$27fcf98b67c2a783$var$r","getOwnPropertyNames","$27fcf98b67c2a783$var$h","$27fcf98b67c2a783$var$o","getPrototypeOf","$27fcf98b67c2a783$var$n","$27fcf98b67c2a783$var$a","$27fcf98b67c2a783$var$c","trustedTypes","$27fcf98b67c2a783$var$l","emptyScript","$27fcf98b67c2a783$var$p","reactiveElementPolyfillSupport","$27fcf98b67c2a783$var$d","$27fcf98b67c2a783$export$7312b35fbf521afb","toAttribute","Boolean","fromAttribute","$27fcf98b67c2a783$export$53a6892c50694894","$27fcf98b67c2a783$var$y","String","converter","reflect","hasChanged","metadata","litPropertyMetadata","$27fcf98b67c2a783$export$c7c07a37856565d","HTMLElement","addInitializer","_$Ei","observedAttributes","finalize","_$Eh","createProperty","elementProperties","noAccessor","getPropertyDescriptor","requestUpdate","getPropertyOptions","finalized","_$Eu","elementStyles","finalizeStyles","styles","Set","_$Ep","isUpdatePending","hasUpdated","_$Em","_$Ev","_$ES","enableUpdating","_$AL","_$E_","addController","_$EO","renderRoot","isConnected","hostConnected","removeController","createRenderRoot","shadowRoot","attachShadow","shadowRootOptions","connectedCallback","disconnectedCallback","hostDisconnected","attributeChangedCallback","_$AK","_$EC","removeAttribute","P","_$ET","_$Ej","scheduleUpdate","performUpdate","wrapped","shouldUpdate","willUpdate","hostUpdate","_$EU","_$AE","hostUpdated","firstUpdated","updated","updateComplete","getUpdateComplete","mode","ReactiveElement","reactiveElementVersions","$e5ed8027d647799b$var$t","$e5ed8027d647799b$var$i","$e5ed8027d647799b$var$s","createPolicy","createHTML","$e5ed8027d647799b$var$e","$e5ed8027d647799b$var$h","random","toFixed","$e5ed8027d647799b$var$o","$e5ed8027d647799b$var$n","$e5ed8027d647799b$var$r","$e5ed8027d647799b$var$l","createComment","$e5ed8027d647799b$var$c","$e5ed8027d647799b$var$a","$e5ed8027d647799b$var$u","iterator","$e5ed8027d647799b$var$d","$e5ed8027d647799b$var$f","$e5ed8027d647799b$var$v","$e5ed8027d647799b$var$_","$e5ed8027d647799b$var$m","$e5ed8027d647799b$var$p","$e5ed8027d647799b$var$g","$e5ed8027d647799b$var$$","$e5ed8027d647799b$var$y","_$litType$","strings","$e5ed8027d647799b$export$c0bb0b647f701bb5","$e5ed8027d647799b$export$9c068ae9cc5db4e8","for","$e5ed8027d647799b$export$45b790e32b2810ee","$e5ed8027d647799b$var$A","$e5ed8027d647799b$var$E","createTreeWalker","$e5ed8027d647799b$var$C","$e5ed8027d647799b$var$P","$e5ed8027d647799b$var$V","parts","el","currentNode","content","firstChild","replaceWith","childNodes","nextNode","nodeType","hasAttributes","getAttributeNames","ctor","$e5ed8027d647799b$var$k","$e5ed8027d647799b$var$H","$e5ed8027d647799b$var$I","$e5ed8027d647799b$var$R","tagName","$e5ed8027d647799b$var$N","_$Co","_$Cl","_$litDirective$","_$AO","_$AT","_$AS","$e5ed8027d647799b$var$S","_$AV","_$AN","_$AD","_$AM","parentNode","_$AU","creationScope","importNode","$e5ed8027d647799b$var$M","nextSibling","$e5ed8027d647799b$var$L","_$AI","_$Cv","_$AH","_$AA","_$AB","startNode","endNode","_$AR","$","T","insertBefore","createTextNode","_$AC","_$AP","setConnected","toggleAttribute","capture","passive","handleEvent","host","$e5ed8027d647799b$var$Z","litHtmlPolyfillSupport","litHtmlVersions","$e5ed8027d647799b$export$b3890eb0ae9dca99","renderBefore","_$litPart$","$fe586ba0757c37f7$export$3f2f9f5909897157","renderOptions","_$Do","_$litElement$","litElementHydrateSupport","LitElement","$fe586ba0757c37f7$var$r","litElementPolyfillSupport","litElementVersions","$b2fdcbe153c88f81$var$o","$b2fdcbe153c88f81$export$8d623b1670eb40f4","kind","$b2fdcbe153c88f81$export$d541bacb2bda4494","$7162e77b40ffab5c$export$ca000e230c0caa3e","$38d513fd875e37ff$export$d7b50392f15c447d","outPoint","subtract","multiplyScalar","scalar","magnitude","magnitudeSquared","project","onto","normalizedScalarProjection","dotProduct","containsRect","intersection","outRect","union","$c220e1d99a2da004$export$a6aad6334ef58a1c","Environment","$a52ecd5a016ebe0a$export$ee43dd1acddf6cf8","self","WorkerGlobalScope","$326e7279631cea1a$var$environments","$326e7279631cea1a$export$72225172dd907279","manageImports","env","$3UUq4","$7cb4832c2de4c977$export$216169f30082c873","gpu","requestAdapter","requestDevice","$bf7ca24d384e2f55$var$renderPriority","$bf7ca24d384e2f55$export$3583b92ab8150eb6","RendererClass","finalOptions","rendererType","WebGPURenderer","webgpu","contextOptions","stencil","AbstractRenderer","success","getContextAttributes","WebGLRenderer","webgl","$2202931bfc9ee5c9$var$_Application","_Application","stage","_plugins","plugin","rendererDestroyOptions","plugins","Application","$2202931bfc9ee5c9$export$16975c34e60e1e61","$1adc37b2cea8de16$export$1949379a83b843d5","verbose","_loader","_assetList","_isLoading","_maxConcurrent","assetUrls","_isActive","_next","toLoad","toLoadAmount","active","$df4c0fb70a898168$export$407b4625a915919d","CacheParser","$36c6a70b0c6633f6$export$7c459e568e7cea2c","imageData","Image","onload","blob","createImageBitmap","$ca5df6e874c0bc98$export$a60d2d4a3c570783","DetectionParser","formats","$c65eb9bc0713cb5d$var$imageFormats","$c65eb9bc0713cb5d$export$b106d7c2de3b4d89","$2ba590fe27c747f9$var$inWorker","$2ba590fe27c747f9$export$7a571c147b03abb1","mimeType","canPlayType","$8c93018bb9bae76f$export$7726d83fee274e25","$dfa8be665f85221f$export$5a1da481121f806a","$64abecc9a39a8c54$export$a041d698a1896657","$c494cf4c5ea6913a$export$d19529a9ed9823d4","$be4c9d6031b69343$export$3b0d6d7590275603","_parsersValidated","Proxy","promiseCache","_getLoadPromiseAndParser","promise","_parserHash","parserX","parser2","assetsToLoadIn","onProgress","_validateParsers","assetsToLoad","assetsToUnloadIn","assetsToUnload","loadPromise","loadedAsset","hash","$d89e452ad91824ca$export$7ff8b059fb914323","mimes","mime","$8f487e3828a5ee92$export$fd0180357b95b812","$c569a63b2f914437$export$e7c8553478f3aac7","Low","response","json","$779da4c964b62347$export$3835b7ee6dbebde8","$0568dcd95d86dd78$var$validWeights","$0568dcd95d86dd78$var$validFontExtensions","$0568dcd95d86dd78$var$validFontMIMEs","$0568dcd95d86dd78$var$CSS_IDENT_TOKEN_REGEX","$0568dcd95d86dd78$var$validURICharactersRegex","$0568dcd95d86dd78$export$129ed93ad26b0298","fontFaces","family","$0568dcd95d86dd78$export$c461ca8f39d93d9b","nameTokens","nameWithSpaces","word","charAt","toUpperCase","valid","fontFamilyName","weights","weight","FontFace","encodeURI","$69836a01b04ce50b$export$8695ab2f322d2637","$703462f38e5d63e3$export$37b981a8c575f415","$258a91d856307e86$export$b6a2e78b63791dfa","parseAsGraphicsContext","$258a91d856307e86$var$loadAsGraphics","$258a91d856307e86$var$loadAsTexture","blobUrl","URL","createObjectURL","decode","revokeObjectURL","_p","svgSource","$9a21140edc3f77d8$var$WORKER_URL","$9a21140edc3f77d8$export$2e2bcd8739ae039","Blob","worker","Worker","$361d1ede8b4541ed$var$WORKER_URL","$361d1ede8b4541ed$export$2e2bcd8739ae039","$778464c1601fd395$var$UUID","$778464c1601fd395$export$bcff6015853c67ce","_createdWorkers","_workerPool","_resolveHash","isImageBitmapSupported","_isImageBitmapSupported","terminate","loadImageBitmap","_run","_initWorkers","_getWorker","hardwareConcurrency","_complete","_returnWorker","error","uuid","toDo","postMessage","$7390591d087b0cdb$var$validImageExtensions","$7390591d087b0cdb$var$validImageMIMEs","$7390591d087b0cdb$export$c614e6247302006d","ok","status","statusText","imageBlob","$7390591d087b0cdb$export$897b113ee8307cd0","High","preferWorkers","preferCreateImageBitmap","$170b999e73028fac$var$validVideoExtensions","$170b999e73028fac$var$validVideoMIMEs","$170b999e73028fac$export$68fa0976ba667d63","isValidDataUrl","isValidExtension","videoElement","attributeMap","$170b999e73028fac$export$292083da55c5b406","loc","parsedUrl","hostname","port","sourceElement","onCanPlay","loaded","cleanup","$f9f0a4a658d5e519$export$cc356fa83de02bea","ResolveParser","$7c85897abf6bc2d6$export$2b5cca0b89cb089c","$f4e4ce59fcdafcd2$export$c8eca95e306f7116","_detections","_backgroundLoader","defaultSearchParams","resolutionPref","texturePreference","_detectFormats","preferredFormats","skipDetections","detections","preferences","setPreferences","urls","urlArray","some","resolveResults","_mapLoadToResolve","loadBundle","_onProgress","resolveResult","resolveResult2","backgroundLoad","backgroundLoadBundle","resolveArray","loadedAssets","_unloadFromResolved","unloadBundle","detection","$f4e4ce59fcdafcd2$var$assetKeyMap","$3cebA","$hIpDK","$e9e4a9e44b3c9d74$var$_NineSliceSprite","_NineSliceSprite","NineSliceGeometry","_width","_height","$7e36113173fcb92e$export$daf74670712de91","styleClass","_didTextUpdate","_styleClass","_text","_getKey","owner","$wLFHs","$eKNW7","$dd84afd4ef9f1e09$export$5f1af8db9871e1d6","TextStyle","CanvasTextMetrics","$99105ae177c29e38$export$6ff07836956a79aa","app","delegate","week","lifetime","cumulativeMS","succeedOnTimeout","clock","Graphics","clockArc","$99105ae177c29e38$var$CLOCK_PADDING","attach","onTick","populateContainer","detach","square","eventMode","finishMinigame","passed","pendingPromises","onMinigameEnd","percentage","$99105ae177c29e38$var$CLOCK_RADIUS","$eada55855a105cab$export$75f80544f8184343","$64dbf4c474740b9a$var$__defProp","$64dbf4c474740b9a$var$__defNormalProp","writable","$64dbf4c474740b9a$var$__publicField","$64dbf4c474740b9a$export$c17561cb55d4db30","innerView","bg","fillPaddings","progress","setBackground","setFill","nineSliceSprite","fillPadding","offsetX","offsetY","fillMask","validate","_progress","progressStart","leftPadding","rightPadding","topPadding","bottomPadding","$6e1e16f555a84269$var$MINIGAME_ASSET_FILENAMES","$6e1e16f555a84269$var$getAssetPath","filename","$fa9ef9bbaee2fee2$var$POPUP_ASSETS","POPUP_1","POPUP_2","POPUP_3","POPUP_4","POPUP_5","$df2d689f8a3c506f$var$TrieNode","_isEndOfWord","_parent","isLeaf","getChar","setParent","getParent","setEndOfWord","isEndOfWord","childNode","getChild","hasChild","childrenCount","$bff485a8fc680118$var$Trie","_root","_wordsCount","_nodesCount","insert","cb","forEachRecursive","node","nodesCount","wordsCount","trie","$068f3b50daf3346f$export$248346f792cea416","keyDownListener","onKeyDown","$9b8bd60ae59c3c3c$var$ALL_WORDS","$a0a284949824ccdb$var$DIRT_ASSETS","BATH_DIRT_1","BATH_DIRT_2","BATH_DIRT_3","BATH_DIRT_4","$a0a284949824ccdb$var$DirtySpot","health","getObject","dirtAssetId","dirtAsset","spot","isPointerDown","movement","markCleaned","$ec1b68aa6a9802f7$export$39fab2494f708073","hitArea","URLSearchParams","search","$8b679de7a6842c56$var$stringifyPoint","$00fae121cfaa6e06$export$9847db861136c05a","assetAlias","additionalObjects","advanceMode","autoAdvanceMs","sprite","$00fae121cfaa6e06$export$e8e0592187a724b2","relativeBounds","drawBubble","borderWidth","bubble","$d435b25f36463079$var$getSpeech1","$d435b25f36463079$var$getSpeech2","$d435b25f36463079$var$getSpeech5","$d435b25f36463079$var$getSpeech6","$d435b25f36463079$var$getSpeech8","$aeb6aa7d4e276ee0$var$getSpeech1","$aeb6aa7d4e276ee0$var$getSpeech2","$aeb6aa7d4e276ee0$var$getSpeech4","$aeb6aa7d4e276ee0$var$getSpeech5","$a07f1723987cafba$var$getSpeech1","$a07f1723987cafba$var$getSpeech2","$a07f1723987cafba$var$getSpeech3","$a07f1723987cafba$var$getSpeech4","$fbd5350d83bd6d7d$var$INTERLUDE_ASSET_PATHS","intro1","intro2","intro3","intro4","intro5","intro6","intro7","intro8","intro9","intro10","intro11","intro12","intro13","intro14","intro15","beforeComp1","beforeComp2","beforeComp3","beforeComp4","beforeComp5","beforeComp6","beforeComp7","beforeComp8","afterComp1","afterComp2","afterComp3","$fbd5350d83bd6d7d$var$framesList","$fbd5350d83bd6d7d$export$6aceaa2aadf4b436","currentFrame","getFrames","showNextFrame","onInterludeEnd","remainingTime","$147878e7c7ba608b$export$a890a978955b9c6","cacheAssets","initialBackgroundAlias","initialBackgroundScale","chargeBar","drainRate","updateBackground","finishCheckpoint","changeBackgroundTexture","endContent","minigameComplete","chargeRate","bounce","peakScale","timeToFinishMs","bounceProgress","directionVector","CHECKPOINT_1_1","$0fc9e5698905dde8$export$7fa05bad4e631cc4","CHECKPOINT_1_2","CHECKPOINT_1_3","CHECKPOINT_1_4","ROOMBA","roomba","aspectRatio","$82075403d4ddd3bc$export$d155972b9bf563b2","CHECKPOINT_2_1","CHECKPOINT_2_2","CHECKPOINT_2_3","CHECKPOINT_2_4","CHECKPOINT_2_5","RABBIT","rabbit","destination","$1a642378d14820d1$export$f9f2f5e841ffbc58","CHECKPOINT_3_1","CHECKPOINT_3_2","CHECKPOINT_3_3","CHECKPOINT_3_4","CHECKPOINT_3_5","BAR","bar","$a93d756e0c61289b$var$MINIGAMES_POOL","phonescreenTexture","PHONE_SCREEN","phonescreen","getString","remainingWords","infiniteLoopPreventer","BALANCE_BG","balancingObject","BALANCE_C1","addRotForce","forceAmount","amount","currentForce","increment","appDimensions","onDragEnd","constructBackground","basket","constructBasket","onBasketDrop","security","constructSecurity","periodicallyToggleSecurity","allItems","randomItem","shoppingList","allPositions","periodicallyAddItems","onDragStart","dragTarget","dragListener","securityIsWatching","originalPosition","easeToPos","collectedItemPosition","collectedItemCount","shelves","remaining","onDragMove","getLocalPosition","timeUntilNextSecurityToggleMs","SECURITY_ON","SECURITY_OFF","timeUntilNextStockMs","currentlyOnShelf","requiredUnstockedItems","availablePositions","itemType","itemSprite","constructItem","SHOPPING_BACKGROUND","BASKET","boundsWidth","boundsHeight","$8b679de7a6842c56$var$getHitAreaForItem","relativePoint","startPos","endPos","timeToArriveMs","easeMap","scoreToPass","shakeAble","BLENDER","loadSprite","BLENDERFILL","progSprite","BLENDERPROG","prog","aspect","dragObject","onDrag","previousPos","vel","score","scoreText","countdown","waitFor","waitingForPress","cursor","bgAsset","BATH_BG_1","characterAssetId","BATH_MC_1","BATH_MC_2","BATH_MC_3","numSpots","characterAsset","mc","heightScale","characterSize","torsoRatio","dirtableSize","dirtableArea","remainingDirtySpots","pointerDown","addPopup","popupAssetId","spawnedPopups","velocityInfo","checkSquarePos","squarePos","popupsOnScreen","tickerCallbacks","handleSquarePhysics","handlePhysics","BLOG_POST_1","BLOG_POST_2","BLOG_POST_3","progressBar","LEARNING_PROGRESS_CONTAINER","PROGRESS_BAR","processPopups","learningTime","timeToNextPopup","goal","minTime","adjustedVel","dragTargetVelocity","$a93d756e0c61289b$export$bd0bf19f25da8474","completedMinigamePhases","minigameQueue","minigameLoseCount","intro","currentMinigame","startNextInterlude","populateMinigameQueue","startNextMinigame","minigame","interlude","_counter","_html5AudioPool","html5PoolSize","_codecs","_howls","_muted","_volume","_canPlayEvent","_navigator","masterGain","noAudio","usingWebAudio","autoSuspend","autoUnlock","_setup","volume","vol","gain","setValueAtTime","_webAudio","_getSoundIds","sound","_soundById","_node","mute","codecs","_autoSuspend","Audio","oncanplaythrough","_setupCodecs","audioTest","mpegTest","ua","userAgent","checkOpera","isOldOpera","checkSafari","safariVersion","isOldSafari","mp3","mpeg","opus","ogg","oga","wav","aac","caf","m4a","m4b","mp4","weba","webm","dolby","flac","_unlockAudio","_audioUnlocked","_mobileUnloaded","sampleRate","_scratchBuffer","createBuffer","unlock","audioNode","_unlocked","_releaseHtml5Audio","_autoResume","createBufferSource","noteOn","resume","onended","disconnect","_emit","_obtainHtml5Audio","testPlay","catch","audio","suspend","_sounds","_paused","_suspendTimer","handleSuspension","_resumeAfterSuspend","_autoplay","_format","_html5","html5","_loop","_preload","_rate","rate","_sprite","_src","_xhr","xhr","headers","withCredentials","_duration","_state","_endTimers","_playLock","_onend","onend","_onfade","onfade","_onload","_onloaderror","onloaderror","_onplayerror","onplayerror","_onpause","onpause","_onplay","onplay","_onstop","onstop","_onmute","onmute","_onvolume","onvolume","_onrate","onrate","_onseek","onseek","_onunlock","onunlock","_onresume","internal","_ended","_id","_inactiveSound","soundId","_loadQueue","seek","_seek","duration","timeout","setParams","_start","_stop","playWebAudio","_refreshBuffer","_playStart","bufferSource","noteGrainOn","_clearTimer","playHtml5","loadedNoReadyState","ejecta","isCocoonJS","_rateSeek","_stopFade","noteOff","_cleanBuffer","isNaN","_clearSound","_interval","fade","to","linearRampToValueAtTime","_startFadeInterval","isGroup","diff","lastTick","Date","_fadeTo","setInterval","clearInterval","cancelScheduledValues","loopStart","loopEnd","playing","seekAndEmit","emitSeek","realTime","rateSeek","sounds","_errorFn","_loadFn","_endFn","remCache","isId","msg","task","_drain","limit","cnt","_panner","isIOS","vendor","howl","createGain","createGainNode","_errorListener","_loadListener","_endListener","__default","atob","dataView","XMLHttpRequest","open","responseType","setRequestHeader","send","arraybuffer","AudioContext","webkitAudioContext","iOS","platform","appVersion","safari","define","amd","Howler","Howl","HowlerGlobal","Sound","_pos","_orientation","stereo","pan","positionX","setTargetAtTime","positionY","positionZ","setPosition","xUp","yUp","zUp","or","forwardX","forwardY","forwardZ","upX","upY","upZ","setOrientation","_stereo","_pannerAttr","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","panningModel","refDistance","rolloffFactor","_onstereo","onstereo","_onpos","onpos","_onorientation","onorientation","pannerType","createStereoPanner","orientationX","orientationY","orientationZ","pannerAttr","_coneInnerAngle","_coneOuterAngle","_coneOuterGain","_distanceModel","_maxDistance","_refDistance","_rolloffFactor","_panningModel","pa","panner","createPanner","$f761722007ed7192$export$5564cffdff00d859","tracks","allTracks","playTitleScreenMusic","$e46db5192eb49d53$export$119d2a93e2780362","audioController","controller","screenHeight","documentElement","clientHeight","screenWidth","clientWidth","constrainByWidth","devicePixelRatio","body","$f2a3353d7c2e5cc3$export$4e08dcf990b776c0","loadState","renderLoadingScreen","renderLoadedScreen","settingsOpen","renderSettings","startGame","playHovered","settingsHovered","launch","customElements","STENCIL_MODES","global","emptyStringForBooleanAttribute","polyfillSupport","JSCompiler_renameProperty","_obj","defaultConverter","fromValue","notEqual","old","defaultPropertyDeclaration","initializer","this","__prepare","_initializers","__attributeToPropertyMap","oldValue","superCtor","props","propKeys","attr","__attributeNameForProperty","getCompatibleStyle","super","__instanceProperties","__reflectingProperty","__initialize","__updatePromise","_$changedProperties","__saveInstanceProperties","__controllers","instanceProperties","adoptStyles","_requestedUpdate","_old","_$attributeToProperty","__propertyToAttribute","attrValue","propName","_$changeProperty","__enqueueUpdate","__reflectingProperties","changedProperties","__markUpdated","_$didUpdate","_changedProperties","supportsAdoptingStyleSheets","constructionToken","cssTagCache","CSSResult","safeToken","_strings","_styleSheet","cacheable","unsafeCSS","css","idx","textFromCSSResult","nonce","sheet","rule","cssResultFromStyleSheet","policy","boundAttributeSuffix","marker","markerMatch","nodeMarker","createMarker","isPrimitive","isIterable","SPACE_CHAR","textEndRegex","commentEndRegex","comment2EndRegex","tagEndRegex","singleQuoteAttrEndRegex","doubleQuoteAttrEndRegex","rawTextElement","tag","html","noChange","nothing","templateCache","walker","trustFromTemplateString","tsa","stringFromTSA","getTemplateHtml","attrNames","rawTextEndRegex","regex","attrName","attrNameEndIndex","Template","nodeIndex","attrNameIndex","partCount","svgElement","realName","statics","PropertyPart","BooleanAttributePart","EventPart","AttributePart","_options","resolveDirective","part","attributeIndex","currentDirective","__directives","__directive","nextDirectiveConstructor","_$initialize","_$resolve","TemplateInstance","template","_$parts","_$disconnectableChildren","_$template","_$parent","_$isConnected","_clone","fragment","partIndex","templatePart","ChildPart","ElementPart","_update","_$setValue","__isConnected","_$committedValue","_$startNode","_$endNode","directiveParent","_$clear","_commitText","_commitTemplateResult","_commitNode","_commitIterable","_insert","_$getTemplate","instance","itemParts","itemPart","_$notifyConnectionChanged","valueIndex","noCommit","change","_commitValue","newListener","oldListener","shouldRemoveListener","shouldAddListener","_$LH","_boundAttributeSuffix","_marker","_markerMatch","_HTML_RESULT","_getTemplateHtml","_TemplateInstance","_isIterable","_resolveDirective","_ChildPart","_AttributePart","_BooleanAttributePart","_EventPart","_PropertyPart","_ElementPart","partOwnerNode","__childPart","_$LE","isServer","customElement","classOrTarget","standardProperty","property","protoOrTarget","nameOrContext","legacyProperty","eventOptions","protoOrValue","query","selector","doQuery","queryAll","createDocumentFragment","querySelectorAll","queryAsync","queryAssignedElements","slot","slotSelector","slotEl","assignedElements","matches","queryAssignedNodes","assignedNodes","CheckImageBitmapWorker","LoadImageBitmapWorker","PixiNineSliceSprite"],"version":3,"file":"index.60475b3b.js.map"}