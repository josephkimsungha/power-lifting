{"mappings":"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","sources":["<anon>","node_modules/pixi.js/lib/app/init.mjs","node_modules/pixi.js/src/app/init.ts","node_modules/pixi.js/lib/app/ResizePlugin.mjs","node_modules/pixi.js/src/app/ResizePlugin.ts","node_modules/pixi.js/lib/app/TickerPlugin.mjs","node_modules/pixi.js/src/app/TickerPlugin.ts","node_modules/pixi.js/lib/scene/graphics/init.mjs","node_modules/pixi.js/src/scene/graphics/init.ts","node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs","node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","node_modules/pixi.js/lib/scene/mesh/init.mjs","node_modules/pixi.js/src/scene/mesh/init.ts","node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs","node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs","node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","node_modules/pixi.js/lib/scene/text/init.mjs","node_modules/pixi.js/src/scene/text/init.ts","node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs","node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs","node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs","node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts","node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs","node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts","node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs","node_modules/pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts","node_modules/pixi.js/lib/scene/text-bitmap/init.mjs","node_modules/pixi.js/src/scene/text-bitmap/init.ts","node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs","node_modules/pixi.js/src/scene/text-bitmap/asset/loadBitmapFont.ts","node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs","node_modules/pixi.js/src/scene/text-bitmap/BitmapFont.ts","node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs","node_modules/pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts","node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs","node_modules/pixi.js/src/scene/text-bitmap/BitmapFontManager.ts","node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs","node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts","node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs","node_modules/pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts","node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs","node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts","node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs","node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontTextParser.ts","node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs","node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLStringParser.ts","node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs","node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLParser.ts","node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs","node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs","node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs","node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs","node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","node_modules/pixi.js/lib/scene/text-html/init.mjs","node_modules/pixi.js/src/scene/text-html/init.ts","node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs","node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs","node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","node_modules/pixi.js/lib/utils/browser/isSafari.mjs","node_modules/pixi.js/src/utils/browser/isSafari.ts","node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs","node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs","node_modules/pixi.js/src/scene/text-html/HtmlTextStyle.ts","node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs","node_modules/pixi.js/src/scene/text-html/utils/textStyleToCSS.ts","node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs","node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs","node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs","node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs","node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs","node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs","node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs","node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs","node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs","node_modules/pixi.js/src/scene/sprite-tiling/init.ts","node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs","node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs","node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs","node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs","node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs","node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs","node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs","node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs","node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs","node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","node_modules/pixi.js/lib/filters/init.mjs","node_modules/pixi.js/src/filters/init.ts","node_modules/pixi.js/lib/filters/FilterPipe.mjs","node_modules/pixi.js/src/filters/FilterPipe.ts","node_modules/pixi.js/lib/filters/FilterSystem.mjs","node_modules/pixi.js/src/filters/FilterSystem.ts","node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs","node_modules/pixi.js/src/scene/container/bounds/getFastGlobalBounds.ts","node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs","node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire718f\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"xtmW0\", function(module, exports) {\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $39o25 = parcelRequire(\"39o25\");\n\nvar $8V0wO = parcelRequire(\"8V0wO\");\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $39o25.ResizePlugin));\n(0, $i9BKe.extensions).add((0, $8V0wO.TickerPlugin));\n\n});\nparcelRegister(\"39o25\", function(module, exports) {\n\n$parcel$export(module.exports, \"ResizePlugin\", () => $ea1a06b152e6d4d8$export$6453cd852defe94a);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\nclass $ea1a06b152e6d4d8$export$6453cd852defe94a {\n    /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */ static init(options) {\n        Object.defineProperty(this, \"resizeTo\", /**\n       * The HTML element or window to automatically resize the\n       * renderer's view element to match width and height.\n       * @member {Window|HTMLElement}\n       * @name resizeTo\n       * @memberof app.Application#\n       */ {\n            set (dom) {\n                globalThis.removeEventListener(\"resize\", this.queueResize);\n                this._resizeTo = dom;\n                if (dom) {\n                    globalThis.addEventListener(\"resize\", this.queueResize);\n                    this.resize();\n                }\n            },\n            get () {\n                return this._resizeTo;\n            }\n        });\n        this.queueResize = ()=>{\n            if (!this._resizeTo) return;\n            this._cancelResize();\n            this._resizeId = requestAnimationFrame(()=>this.resize());\n        };\n        this._cancelResize = ()=>{\n            if (this._resizeId) {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n        this.resize = ()=>{\n            if (!this._resizeTo) return;\n            this._cancelResize();\n            let width;\n            let height;\n            if (this._resizeTo === globalThis.window) {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            } else {\n                const { clientWidth: clientWidth, clientHeight: clientHeight } = this._resizeTo;\n                width = clientWidth;\n                height = clientHeight;\n            }\n            this.renderer.resize(width, height);\n            this.render();\n        };\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n    /**\n   * Clean up the ticker, scoped to application\n   * @static\n   * @private\n   */ static destroy() {\n        globalThis.removeEventListener(\"resize\", this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n/** @ignore */ $ea1a06b152e6d4d8$export$6453cd852defe94a.extension = (0, $i9BKe.ExtensionType).Application;\n\n});\n\nparcelRegister(\"8V0wO\", function(module, exports) {\n\n$parcel$export(module.exports, \"TickerPlugin\", () => $63bd109872b60747$export$50c361ceb4e2f4f0);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $cQMLP = parcelRequire(\"cQMLP\");\n\nvar $4J7WL = parcelRequire(\"4J7WL\");\n\"use strict\";\nclass $63bd109872b60747$export$50c361ceb4e2f4f0 {\n    /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */ static init(options) {\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false\n        }, options);\n        Object.defineProperty(this, \"ticker\", {\n            set (ticker) {\n                if (this._ticker) this._ticker.remove(this.render, this);\n                this._ticker = ticker;\n                if (ticker) ticker.add(this.render, this, (0, $cQMLP.UPDATE_PRIORITY).LOW);\n            },\n            get () {\n                return this._ticker;\n            }\n        });\n        this.stop = ()=>{\n            this._ticker.stop();\n        };\n        this.start = ()=>{\n            this._ticker.start();\n        };\n        this._ticker = null;\n        this.ticker = options.sharedTicker ? (0, $4J7WL.Ticker).shared : new (0, $4J7WL.Ticker)();\n        if (options.autoStart) this.start();\n    }\n    /**\n   * Clean up the ticker, scoped to application.\n   * @static\n   * @private\n   */ static destroy() {\n        if (this._ticker) {\n            const oldTicker = this._ticker;\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n/** @ignore */ $63bd109872b60747$export$50c361ceb4e2f4f0.extension = (0, $i9BKe.ExtensionType).Application;\n\n});\n\n\nparcelRegister(\"bqs0D\", function(module, exports) {\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $hFzkv = parcelRequire(\"hFzkv\");\n\nvar $3Ey0f = parcelRequire(\"3Ey0f\");\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $3Ey0f.GraphicsPipe));\n(0, $i9BKe.extensions).add((0, $hFzkv.GraphicsContextSystem));\n\n});\nparcelRegister(\"3Ey0f\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsPipe\", () => $41b59a27ea0e0c59$export$56171ef5563dc803);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $2Aebl = parcelRequire(\"2Aebl\");\n\nvar $61KiY = parcelRequire(\"61KiY\");\n\nvar $6B0gZ = parcelRequire(\"6B0gZ\");\n\nvar $xZ5a3 = parcelRequire(\"xZ5a3\");\n\"use strict\";\nclass $41b59a27ea0e0c59$export$56171ef5563dc803 {\n    constructor(renderer, adaptor){\n        this.state = (0, $2Aebl.State).for2d();\n        // batchable graphics list, used to render batches\n        this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n    validateRenderable(graphics) {\n        const context = graphics.context;\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) return true;\n        return false;\n    }\n    addRenderable(graphics, instructionSet) {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n        if (graphics._didGraphicsUpdate) {\n            graphics._didGraphicsUpdate = false;\n            this._rebuild(graphics);\n        }\n        if (gpuContext.isBatchable) this._addToBatcher(graphics, instructionSet);\n        else {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n    updateRenderable(graphics) {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n        if (batches) for(let i = 0; i < batches.length; i++){\n            const batch = batches[i];\n            batch.batcher.updateElement(batch);\n        }\n    }\n    destroyRenderable(graphics) {\n        if (this._graphicsBatchesHash[graphics.uid]) this._removeBatchForRenderable(graphics.uid);\n    }\n    execute(graphics) {\n        if (!graphics.isRenderable) return;\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n        if (!contextSystem.getGpuContext(context).batches.length) return;\n        const shader = context.customShader || this._adaptor.shader;\n        this.state.blendMode = graphics.groupBlendMode;\n        const localUniforms = shader.resources.localUniforms.uniforms;\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n        (0, $6B0gZ.color32BitToUniform)(graphics.groupColorAlpha, localUniforms.uColor, 0);\n        this._adaptor.execute(this, graphics);\n    }\n    _rebuild(graphics) {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n        if (wasBatched) this._removeBatchForRenderable(graphics.uid);\n        if (gpuContext.isBatchable) this._initBatchesForRenderable(graphics);\n        graphics.batched = gpuContext.isBatchable;\n    }\n    _addToBatcher(graphics, instructionSet) {\n        const batchPipe = this.renderer.renderPipes.batch;\n        const batches = this._getBatchesForRenderable(graphics);\n        for(let i = 0; i < batches.length; i++){\n            const batch = batches[i];\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n    _getBatchesForRenderable(graphics) {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n    _initBatchesForRenderable(graphics) {\n        const context = graphics.context;\n        const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n        const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n        const batches = gpuContext.batches.map((batch)=>{\n            const batchClone = (0, $61KiY.BigPool).get((0, $xZ5a3.BatchableGraphics));\n            batch.copyTo(batchClone);\n            batchClone.renderable = graphics;\n            batchClone.roundPixels = roundPixels;\n            return batchClone;\n        });\n        this._graphicsBatchesHash[graphics.uid] = batches;\n        graphics.on(\"destroyed\", ()=>{\n            this.destroyRenderable(graphics);\n        });\n        return batches;\n    }\n    _removeBatchForRenderable(graphicsUid) {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch)=>{\n            (0, $61KiY.BigPool).return(batch);\n        });\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n    destroy() {\n        this.renderer = null;\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n        for(const i in this._graphicsBatchesHash)this._removeBatchForRenderable(i);\n        this._graphicsBatchesHash = null;\n    }\n}\n/** @ignore */ $41b59a27ea0e0c59$export$56171ef5563dc803.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLPipes,\n        (0, $i9BKe.ExtensionType).WebGPUPipes,\n        (0, $i9BKe.ExtensionType).CanvasPipes\n    ],\n    name: \"graphics\"\n};\n\n});\n\n\nparcelRegister(\"7rvGX\", function(module, exports) {\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $6RHrb = parcelRequire(\"6RHrb\");\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $6RHrb.MeshPipe));\n\n});\nparcelRegister(\"6RHrb\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshPipe\", () => $b76d26320e7f1ae7$export$ec121977b4273ffd);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $awcfo = parcelRequire(\"awcfo\");\n\nvar $cryyq = parcelRequire(\"cryyq\");\n\nvar $61KiY = parcelRequire(\"61KiY\");\n\nvar $6B0gZ = parcelRequire(\"6B0gZ\");\n\nvar $72TA5 = parcelRequire(\"72TA5\");\n\"use strict\";\nclass $b76d26320e7f1ae7$export$ec121977b4273ffd {\n    constructor(renderer, adaptor){\n        this.localUniforms = new (0, $cryyq.UniformGroup)({\n            uTransformMatrix: {\n                value: new (0, $eY4rt.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uColor: {\n                value: new Float32Array([\n                    1,\n                    1,\n                    1,\n                    1\n                ]),\n                type: \"vec4<f32>\"\n            },\n            uRound: {\n                value: 0,\n                type: \"f32\"\n            }\n        });\n        this.localUniformsBindGroup = new (0, $awcfo.BindGroup)({\n            0: this.localUniforms\n        });\n        this._meshDataHash = /* @__PURE__ */ Object.create(null);\n        this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n    validateRenderable(mesh) {\n        const meshData = this._getMeshData(mesh);\n        const wasBatched = meshData.batched;\n        const isBatched = mesh.batched;\n        meshData.batched = isBatched;\n        if (wasBatched !== isBatched) return true;\n        else if (isBatched) {\n            const geometry = mesh._geometry;\n            if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n                return true;\n            }\n            const batchableMesh = this._getBatchableMesh(mesh);\n            const texture = mesh.texture;\n            if (batchableMesh.texture._source !== texture._source) {\n                if (batchableMesh.texture._source !== texture._source) return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n            }\n        }\n        return false;\n    }\n    addRenderable(mesh, instructionSet) {\n        const batcher = this.renderer.renderPipes.batch;\n        const { batched: batched } = this._getMeshData(mesh);\n        if (batched) {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n            batcher.addToBatch(gpuBatchableMesh);\n        } else {\n            batcher.break(instructionSet);\n            instructionSet.add({\n                renderPipeId: \"mesh\",\n                mesh: mesh\n            });\n        }\n    }\n    updateRenderable(mesh) {\n        if (mesh.batched) {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n    destroyRenderable(mesh) {\n        this._meshDataHash[mesh.uid] = null;\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n        if (gpuMesh) {\n            (0, $61KiY.BigPool).return(gpuMesh);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n    }\n    execute({ mesh: mesh }) {\n        if (!mesh.isRenderable) return;\n        mesh.state.blendMode = mesh.groupBlendMode;\n        const localUniforms = this.localUniforms;\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n        (0, $6B0gZ.color32BitToUniform)(mesh.groupColorAlpha, localUniforms.uniforms.uColor, 0);\n        this._adaptor.execute(this, mesh);\n    }\n    _getMeshData(mesh) {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n    _initMeshData(mesh) {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length\n        };\n        mesh.on(\"destroyed\", ()=>{\n            this.destroyRenderable(mesh);\n        });\n        return this._meshDataHash[mesh.uid];\n    }\n    _getBatchableMesh(mesh) {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n    _initBatchableMesh(mesh) {\n        const gpuMesh = (0, $61KiY.BigPool).get((0, $72TA5.BatchableMesh));\n        gpuMesh.mesh = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n        gpuMesh.mesh = mesh;\n        return gpuMesh;\n    }\n    destroy() {\n        for(const i in this._gpuBatchableMeshHash)if (this._gpuBatchableMeshHash[i]) (0, $61KiY.BigPool).return(this._gpuBatchableMeshHash[i]);\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.renderer = null;\n    }\n}\n/** @ignore */ $b76d26320e7f1ae7$export$ec121977b4273ffd.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLPipes,\n        (0, $i9BKe.ExtensionType).WebGPUPipes,\n        (0, $i9BKe.ExtensionType).CanvasPipes\n    ],\n    name: \"mesh\"\n};\n\n});\nparcelRegister(\"72TA5\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableMesh\", () => $67b85de4aa7ff7ce$export$2fa0f0ec877329e3);\n\"use strict\";\nclass $67b85de4aa7ff7ce$export$2fa0f0ec877329e3 {\n    constructor(){\n        this.batcher = null;\n        this.batch = null;\n        this.roundPixels = 0;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n    get blendMode() {\n        return this.mesh.groupBlendMode;\n    }\n    reset() {\n        this.mesh = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n    }\n    packIndex(indexBuffer, index, indicesOffset) {\n        const indices = this.geometry.indices;\n        for(let i = 0; i < indices.length; i++)indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n    packAttributes(float32View, uint32View, index, textureId) {\n        const mesh = this.mesh;\n        const geometry = this.geometry;\n        const wt = mesh.groupTransform;\n        const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n        const positions = geometry.positions;\n        const uvBuffer = geometry.getBuffer(\"aUV\");\n        const uvs = uvBuffer.data;\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n        if (!textureMatrix.isSimple) {\n            transformedUvs = this._transformedUvs;\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n                if (!transformedUvs || transformedUvs.length < uvs.length) transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n                textureMatrix.multiplyUvs(uvs, transformedUvs);\n            }\n        }\n        const abgr = mesh.groupColorAlpha;\n        for(let i = 0; i < positions.length; i += 2){\n            const x = positions[i];\n            const y = positions[i + 1];\n            float32View[index] = a * x + c * y + tx;\n            float32View[index + 1] = b * x + d * y + ty;\n            float32View[index + 2] = transformedUvs[i];\n            float32View[index + 3] = transformedUvs[i + 1];\n            uint32View[index + 4] = abgr;\n            uint32View[index + 5] = textureIdAndRound;\n            index += 6;\n        }\n    }\n    get vertexSize() {\n        return this.geometry.positions.length / 2;\n    }\n    get indexSize() {\n        return this.geometry.indices.length;\n    }\n}\n\n});\n\n\n\nparcelRegister(\"72HgH\", function(module, exports) {\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $5uDRx = parcelRequire(\"5uDRx\");\n\nvar $3O6SX = parcelRequire(\"3O6SX\");\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $3O6SX.CanvasTextSystem));\n(0, $i9BKe.extensions).add((0, $5uDRx.CanvasTextPipe));\n\n});\nparcelRegister(\"5uDRx\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasTextPipe\", () => $c066d8737bdb07a6$export$ed0d779e44b53050);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $f8J9J = parcelRequire(\"f8J9J\");\n\nvar $61KiY = parcelRequire(\"61KiY\");\n\nvar $6qNFd = parcelRequire(\"6qNFd\");\n\"use strict\";\nclass $c066d8737bdb07a6$export$ed0d779e44b53050 {\n    constructor(renderer){\n        this._gpuText = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    validateRenderable(text) {\n        const gpuText = this._getGpuText(text);\n        const newKey = text._getKey();\n        if (gpuText.currentKey !== newKey) {\n            const resolution = text.resolution ?? this._renderer.resolution;\n            const { width: width, height: height } = this._renderer.canvasText.getTextureSize(text.text, resolution, text._style);\n            if (// is only being used by this text:\n            this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height) return false;\n            return true;\n        }\n        return false;\n    }\n    addRenderable(text, _instructionSet) {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n        if (text._didTextUpdate) this._updateText(text);\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n    updateRenderable(text) {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n        if (text._didTextUpdate) this._updateText(text);\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n    destroyRenderable(text) {\n        this._destroyRenderableById(text.uid);\n    }\n    _destroyRenderableById(textUid) {\n        const gpuText = this._gpuText[textUid];\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        (0, $61KiY.BigPool).return(gpuText.batchableSprite);\n        this._gpuText[textUid] = null;\n    }\n    _updateText(text) {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n        if (gpuText.currentKey !== newKey) this._updateGpuText(text);\n        text._didTextUpdate = false;\n        const padding = text._style.padding;\n        (0, $f8J9J.updateQuadBounds)(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n    _updateGpuText(text) {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n        if (gpuText.texture) this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        const resolution = text.resolution ?? this._renderer.resolution;\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(text.text, resolution, text._style, text._getKey());\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n    _getGpuText(text) {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n    initGpuText(text) {\n        const gpuTextData = {\n            texture: null,\n            currentKey: \"--\",\n            batchableSprite: (0, $61KiY.BigPool).get((0, $6qNFd.BatchableSprite))\n        };\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.bounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;\n        this._gpuText[text.uid] = gpuTextData;\n        this._updateText(text);\n        text.on(\"destroyed\", ()=>{\n            this.destroyRenderable(text);\n        });\n        return gpuTextData;\n    }\n    destroy() {\n        for(const i in this._gpuText)this._destroyRenderableById(i);\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $c066d8737bdb07a6$export$ed0d779e44b53050.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLPipes,\n        (0, $i9BKe.ExtensionType).WebGPUPipes,\n        (0, $i9BKe.ExtensionType).CanvasPipes\n    ],\n    name: \"text\"\n};\n\n});\n\nparcelRegister(\"3O6SX\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasTextSystem\", () => $78c42d114b108bc4$export$56e4907c2e518abc);\n\nvar $a2eTA = parcelRequire(\"a2eTA\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $NbSCN = parcelRequire(\"NbSCN\");\n\nvar $6RGCN = parcelRequire(\"6RGCN\");\n\nvar $3Xbp7 = parcelRequire(\"3Xbp7\");\n\nvar $ha93z = parcelRequire(\"ha93z\");\n\nvar $l7b1V = parcelRequire(\"l7b1V\");\n\nvar $wLFHs = parcelRequire(\"wLFHs\");\n\nvar $fI0NC = parcelRequire(\"fI0NC\");\n\nvar $4JkiF = parcelRequire(\"4JkiF\");\n\"use strict\";\nclass $78c42d114b108bc4$export$56e4907c2e518abc {\n    constructor(){\n        this._activeTextures = {};\n    }\n    getTextureSize(text, resolution, style) {\n        const measured = (0, $wLFHs.CanvasTextMetrics).measureText(text || \" \", style);\n        let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n        let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n        width = Math.ceil(width - 1e-6);\n        height = Math.ceil(height - 1e-6);\n        width = (0, $NbSCN.nextPow2)(width);\n        height = (0, $NbSCN.nextPow2)(height);\n        return {\n            width: width,\n            height: height\n        };\n    }\n    getTexture(text, resolution, style, textKey) {\n        if (this._activeTextures[textKey]) {\n            this._increaseReferenceCount(textKey);\n            return this._activeTextures[textKey].texture;\n        }\n        const measured = (0, $wLFHs.CanvasTextMetrics).measureText(text || \" \", style);\n        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n        const canvasAndContext = (0, $6RGCN.CanvasPool).getOptimalCanvasAndContext(width, height);\n        const { canvas: canvas } = canvasAndContext;\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n        const texture = (0, $l7b1V.getPo2TextureFromSource)(canvas, width, height, resolution);\n        if (style.trim) {\n            const trimmed = (0, $ha93z.getCanvasBoundingBox)(canvas, resolution);\n            texture.frame.copyFrom(trimmed);\n            texture.updateUvs();\n        }\n        this._activeTextures[textKey] = {\n            canvasAndContext: canvasAndContext,\n            texture: texture,\n            usageCount: 1\n        };\n        return texture;\n    }\n    _increaseReferenceCount(textKey) {\n        this._activeTextures[textKey].usageCount++;\n    }\n    decreaseReferenceCount(textKey) {\n        const activeTexture = this._activeTextures[textKey];\n        activeTexture.usageCount--;\n        if (activeTexture.usageCount === 0) {\n            (0, $6RGCN.CanvasPool).returnCanvasAndContext(activeTexture.canvasAndContext);\n            (0, $3Xbp7.TexturePool).returnTexture(activeTexture.texture);\n            const source = activeTexture.texture.source;\n            source.resource = null;\n            source.uploadMethodId = \"unknown\";\n            source.alphaMode = \"no-premultiply-alpha\";\n            this._activeTextures[textKey] = null;\n        }\n    }\n    getReferenceCount(textKey) {\n        return this._activeTextures[textKey].usageCount;\n    }\n    /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */ renderTextToCanvas(text, style, resolution, canvasAndContext) {\n        const { canvas: canvas, context: context } = canvasAndContext;\n        const font = (0, $fI0NC.fontStringFromTextStyle)(style);\n        const measured = (0, $wLFHs.CanvasTextMetrics).measureText(text || \" \", style);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n        const height = canvas.height;\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.clearRect(0, 0, measured.width + 4, measured.height + 4);\n        if (style._stroke?.width) {\n            const strokeStyle = style._stroke;\n            context.lineWidth = strokeStyle.width;\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n        context.font = font;\n        let linePositionX;\n        let linePositionY;\n        const passesCount = style.dropShadow ? 2 : 1;\n        for(let i = 0; i < passesCount; ++i){\n            const isShadowPass = style.dropShadow && i === 0;\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n            if (isShadowPass) {\n                context.fillStyle = \"black\";\n                context.strokeStyle = \"black\";\n                const shadowOptions = style.dropShadow;\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n                context.shadowColor = (0, $a2eTA.Color).shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n            } else {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? (0, $4JkiF.getCanvasFillStyle)(style._fill, context) : null;\n                if (style._stroke?.width) context.strokeStyle = (0, $4JkiF.getCanvasFillStyle)(style._stroke, context);\n                context.shadowColor = \"black\";\n            }\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n            if (lineHeight - fontProperties.fontSize < 0) linePositionYShift = 0;\n            const strokeWidth = style._stroke?.width ?? 0;\n            for(let i2 = 0; i2 < lines.length; i2++){\n                linePositionX = strokeWidth / 2;\n                linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n                if (style.align === \"right\") linePositionX += maxLineWidth - lineWidths[i2];\n                else if (style.align === \"center\") linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n                if (style._stroke) this._drawLetterSpacing(lines[i2], style, canvasAndContext, linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);\n                if (style._fill !== void 0) this._drawLetterSpacing(lines[i2], style, canvasAndContext, linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);\n            }\n        }\n    }\n    /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it's for the inside fill\n   */ _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n        const { context: context } = canvasAndContext;\n        const letterSpacing = style.letterSpacing;\n        let useExperimentalLetterSpacing = false;\n        if ((0, $wLFHs.CanvasTextMetrics).experimentalLetterSpacingSupported) {\n            if ((0, $wLFHs.CanvasTextMetrics).experimentalLetterSpacing) {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            } else {\n                context.letterSpacing = \"0px\";\n                context.textLetterSpacing = \"0px\";\n            }\n        }\n        if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n            if (isStroke) context.strokeText(text, x, y);\n            else context.fillText(text, x, y);\n            return;\n        }\n        let currentPosition = x;\n        const stringArray = (0, $wLFHs.CanvasTextMetrics).graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n        for(let i = 0; i < stringArray.length; ++i){\n            const currentChar = stringArray[i];\n            if (isStroke) context.strokeText(currentChar, currentPosition, y);\n            else context.fillText(currentChar, currentPosition, y);\n            let textStr = \"\";\n            for(let j = i + 1; j < stringArray.length; ++j)textStr += stringArray[j];\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n    destroy() {\n        this._activeTextures = null;\n    }\n}\n/** @ignore */ $78c42d114b108bc4$export$56e4907c2e518abc.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem,\n        (0, $i9BKe.ExtensionType).WebGPUSystem,\n        (0, $i9BKe.ExtensionType).CanvasSystem\n    ],\n    name: \"canvasText\"\n};\n\n});\nparcelRegister(\"ha93z\", function(module, exports) {\n\n$parcel$export(module.exports, \"getCanvasBoundingBox\", () => $c7f22f786b0aa888$export$550eedf6c679837d);\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\"use strict\";\nfunction $c7f22f786b0aa888$var$checkRow(data, width, y) {\n    for(let x = 0, index = 4 * y * width; x < width; ++x, index += 4){\n        if (data[index + 3] !== 0) return false;\n    }\n    return true;\n}\nfunction $c7f22f786b0aa888$var$checkColumn(data, width, x, top, bottom) {\n    const stride = 4 * width;\n    for(let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride){\n        if (data[index + 3] !== 0) return false;\n    }\n    return true;\n}\nfunction $c7f22f786b0aa888$export$550eedf6c679837d(canvas, resolution = 1) {\n    const { width: width, height: height } = canvas;\n    const context = canvas.getContext(\"2d\", {\n        willReadFrequently: true\n    });\n    if (context === null) throw new TypeError(\"Failed to get canvas 2D context\");\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n    while(top < height && $c7f22f786b0aa888$var$checkRow(data, width, top))++top;\n    if (top === height) return (0, $fM4Mk.Rectangle).EMPTY;\n    while($c7f22f786b0aa888$var$checkRow(data, width, bottom))--bottom;\n    while($c7f22f786b0aa888$var$checkColumn(data, width, left, top, bottom))++left;\n    while($c7f22f786b0aa888$var$checkColumn(data, width, right, top, bottom))--right;\n    ++right;\n    ++bottom;\n    return new (0, $fM4Mk.Rectangle)(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n\n});\n\nparcelRegister(\"l7b1V\", function(module, exports) {\n\n$parcel$export(module.exports, \"getPo2TextureFromSource\", () => $eeb1e6506bb24c84$export$80c61c6b7fb407a3);\n\nvar $3Xbp7 = parcelRequire(\"3Xbp7\");\n\nvar $7wtv9 = parcelRequire(\"7wtv9\");\n\"use strict\";\nconst $eeb1e6506bb24c84$var$tempBounds = new (0, $7wtv9.Bounds)();\nfunction $eeb1e6506bb24c84$export$80c61c6b7fb407a3(image, width, height, resolution) {\n    const bounds = $eeb1e6506bb24c84$var$tempBounds;\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = image.width / resolution | 0;\n    bounds.maxY = image.height / resolution | 0;\n    const texture = (0, $3Xbp7.TexturePool).getOptimalTexture(bounds.width, bounds.height, resolution, false);\n    texture.source.uploadMethodId = \"image\";\n    texture.source.resource = image;\n    texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n    texture.source.emit(\"update\", texture.source);\n    texture.updateUvs();\n    return texture;\n}\n\n});\n\nparcelRegister(\"4JkiF\", function(module, exports) {\n\n$parcel$export(module.exports, \"getCanvasFillStyle\", () => $70d03c252755e3f8$export$c31af9427fa8602b);\n\nvar $a2eTA = parcelRequire(\"a2eTA\");\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $gwwtL = parcelRequire(\"gwwtL\");\n\nvar $ktCpi = parcelRequire(\"ktCpi\");\n\"use strict\";\nfunction $70d03c252755e3f8$export$c31af9427fa8602b(fillStyle, context) {\n    if (fillStyle.texture === (0, $bLlTJ.Texture).WHITE && !fillStyle.fill) return (0, $a2eTA.Color).shared.setValue(fillStyle.color).toHex();\n    else if (!fillStyle.fill) {\n        const pattern = context.createPattern(fillStyle.texture.source.resource, \"repeat\");\n        const tempMatrix = fillStyle.matrix.copyTo((0, $eY4rt.Matrix).shared);\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n        pattern.setTransform(tempMatrix);\n        return pattern;\n    } else if (fillStyle.fill instanceof (0, $ktCpi.FillPattern)) {\n        const fillPattern = fillStyle.fill;\n        const pattern = context.createPattern(fillPattern.texture.source.resource, \"repeat\");\n        const tempMatrix = fillPattern.transform.copyTo((0, $eY4rt.Matrix).shared);\n        tempMatrix.scale(fillPattern.texture.frame.width, fillPattern.texture.frame.height);\n        pattern.setTransform(tempMatrix);\n        return pattern;\n    } else if (fillStyle.fill instanceof (0, $gwwtL.FillGradient)) {\n        const fillGradient = fillStyle.fill;\n        if (fillGradient.type === \"linear\") {\n            const gradient = context.createLinearGradient(fillGradient.x0, fillGradient.y0, fillGradient.x1, fillGradient.y1);\n            fillGradient.gradientStops.forEach((stop)=>{\n                gradient.addColorStop(stop.offset, (0, $a2eTA.Color).shared.setValue(stop.color).toHex());\n            });\n            return gradient;\n        }\n    }\n    (0, $hUCK4.warn)(\"FillStyle not recognised\", fillStyle);\n    return \"red\";\n}\n\n});\n\n\n\nparcelRegister(\"gltHT\", function(module, exports) {\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $5ilA5 = parcelRequire(\"5ilA5\");\n\nvar $5FVru = parcelRequire(\"5FVru\");\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $5FVru.BitmapTextPipe), (0, $5ilA5.loadBitmapFont), (0, $5ilA5.bitmapFontCachePlugin));\n\n});\nparcelRegister(\"5ilA5\", function(module, exports) {\n\n$parcel$export(module.exports, \"bitmapFontCachePlugin\", () => $67f0360d0045775d$export$778a313228f06f6c);\n$parcel$export(module.exports, \"loadBitmapFont\", () => $67f0360d0045775d$export$402edee29ac8bed4);\n\nvar $iEtN5 = parcelRequire(\"iEtN5\");\n\nvar $5Oad7 = parcelRequire(\"5Oad7\");\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $lzfZe = parcelRequire(\"lzfZe\");\n\nvar $fl08K = parcelRequire(\"fl08K\");\n\nvar $isMCe = parcelRequire(\"isMCe\");\n\nvar $hsuiF = parcelRequire(\"hsuiF\");\n\"use strict\";\nconst $67f0360d0045775d$var$validExtensions = [\n    \".xml\",\n    \".fnt\"\n];\nconst $67f0360d0045775d$export$778a313228f06f6c = {\n    extension: (0, $i9BKe.ExtensionType).CacheParser,\n    test: (asset)=>asset instanceof (0, $fl08K.BitmapFont),\n    getCacheableAssets (keys, asset) {\n        const out = {};\n        keys.forEach((key)=>{\n            out[key] = asset;\n        });\n        out[`${asset.fontFamily}-bitmap`] = asset;\n        return out;\n    }\n};\nconst $67f0360d0045775d$export$402edee29ac8bed4 = {\n    extension: {\n        type: (0, $i9BKe.ExtensionType).LoadParser,\n        priority: (0, $iEtN5.LoaderParserPriority).Normal\n    },\n    test (url) {\n        return $67f0360d0045775d$var$validExtensions.includes((0, $lzfZe.path).extname(url).toLowerCase());\n    },\n    async testParse (data) {\n        return (0, $isMCe.bitmapFontTextParser).test(data) || (0, $hsuiF.bitmapFontXMLStringParser).test(data);\n    },\n    async parse (asset, data, loader) {\n        const bitmapFontData = (0, $isMCe.bitmapFontTextParser).test(asset) ? (0, $isMCe.bitmapFontTextParser).parse(asset) : (0, $hsuiF.bitmapFontXMLStringParser).parse(asset);\n        const { src: src } = data;\n        const { pages: pages } = bitmapFontData;\n        const textureUrls = [];\n        for(let i = 0; i < pages.length; ++i){\n            const pageFile = pages[i].file;\n            let imagePath = (0, $lzfZe.path).join((0, $lzfZe.path).dirname(src), pageFile);\n            imagePath = (0, $5Oad7.copySearchParams)(imagePath, src);\n            textureUrls.push(imagePath);\n        }\n        const loadedTextures = await loader.load(textureUrls);\n        const textures = textureUrls.map((url)=>loadedTextures[url]);\n        const bitmapFont = new (0, $fl08K.BitmapFont)({\n            data: bitmapFontData,\n            textures: textures\n        }, src);\n        return bitmapFont;\n    },\n    async load (url, _options) {\n        const response = await (0, $iCGeI.DOMAdapter).get().fetch(url);\n        return await response.text();\n    },\n    async unload (bitmapFont, _resolvedAsset, loader) {\n        await Promise.all(bitmapFont.pages.map((page)=>loader.unload(page.texture.source._sourceOrigin)));\n        bitmapFont.destroy();\n    }\n};\n\n});\nparcelRegister(\"fl08K\", function(module, exports) {\n\n$parcel$export(module.exports, \"BitmapFont\", () => $e203ca19ce7419c5$export$17957a09927cadc7);\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $hlNkG = parcelRequire(\"hlNkG\");\n\nvar $axl5b = parcelRequire(\"axl5b\");\n\"use strict\";\nclass $e203ca19ce7419c5$export$17957a09927cadc7 extends (0, $hlNkG.AbstractBitmapFont) {\n    constructor(options, url){\n        super();\n        const { textures: textures, data: data } = options;\n        Object.keys(data.pages).forEach((key)=>{\n            const pageData = data.pages[parseInt(key, 10)];\n            const texture = textures[pageData.id];\n            this.pages.push({\n                texture: texture\n            });\n        });\n        Object.keys(data.chars).forEach((key)=>{\n            const charData = data.chars[key];\n            const textureSource = textures[charData.page].source;\n            const frameReal = new (0, $fM4Mk.Rectangle)(charData.x, charData.y, charData.width, charData.height);\n            const texture = new (0, $bLlTJ.Texture)({\n                source: textureSource,\n                frame: frameReal\n            });\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture: texture\n            };\n        });\n        this.baseRenderedFontSize = data.fontSize;\n        this.baseMeasurementFontSize = data.fontSize;\n        this.fontMetrics = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize\n        };\n        this.baseLineOffset = data.baseLineOffset;\n        this.lineHeight = data.lineHeight;\n        this.fontFamily = data.fontFamily;\n        this.distanceField = data.distanceField ?? {\n            type: \"none\",\n            range: 0\n        };\n        this.url = url;\n    }\n    /** Destroys the BitmapFont object. */ destroy() {\n        super.destroy();\n        for(let i = 0; i < this.pages.length; i++){\n            const { texture: texture } = this.pages[i];\n            texture.destroy(true);\n        }\n        this.pages = null;\n    }\n    /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from 'pixi.js';\n   *\n   * BitmapFont.install('TitleFont', {\n   *     fontFamily: 'Arial',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: 'purple',\n   * });\n   *\n   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n   */ static install(options) {\n        (0, $axl5b.BitmapFontManager).install(options);\n    }\n    /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */ static uninstall(name) {\n        (0, $axl5b.BitmapFontManager).uninstall(name);\n    }\n}\n\n});\nparcelRegister(\"hlNkG\", function(module, exports) {\n\n$parcel$export(module.exports, \"AbstractBitmapFont\", () => $5d74af76d429a42b$export$70779aee6e4c1309);\n\nvar $3vRz3 = parcelRequire(\"3vRz3\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\"use strict\";\nclass $5d74af76d429a42b$export$70779aee6e4c1309 extends (0, (/*@__PURE__*/$parcel$interopDefault($3vRz3))) {\n    constructor(){\n        super(...arguments);\n        /** The map of characters by character code. */ this.chars = /* @__PURE__ */ Object.create(null);\n        /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */ this.lineHeight = 0;\n        /**\n     * The name of the font face\n     * @type {string}\n     */ this.fontFamily = \"\";\n        /** The metrics of the font face. */ this.fontMetrics = {\n            fontSize: 0,\n            ascent: 0,\n            descent: 0\n        };\n        /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */ this.baseLineOffset = 0;\n        /** The range and type of the distance field for this font. */ this.distanceField = {\n            type: \"none\",\n            range: 0\n        };\n        /** The map of base page textures (i.e., sheets of glyphs). */ this.pages = [];\n        /** The size of the font face in pixels. */ this.baseMeasurementFontSize = 100;\n        this.baseRenderedFontSize = 100;\n    }\n    /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */ get font() {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.\");\n        return this.fontFamily;\n    }\n    /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */ get pageTextures() {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n        return this.pages;\n    }\n    /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */ get size() {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.\");\n        return this.fontMetrics.fontSize;\n    }\n    /**\n   * The kind of distance field for this font or \"none\".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */ get distanceFieldRange() {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.\");\n        return this.distanceField.range;\n    }\n    /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */ get distanceFieldType() {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.\");\n        return this.distanceField.type;\n    }\n    destroy(destroyTextures = false) {\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n        for(const i in this.chars)this.chars[i].texture.destroy();\n        this.chars = null;\n        if (destroyTextures) {\n            this.pages.forEach((page)=>page.texture.destroy(true));\n            this.pages = null;\n        }\n    }\n}\n\n});\n\nparcelRegister(\"axl5b\", function(module, exports) {\n\n$parcel$export(module.exports, \"BitmapFontManager\", () => $906f35d9788bb217$export$d2ee57cdc0e1ed7f);\n\nvar $2IhKp = parcelRequire(\"2IhKp\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\nvar $eKNW7 = parcelRequire(\"eKNW7\");\n\nvar $5Jnul = parcelRequire(\"5Jnul\");\n\nvar $hzhPt = parcelRequire(\"hzhPt\");\n\nvar $6ch13 = parcelRequire(\"6ch13\");\n\"use strict\";\nclass $906f35d9788bb217$var$BitmapFontManagerClass {\n    constructor(){\n        /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */ this.ALPHA = [\n            [\n                \"a\",\n                \"z\"\n            ],\n            [\n                \"A\",\n                \"Z\"\n            ],\n            \" \"\n        ];\n        /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */ this.NUMERIC = [\n            [\n                \"0\",\n                \"9\"\n            ]\n        ];\n        /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */ this.ALPHANUMERIC = [\n            [\n                \"a\",\n                \"z\"\n            ],\n            [\n                \"A\",\n                \"Z\"\n            ],\n            [\n                \"0\",\n                \"9\"\n            ],\n            \" \"\n        ];\n        /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */ this.ASCII = [\n            [\n                \" \",\n                \"~\"\n            ]\n        ];\n        /** Default options for installing a new BitmapFont. */ this.defaultOptions = {\n            chars: this.ALPHANUMERIC,\n            resolution: 1,\n            padding: 4,\n            skipKerning: false\n        };\n    }\n    /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */ getFont(text, style) {\n        let fontFamilyKey = `${style.fontFamily}-bitmap`;\n        let overrideFill = true;\n        if (style._fill.fill) {\n            fontFamilyKey += style._fill.fill.uid;\n            overrideFill = false;\n        }\n        if (!(0, $2IhKp.Cache).has(fontFamilyKey)) {\n            const fnt = new (0, $5Jnul.DynamicBitmapFont)({\n                style: style,\n                overrideFill: overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions\n            });\n            fnt.once(\"destroy\", ()=>(0, $2IhKp.Cache).remove(fontFamilyKey));\n            (0, $2IhKp.Cache).set(fontFamilyKey, fnt);\n        }\n        const dynamicFont = (0, $2IhKp.Cache).get(fontFamilyKey);\n        dynamicFont.ensureCharacters?.(text);\n        return dynamicFont;\n    }\n    /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   */ getLayout(text, style) {\n        const bitmapFont = this.getFont(text, style);\n        return (0, $hzhPt.getBitmapTextLayout)(text.split(\"\"), style, bitmapFont);\n    }\n    /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   */ measureText(text, style) {\n        return this.getLayout(text, style);\n    }\n    // eslint-disable-next-line max-len\n    install(...args) {\n        let options = args[0];\n        if (typeof options === \"string\") {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning\n            };\n            (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})\");\n        }\n        const name = options?.name;\n        if (!name) throw new Error(\"[BitmapFontManager] Property `name` is required.\");\n        options = {\n            ...this.defaultOptions,\n            ...options\n        };\n        const textStyle = options.style;\n        const style = textStyle instanceof (0, $eKNW7.TextStyle) ? textStyle : new (0, $eKNW7.TextStyle)(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n        const font = new (0, $5Jnul.DynamicBitmapFont)({\n            style: style,\n            overrideFill: overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n        const flatChars = (0, $6ch13.resolveCharacters)(options.chars);\n        font.ensureCharacters(flatChars.join(\"\"));\n        (0, $2IhKp.Cache).set(`${name}-bitmap`, font);\n        font.once(\"destroy\", ()=>(0, $2IhKp.Cache).remove(`${name}-bitmap`));\n        return font;\n    }\n    /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */ uninstall(name) {\n        const cacheKey = `${name}-bitmap`;\n        const font = (0, $2IhKp.Cache).get(cacheKey);\n        if (font) {\n            (0, $2IhKp.Cache).remove(cacheKey);\n            font.destroy();\n        }\n    }\n}\nconst $906f35d9788bb217$export$d2ee57cdc0e1ed7f = new $906f35d9788bb217$var$BitmapFontManagerClass();\n\n});\nparcelRegister(\"5Jnul\", function(module, exports) {\n\n$parcel$export(module.exports, \"DynamicBitmapFont\", () => $8f5ec95844dc935f$export$bce21273d0a2e6c7);\n\nvar $a2eTA = parcelRequire(\"a2eTA\");\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\nvar $6RGCN = parcelRequire(\"6RGCN\");\n\nvar $aQPld = parcelRequire(\"aQPld\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $kXq8E = parcelRequire(\"kXq8E\");\n\nvar $wLFHs = parcelRequire(\"wLFHs\");\n\nvar $fI0NC = parcelRequire(\"fI0NC\");\n\nvar $4JkiF = parcelRequire(\"4JkiF\");\n\nvar $hlNkG = parcelRequire(\"hlNkG\");\n\nvar $6ch13 = parcelRequire(\"6ch13\");\n\"use strict\";\nclass $8f5ec95844dc935f$export$bce21273d0a2e6c7 extends (0, $hlNkG.AbstractBitmapFont) {\n    /**\n   * @param options - The options for the dynamic bitmap font.\n   */ constructor(options){\n        super();\n        /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */ this.resolution = 1;\n        /** The pages of the font. */ this.pages = [];\n        this._padding = 4;\n        this._measureCache = /* @__PURE__ */ Object.create(null);\n        this._currentChars = [];\n        this._currentX = 0;\n        this._currentY = 0;\n        this._currentPageIndex = -1;\n        this._skipKerning = false;\n        const dynamicOptions = options;\n        const style = dynamicOptions.style.clone();\n        if (dynamicOptions.overrideFill) {\n            style._fill.color = 16777215;\n            style._fill.alpha = 1;\n            style._fill.texture = (0, $bLlTJ.Texture).WHITE;\n            style._fill.fill = null;\n        }\n        const requestedFontSize = style.fontSize;\n        style.fontSize = this.baseMeasurementFontSize;\n        const font = (0, $fI0NC.fontStringFromTextStyle)(style);\n        if (dynamicOptions.overrideSize) {\n            if (style._stroke) style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n        } else style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n        this.fontMetrics = (0, $wLFHs.CanvasTextMetrics).measureFont(font);\n        this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n    ensureCharacters(chars) {\n        const charList = (0, $6ch13.resolveCharacters)(chars).filter((char)=>!this._currentChars.includes(char)).filter((char, index, self)=>self.indexOf(char) === index);\n        if (!charList.length) return;\n        this._currentChars = [\n            ...this._currentChars,\n            ...charList\n        ];\n        let pageData;\n        if (this._currentPageIndex === -1) pageData = this._nextPage();\n        else pageData = this.pages[this._currentPageIndex];\n        let { canvas: canvas, context: context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n        const style = this._style;\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n        const widthScale = style.fontStyle === \"italic\" ? 2 : 1;\n        let maxCharHeight = 0;\n        let skipTexture = false;\n        for(let i = 0; i < charList.length; i++){\n            const char = charList[i];\n            const metrics = (0, $wLFHs.CanvasTextMetrics).measureText(char, style, canvas, false);\n            metrics.lineHeight = metrics.height;\n            const width = widthScale * metrics.width * fontScale;\n            const height = metrics.height * fontScale;\n            const paddedWidth = width + padding * 2;\n            const paddedHeight = height + padding * 2;\n            skipTexture = false;\n            if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n            }\n            if (currentX + paddedWidth > 512) {\n                currentY += maxCharHeight;\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n                if (currentY + maxCharHeight > 512) {\n                    textureSource.update();\n                    const pageData2 = this._nextPage();\n                    canvas = pageData2.canvasAndContext.canvas;\n                    context = pageData2.canvasAndContext.context;\n                    textureSource = pageData2.texture.source;\n                    currentY = 0;\n                }\n            }\n            const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance: xAdvance,\n                kerning: {}\n            };\n            if (skipTexture) {\n                this._drawGlyph(context, metrics, currentX + padding, currentY + padding, fontScale, style);\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n                const frame = new (0, $fM4Mk.Rectangle)(currentX / px * textureSource.width, currentY / py * textureSource.height, paddedWidth / px * textureSource.width, paddedHeight / py * textureSource.height);\n                this.chars[char].texture = new (0, $bLlTJ.Texture)({\n                    source: textureSource,\n                    frame: frame\n                });\n                currentX += Math.ceil(paddedWidth);\n            }\n        }\n        textureSource.update();\n        this._currentX = currentX;\n        this._currentY = currentY;\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n    /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */ get pageTextures() {\n        (0, $kXq8E.deprecation)((0, $kXq8E.v8_0_0), \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n        return this.pages;\n    }\n    _applyKerning(newChars, context) {\n        const measureCache = this._measureCache;\n        for(let i = 0; i < newChars.length; i++){\n            const first = newChars[i];\n            for(let j = 0; j < this._currentChars.length; j++){\n                const second = this._currentChars[j];\n                let c1 = measureCache[first];\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n                let c2 = measureCache[second];\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n                if (amount) this.chars[first].kerning[second] = amount;\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n                if (amount) this.chars[second].kerning[first] = amount;\n            }\n        }\n    }\n    _nextPage() {\n        this._currentPageIndex++;\n        const textureResolution = this.resolution;\n        const canvasAndContext = (0, $6RGCN.CanvasPool).getOptimalCanvasAndContext(512, 512, textureResolution);\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new (0, $bLlTJ.Texture)({\n            source: new (0, $aQPld.ImageSource)({\n                resource: canvasAndContext.canvas,\n                resolution: resolution,\n                alphaMode: \"premultiply-alpha-on-upload\"\n            })\n        });\n        const pageData = {\n            canvasAndContext: canvasAndContext,\n            texture: texture\n        };\n        this.pages[this._currentPageIndex] = pageData;\n        return pageData;\n    }\n    // canvas style!\n    _setupContext(context, style, resolution) {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = (0, $fI0NC.fontStringFromTextStyle)(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n        if (stroke) {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n            context.strokeStyle = (0, $4JkiF.getCanvasFillStyle)(stroke, context);\n        }\n        if (style._fill) context.fillStyle = (0, $4JkiF.getCanvasFillStyle)(style._fill, context);\n        if (style.dropShadow) {\n            const shadowOptions = style.dropShadow;\n            const rgb = (0, $a2eTA.Color).shared.setValue(shadowOptions.color).toArray();\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        } else {\n            context.shadowColor = \"black\";\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n    _drawGlyph(context, metrics, x, y, fontScale, style) {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n        const tx = x + strokeThickness / 2;\n        const ty = y - strokeThickness / 2;\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n        if (style.stroke && strokeThickness) context.strokeText(char, tx, ty + lineHeight - descent);\n        if (style._fill) context.fillText(char, tx, ty + lineHeight - descent);\n    }\n    destroy() {\n        super.destroy();\n        for(let i = 0; i < this.pages.length; i++){\n            const { canvasAndContext: canvasAndContext, texture: texture } = this.pages[i];\n            (0, $6RGCN.CanvasPool).returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n        this.pages = null;\n    }\n}\n\n});\nparcelRegister(\"6ch13\", function(module, exports) {\n\n$parcel$export(module.exports, \"resolveCharacters\", () => $6068e3267b929dcc$export$221291e5031b03d8);\n\"use strict\";\nfunction $6068e3267b929dcc$export$221291e5031b03d8(chars) {\n    if (chars === \"\") return [];\n    if (typeof chars === \"string\") chars = [\n        chars\n    ];\n    const result = [];\n    for(let i = 0, j = chars.length; i < j; i++){\n        const item = chars[i];\n        if (Array.isArray(item)) {\n            if (item.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            if (item[0].length === 0 || item[1].length === 0) throw new Error(\"[BitmapFont]: Invalid character delimiter.\");\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n            if (endCode < startCode) throw new Error(\"[BitmapFont]: Invalid character range.\");\n            for(let i2 = startCode, j2 = endCode; i2 <= j2; i2++)result.push(String.fromCharCode(i2));\n        } else result.push(...Array.from(item));\n    }\n    if (result.length === 0) throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n    return result;\n}\n\n});\n\n\nparcelRegister(\"hzhPt\", function(module, exports) {\n\n$parcel$export(module.exports, \"getBitmapTextLayout\", () => $a05acbad40de1576$export$beeb37b3e20d3ee4);\n\"use strict\";\nfunction $a05acbad40de1576$export$beeb37b3e20d3ee4(chars, style, font) {\n    const layoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [\n            {\n                width: 0,\n                charPositions: [],\n                spaceWidth: 0,\n                spacesIndex: [],\n                chars: []\n            }\n        ]\n    };\n    layoutData.offsetY = font.baseLineOffset;\n    let currentLine = layoutData.lines[0];\n    let previousChar = null;\n    let firstWord = true;\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0,\n        // use index to not modify the array as we use it a lot!\n        positions: [],\n        chars: []\n    };\n    const nextWord = (word)=>{\n        const start = currentLine.width;\n        for(let j = 0; j < currentWord.index; j++){\n            const position = word.positions[j];\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n        currentLine.width += word.width;\n        firstWord = false;\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n    };\n    const nextLine = ()=>{\n        let index = currentLine.chars.length - 1;\n        let lastChar = currentLine.chars[index];\n        while(lastChar === \" \"){\n            currentLine.width -= font.chars[lastChar].xAdvance;\n            lastChar = currentLine.chars[--index];\n        }\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: []\n        };\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n    for(let i = 0; i < chars.length + 1; i++){\n        let char;\n        const isEnd = i === chars.length;\n        if (!isEnd) char = chars[i];\n        const charData = font.chars[char] || font.chars[\" \"];\n        const isSpace = /(?:\\s)/.test(char);\n        const isWordBreak = isSpace || char === \"\\r\" || char === \"\\n\" || isEnd;\n        if (isWordBreak) {\n            const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n            if (addWordToNextLine) {\n                nextLine();\n                nextWord(currentWord);\n                if (!isEnd) currentLine.charPositions.push(0);\n            } else {\n                currentWord.start = currentLine.width;\n                nextWord(currentWord);\n                if (!isEnd) currentLine.charPositions.push(0);\n            }\n            if (char === \"\\r\" || char === \"\\n\") {\n                if (currentLine.width !== 0) nextLine();\n            } else if (!isEnd) {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n                currentLine.width += spaceWidth;\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n            }\n        } else {\n            const kerning = charData.kerning[previousChar] || 0;\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n            currentWord.width += nextCharWidth;\n        }\n        previousChar = char;\n    }\n    nextLine();\n    if (style.align === \"center\") $a05acbad40de1576$var$alignCenter(layoutData);\n    else if (style.align === \"right\") $a05acbad40de1576$var$alignRight(layoutData);\n    else if (style.align === \"justify\") $a05acbad40de1576$var$alignJustify(layoutData);\n    return layoutData;\n}\nfunction $a05acbad40de1576$var$alignCenter(measurementData) {\n    for(let i = 0; i < measurementData.lines.length; i++){\n        const line = measurementData.lines[i];\n        const offset = measurementData.width / 2 - line.width / 2;\n        for(let j = 0; j < line.charPositions.length; j++)line.charPositions[j] += offset;\n    }\n}\nfunction $a05acbad40de1576$var$alignRight(measurementData) {\n    for(let i = 0; i < measurementData.lines.length; i++){\n        const line = measurementData.lines[i];\n        const offset = measurementData.width - line.width;\n        for(let j = 0; j < line.charPositions.length; j++)line.charPositions[j] += offset;\n    }\n}\nfunction $a05acbad40de1576$var$alignJustify(measurementData) {\n    const width = measurementData.width;\n    for(let i = 0; i < measurementData.lines.length; i++){\n        const line = measurementData.lines[i];\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n        let offset = 0;\n        const totalSpaces = line.spacesIndex.length;\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n        const spaceWidth = newSpaceWidth;\n        for(let j = 0; j < line.charPositions.length; j++){\n            if (j === spaceIndex) {\n                spaceIndex = line.spacesIndex[indy++];\n                offset += spaceWidth;\n            }\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\n});\n\n\n\nparcelRegister(\"isMCe\", function(module, exports) {\n\n$parcel$export(module.exports, \"bitmapFontTextParser\", () => $2e97ab653ff7bb1e$export$4c1815a0944ccac0);\n\"use strict\";\nconst $2e97ab653ff7bb1e$export$4c1815a0944ccac0 = {\n    test (data) {\n        return typeof data === \"string\" && data.startsWith(\"info face=\");\n    },\n    parse (txt) {\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: []\n        };\n        for(const i in items){\n            const name = items[i].match(/^[a-z]+/gm)[0];\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n            const itemData = {};\n            for(const i2 in attributeList){\n                const split = attributeList[i2].split(\"=\");\n                const key = split[0];\n                const strValue = split[1].replace(/\"/gm, \"\");\n                const floatValue = parseFloat(strValue);\n                const value = isNaN(floatValue) ? strValue : floatValue;\n                itemData[key] = value;\n            }\n            rawData[name].push(itemData);\n        }\n        const font = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: \"\",\n            distanceField: null,\n            baseLineOffset: 0\n        };\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n        if (distanceField) font.distanceField = {\n            range: parseInt(distanceField.distanceRange, 10),\n            type: distanceField.fieldType\n        };\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n        const page = rawData.page;\n        for(let i = 0; i < page.length; i++)font.pages.push({\n            id: parseInt(page[i].id, 10) || 0,\n            file: page[i].file\n        });\n        const map = {};\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n        const char = rawData.char;\n        for(let i = 0; i < char.length; i++){\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n            if (letter === \"space\") letter = \" \";\n            map[id] = letter;\n            font.chars[letter] = {\n                id: id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {}\n            };\n        }\n        const kerning = rawData.kerning || [];\n        for(let i = 0; i < kerning.length; i++){\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n        return font;\n    }\n};\n\n});\n\nparcelRegister(\"hsuiF\", function(module, exports) {\n\n$parcel$export(module.exports, \"bitmapFontXMLStringParser\", () => $bc1a44b21cd9ad12$export$bfc0a19e2e2cc16);\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $KAE8q = parcelRequire(\"KAE8q\");\n\"use strict\";\nconst $bc1a44b21cd9ad12$export$bfc0a19e2e2cc16 = {\n    test (data) {\n        if (typeof data === \"string\" && data.includes(\"<font>\")) return (0, $KAE8q.bitmapFontXMLParser).test((0, $iCGeI.DOMAdapter).get().parseXML(data));\n        return false;\n    },\n    parse (data) {\n        return (0, $KAE8q.bitmapFontXMLParser).parse((0, $iCGeI.DOMAdapter).get().parseXML(data));\n    }\n};\n\n});\nparcelRegister(\"KAE8q\", function(module, exports) {\n\n$parcel$export(module.exports, \"bitmapFontXMLParser\", () => $e7c71a5aa13eb859$export$7a7adbcafc5cf8e3);\n\"use strict\";\nconst $e7c71a5aa13eb859$export$7a7adbcafc5cf8e3 = {\n    test (data) {\n        const xml = data;\n        return typeof xml !== \"string\" && \"getElementsByTagName\" in xml && xml.getElementsByTagName(\"page\").length && xml.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n    },\n    parse (xml) {\n        const data = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: \"\",\n            distanceField: null,\n            baseLineOffset: 0\n        };\n        const info = xml.getElementsByTagName(\"info\")[0];\n        const common = xml.getElementsByTagName(\"common\")[0];\n        const distanceField = xml.getElementsByTagName(\"distanceField\")[0];\n        if (distanceField) data.distanceField = {\n            type: distanceField.getAttribute(\"fieldType\"),\n            range: parseInt(distanceField.getAttribute(\"distanceRange\"), 10)\n        };\n        const page = xml.getElementsByTagName(\"page\");\n        const char = xml.getElementsByTagName(\"char\");\n        const kerning = xml.getElementsByTagName(\"kerning\");\n        data.fontSize = parseInt(info.getAttribute(\"size\"), 10);\n        data.fontFamily = info.getAttribute(\"face\");\n        data.lineHeight = parseInt(common.getAttribute(\"lineHeight\"), 10);\n        for(let i = 0; i < page.length; i++)data.pages.push({\n            id: parseInt(page[i].getAttribute(\"id\"), 10) || 0,\n            file: page[i].getAttribute(\"file\")\n        });\n        const map = {};\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute(\"base\"), 10);\n        for(let i = 0; i < char.length; i++){\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute(\"id\"), 10);\n            let letter = charNode.getAttribute(\"letter\") ?? charNode.getAttribute(\"char\") ?? String.fromCharCode(id);\n            if (letter === \"space\") letter = \" \";\n            map[id] = letter;\n            data.chars[letter] = {\n                id: id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute(\"page\"), 10) || 0,\n                x: parseInt(charNode.getAttribute(\"x\"), 10),\n                y: parseInt(charNode.getAttribute(\"y\"), 10),\n                width: parseInt(charNode.getAttribute(\"width\"), 10),\n                height: parseInt(charNode.getAttribute(\"height\"), 10),\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute(\"xoffset\"), 10),\n                yOffset: parseInt(charNode.getAttribute(\"yoffset\"), 10),\n                // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute(\"xadvance\"), 10),\n                kerning: {}\n            };\n        }\n        for(let i = 0; i < kerning.length; i++){\n            const first = parseInt(kerning[i].getAttribute(\"first\"), 10);\n            const second = parseInt(kerning[i].getAttribute(\"second\"), 10);\n            const amount = parseInt(kerning[i].getAttribute(\"amount\"), 10);\n            data.chars[map[second]].kerning[map[first]] = amount;\n        }\n        return data;\n    }\n};\n\n});\n\n\n\nparcelRegister(\"5FVru\", function(module, exports) {\n\n$parcel$export(module.exports, \"BitmapTextPipe\", () => $a13522d534d45eca$export$83d8b05a29a5f8ed);\n\nvar $2IhKp = parcelRequire(\"2IhKp\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $61KiY = parcelRequire(\"61KiY\");\n\nvar $3cebA = parcelRequire(\"3cebA\");\n\nvar $kSjlm = parcelRequire(\"kSjlm\");\n\nvar $axl5b = parcelRequire(\"axl5b\");\n\nvar $hzhPt = parcelRequire(\"hzhPt\");\n\"use strict\";\nclass $a13522d534d45eca$export$83d8b05a29a5f8ed {\n    constructor(renderer){\n        this._gpuBitmapText = {};\n        this._renderer = renderer;\n    }\n    validateRenderable(bitmapText) {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n        if (bitmapText._didTextUpdate) {\n            bitmapText._didTextUpdate = false;\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n    }\n    addRenderable(bitmapText, instructionSet) {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n        $a13522d534d45eca$var$syncWithProxy(bitmapText, graphicsRenderable);\n        if (bitmapText._didTextUpdate) {\n            bitmapText._didTextUpdate = false;\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n        if (graphicsRenderable.context.customShader) this._updateDistanceField(bitmapText);\n    }\n    destroyRenderable(bitmapText) {\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n    _destroyRenderableByUid(renderableUid) {\n        (0, $61KiY.BigPool).return(this._gpuBitmapText[renderableUid]);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n    updateRenderable(bitmapText) {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n        $a13522d534d45eca$var$syncWithProxy(bitmapText, graphicsRenderable);\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n        if (graphicsRenderable.context.customShader) this._updateDistanceField(bitmapText);\n    }\n    _updateContext(bitmapText, proxyGraphics) {\n        const { context: context } = proxyGraphics;\n        const bitmapFont = (0, $axl5b.BitmapFontManager).getFont(bitmapText.text, bitmapText._style);\n        context.clear();\n        if (bitmapFont.distanceField.type !== \"none\") {\n            if (!context.customShader) {\n                if (!this._sdfShader) this._sdfShader = new (0, $kSjlm.SdfShader)();\n                context.customShader = this._sdfShader;\n            }\n        }\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n        let currentY = (style._stroke?.width || 0) / 2;\n        currentY += bitmapFont.baseLineOffset;\n        const bitmapTextLayout = (0, $hzhPt.getBitmapTextLayout)(chars, style, bitmapFont);\n        let index = 0;\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n        context.translate(-bitmapText._anchor._x * bitmapTextLayout.width - padding, -bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding).scale(scale, scale);\n        const tint = style._fill.color;\n        for(let i = 0; i < bitmapTextLayout.lines.length; i++){\n            const line = bitmapTextLayout.lines[i];\n            for(let j = 0; j < line.charPositions.length; j++){\n                const char = chars[index++];\n                const charData = bitmapFont.chars[char];\n                if (charData?.texture) context.texture(charData.texture, tint ? tint : \"black\", Math.round(line.charPositions[j] + charData.xOffset), Math.round(currentY + charData.yOffset));\n            }\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n    _getGpuBitmapText(bitmapText) {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n    initGpuText(bitmapText) {\n        const proxyRenderable = (0, $61KiY.BigPool).get((0, $3cebA.Graphics));\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n        this._updateContext(bitmapText, proxyRenderable);\n        bitmapText.on(\"destroyed\", ()=>{\n            this.destroyRenderable(bitmapText);\n        });\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n    _updateDistanceField(bitmapText) {\n        const context = this._getGpuBitmapText(bitmapText).context;\n        const fontFamily = bitmapText._style.fontFamily;\n        const dynamicFont = (0, $2IhKp.Cache).get(`${fontFamily}-bitmap`);\n        const { a: a, b: b, c: c, d: d } = bitmapText.groupTransform;\n        const dx = Math.sqrt(a * a + b * b);\n        const dy = Math.sqrt(c * c + d * d);\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n        const resolution = bitmapText.resolution ?? this._renderer.resolution;\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n    destroy() {\n        for(const uid in this._gpuBitmapText)this._destroyRenderableByUid(uid);\n        this._gpuBitmapText = null;\n        this._sdfShader?.destroy(true);\n        this._sdfShader = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $a13522d534d45eca$export$83d8b05a29a5f8ed.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLPipes,\n        (0, $i9BKe.ExtensionType).WebGPUPipes,\n        (0, $i9BKe.ExtensionType).CanvasPipes\n    ],\n    name: \"bitmapText\"\n};\nfunction $a13522d534d45eca$var$syncWithProxy(container, proxy) {\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n\n});\nparcelRegister(\"kSjlm\", function(module, exports) {\n\n$parcel$export(module.exports, \"SdfShader\", () => $838fb3551287e62a$export$f19b070f8409d54d);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $67Wkd = parcelRequire(\"67Wkd\");\n\nvar $3JBHn = parcelRequire(\"3JBHn\");\n\nvar $cNnNT = parcelRequire(\"cNnNT\");\n\nvar $ikSZA = parcelRequire(\"ikSZA\");\n\nvar $kSpdC = parcelRequire(\"kSpdC\");\n\nvar $5FRY8 = parcelRequire(\"5FRY8\");\n\nvar $5iDyo = parcelRequire(\"5iDyo\");\n\nvar $cryyq = parcelRequire(\"cryyq\");\n\nvar $h31yJ = parcelRequire(\"h31yJ\");\n\nvar $bSURu = parcelRequire(\"bSURu\");\n\"use strict\";\nclass $838fb3551287e62a$export$f19b070f8409d54d extends (0, $5iDyo.Shader) {\n    constructor(){\n        const uniforms = new (0, $cryyq.UniformGroup)({\n            uColor: {\n                value: new Float32Array([\n                    1,\n                    1,\n                    1,\n                    1\n                ]),\n                type: \"vec4<f32>\"\n            },\n            uTransformMatrix: {\n                value: new (0, $eY4rt.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uDistance: {\n                value: 4,\n                type: \"f32\"\n            },\n            uRound: {\n                value: 0,\n                type: \"f32\"\n            }\n        });\n        const gpuProgram = (0, $3JBHn.compileHighShaderGpuProgram)({\n            name: \"sdf-shader\",\n            bits: [\n                (0, $cNnNT.colorBit),\n                (0, $ikSZA.generateTextureBatchBit)((0, $67Wkd.MAX_TEXTURES)),\n                (0, $h31yJ.localUniformMSDFBit),\n                (0, $bSURu.mSDFBit),\n                (0, $kSpdC.roundPixelsBit)\n            ]\n        });\n        const glProgram = (0, $3JBHn.compileHighShaderGlProgram)({\n            name: \"sdf-shader\",\n            bits: [\n                (0, $cNnNT.colorBitGl),\n                (0, $ikSZA.generateTextureBatchBitGl)((0, $67Wkd.MAX_TEXTURES)),\n                (0, $h31yJ.localUniformMSDFBitGl),\n                (0, $bSURu.mSDFBitGl),\n                (0, $kSpdC.roundPixelsBitGl)\n            ]\n        });\n        super({\n            glProgram: glProgram,\n            gpuProgram: gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: (0, $5FRY8.batchSamplersUniformGroup)\n            }\n        });\n    }\n}\n\n});\nparcelRegister(\"h31yJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"localUniformMSDFBit\", () => $93ced60a46db0c48$export$95191d1d81ffe694);\n$parcel$export(module.exports, \"localUniformMSDFBitGl\", () => $93ced60a46db0c48$export$7542046ad25e8068);\n\"use strict\";\nconst $93ced60a46db0c48$export$95191d1d81ffe694 = {\n    name: \"local-uniform-msdf-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */ `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */ `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */ `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */ ` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n    }\n};\nconst $93ced60a46db0c48$export$7542046ad25e8068 = {\n    name: \"local-uniform-msdf-bit\",\n    vertex: {\n        header: /* glsl */ `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */ `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */ `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */ `\n            uniform float uDistance;\n         `,\n        main: /* glsl */ ` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n    }\n};\n\n});\n\nparcelRegister(\"bSURu\", function(module, exports) {\n\n$parcel$export(module.exports, \"mSDFBit\", () => $7144684246b95ecb$export$382a0eb192cd0a47);\n$parcel$export(module.exports, \"mSDFBitGl\", () => $7144684246b95ecb$export$52c5bf2a8ebe1f2a);\n\"use strict\";\nconst $7144684246b95ecb$export$382a0eb192cd0a47 = {\n    name: \"msdf-bit\",\n    fragment: {\n        header: /* wgsl */ `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    }\n};\nconst $7144684246b95ecb$export$52c5bf2a8ebe1f2a = {\n    name: \"msdf-bit\",\n    fragment: {\n        header: /* glsl */ `\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    }\n};\n\n});\n\n\n\n\nparcelRegister(\"7t4bH\", function(module, exports) {\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $gTm15 = parcelRequire(\"gTm15\");\n\nvar $8fPaG = parcelRequire(\"8fPaG\");\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $8fPaG.HTMLTextSystem));\n(0, $i9BKe.extensions).add((0, $gTm15.HTMLTextPipe));\n\n});\nparcelRegister(\"gTm15\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextPipe\", () => $d64c140cd435980d$export$ffcef6958193be1c);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $f8J9J = parcelRequire(\"f8J9J\");\n\nvar $61KiY = parcelRequire(\"61KiY\");\n\nvar $6qNFd = parcelRequire(\"6qNFd\");\n\"use strict\";\nclass $d64c140cd435980d$export$ffcef6958193be1c {\n    constructor(renderer){\n        this._gpuText = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    validateRenderable(htmlText) {\n        const gpuText = this._getGpuText(htmlText);\n        const newKey = htmlText._getKey();\n        if (gpuText.textureNeedsUploading) {\n            gpuText.textureNeedsUploading = false;\n            return true;\n        }\n        if (gpuText.currentKey !== newKey) return true;\n        return false;\n    }\n    addRenderable(htmlText) {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n        if (htmlText._didTextUpdate) this._updateText(htmlText);\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n    updateRenderable(htmlText) {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n        if (htmlText._didTextUpdate) this._updateText(htmlText);\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n    destroyRenderable(htmlText) {\n        this._destroyRenderableById(htmlText.uid);\n    }\n    _destroyRenderableById(htmlTextUid) {\n        const gpuText = this._gpuText[htmlTextUid];\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n        (0, $61KiY.BigPool).return(gpuText.batchableSprite);\n        this._gpuText[htmlTextUid] = null;\n    }\n    _updateText(htmlText) {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n        if (gpuText.currentKey !== newKey) this._updateGpuText(htmlText).catch((e)=>{\n            console.error(e);\n        });\n        htmlText._didTextUpdate = false;\n        const padding = htmlText._style.padding;\n        (0, $f8J9J.updateQuadBounds)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n    async _updateGpuText(htmlText) {\n        htmlText._didTextUpdate = false;\n        const gpuText = this._getGpuText(htmlText);\n        if (gpuText.generatingTexture) return;\n        const newKey = htmlText._getKey();\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n        gpuText.generatingTexture = true;\n        gpuText.currentKey = newKey;\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n        const texture = await this._renderer.htmlText.getManagedTexture(htmlText.text, resolution, htmlText._style, htmlText._getKey());\n        const batchableSprite = gpuText.batchableSprite;\n        batchableSprite.texture = gpuText.texture = texture;\n        gpuText.generatingTexture = false;\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n        const padding = htmlText._style.padding;\n        (0, $f8J9J.updateQuadBounds)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n    _getGpuText(htmlText) {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n    initGpuText(htmlText) {\n        const gpuTextData = {\n            texture: (0, $bLlTJ.Texture).EMPTY,\n            currentKey: \"--\",\n            batchableSprite: (0, $61KiY.BigPool).get((0, $6qNFd.BatchableSprite)),\n            textureNeedsUploading: false,\n            generatingTexture: false\n        };\n        const batchableSprite = gpuTextData.batchableSprite;\n        batchableSprite.renderable = htmlText;\n        batchableSprite.texture = (0, $bLlTJ.Texture).EMPTY;\n        batchableSprite.bounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n        this._gpuText[htmlText.uid] = gpuTextData;\n        htmlText.on(\"destroyed\", ()=>{\n            this.destroyRenderable(htmlText);\n        });\n        return gpuTextData;\n    }\n    destroy() {\n        for(const i in this._gpuText)this._destroyRenderableById(i);\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $d64c140cd435980d$export$ffcef6958193be1c.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLPipes,\n        (0, $i9BKe.ExtensionType).WebGPUPipes,\n        (0, $i9BKe.ExtensionType).CanvasPipes\n    ],\n    name: \"htmlText\"\n};\n\n});\n\nparcelRegister(\"8fPaG\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextSystem\", () => $e561e497783631a4$export$f1b82676a746d8e9);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $3Xbp7 = parcelRequire(\"3Xbp7\");\n\nvar $2bK9z = parcelRequire(\"2bK9z\");\n\nvar $2yYcV = parcelRequire(\"2yYcV\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $61KiY = parcelRequire(\"61KiY\");\n\nvar $l7b1V = parcelRequire(\"l7b1V\");\n\nvar $38D3N = parcelRequire(\"38D3N\");\n\nvar $hbhnn = parcelRequire(\"hbhnn\");\n\nvar $4n9ps = parcelRequire(\"4n9ps\");\n\nvar $4He3o = parcelRequire(\"4He3o\");\n\nvar $lT5va = parcelRequire(\"lT5va\");\n\nvar $2ir1m = parcelRequire(\"2ir1m\");\n\nvar $1VDyN = parcelRequire(\"1VDyN\");\n\nvar $8z3uC = parcelRequire(\"8z3uC\");\n\"use strict\";\nclass $e561e497783631a4$export$f1b82676a746d8e9 {\n    constructor(renderer){\n        this._activeTextures = {};\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === (0, $2bK9z.RendererType).WEBGPU;\n    }\n    getTexture(options) {\n        return this._buildTexturePromise(options.text, options.resolution, options.style);\n    }\n    getManagedTexture(text, resolution, style, textKey) {\n        if (this._activeTextures[textKey]) {\n            this._increaseReferenceCount(textKey);\n            return this._activeTextures[textKey].promise;\n        }\n        const promise = this._buildTexturePromise(text, resolution, style).then((texture)=>{\n            this._activeTextures[textKey].texture = texture;\n            return texture;\n        });\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise: promise,\n            usageCount: 1\n        };\n        return promise;\n    }\n    async _buildTexturePromise(text, resolution, style) {\n        const htmlTextData = (0, $61KiY.BigPool).get((0, $38D3N.HTMLTextRenderData));\n        const fontFamilies = (0, $4n9ps.extractFontFamilies)(text, style);\n        const fontCSS = await (0, $4He3o.getFontCss)(fontFamilies, style, (0, $hbhnn.HTMLTextStyle).defaultTextStyle);\n        const measured = (0, $8z3uC.measureHtmlText)(text, style, fontCSS, htmlTextData);\n        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n        const image = htmlTextData.image;\n        image.width = width | 0;\n        image.height = height | 0;\n        const svgURL = (0, $lT5va.getSVGUrl)(text, style, resolution, fontCSS, htmlTextData);\n        await (0, $1VDyN.loadSVGImage)(image, svgURL, (0, $2yYcV.isSafari)() && fontFamilies.length > 0);\n        let resource = image;\n        if (this._createCanvas) resource = (0, $2ir1m.getTemporaryCanvasFromImage)(image, resolution);\n        const texture = (0, $l7b1V.getPo2TextureFromSource)(resource, image.width, image.height, resolution);\n        if (this._createCanvas) this._renderer.texture.initSource(texture.source);\n        (0, $61KiY.BigPool).return(htmlTextData);\n        return texture;\n    }\n    _increaseReferenceCount(textKey) {\n        this._activeTextures[textKey].usageCount++;\n    }\n    decreaseReferenceCount(textKey) {\n        const activeTexture = this._activeTextures[textKey];\n        if (!activeTexture) return;\n        activeTexture.usageCount--;\n        if (activeTexture.usageCount === 0) {\n            if (activeTexture.texture) this._cleanUp(activeTexture);\n            else activeTexture.promise.then((texture)=>{\n                activeTexture.texture = texture;\n                this._cleanUp(activeTexture);\n            }).catch(()=>{\n                (0, $hUCK4.warn)(\"HTMLTextSystem: Failed to clean texture\");\n            });\n            this._activeTextures[textKey] = null;\n        }\n    }\n    _cleanUp(activeTexture) {\n        (0, $3Xbp7.TexturePool).returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = \"unknown\";\n    }\n    getReferenceCount(textKey) {\n        return this._activeTextures[textKey].usageCount;\n    }\n    destroy() {\n        this._activeTextures = null;\n    }\n}\n/** @ignore */ $e561e497783631a4$export$f1b82676a746d8e9.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem,\n        (0, $i9BKe.ExtensionType).WebGPUSystem,\n        (0, $i9BKe.ExtensionType).CanvasSystem\n    ],\n    name: \"htmlText\"\n};\n$e561e497783631a4$export$f1b82676a746d8e9.defaultFontOptions = {\n    fontFamily: \"Arial\",\n    fontStyle: \"normal\",\n    fontWeight: \"normal\"\n};\n\n});\nparcelRegister(\"2yYcV\", function(module, exports) {\n\n$parcel$export(module.exports, \"isSafari\", () => $bd3bd17de916f737$export$95df08bae54cb4df);\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\"use strict\";\nfunction $bd3bd17de916f737$export$95df08bae54cb4df() {\n    const { userAgent: userAgent } = (0, $iCGeI.DOMAdapter).get().getNavigator();\n    return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\n});\n\nparcelRegister(\"38D3N\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextRenderData\", () => $60c804f97fa70757$export$47ab50939402e24e);\n\"use strict\";\nconst $60c804f97fa70757$export$5211e83ad76beaeb = \"http://www.w3.org/2000/svg\";\nconst $60c804f97fa70757$export$ff15d493b5bfa767 = \"http://www.w3.org/1999/xhtml\";\nclass $60c804f97fa70757$export$47ab50939402e24e {\n    constructor(){\n        this.svgRoot = document.createElementNS($60c804f97fa70757$export$5211e83ad76beaeb, \"svg\");\n        this.foreignObject = document.createElementNS($60c804f97fa70757$export$5211e83ad76beaeb, \"foreignObject\");\n        this.domElement = document.createElementNS($60c804f97fa70757$export$ff15d493b5bfa767, \"div\");\n        this.styleElement = document.createElementNS($60c804f97fa70757$export$ff15d493b5bfa767, \"style\");\n        this.image = new Image();\n        const { foreignObject: foreignObject, svgRoot: svgRoot, styleElement: styleElement, domElement: domElement } = this;\n        foreignObject.setAttribute(\"width\", \"10000\");\n        foreignObject.setAttribute(\"height\", \"10000\");\n        foreignObject.style.overflow = \"hidden\";\n        svgRoot.appendChild(foreignObject);\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n\n});\n\nparcelRegister(\"hbhnn\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextStyle\", () => $d10b94f8d29aac83$export$a2664b42ece43c6c);\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $eKNW7 = parcelRequire(\"eKNW7\");\n\nvar $6XitK = parcelRequire(\"6XitK\");\n\nvar $9CzjF = parcelRequire(\"9CzjF\");\n\"use strict\";\nclass $d10b94f8d29aac83$export$a2664b42ece43c6c extends (0, $eKNW7.TextStyle) {\n    constructor(options = {}){\n        super(options);\n        this._cssOverrides = [];\n        this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);\n        this.tagStyles = options.tagStyles ?? {};\n    }\n    /** List of style overrides that will be applied to the HTML text. */ set cssOverrides(value) {\n        this._cssOverrides = value instanceof Array ? value : [\n            value\n        ];\n        this.update();\n    }\n    get cssOverrides() {\n        return this._cssOverrides;\n    }\n    _generateKey() {\n        this._styleKey = (0, $6XitK.generateTextStyleKey)(this) + this._cssOverrides.join(\"-\");\n        return this._styleKey;\n    }\n    update() {\n        this._cssStyle = null;\n        super.update();\n    }\n    /**\n   * Creates a new HTMLTextStyle object with the same values as this one.\n   * @returns New cloned HTMLTextStyle object\n   */ clone() {\n        return new $d10b94f8d29aac83$export$a2664b42ece43c6c({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides\n        });\n    }\n    get cssStyle() {\n        if (!this._cssStyle) this._cssStyle = (0, $9CzjF.textStyleToCSS)(this);\n        return this._cssStyle;\n    }\n    /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride('background-color: red');\n   */ addOverride(...value) {\n        const toAdd = value.filter((v)=>!this.cssOverrides.includes(v));\n        if (toAdd.length > 0) {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n    /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride('background-color: red');\n   */ removeOverride(...value) {\n        const toRemove = value.filter((v)=>this.cssOverrides.includes(v));\n        if (toRemove.length > 0) {\n            this.cssOverrides = this.cssOverrides.filter((v)=>!toRemove.includes(v));\n            this.update();\n        }\n    }\n    set fill(value) {\n        if (typeof value !== \"string\" && typeof value !== \"number\") (0, $hUCK4.warn)(\"[HTMLTextStyle] only color fill is not supported by HTMLText\");\n        super.fill = value;\n    }\n    set stroke(value) {\n        if (value && typeof value !== \"string\" && typeof value !== \"number\") (0, $hUCK4.warn)(\"[HTMLTextStyle] only color stroke is not supported by HTMLText\");\n        super.stroke = value;\n    }\n}\n\n});\nparcelRegister(\"9CzjF\", function(module, exports) {\n\n$parcel$export(module.exports, \"textStyleToCSS\", () => $891e077217b1b85f$export$8daecfbc002513c1);\n\nvar $a2eTA = parcelRequire(\"a2eTA\");\n\"use strict\";\nfunction $891e077217b1b85f$export$8daecfbc002513c1(style) {\n    const stroke = style._stroke;\n    const fill = style._fill;\n    const cssStyleString = [\n        `color: ${(0, $a2eTA.Color).shared.setValue(fill.color).toHex()}`,\n        `font-size: ${style.fontSize}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${style.whiteSpace === \"pre\" && style.wordWrap ? \"pre-wrap\" : style.whiteSpace}`,\n        ...style.lineHeight ? [\n            `line-height: ${style.lineHeight}px`\n        ] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? \"break-all\" : \"break-word\"}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [\n            $891e077217b1b85f$var$strokeToCSS(stroke)\n        ] : [],\n        ...style.dropShadow ? [\n            $891e077217b1b85f$var$dropShadowToCSS(style.dropShadow)\n        ] : [],\n        ...style.cssOverrides\n    ].join(\";\");\n    const cssStyles = [\n        `div { ${cssStyleString} }`\n    ];\n    $891e077217b1b85f$var$tagStyleToCSS(style.tagStyles, cssStyles);\n    return cssStyles.join(\" \");\n}\nfunction $891e077217b1b85f$var$dropShadowToCSS(dropShadowStyle) {\n    const color = (0, $a2eTA.Color).shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const position = `${x}px ${y}px`;\n    if (dropShadowStyle.blur > 0) return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    return `text-shadow: ${position} ${color}`;\n}\nfunction $891e077217b1b85f$var$strokeToCSS(stroke) {\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${(0, $a2eTA.Color).shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${(0, $a2eTA.Color).shared.setValue(stroke.color).toHex()}`,\n        \"paint-order: stroke\"\n    ].join(\";\");\n}\nconst $891e077217b1b85f$var$templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`\n};\nconst $891e077217b1b85f$var$transform = {\n    fill: (value)=>`color: ${(0, $a2eTA.Color).shared.setValue(value).toHex()}`,\n    breakWords: (value)=>`word-wrap: ${value ? \"break-all\" : \"break-word\"}`,\n    stroke: $891e077217b1b85f$var$strokeToCSS,\n    dropShadow: $891e077217b1b85f$var$dropShadowToCSS\n};\nfunction $891e077217b1b85f$var$tagStyleToCSS(tagStyles, out) {\n    for(const i in tagStyles){\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n        for(const j in tagStyle){\n            if ($891e077217b1b85f$var$transform[j]) cssTagStyle.push($891e077217b1b85f$var$transform[j](tagStyle[j]));\n            else if ($891e077217b1b85f$var$templates[j]) cssTagStyle.push($891e077217b1b85f$var$templates[j].replace(\"{{VALUE}}\", tagStyle[j]));\n        }\n        out.push(`${i} { ${cssTagStyle.join(\";\")} }`);\n    }\n}\n\n});\n\n\nparcelRegister(\"4n9ps\", function(module, exports) {\n\n$parcel$export(module.exports, \"extractFontFamilies\", () => $e590b2205fe17cfb$export$464e4dcbf779d16c);\n\"use strict\";\nfunction $e590b2205fe17cfb$export$464e4dcbf779d16c(text, style) {\n    const fontFamily = style.fontFamily;\n    const fontFamilies = [];\n    const dedupe = {};\n    const regex = /font-family:([^;\"\\s]+)/g;\n    const matches = text.match(regex);\n    function addFontFamily(fontFamily2) {\n        if (!dedupe[fontFamily2]) {\n            fontFamilies.push(fontFamily2);\n            dedupe[fontFamily2] = true;\n        }\n    }\n    if (Array.isArray(fontFamily)) for(let i = 0; i < fontFamily.length; i++)addFontFamily(fontFamily[i]);\n    else addFontFamily(fontFamily);\n    if (matches) matches.forEach((match)=>{\n        const fontFamily2 = match.split(\":\")[1].trim();\n        addFontFamily(fontFamily2);\n    });\n    for(const i in style.tagStyles){\n        const fontFamily2 = style.tagStyles[i].fontFamily;\n        addFontFamily(fontFamily2);\n    }\n    return fontFamilies;\n}\n\n});\n\nparcelRegister(\"4He3o\", function(module, exports) {\n\n$parcel$export(module.exports, \"getFontCss\", () => $e10fa454ed748556$export$634b39f5e6e8534d);\n\nvar $2IhKp = parcelRequire(\"2IhKp\");\n\nvar $4gc1a = parcelRequire(\"4gc1a\");\n\"use strict\";\nconst $e10fa454ed748556$export$9b6075a0351ad0f8 = /* @__PURE__ */ new Map();\nasync function $e10fa454ed748556$export$634b39f5e6e8534d(fontFamilies, style, defaultOptions) {\n    const fontPromises = fontFamilies.filter((fontFamily)=>(0, $2IhKp.Cache).has(`${fontFamily}-and-url`)).map((fontFamily, i)=>{\n        if (!$e10fa454ed748556$export$9b6075a0351ad0f8.has(fontFamily)) {\n            const { url: url } = (0, $2IhKp.Cache).get(`${fontFamily}-and-url`);\n            if (i === 0) $e10fa454ed748556$export$9b6075a0351ad0f8.set(fontFamily, (0, $4gc1a.loadFontCSS)(style, url));\n            else $e10fa454ed748556$export$9b6075a0351ad0f8.set(fontFamily, (0, $4gc1a.loadFontCSS)({\n                fontWeight: defaultOptions.fontWeight,\n                fontStyle: defaultOptions.fontStyle,\n                fontFamily: fontFamily\n            }, url));\n        }\n        return $e10fa454ed748556$export$9b6075a0351ad0f8.get(fontFamily);\n    });\n    return (await Promise.all(fontPromises)).join(\"\\n\");\n}\n\n});\nparcelRegister(\"4gc1a\", function(module, exports) {\n\n$parcel$export(module.exports, \"loadFontCSS\", () => $b2fd88ccbe9e838b$export$d5a8e182a5491db2);\n\nvar $e72s4 = parcelRequire(\"e72s4\");\n\"use strict\";\nasync function $b2fd88ccbe9e838b$export$d5a8e182a5491db2(style, url) {\n    const dataSrc = await (0, $e72s4.loadFontAsBase64)(url);\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\n});\nparcelRegister(\"e72s4\", function(module, exports) {\n\n$parcel$export(module.exports, \"loadFontAsBase64\", () => $212d11a0b2e57b9f$export$21404a5ba2126552);\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\"use strict\";\nasync function $212d11a0b2e57b9f$export$21404a5ba2126552(url) {\n    const response = await (0, $iCGeI.DOMAdapter).get().fetch(url);\n    const blob = await response.blob();\n    const reader = new FileReader();\n    const dataSrc = await new Promise((resolve, reject)=>{\n        reader.onloadend = ()=>resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n    return dataSrc;\n}\n\n});\n\n\n\nparcelRegister(\"lT5va\", function(module, exports) {\n\n$parcel$export(module.exports, \"getSVGUrl\", () => $9b8d4f16b0cabdb3$export$98b744dca5b9429f);\n\"use strict\";\nfunction $9b8d4f16b0cabdb3$export$98b744dca5b9429f(text, style, resolution, fontCSS, htmlTextData) {\n    const { domElement: domElement, styleElement: styleElement, svgRoot: svgRoot } = htmlTextData;\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n    domElement.setAttribute(\"style\", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n    const { width: width, height: height } = htmlTextData.image;\n    svgRoot.setAttribute(\"width\", width.toString());\n    svgRoot.setAttribute(\"height\", height.toString());\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n\n});\n\nparcelRegister(\"2ir1m\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTemporaryCanvasFromImage\", () => $42569c927ab701bc$export$d871fed544c30b4e);\n\nvar $6RGCN = parcelRequire(\"6RGCN\");\n\"use strict\";\nfunction $42569c927ab701bc$export$d871fed544c30b4e(image, resolution) {\n    const canvasAndContext = (0, $6RGCN.CanvasPool).getOptimalCanvasAndContext(image.width, image.height, resolution);\n    const { context: context } = canvasAndContext;\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n    (0, $6RGCN.CanvasPool).returnCanvasAndContext(canvasAndContext);\n    return canvasAndContext.canvas;\n}\n\n});\n\nparcelRegister(\"1VDyN\", function(module, exports) {\n\n$parcel$export(module.exports, \"loadSVGImage\", () => $eec64bea0a1a7a3b$export$31cf685397f1a12a);\n\"use strict\";\nfunction $eec64bea0a1a7a3b$export$31cf685397f1a12a(image, url, delay) {\n    return new Promise(async (resolve)=>{\n        if (delay) await new Promise((resolve2)=>setTimeout(resolve2, 100));\n        image.onload = ()=>{\n            resolve();\n        };\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = \"anonymous\";\n    });\n}\n\n});\n\nparcelRegister(\"8z3uC\", function(module, exports) {\n\n$parcel$export(module.exports, \"measureHtmlText\", () => $1346f45679b49b72$export$9df7f2a259800030);\n\nvar $wLFHs = parcelRequire(\"wLFHs\");\n\nvar $38D3N = parcelRequire(\"38D3N\");\n\"use strict\";\nlet $1346f45679b49b72$var$tempHTMLTextRenderData;\nfunction $1346f45679b49b72$export$9df7f2a259800030(text, style, fontStyleCSS, htmlTextRenderData) {\n    htmlTextRenderData = htmlTextRenderData || $1346f45679b49b72$var$tempHTMLTextRenderData || ($1346f45679b49b72$var$tempHTMLTextRenderData = new (0, $38D3N.HTMLTextRenderData)());\n    const { domElement: domElement, styleElement: styleElement, svgRoot: svgRoot } = htmlTextRenderData;\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n    domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n    if (fontStyleCSS) styleElement.textContent = fontStyleCSS;\n    document.body.appendChild(svgRoot);\n    const contentBounds = domElement.getBoundingClientRect();\n    svgRoot.remove();\n    const descenderPadding = (0, $wLFHs.CanvasTextMetrics).measureFont(style.fontStyle).descent;\n    return {\n        width: contentBounds.width,\n        height: contentBounds.height + descenderPadding\n    };\n}\n\n});\n\n\n\nparcelRegister(\"jbAJT\", function(module, exports) {\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $boJto = parcelRequire(\"boJto\");\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $boJto.TilingSpritePipe));\n\n});\nparcelRegister(\"boJto\", function(module, exports) {\n\n$parcel$export(module.exports, \"TilingSpritePipe\", () => $877b600b00add877$export$b56051ebf906ec5d);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $2Aebl = parcelRequire(\"2Aebl\");\n\nvar $2bK9z = parcelRequire(\"2bK9z\");\n\nvar $6B0gZ = parcelRequire(\"6B0gZ\");\n\nvar $72TA5 = parcelRequire(\"72TA5\");\n\nvar $8jdbq = parcelRequire(\"8jdbq\");\n\nvar $jWUuA = parcelRequire(\"jWUuA\");\n\nvar $gKZ05 = parcelRequire(\"gKZ05\");\n\nvar $eomSC = parcelRequire(\"eomSC\");\n\nvar $abfr9 = parcelRequire(\"abfr9\");\n\"use strict\";\nconst $877b600b00add877$var$sharedQuad = new (0, $gKZ05.QuadGeometry)();\nclass $877b600b00add877$export$b56051ebf906ec5d {\n    constructor(renderer){\n        this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    validateRenderable(renderable) {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n        const couldBatch = tilingSpriteData.canBatch;\n        this._updateCanBatch(renderable);\n        const canBatch = tilingSpriteData.canBatch;\n        if (canBatch && canBatch === couldBatch) {\n            const { batchableMesh: batchableMesh } = tilingSpriteData;\n            if (batchableMesh.texture._source !== renderable.texture._source) return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n        }\n        return couldBatch !== canBatch;\n    }\n    addRenderable(tilingSprite, instructionSet) {\n        const batcher = this._renderer.renderPipes.batch;\n        this._updateCanBatch(tilingSprite);\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n        const { geometry: geometry, canBatch: canBatch } = tilingSpriteData;\n        if (canBatch) {\n            tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new (0, $72TA5.BatchableMesh)());\n            const batchableMesh = tilingSpriteData.batchableMesh;\n            if (tilingSprite._didTilingSpriteUpdate) {\n                tilingSprite._didTilingSpriteUpdate = false;\n                this._updateBatchableMesh(tilingSprite);\n                batchableMesh.geometry = geometry;\n                batchableMesh.mesh = tilingSprite;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n            batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n            batcher.addToBatch(batchableMesh);\n        } else {\n            batcher.break(instructionSet);\n            tilingSpriteData.shader || (tilingSpriteData.shader = new (0, $jWUuA.TilingSpriteShader)());\n            this.updateRenderable(tilingSprite);\n            instructionSet.add(tilingSprite);\n        }\n    }\n    execute(tilingSprite) {\n        const { shader: shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n        const localUniforms = shader.resources.localUniforms.uniforms;\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n        (0, $6B0gZ.color32BitToUniform)(tilingSprite.groupColorAlpha, localUniforms.uColor, 0);\n        this._renderer.encoder.draw({\n            geometry: $877b600b00add877$var$sharedQuad,\n            shader: shader,\n            state: (0, $2Aebl.State).default2d\n        });\n    }\n    updateRenderable(tilingSprite) {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n        const { canBatch: canBatch } = tilingSpriteData;\n        if (canBatch) {\n            const { batchableMesh: batchableMesh } = tilingSpriteData;\n            if (tilingSprite._didTilingSpriteUpdate) this._updateBatchableMesh(tilingSprite);\n            batchableMesh.batcher.updateElement(batchableMesh);\n        } else if (tilingSprite._didTilingSpriteUpdate) {\n            const { shader: shader } = tilingSpriteData;\n            shader.updateUniforms(tilingSprite.width, tilingSprite.height, tilingSprite._tileTransform.matrix, tilingSprite.anchor.x, tilingSprite.anchor.y, tilingSprite.texture);\n        }\n        tilingSprite._didTilingSpriteUpdate = false;\n    }\n    destroyRenderable(tilingSprite) {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n        tilingSpriteData.batchableMesh = null;\n        tilingSpriteData.shader?.destroy();\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n    }\n    _getTilingSpriteData(renderable) {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n    _initTilingSpriteData(tilingSprite) {\n        const geometry = new (0, $8jdbq.MeshGeometry)({\n            indices: $877b600b00add877$var$sharedQuad.indices,\n            positions: $877b600b00add877$var$sharedQuad.positions.slice(),\n            uvs: $877b600b00add877$var$sharedQuad.uvs.slice()\n        });\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry: geometry\n        };\n        tilingSprite.on(\"destroyed\", ()=>{\n            this.destroyRenderable(tilingSprite);\n        });\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n    _updateBatchableMesh(tilingSprite) {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const { geometry: geometry } = renderableData;\n        const style = tilingSprite.texture.source.style;\n        if (style.addressMode !== \"repeat\") {\n            style.addressMode = \"repeat\";\n            style.update();\n        }\n        (0, $abfr9.setUvs)(tilingSprite, geometry.uvs);\n        (0, $eomSC.setPositions)(tilingSprite, geometry.positions);\n    }\n    destroy() {\n        for(const i in this._tilingSpriteDataHash)this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        this._tilingSpriteDataHash = null;\n        this._renderer = null;\n    }\n    _updateCanBatch(tilingSprite) {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n        let _nonPowOf2wrapping = true;\n        if (this._renderer.type === (0, $2bK9z.RendererType).WEBGL) _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n        return renderableData.canBatch;\n    }\n}\n/** @ignore */ $877b600b00add877$export$b56051ebf906ec5d.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLPipes,\n        (0, $i9BKe.ExtensionType).WebGPUPipes,\n        (0, $i9BKe.ExtensionType).CanvasPipes\n    ],\n    name: \"tilingSprite\"\n};\n\n});\nparcelRegister(\"jWUuA\", function(module, exports) {\n\n$parcel$export(module.exports, \"TilingSpriteShader\", () => $9e5ad752c25c114f$export$d1a26cc57b383809);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $3JBHn = parcelRequire(\"3JBHn\");\n\nvar $huPGn = parcelRequire(\"huPGn\");\n\nvar $kSpdC = parcelRequire(\"kSpdC\");\n\nvar $5iDyo = parcelRequire(\"5iDyo\");\n\nvar $cryyq = parcelRequire(\"cryyq\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $8CB2b = parcelRequire(\"8CB2b\");\n\"use strict\";\nlet $9e5ad752c25c114f$var$gpuProgram;\nlet $9e5ad752c25c114f$var$glProgram;\nclass $9e5ad752c25c114f$export$d1a26cc57b383809 extends (0, $5iDyo.Shader) {\n    constructor(){\n        $9e5ad752c25c114f$var$gpuProgram ?? ($9e5ad752c25c114f$var$gpuProgram = (0, $3JBHn.compileHighShaderGpuProgram)({\n            name: \"tiling-sprite-shader\",\n            bits: [\n                (0, $huPGn.localUniformBit),\n                (0, $8CB2b.tilingBit),\n                (0, $kSpdC.roundPixelsBit)\n            ]\n        }));\n        $9e5ad752c25c114f$var$glProgram ?? ($9e5ad752c25c114f$var$glProgram = (0, $3JBHn.compileHighShaderGlProgram)({\n            name: \"tiling-sprite-shader\",\n            bits: [\n                (0, $huPGn.localUniformBitGl),\n                (0, $8CB2b.tilingBitGl),\n                (0, $kSpdC.roundPixelsBitGl)\n            ]\n        }));\n        const tilingUniforms = new (0, $cryyq.UniformGroup)({\n            uMapCoord: {\n                value: new (0, $eY4rt.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uClampFrame: {\n                value: new Float32Array([\n                    0,\n                    0,\n                    1,\n                    1\n                ]),\n                type: \"vec4<f32>\"\n            },\n            uClampOffset: {\n                value: new Float32Array([\n                    0,\n                    0\n                ]),\n                type: \"vec2<f32>\"\n            },\n            uTextureTransform: {\n                value: new (0, $eY4rt.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uSizeAnchor: {\n                value: new Float32Array([\n                    100,\n                    100,\n                    0.5,\n                    0.5\n                ]),\n                type: \"vec4<f32>\"\n            }\n        });\n        super({\n            glProgram: $9e5ad752c25c114f$var$glProgram,\n            gpuProgram: $9e5ad752c25c114f$var$gpuProgram,\n            resources: {\n                localUniforms: new (0, $cryyq.UniformGroup)({\n                    uTransformMatrix: {\n                        value: new (0, $eY4rt.Matrix)(),\n                        type: \"mat3x3<f32>\"\n                    },\n                    uColor: {\n                        value: new Float32Array([\n                            1,\n                            1,\n                            1,\n                            1\n                        ]),\n                        type: \"vec4<f32>\"\n                    },\n                    uRound: {\n                        value: 0,\n                        type: \"f32\"\n                    }\n                }),\n                tilingUniforms: tilingUniforms,\n                uTexture: (0, $bLlTJ.Texture).EMPTY.source,\n                uSampler: (0, $bLlTJ.Texture).EMPTY.source.style\n            }\n        });\n    }\n    updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n        const tilingUniforms = this.resources.tilingUniforms;\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n        uTextureTransform.set(matrix.a * textureWidth / width, matrix.b * textureWidth / height, matrix.c * textureHeight / width, matrix.d * textureHeight / height, matrix.tx / width, matrix.ty / height);\n        uTextureTransform.invert();\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n        if (texture) {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n\n});\nparcelRegister(\"8CB2b\", function(module, exports) {\n\n$parcel$export(module.exports, \"tilingBit\", () => $968261c072b57756$export$7551c6773b6af70d);\n$parcel$export(module.exports, \"tilingBitGl\", () => $968261c072b57756$export$a104558c66046525);\n\"use strict\";\nconst $968261c072b57756$export$7551c6773b6af70d = {\n    name: \"tiling-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */ `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */ `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */ `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n};\nconst $968261c072b57756$export$a104558c66046525 = {\n    name: \"tiling-bit\",\n    vertex: {\n        header: /* glsl */ `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */ `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */ `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */ `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n};\n\n});\n\n\nparcelRegister(\"gKZ05\", function(module, exports) {\n\n$parcel$export(module.exports, \"QuadGeometry\", () => $8efbb87deaee95b8$export$d27e254c8c1b5a0e);\n\nvar $8jdbq = parcelRequire(\"8jdbq\");\n\"use strict\";\nclass $8efbb87deaee95b8$export$d27e254c8c1b5a0e extends (0, $8jdbq.MeshGeometry) {\n    constructor(){\n        super({\n            positions: new Float32Array([\n                0,\n                0,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1\n            ]),\n            uvs: new Float32Array([\n                0,\n                0,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1\n            ]),\n            indices: new Uint32Array([\n                0,\n                1,\n                2,\n                0,\n                2,\n                3\n            ])\n        });\n    }\n}\n\n});\n\nparcelRegister(\"eomSC\", function(module, exports) {\n\n$parcel$export(module.exports, \"setPositions\", () => $91fe1eed38103067$export$7d390d1e3efa819a);\n\"use strict\";\nfunction $91fe1eed38103067$export$7d390d1e3efa819a(tilingSprite, positions) {\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\n});\n\nparcelRegister(\"abfr9\", function(module, exports) {\n\n$parcel$export(module.exports, \"setUvs\", () => $2b8cdf8bb9c2c4d7$export$f99a1f47283a6d20);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $64pcG = parcelRequire(\"64pcG\");\n\"use strict\";\nfunction $2b8cdf8bb9c2c4d7$export$f99a1f47283a6d20(tilingSprite, uvs) {\n    const texture = tilingSprite.texture;\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n    let anchorX = 0;\n    let anchorY = 0;\n    if (tilingSprite._applyAnchorToTexture) {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n    const textureMatrix = (0, $eY4rt.Matrix).shared;\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n    textureMatrix.invert();\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n    (0, $64pcG.applyMatrix)(uvs, 2, 0, textureMatrix);\n}\n\n});\nparcelRegister(\"64pcG\", function(module, exports) {\n\n$parcel$export(module.exports, \"applyMatrix\", () => $7c4d06e5b7dad575$export$8e14504c3429ee65);\n\"use strict\";\nfunction $7c4d06e5b7dad575$export$8e14504c3429ee65(array, stride, offset, matrix) {\n    let index = 0;\n    const size = array.length / (stride || 2);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    offset *= stride;\n    while(index < size){\n        const x = array[offset];\n        const y = array[offset + 1];\n        array[offset] = a * x + c * y + tx;\n        array[offset + 1] = b * x + d * y + ty;\n        offset += stride;\n        index++;\n    }\n}\n\n});\n\n\n\n\nparcelRegister(\"3WtzG\", function(module, exports) {\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $bGvgZ = parcelRequire(\"bGvgZ\");\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $bGvgZ.NineSliceSpritePipe));\n\n});\nparcelRegister(\"bGvgZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"NineSliceSpritePipe\", () => $6a89a429372cfe88$export$69030e8b070eaa80);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $61KiY = parcelRequire(\"61KiY\");\n\nvar $72TA5 = parcelRequire(\"72TA5\");\n\nvar $hIpDK = parcelRequire(\"hIpDK\");\n\"use strict\";\nclass $6a89a429372cfe88$export$69030e8b070eaa80 {\n    constructor(renderer){\n        this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    addRenderable(sprite, _instructionSet) {\n        const gpuSprite = this._getGpuSprite(sprite);\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n    }\n    updateRenderable(sprite) {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n        gpuSprite.batcher.updateElement(gpuSprite);\n    }\n    validateRenderable(sprite) {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n        if (gpuSprite.texture._source !== texture._source) return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n        return false;\n    }\n    destroyRenderable(sprite) {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n        (0, $61KiY.BigPool).return(batchableSprite);\n        this._gpuSpriteHash[sprite.uid] = null;\n    }\n    _updateBatchableSprite(sprite, batchableSprite) {\n        sprite._didSpriteUpdate = false;\n        batchableSprite.geometry.update(sprite);\n        batchableSprite.texture = sprite._texture;\n    }\n    _getGpuSprite(sprite) {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n    _initGPUSprite(sprite) {\n        const batchableMesh = new (0, $72TA5.BatchableMesh)();\n        batchableMesh.geometry = new (0, $hIpDK.NineSliceGeometry)();\n        batchableMesh.mesh = sprite;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n        sprite.on(\"destroyed\", ()=>{\n            this.destroyRenderable(sprite);\n        });\n        return batchableMesh;\n    }\n    destroy() {\n        for(const i in this._gpuSpriteHash){\n            const batchableMesh = this._gpuSpriteHash[i];\n            batchableMesh.geometry.destroy();\n        }\n        this._gpuSpriteHash = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $6a89a429372cfe88$export$69030e8b070eaa80.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLPipes,\n        (0, $i9BKe.ExtensionType).WebGPUPipes,\n        (0, $i9BKe.ExtensionType).CanvasPipes\n    ],\n    name: \"nineSliceSprite\"\n};\n\n});\n\n\nparcelRegister(\"3v0XG\", function(module, exports) {\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $fVpPG = parcelRequire(\"fVpPG\");\n\nvar $6k8LM = parcelRequire(\"6k8LM\");\n\"use strict\";\n(0, $i9BKe.extensions).add((0, $6k8LM.FilterSystem));\n(0, $i9BKe.extensions).add((0, $fVpPG.FilterPipe));\n\n});\nparcelRegister(\"fVpPG\", function(module, exports) {\n\n$parcel$export(module.exports, \"FilterPipe\", () => $f5c2b3c7c7673802$export$26a654548ff780c7);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\nclass $f5c2b3c7c7673802$export$26a654548ff780c7 {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    push(filterEffect, container, instructionSet) {\n        const renderPipes = this._renderer.renderPipes;\n        renderPipes.batch.break(instructionSet);\n        instructionSet.add({\n            renderPipeId: \"filter\",\n            canBundle: false,\n            action: \"pushFilter\",\n            container: container,\n            filterEffect: filterEffect\n        });\n    }\n    pop(_filterEffect, _container, instructionSet) {\n        this._renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add({\n            renderPipeId: \"filter\",\n            action: \"popFilter\",\n            canBundle: false\n        });\n    }\n    execute(instruction) {\n        if (instruction.action === \"pushFilter\") this._renderer.filter.push(instruction);\n        else if (instruction.action === \"popFilter\") this._renderer.filter.pop();\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n$f5c2b3c7c7673802$export$26a654548ff780c7.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLPipes,\n        (0, $i9BKe.ExtensionType).WebGPUPipes,\n        (0, $i9BKe.ExtensionType).CanvasPipes\n    ],\n    name: \"filter\"\n};\n\n});\n\nparcelRegister(\"6k8LM\", function(module, exports) {\n\n$parcel$export(module.exports, \"FilterSystem\", () => $bad2f65b6eb67e91$export$e94225c0dfac29cf);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $1HooC = parcelRequire(\"1HooC\");\n\nvar $awcfo = parcelRequire(\"awcfo\");\n\nvar $cOnev = parcelRequire(\"cOnev\");\n\nvar $cryyq = parcelRequire(\"cryyq\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $3Xbp7 = parcelRequire(\"3Xbp7\");\n\nvar $2bK9z = parcelRequire(\"2bK9z\");\n\nvar $7wtv9 = parcelRequire(\"7wtv9\");\n\nvar $34O3h = parcelRequire(\"34O3h\");\n\nvar $almkH = parcelRequire(\"almkH\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\"use strict\";\nconst $bad2f65b6eb67e91$var$quadGeometry = new (0, $cOnev.Geometry)({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([\n                0,\n                0,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1\n            ]),\n            location: 0,\n            format: \"float32x2\",\n            stride: 8,\n            offset: 0\n        }\n    },\n    indexBuffer: new Uint32Array([\n        0,\n        1,\n        2,\n        0,\n        2,\n        3\n    ])\n});\nclass $bad2f65b6eb67e91$export$e94225c0dfac29cf {\n    constructor(renderer){\n        this._filterStackIndex = 0;\n        this._filterStack = [];\n        this._filterGlobalUniforms = new (0, $cryyq.UniformGroup)({\n            uInputSize: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uInputPixel: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uInputClamp: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uOutputFrame: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uGlobalFrame: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uOutputTexture: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            }\n        });\n        this._globalFilterBindGroup = new (0, $awcfo.BindGroup)({});\n        this.renderer = renderer;\n    }\n    /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */ get activeBackTexture() {\n        return this._activeFilterData?.backTexture;\n    }\n    push(instruction) {\n        const renderer = this.renderer;\n        const filters = instruction.filterEffect.filters;\n        if (!this._filterStack[this._filterStackIndex]) this._filterStack[this._filterStackIndex] = this._getFilterData();\n        const filterData = this._filterStack[this._filterStackIndex];\n        this._filterStackIndex++;\n        if (filters.length === 0) {\n            filterData.skip = true;\n            return;\n        }\n        const bounds = filterData.bounds;\n        if (instruction.renderables) (0, $almkH.getGlobalRenderableBounds)(instruction.renderables, bounds);\n        else if (instruction.filterEffect.filterArea) {\n            bounds.clear();\n            bounds.addRect(instruction.filterEffect.filterArea);\n            bounds.applyMatrix(instruction.container.worldTransform);\n        } else (0, $34O3h.getFastGlobalBounds)(instruction.container, bounds);\n        const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n        let resolution = colorTextureSource._resolution;\n        let padding = 0;\n        let antialias = colorTextureSource.antialias;\n        let blendRequired = false;\n        let enabled = false;\n        for(let i = 0; i < filters.length; i++){\n            const filter = filters[i];\n            resolution = Math.min(resolution, filter.resolution);\n            padding += filter.padding;\n            if (filter.antialias !== \"inherit\") {\n                if (filter.antialias === \"on\") antialias = true;\n                else antialias = false;\n            }\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n            if (!isCompatible) {\n                enabled = false;\n                break;\n            }\n            if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n                (0, $hUCK4.warn)(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n                enabled = false;\n                break;\n            }\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n        if (!enabled) {\n            filterData.skip = true;\n            return;\n        }\n        const viewPort = renderer.renderTarget.rootViewPort;\n        bounds.scale(resolution).fitBounds(0, viewPort.width, 0, viewPort.height).scale(1 / resolution).pad(padding).ceil();\n        if (!bounds.isPositive) {\n            filterData.skip = true;\n            return;\n        }\n        filterData.skip = false;\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n        filterData.inputTexture = (0, $3Xbp7.TexturePool).getOptimalTexture(bounds.width, bounds.height, resolution, antialias);\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        renderer.globalUniforms.push({\n            offset: bounds\n        });\n    }\n    pop() {\n        const renderer = this.renderer;\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n        if (filterData.skip) return;\n        this._activeFilterData = filterData;\n        const inputTexture = filterData.inputTexture;\n        const bounds = filterData.bounds;\n        let backTexture = (0, $bLlTJ.Texture).EMPTY;\n        renderer.renderTarget.finishRenderPass();\n        if (filterData.blendRequired) {\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n        filterData.backTexture = backTexture;\n        const filters = filterData.filterEffect.filters;\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n        renderer.globalUniforms.pop();\n        if (filters.length === 1) {\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n            (0, $3Xbp7.TexturePool).returnTexture(inputTexture);\n        } else {\n            let flip = filterData.inputTexture;\n            let flop = (0, $3Xbp7.TexturePool).getOptimalTexture(bounds.width, bounds.height, flip.source._resolution, false);\n            let i = 0;\n            for(i = 0; i < filters.length - 1; ++i){\n                const filter = filters[i];\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n                flip = flop;\n                flop = t;\n            }\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n            (0, $3Xbp7.TexturePool).returnTexture(flip);\n            (0, $3Xbp7.TexturePool).returnTexture(flop);\n        }\n        if (filterData.blendRequired) (0, $3Xbp7.TexturePool).returnTexture(backTexture);\n    }\n    getBackTexture(lastRenderSurface, bounds, previousBounds) {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n        const backTexture = (0, $3Xbp7.TexturePool).getOptimalTexture(bounds.width, bounds.height, backgroundResolution, false);\n        let x = bounds.minX;\n        let y = bounds.minY;\n        if (previousBounds) {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n        this.renderer.renderTarget.copyToTexture(lastRenderSurface, backTexture, {\n            x: x,\n            y: y\n        }, {\n            width: width,\n            height: height\n        }, {\n            x: 0,\n            y: 0\n        });\n        return backTexture;\n    }\n    applyFilter(filter, input, output, clear) {\n        const renderer = this.renderer;\n        const filterData = this._filterStack[this._filterStackIndex];\n        const bounds = filterData.bounds;\n        const offset = (0, $1HooC.Point).shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n        const isFinalTarget = previousRenderSurface === output;\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n        let currentIndex = this._filterStackIndex - 1;\n        while(currentIndex > 0 && this._filterStack[currentIndex].skip)--currentIndex;\n        if (currentIndex > 0) resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n        if (isFinalTarget) {\n            let lastIndex = this._filterStackIndex;\n            while(lastIndex > 0){\n                lastIndex--;\n                const filterData2 = this._filterStack[this._filterStackIndex - 1];\n                if (!filterData2.skip) {\n                    offset.x = filterData2.bounds.minX;\n                    offset.y = filterData2.bounds.minY;\n                    break;\n                }\n            }\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        } else {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1 / inputPixel[0];\n        inputPixel[3] = 1 / inputPixel[1];\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n        inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n        renderer.renderTarget.bind(output, !!clear);\n        if (output instanceof (0, $bLlTJ.Texture)) {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        } else {\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n        if (renderer.renderPipes.uniformBatch) {\n            const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        } else this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n        filter.groups[0] = this._globalFilterBindGroup;\n        renderer.encoder.draw({\n            geometry: $bad2f65b6eb67e91$var$quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: \"triangle-list\"\n        });\n        if (renderer.type === (0, $2bK9z.RendererType).WEBGL) renderer.renderTarget.finishRenderPass();\n    }\n    _getFilterData() {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new (0, $7wtv9.Bounds)(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null\n        };\n    }\n    /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */ calculateSpriteMatrix(outputMatrix, sprite) {\n        const data = this._activeFilterData;\n        const mappedMatrix = outputMatrix.set(data.inputTexture._source.width, 0, 0, data.inputTexture._source.height, data.bounds.minX, data.bounds.minY);\n        const worldTransform = sprite.worldTransform.copyTo((0, $eY4rt.Matrix).shared);\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(1 / sprite.texture.frame.width, 1 / sprite.texture.frame.height);\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n        return mappedMatrix;\n    }\n}\n/** @ignore */ $bad2f65b6eb67e91$export$e94225c0dfac29cf.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem,\n        (0, $i9BKe.ExtensionType).WebGPUSystem\n    ],\n    name: \"filter\"\n};\n\n});\nparcelRegister(\"34O3h\", function(module, exports) {\n\n$parcel$export(module.exports, \"getFastGlobalBounds\", () => $0b3ff78e821417cf$export$ec3cb2102fa5391a);\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $5tmC8 = parcelRequire(\"5tmC8\");\n\"use strict\";\nconst $0b3ff78e821417cf$var$tempMatrix = new (0, $eY4rt.Matrix)();\nfunction $0b3ff78e821417cf$export$ec3cb2102fa5391a(target, bounds) {\n    bounds.clear();\n    $0b3ff78e821417cf$export$b7169265e2c9b9ba(target, bounds);\n    if (!bounds.isValid) bounds.set(0, 0, 0, 0);\n    if (!target.isRenderGroupRoot) bounds.applyMatrix(target.renderGroup.worldTransform);\n    else bounds.applyMatrix(target.renderGroup.localTransform);\n    return bounds;\n}\nfunction $0b3ff78e821417cf$export$b7169265e2c9b9ba(target, bounds) {\n    if (target.localDisplayStatus !== 7 || !target.measurable) return;\n    const manageEffects = !!target.effects.length;\n    let localBounds = bounds;\n    if (target.isRenderGroupRoot || manageEffects) localBounds = (0, $5tmC8.boundsPool).get().clear();\n    if (target.boundsArea) bounds.addRect(target.boundsArea, target.worldTransform);\n    else {\n        if (target.renderPipeId) {\n            const viewBounds = target.bounds;\n            localBounds.addFrame(viewBounds.minX, viewBounds.minY, viewBounds.maxX, viewBounds.maxY, target.groupTransform);\n        }\n        const children = target.children;\n        for(let i = 0; i < children.length; i++)$0b3ff78e821417cf$export$b7169265e2c9b9ba(children[i], localBounds);\n    }\n    if (manageEffects) {\n        let advanced = false;\n        for(let i = 0; i < target.effects.length; i++)if (target.effects[i].addBounds) {\n            if (!advanced) {\n                advanced = true;\n                localBounds.applyMatrix(target.renderGroup.worldTransform);\n            }\n            target.effects[i].addBounds(localBounds, true);\n        }\n        if (advanced) {\n            localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo($0b3ff78e821417cf$var$tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n        bounds.addBounds(localBounds);\n        (0, $5tmC8.boundsPool).return(localBounds);\n    } else if (target.isRenderGroupRoot) {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        (0, $5tmC8.boundsPool).return(localBounds);\n    }\n}\n\n});\n\nparcelRegister(\"almkH\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGlobalRenderableBounds\", () => $1b7255a412b4bb69$export$11abb8ef28048394);\n\"use strict\";\nfunction $1b7255a412b4bb69$export$11abb8ef28048394(renderables, bounds) {\n    bounds.clear();\n    const tempMatrix = bounds.matrix;\n    for(let i = 0; i < renderables.length; i++){\n        const renderable = renderables[i];\n        if (renderable.globalDisplayStatus < 7) continue;\n        bounds.matrix = renderable.worldTransform;\n        renderable.addBounds(bounds);\n    }\n    bounds.matrix = tempMatrix;\n    return bounds;\n}\n\n});\n\n\n\n\n//# sourceMappingURL=browserAll.abfd9ec1.js.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { ResizePlugin } from './ResizePlugin.mjs';\nimport { TickerPlugin } from './TickerPlugin.mjs';\n\n\"use strict\";\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      \"resizeTo\",\n      /**\n       * The HTML element or window to automatically resize the\n       * renderer's view element to match width and height.\n       * @member {Window|HTMLElement}\n       * @name resizeTo\n       * @memberof app.Application#\n       */\n      {\n        set(dom) {\n          globalThis.removeEventListener(\"resize\", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener(\"resize\", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @static\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener(\"resize\", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = ExtensionType.Application;\n\nexport { ResizePlugin };\n//# sourceMappingURL=ResizePlugin.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { UPDATE_PRIORITY } from '../ticker/const.mjs';\nimport { Ticker } from '../ticker/Ticker.mjs';\n\n\"use strict\";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      \"ticker\",\n      {\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @static\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = ExtensionType.Application;\n\nexport { TickerPlugin };\n//# sourceMappingURL=TickerPlugin.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPluginOptions}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem.mjs';\nimport { GraphicsPipe } from './shared/GraphicsPipe.mjs';\n\n\"use strict\";\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../gpu/colorToUniform.mjs';\nimport { BatchableGraphics } from './BatchableGraphics.mjs';\n\n\"use strict\";\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    // batchable graphics list, used to render batches\n    this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics._didGraphicsUpdate) {\n      graphics._didGraphicsUpdate = false;\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const batches = this._graphicsBatchesHash[graphics.uid];\n    if (batches) {\n      for (let i = 0; i < batches.length; i++) {\n        const batch = batches[i];\n        batch.batcher.updateElement(batch);\n      }\n    }\n  }\n  destroyRenderable(graphics) {\n    if (this._graphicsBatchesHash[graphics.uid]) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    color32BitToUniform(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (wasBatched) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n    if (gpuContext.isBatchable) {\n      this._initBatchesForRenderable(graphics);\n    }\n    graphics.batched = gpuContext.isBatchable;\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getBatchesForRenderable(graphics);\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getBatchesForRenderable(graphics) {\n    return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n  }\n  _initBatchesForRenderable(graphics) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    const batches = gpuContext.batches.map((batch) => {\n      const batchClone = BigPool.get(BatchableGraphics);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n    this._graphicsBatchesHash[graphics.uid] = batches;\n    graphics.on(\"destroyed\", () => {\n      this.destroyRenderable(graphics);\n    });\n    return batches;\n  }\n  _removeBatchForRenderable(graphicsUid) {\n    this._graphicsBatchesHash[graphicsUid].forEach((batch) => {\n      BigPool.return(batch);\n    });\n    this._graphicsBatchesHash[graphicsUid] = null;\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n    for (const i in this._graphicsBatchesHash) {\n      this._removeBatchForRenderable(i);\n    }\n    this._graphicsBatchesHash = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"graphics\"\n};\n\nexport { GraphicsPipe };\n//# sourceMappingURL=GraphicsPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics._didGraphicsUpdate)\n        {\n            graphics._didGraphicsUpdate = false;\n\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch.batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            // TODO pool this!!\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        graphics.on('destroyed', () =>\n        {\n            this.destroyRenderable(graphics);\n        });\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { MeshPipe } from './shared/MeshPipe.mjs';\n\n\"use strict\";\nextensions.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from './BatchableMesh.mjs';\n\n\"use strict\";\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this.localUniformsBindGroup = new BindGroup({\n      0: this.localUniforms\n    });\n    this._meshDataHash = /* @__PURE__ */ Object.create(null);\n    this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      const texture = mesh.texture;\n      if (batchableMesh.texture._source !== texture._source) {\n        if (batchableMesh.texture._source !== texture._source) {\n          return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n        }\n      }\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const { batched } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add({\n        renderPipeId: \"mesh\",\n        mesh\n      });\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  destroyRenderable(mesh) {\n    this._meshDataHash[mesh.uid] = null;\n    const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n    if (gpuMesh) {\n      BigPool.return(gpuMesh);\n      this._gpuBatchableMeshHash[mesh.uid] = null;\n    }\n  }\n  execute({ mesh }) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = mesh.groupBlendMode;\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    color32BitToUniform(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    this._meshDataHash[mesh.uid] = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    mesh.on(\"destroyed\", () => {\n      this.destroyRenderable(mesh);\n    });\n    return this._meshDataHash[mesh.uid];\n  }\n  _getBatchableMesh(mesh) {\n    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = BigPool.get(BatchableMesh);\n    gpuMesh.mesh = mesh;\n    gpuMesh.texture = mesh._texture;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n    gpuMesh.mesh = mesh;\n    return gpuMesh;\n  }\n  destroy() {\n    for (const i in this._gpuBatchableMeshHash) {\n      if (this._gpuBatchableMeshHash[i]) {\n        BigPool.return(this._gpuBatchableMeshHash[i]);\n      }\n    }\n    this._gpuBatchableMeshHash = null;\n    this._meshDataHash = null;\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"mesh\"\n};\n\nexport { MeshPipe };\n//# sourceMappingURL=MeshPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport interface MeshInstruction extends Instruction\n{\n    renderPipeId: 'mesh';\n    mesh: Mesh;\n}\n\n// eslint-disable-next-line max-len\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<MeshInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            const texture = mesh.texture;\n\n            if (batchableMesh.texture._source !== texture._source)\n            {\n                if (batchableMesh.texture._source !== texture._source)\n                {\n                    return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add({\n                renderPipeId: 'mesh',\n                mesh\n            } as MeshInstruction);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n    }\n\n    public execute({ mesh }: MeshInstruction)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = mesh.groupBlendMode;\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', () =>\n        {\n            this.destroyRenderable(mesh);\n        });\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.mesh = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        gpuMesh.mesh = mesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","\"use strict\";\nclass BatchableMesh {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  get blendMode() {\n    return this.mesh.groupBlendMode;\n  }\n  reset() {\n    this.mesh = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometry.indices;\n    for (let i = 0; i < indices.length; i++) {\n      indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const mesh = this.mesh;\n    const geometry = this.geometry;\n    const wt = mesh.groupTransform;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const positions = geometry.positions;\n    const uvBuffer = geometry.getBuffer(\"aUV\");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    const abgr = mesh.groupColorAlpha;\n    for (let i = 0; i < positions.length; i += 2) {\n      const x = positions[i];\n      const y = positions[i + 1];\n      float32View[index] = a * x + c * y + tx;\n      float32View[index + 1] = b * x + d * y + ty;\n      float32View[index + 2] = transformedUvs[i];\n      float32View[index + 3] = transformedUvs[i + 1];\n      uint32View[index + 4] = abgr;\n      uint32View[index + 5] = textureIdAndRound;\n      index += 6;\n    }\n  }\n  get vertexSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\nexport { BatchableMesh };\n//# sourceMappingURL=BatchableMesh.mjs.map\n","import type { Batch, BatchableObject, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Container } from '../../container/Container';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements BatchableObject\n{\n    public indexStart: number;\n    public textureId: number;\n    public texture: Texture;\n    public location: number;\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public mesh: Container;\n    public geometry: MeshGeometry;\n\n    public roundPixels: 0 | 1 = 0;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n    private _textureMatrixUpdateId: number = -1;\n\n    get blendMode() { return this.mesh.groupBlendMode; }\n\n    public reset()\n    {\n        this.mesh = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.geometry.indices;\n\n        for (let i = 0; i < indices.length; i++)\n        {\n            indexBuffer[index++] = indices[i] + indicesOffset;\n        }\n    }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const mesh = this.mesh;\n\n        const geometry = this.geometry;\n        const wt = mesh.groupTransform;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        // const trim = texture.trim;\n        const positions = geometry.positions;\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        const abgr = mesh.groupColorAlpha;\n\n        for (let i = 0; i < positions.length; i += 2)\n        {\n            const x = positions[i];\n            const y = positions[i + 1];\n\n            float32View[index] = (a * x) + (c * y) + tx;\n            float32View[index + 1] = (b * x) + (d * y) + ty;\n\n            // TODO implement texture matrix?\n            float32View[index + 2] = transformedUvs[i];\n            float32View[index + 3] = transformedUvs[i + 1];\n\n            uint32View[index + 4] = abgr;\n            uint32View[index + 5] = textureIdAndRound;\n\n            index += 6;\n        }\n    }\n\n    get vertexSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe.mjs';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem.mjs';\n\n\"use strict\";\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const newKey = text._getKey();\n    if (gpuText.currentKey !== newKey) {\n      const resolution = text.resolution ?? this._renderer.resolution;\n      const { width, height } = this._renderer.canvasText.getTextureSize(\n        text.text,\n        resolution,\n        text._style\n      );\n      if (\n        // is only being used by this text:\n        this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height\n      ) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n  addRenderable(text, _instructionSet) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(text) {\n    this._destroyRenderableById(text.uid);\n  }\n  _destroyRenderableById(textUid) {\n    const gpuText = this._gpuText[textUid];\n    this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    BigPool.return(gpuText.batchableSprite);\n    this._gpuText[textUid] = null;\n  }\n  _updateText(text) {\n    const newKey = text._getKey();\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(text);\n    }\n    text._didTextUpdate = false;\n    const padding = text._style.padding;\n    updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n  }\n  _updateGpuText(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.texture) {\n      this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    }\n    const resolution = text.resolution ?? this._renderer.resolution;\n    gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(\n      text.text,\n      resolution,\n      text._style,\n      text._getKey()\n    );\n    gpuText.currentKey = text._getKey();\n    batchableSprite.texture = gpuText.texture;\n  }\n  _getGpuText(text) {\n    return this._gpuText[text.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const gpuTextData = {\n      texture: null,\n      currentKey: \"--\",\n      batchableSprite: BigPool.get(BatchableSprite)\n    };\n    gpuTextData.batchableSprite.renderable = text;\n    gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    this._gpuText[text.uid] = gpuTextData;\n    this._updateText(text);\n    text.on(\"destroyed\", () => {\n      this.destroyRenderable(text);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"text\"\n};\n\nexport { CanvasTextPipe };\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            const resolution = text.resolution ?? this._renderer.resolution;\n\n            const { width, height } = this._renderer.canvasText.getTextureSize(\n                text.text,\n                resolution,\n                text._style,\n            );\n\n            if (\n                // is only being used by this text:\n                this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1\n                // check the size of the text is the same po2\n                && width === gpuText.texture._source.width\n                && height === gpuText.texture._source.height\n            )\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, _instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        const padding = text._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        const resolution = text.resolution ?? this._renderer.resolution;\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(\n            text.text,\n            resolution,\n            text._style,\n            text._getKey()\n        );\n\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', () =>\n        {\n            this.destroyRenderable(text);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n","import { Color } from '../../../color/Color.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { nextPow2 } from '../../../maths/misc/pow2.mjs';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox.mjs';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource.mjs';\nimport { CanvasTextMetrics } from './CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle.mjs';\n\n\"use strict\";\nclass CanvasTextSystem {\n  constructor() {\n    this._activeTextures = {};\n  }\n  getTextureSize(text, resolution, style) {\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    width = Math.ceil(width - 1e-6);\n    height = Math.ceil(height - 1e-6);\n    width = nextPow2(width);\n    height = nextPow2(height);\n    return { width, height };\n  }\n  getTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n    const { canvas } = canvasAndContext;\n    this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n    const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n    if (style.trim) {\n      const trimmed = getCanvasBoundingBox(canvas, resolution);\n      texture.frame.copyFrom(trimmed);\n      texture.updateUvs();\n    }\n    this._activeTextures[textKey] = {\n      canvasAndContext,\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n      TexturePool.returnTexture(activeTexture.texture);\n      const source = activeTexture.texture.source;\n      source.resource = null;\n      source.uploadMethodId = \"unknown\";\n      source.alphaMode = \"no-premultiply-alpha\";\n      this._activeTextures[textKey] = null;\n    }\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */\n  renderTextToCanvas(text, style, resolution, canvasAndContext) {\n    const { canvas, context } = canvasAndContext;\n    const font = fontStringFromTextStyle(style);\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    context.clearRect(0, 0, measured.width + 4, measured.height + 4);\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = \"black\";\n        context.strokeStyle = \"black\";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.globalAlpha = style._fill?.alpha ?? 1;\n        context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n        if (style._stroke?.width) {\n          context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n        }\n        context.shadowColor = \"black\";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === \"right\") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === \"center\") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText,\n            true\n          );\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText\n          );\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it's for the inside fill\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const { context } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = \"\";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"canvasText\"\n};\n\nexport { CanvasTextSystem };\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n","import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { TextStyle } from '../TextStyle';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string)\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n\n        context.scale(resolution, resolution);\n\n        context.clearRect(0, 0, measured.width + 4, measured.height + 4);\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { Rectangle } from '../../maths/shapes/Rectangle.mjs';\n\n\"use strict\";\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas, resolution = 1) {\n  const { width, height } = canvas;\n  const context = canvas.getContext(\"2d\", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError(\"Failed to get canvas 2D context\");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return Rectangle.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n\nexport { getCanvasBoundingBox };\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n","import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = TexturePool.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = \"image\";\n  texture.source.resource = image;\n  texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit(\"update\", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\nexport { getPo2TextureFromSource };\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient.mjs';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern.mjs';\n\n\"use strict\";\nfunction getCanvasFillStyle(fillStyle, context) {\n  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {\n    return Color.shared.setValue(fillStyle.color).toHex();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, \"repeat\");\n    const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillPattern) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, \"repeat\");\n    const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillGradient) {\n    const fillGradient = fillStyle.fill;\n    if (fillGradient.type === \"linear\") {\n      const gradient = context.createLinearGradient(\n        fillGradient.x0,\n        fillGradient.y0,\n        fillGradient.x1,\n        fillGradient.y1\n      );\n      fillGradient.gradientStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n      });\n      return gradient;\n    }\n  }\n  warn(\"FillStyle not recognised\", fillStyle);\n  return \"red\";\n}\n\nexport { getCanvasFillStyle };\n//# sourceMappingURL=getCanvasFillStyle.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/GraphicsContext';\n\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D): string | CanvasGradient | CanvasPattern\n{\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).toHex();\n    }\n    else if (!fillStyle.fill)\n    {\n        // fancy set up...\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n\n        // create an inverted scale matrix..\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill as FillPattern;\n\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill as FillGradient;\n\n        if (fillGradient.type === 'linear')\n        {\n            const gradient = context.createLinearGradient(\n                fillGradient.x0,\n                fillGradient.y0,\n                fillGradient.x1,\n                fillGradient.y1\n            );\n\n            fillGradient.gradientStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n\n            return gradient;\n        }\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { loadBitmapFont, bitmapFontCachePlugin } from './asset/loadBitmapFont.mjs';\nimport { BitmapTextPipe } from './BitmapTextPipe.mjs';\n\n\"use strict\";\nextensions.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from './asset/loadBitmapFont';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);\n","import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser.mjs';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams.mjs';\nimport { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { path } from '../../../utils/path.mjs';\nimport { BitmapFont } from '../BitmapFont.mjs';\nimport { bitmapFontTextParser } from './bitmapFontTextParser.mjs';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser.mjs';\n\n\"use strict\";\nconst validExtensions = [\".xml\", \".fnt\"];\nconst bitmapFontCachePlugin = {\n  extension: ExtensionType.CacheParser,\n  test: (asset) => asset instanceof BitmapFont,\n  getCacheableAssets(keys, asset) {\n    const out = {};\n    keys.forEach((key) => {\n      out[key] = asset;\n    });\n    out[`${asset.fontFamily}-bitmap`] = asset;\n    return out;\n  }\n};\nconst loadBitmapFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Normal\n  },\n  test(url) {\n    return validExtensions.includes(path.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n  },\n  async parse(asset, data, loader) {\n    const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);\n    const { src } = data;\n    const { pages } = bitmapFontData;\n    const textureUrls = [];\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path.join(path.dirname(src), pageFile);\n      imagePath = copySearchParams(imagePath, src);\n      textureUrls.push(imagePath);\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url]);\n    const bitmapFont = new BitmapFont({\n      data: bitmapFontData,\n      textures\n    }, src);\n    return bitmapFont;\n  },\n  async load(url, _options) {\n    const response = await DOMAdapter.get().fetch(url);\n    return await response.text();\n  },\n  async unload(bitmapFont, _resolvedAsset, loader) {\n    await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n    bitmapFont.destroy();\n  }\n};\n\nexport { bitmapFontCachePlugin, loadBitmapFont };\n//# sourceMappingURL=loadBitmapFont.mjs.map\n","import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { path } from '../../../utils/path';\nimport { BitmapFont } from '../BitmapFont';\nimport { bitmapFontTextParser } from './bitmapFontTextParser';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser';\n\nimport type { Loader } from '../../../assets/loader/Loader';\nimport type { LoaderParser } from '../../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../../assets/types';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/** simple loader plugin for loading in bitmap fonts! */\nexport const bitmapFontCachePlugin = {\n    extension: ExtensionType.CacheParser,\n    test: (asset: BitmapFont) => asset instanceof BitmapFont,\n    getCacheableAssets(keys: string[], asset: BitmapFont)\n    {\n        const out: Record<string, BitmapFont> = {};\n\n        keys.forEach((key) =>\n        {\n            out[key] = asset;\n        });\n\n        out[`${asset.fontFamily}-bitmap`] = asset;\n\n        return out;\n    }\n};\n\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n    },\n\n    async parse(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const bitmapFontData = bitmapFontTextParser.test(asset)\n            ? bitmapFontTextParser.parse(asset)\n            : bitmapFontXMLStringParser.parse(asset);\n\n        const { src } = data;\n        const { pages } = bitmapFontData;\n        const textureUrls = [];\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = path.join(path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push(imagePath);\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url]);\n\n        const bitmapFont = new BitmapFont({\n            data: bitmapFontData,\n            textures\n        }, src);\n\n        return bitmapFont;\n    },\n\n    async load(url: string, _options: ResolvedAsset): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        return await response.text();\n    },\n\n    async unload(bitmapFont: BitmapFont, _resolvedAsset, loader): Promise<void>\n    {\n        await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n\n        bitmapFont.destroy();\n    }\n} as LoaderParser;\n","import { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\n\n\"use strict\";\nclass BitmapFont extends AbstractBitmapFont {\n  constructor(options, url) {\n    super();\n    const { textures, data } = options;\n    Object.keys(data.pages).forEach((key) => {\n      const pageData = data.pages[parseInt(key, 10)];\n      const texture = textures[pageData.id];\n      this.pages.push({ texture });\n    });\n    Object.keys(data.chars).forEach((key) => {\n      const charData = data.chars[key];\n      const textureSource = textures[charData.page].source;\n      const frameReal = new Rectangle(\n        charData.x,\n        charData.y,\n        charData.width,\n        charData.height\n      );\n      const texture = new Texture({\n        source: textureSource,\n        frame: frameReal\n      });\n      this.chars[key] = {\n        id: key.codePointAt(0),\n        xOffset: charData.xOffset,\n        yOffset: charData.yOffset,\n        xAdvance: charData.xAdvance,\n        kerning: charData.kerning ?? {},\n        texture\n      };\n    });\n    this.baseRenderedFontSize = data.fontSize;\n    this.baseMeasurementFontSize = data.fontSize;\n    this.fontMetrics = {\n      ascent: 0,\n      descent: 0,\n      fontSize: data.fontSize\n    };\n    this.baseLineOffset = data.baseLineOffset;\n    this.lineHeight = data.lineHeight;\n    this.fontFamily = data.fontFamily;\n    this.distanceField = data.distanceField ?? {\n      type: \"none\",\n      range: 0\n    };\n    this.url = url;\n  }\n  /** Destroys the BitmapFont object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { texture } = this.pages[i];\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n  /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from 'pixi.js';\n   *\n   * BitmapFont.install('TitleFont', {\n   *     fontFamily: 'Arial',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: 'purple',\n   * });\n   *\n   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n   */\n  static install(options) {\n    BitmapFontManager.install(options);\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  static uninstall(name) {\n    BitmapFontManager.uninstall(name);\n  }\n}\n\nexport { BitmapFont };\n//# sourceMappingURL=BitmapFont.mjs.map\n","import { Rectangle } from '../../maths/shapes/Rectangle';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { BitmapFontData } from './AbstractBitmapFont';\nimport type { BitmapFontInstallOptions } from './BitmapFontManager';\n\n/**\n * Options for creating a BitmapFont.\n * @memberof text\n */\nexport interface BitmapFontOptions\n{\n    data: BitmapFontData\n    textures: Texture[]\n}\n\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * @memberof text\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont>\n{\n    /** the url of the font */\n    public url?: string;\n\n    constructor(options: BitmapFontOptions, url?: string)\n    {\n        super();\n\n        const { textures, data } = options;\n\n        Object.keys(data.pages).forEach((key: string) =>\n        {\n            const pageData = data.pages[parseInt(key, 10)];\n\n            const texture = textures[pageData.id];\n\n            this.pages.push({ texture });\n        });\n\n        Object.keys(data.chars).forEach((key: string) =>\n        {\n            const charData = data.chars[key];\n            const textureSource = textures[charData.page].source;\n\n            const frameReal = new Rectangle(\n                charData.x,\n                charData.y,\n                charData.width,\n                charData.height,\n            );\n\n            const texture = new Texture({\n                source: textureSource,\n                frame: frameReal\n            });\n\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture,\n            };\n        });\n\n        this.baseRenderedFontSize = data.fontSize;\n\n        (this.baseMeasurementFontSize as number) = data.fontSize;\n        (this.fontMetrics as FontMetrics) = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize,\n        };\n        (this.baseLineOffset as number) = data.baseLineOffset;\n        (this.lineHeight as number) = data.lineHeight;\n        (this.fontFamily as string) = data.fontFamily;\n        (this.distanceField as { type: string, range: number }) = data.distanceField ?? {\n            type: 'none',\n            range: 0,\n        };\n\n        this.url = url;\n    }\n\n    /** Destroys the BitmapFont object. */\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { texture } = this.pages[i];\n\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFont, BitmapText } from 'pixi.js';\n     *\n     * BitmapFont.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public static install(options: BitmapFontInstallOptions)\n    {\n        BitmapFontManager.install(options);\n    }\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public static uninstall(name: string)\n    {\n        BitmapFontManager.uninstall(name);\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nclass AbstractBitmapFont extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = \"\";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: \"none\", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    deprecation(v8_0_0, \"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.\");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    deprecation(v8_0_0, \"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.\");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or \"none\".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    deprecation(v8_0_0, \"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.\");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    deprecation(v8_0_0, \"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.\");\n    return this.distanceField.type;\n  }\n  destroy(destroyTextures = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture.destroy();\n    }\n    this.chars = null;\n    if (destroyTextures) {\n      this.pages.forEach((page) => page.texture.destroy(true));\n      this.pages = null;\n    }\n  }\n}\n\nexport { AbstractBitmapFont };\n//# sourceMappingURL=AbstractBitmapFont.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @memberof text */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @memberof text\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @memberof text\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @memberof text\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            this.chars[i].texture.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { DynamicBitmapFont } from './DynamicBitmapFont.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\n\"use strict\";\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [[\"0\", \"9\"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"];\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[\" \", \"~\"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill) {\n      fontFamilyKey += style._fill.fill.uid;\n      overrideFill = false;\n    }\n    if (!Cache.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fnt.once(\"destroy\", () => Cache.remove(fontFamilyKey));\n      Cache.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   */\n  getLayout(text, style) {\n    const bitmapFont = this.getFont(text, style);\n    return getBitmapTextLayout(text.split(\"\"), style, bitmapFont);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   */\n  measureText(text, style) {\n    return this.getLayout(text, style);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === \"string\") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      deprecation(v8_0_0, \"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})\");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error(\"[BitmapFontManager] Property `name` is required.\");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false\n    });\n    const flatChars = resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(\"\"));\n    Cache.set(`${name}-bitmap`, font);\n    font.once(\"destroy\", () => Cache.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache.get(cacheKey);\n    if (font) {\n      Cache.remove(cacheKey);\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\nexport { BitmapFontManager };\n//# sourceMappingURL=BitmapFontManager.mjs.map\n","import { Cache } from '../../assets/cache/Cache';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\n/**\n *\n * The options for installing a new BitmapFont. Once installed the font will be available for use in the BitmapText.\n * It can be accessed by the `fontFamily` property of the TextStyle.\n *\n * Install a new BitmapFont will create the characters provided for the font and store them in the cache.\n * But don't worry, if a character is requested that hasn't been generated yet, it will be created on the fly.\n * @memberof text\n */\nexport interface BitmapFontInstallOptions\n{\n    /** the name of the font, this will be the name you use in the fontFamily of text style to access this font */\n    name?: string;\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * If true, this could potentially increase the performance, but may impact the rendered text appearance.\n     * @default false\n     */\n    skipKerning?: boolean;\n    /** Style options to render with BitmapFont. */\n    style?: TextStyle | TextStyleOptions;\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @memberof text\n * @name BitmapFontManager\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n    };\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill)\n        {\n            fontFamilyKey += style._fill.fill.uid;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const fnt = new DynamicBitmapFont({\n                style,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fnt.once('destroy', () => Cache.remove(fontFamilyKey));\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     */\n    public getLayout(text: string, style: TextStyle): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        return getBitmapTextLayout(text.split(''), style, bitmapFont);\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     */\n    public measureText(text: string, style: TextStyle): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== undefined;\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            Cache.remove(cacheKey);\n            font.destroy();\n        }\n    }\n}\n\nexport const BitmapFontManager = new BitmapFontManagerClass();\n","import { Color } from '../../color/Color.mjs';\nimport { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\n\"use strict\";\nclass DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 4;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = options;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture.WHITE;\n      style._fill.fill = null;\n    }\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = fontStringFromTextStyle(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    const widthScale = style.fontStyle === \"italic\" ? 2 : 1;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = widthScale * metrics.width * fontScale;\n      const height = metrics.height * fontScale;\n      const paddedWidth = width + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > 512) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > 512) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture({\n      source: new ImageSource({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: \"premultiply-alpha-on-upload\"\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = fontStringFromTextStyle(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = getCanvasFillStyle(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = getCanvasFillStyle(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = \"black\";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n}\n\nexport { DynamicBitmapFont };\n//# sourceMappingURL=DynamicBitmapFont.mjs.map\n","import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { TextStyle } from '../text/TextStyle';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 4;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = options;\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        const widthScale = style.fontStyle === 'italic' ? 2 : 1;\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps heigh\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = (widthScale * metrics.width) * fontScale;\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = width + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > 512)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > 512)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload'\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n","\"use strict\";\nfunction resolveCharacters(chars) {\n  if (chars === \"\") {\n    return [];\n  }\n  if (typeof chars === \"string\") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error(\"[BitmapFont]: Invalid character delimiter.\");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  }\n  return result;\n}\n\nexport { resolveCharacters };\n//# sourceMappingURL=resolveCharacters.mjs.map\n","/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\n\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n","\"use strict\";\nfunction getBitmapTextLayout(chars, style, font) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    let lastChar = currentLine.chars[index];\n    while (lastChar === \" \") {\n      currentLine.width -= font.chars[lastChar].xAdvance;\n      lastChar = currentLine.chars[--index];\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[\" \"];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === \"\\r\" || char === \"\\n\" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === \"\\r\" || char === \"\\n\") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === \"center\") {\n    alignCenter(layoutData);\n  } else if (style.align === \"right\") {\n    alignRight(layoutData);\n  } else if (style.align === \"justify\") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\nexport { getBitmapTextLayout };\n//# sourceMappingURL=getBitmapTextLayout.mjs.map\n","import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\nexport function getBitmapTextLayout(chars: string[], style: TextStyle, font: AbstractBitmapFont<any>): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n        let lastChar = currentLine.chars[index];\n\n        while (lastChar === ' ')\n        {\n            currentLine.width -= font.chars[lastChar].xAdvance;\n            lastChar = currentLine.chars[--index];\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord\n                && style.wordWrap\n                && (currentLine.width + currentWord.width - adjustedLetterSpacing) > adjustedWordWrapWidth;\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n","\"use strict\";\nconst bitmapFontTextParser = {\n  test(data) {\n    return typeof data === \"string\" && data.startsWith(\"info face=\");\n  },\n  parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split(\"=\");\n        const key = split[0];\n        const strValue = split[1].replace(/\"/gm, \"\");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: \"\",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const [info] = rawData.info;\n    const [common] = rawData.common;\n    const [distanceField] = rawData.distanceField ?? [];\n    if (distanceField) {\n      font.distanceField = {\n        range: parseInt(distanceField.distanceRange, 10),\n        type: distanceField.fieldType\n      };\n    }\n    font.fontSize = parseInt(info.size, 10);\n    font.fontFamily = info.face;\n    font.lineHeight = parseInt(common.lineHeight, 10);\n    const page = rawData.page;\n    for (let i = 0; i < page.length; i++) {\n      font.pages.push({\n        id: parseInt(page[i].id, 10) || 0,\n        file: page[i].file\n      });\n    }\n    const map = {};\n    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n    const char = rawData.char;\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.id, 10);\n      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n      if (letter === \"space\")\n        letter = \" \";\n      map[id] = letter;\n      font.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.page, 10) || 0,\n        x: parseInt(charNode.x, 10),\n        y: parseInt(charNode.y, 10),\n        width: parseInt(charNode.width, 10),\n        height: parseInt(charNode.height, 10),\n        xOffset: parseInt(charNode.xoffset, 10),\n        yOffset: parseInt(charNode.yoffset, 10),\n        xAdvance: parseInt(charNode.xadvance, 10),\n        kerning: {}\n      };\n    }\n    const kerning = rawData.kerning || [];\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].first, 10);\n      const second = parseInt(kerning[i].second, 10);\n      const amount = parseInt(kerning[i].amount, 10);\n      font.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return font;\n  }\n};\n\nexport { bitmapFontTextParser };\n//# sourceMappingURL=bitmapFontTextParser.mjs.map\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string, base: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string\n        page: string\n        xoffset: string\n        yoffset: string\n        xadvance: string,\n        x: string\n        y: string\n        width: string\n        height: string\n        letter?: string\n        char?: string\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: 'sdf' | 'msdf' | 'none';\n        distanceRange: string;\n    }[]\n}\n\nexport const bitmapFontTextParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    },\n\n    parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: BitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontRawData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n\n        if (distanceField)\n        {\n            font.distanceField = {\n                range: parseInt(distanceField.distanceRange, 10),\n                type: distanceField.fieldType\n            };\n        }\n\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n\n        const page = rawData.page;\n\n        for (let i = 0; i < page.length; i++)\n        {\n            font.pages.push({\n                id: parseInt(page[i].id, 10) || 0,\n                file: page[i].file,\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n\n        const char = rawData.char;\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            font.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        const kerning = rawData.kerning || [];\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n\n        return font;\n    }\n};\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser.mjs';\n\n\"use strict\";\nconst bitmapFontXMLStringParser = {\n  test(data) {\n    if (typeof data === \"string\" && data.includes(\"<font>\")) {\n      return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n    }\n    return false;\n  },\n  parse(data) {\n    return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n  }\n};\n\nexport { bitmapFontXMLStringParser };\n//# sourceMappingURL=bitmapFontXMLStringParser.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser';\n\nimport type { BitmapFontData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLStringParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        if (typeof data === 'string' && data.includes('<font>'))\n        {\n            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n        }\n\n        return false;\n    },\n\n    parse(data: string): BitmapFontData\n    {\n        return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n    }\n};\n","\"use strict\";\nconst bitmapFontXMLParser = {\n  test(data) {\n    const xml = data;\n    return typeof xml !== \"string\" && \"getElementsByTagName\" in xml && xml.getElementsByTagName(\"page\").length && xml.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n  },\n  parse(xml) {\n    const data = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: \"\",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const info = xml.getElementsByTagName(\"info\")[0];\n    const common = xml.getElementsByTagName(\"common\")[0];\n    const distanceField = xml.getElementsByTagName(\"distanceField\")[0];\n    if (distanceField) {\n      data.distanceField = {\n        type: distanceField.getAttribute(\"fieldType\"),\n        range: parseInt(distanceField.getAttribute(\"distanceRange\"), 10)\n      };\n    }\n    const page = xml.getElementsByTagName(\"page\");\n    const char = xml.getElementsByTagName(\"char\");\n    const kerning = xml.getElementsByTagName(\"kerning\");\n    data.fontSize = parseInt(info.getAttribute(\"size\"), 10);\n    data.fontFamily = info.getAttribute(\"face\");\n    data.lineHeight = parseInt(common.getAttribute(\"lineHeight\"), 10);\n    for (let i = 0; i < page.length; i++) {\n      data.pages.push({\n        id: parseInt(page[i].getAttribute(\"id\"), 10) || 0,\n        file: page[i].getAttribute(\"file\")\n      });\n    }\n    const map = {};\n    data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute(\"base\"), 10);\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.getAttribute(\"id\"), 10);\n      let letter = charNode.getAttribute(\"letter\") ?? charNode.getAttribute(\"char\") ?? String.fromCharCode(id);\n      if (letter === \"space\")\n        letter = \" \";\n      map[id] = letter;\n      data.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.getAttribute(\"page\"), 10) || 0,\n        x: parseInt(charNode.getAttribute(\"x\"), 10),\n        y: parseInt(charNode.getAttribute(\"y\"), 10),\n        width: parseInt(charNode.getAttribute(\"width\"), 10),\n        height: parseInt(charNode.getAttribute(\"height\"), 10),\n        // render deets..\n        xOffset: parseInt(charNode.getAttribute(\"xoffset\"), 10),\n        yOffset: parseInt(charNode.getAttribute(\"yoffset\"), 10),\n        // + baseLineOffset,\n        xAdvance: parseInt(charNode.getAttribute(\"xadvance\"), 10),\n        kerning: {}\n      };\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].getAttribute(\"first\"), 10);\n      const second = parseInt(kerning[i].getAttribute(\"second\"), 10);\n      const amount = parseInt(kerning[i].getAttribute(\"amount\"), 10);\n      data.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return data;\n  }\n};\n\nexport { bitmapFontXMLParser };\n//# sourceMappingURL=bitmapFontXMLParser.mjs.map\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        const xml = data as Document;\n\n        return typeof xml !== 'string'\n            && 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    },\n\n    parse(xml: Document): BitmapFontData\n    {\n        const data: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const distanceField = xml.getElementsByTagName('distanceField')[0];\n\n        if (distanceField)\n        {\n            data.distanceField = {\n                type: distanceField.getAttribute('fieldType') as 'sdf' | 'msdf' | 'none',\n                range: parseInt(distanceField.getAttribute('distanceRange'), 10),\n            };\n        }\n\n        // pages and chars:\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n\n        data.fontSize = parseInt(info.getAttribute('size'), 10);\n        data.fontFamily = info.getAttribute('face');\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.pages.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute('base'), 10);\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute('id'), 10);\n\n            let letter = charNode.getAttribute('letter') ?? charNode.getAttribute('char') ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            data.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute('page'), 10) || 0,\n                x: parseInt(charNode.getAttribute('x'), 10),\n                y: parseInt(charNode.getAttribute('y'), 10),\n                width: parseInt(charNode.getAttribute('width'), 10),\n                height: parseInt(charNode.getAttribute('height'), 10),\n\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute('xoffset'), 10),\n                yOffset: parseInt(charNode.getAttribute('yoffset'), 10), // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute('xadvance'), 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].getAttribute('first'), 10);\n            const second = parseInt(kerning[i].getAttribute('second'), 10);\n            const amount = parseInt(kerning[i].getAttribute('amount'), 10);\n\n            data.chars[map[second]].kerning[map[first]] = amount;// * 10000;\n        }\n\n        return data;\n    }\n};\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { Graphics } from '../graphics/shared/Graphics.mjs';\nimport { SdfShader } from '../text/sdfShader/SdfShader.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\n\n\"use strict\";\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._gpuBitmapText = {};\n    this._renderer = renderer;\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  destroyRenderable(bitmapText) {\n    this._destroyRenderableByUid(bitmapText.uid);\n  }\n  _destroyRenderableByUid(renderableUid) {\n    BigPool.return(this._gpuBitmapText[renderableUid]);\n    this._gpuBitmapText[renderableUid] = null;\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== \"none\") {\n      if (!context.customShader) {\n        if (!this._sdfShader) {\n          this._sdfShader = new SdfShader();\n        }\n        context.customShader = this._sdfShader;\n      }\n    }\n    const chars = Array.from(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = (style._stroke?.width || 0) / 2;\n    currentY += bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n    let index = 0;\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    context.translate(\n      -bitmapText._anchor._x * bitmapTextLayout.width - padding,\n      -bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding\n    ).scale(scale, scale);\n    const tint = style._fill.color;\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = chars[index++];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          context.texture(\n            charData.texture,\n            tint ? tint : \"black\",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset)\n          );\n        }\n      }\n      currentY += bitmapFont.lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = BigPool.get(Graphics);\n    this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    bitmapText.on(\"destroyed\", () => {\n      this.destroyRenderable(bitmapText);\n    });\n    return this._gpuBitmapText[bitmapText.uid];\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const resolution = bitmapText.resolution ?? this._renderer.resolution;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    for (const uid in this._gpuBitmapText) {\n      this._destroyRenderableByUid(uid);\n    }\n    this._gpuBitmapText = null;\n    this._sdfShader?.destroy(true);\n    this._sdfShader = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"bitmapText\"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\nexport { BitmapTextPipe };\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private _sdfShader: SdfShader;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                if (!this._sdfShader)\n                {\n                    this._sdfShader = new SdfShader();\n                }\n\n                context.customShader = this._sdfShader;\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = (style._stroke?.width || 0) / 2;\n\n        currentY += bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        context\n            .translate(\n                (-bitmapText._anchor._x * bitmapTextLayout.width) - padding,\n                (-bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY)) - padding)\n            .scale(scale, scale);\n\n        const tint = style._fill.color;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that hav the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', () =>\n        {\n            this.destroyRenderable(bitmapText);\n        });\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const resolution = bitmapText.resolution ?? this._renderer.resolution;\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._sdfShader?.destroy(true);\n        this._sdfShader = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { batchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit.mjs';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit.mjs';\n\n\"use strict\";\nclass SdfShader extends Shader {\n  constructor() {\n    const uniforms = new UniformGroup({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uDistance: { value: 4, type: \"f32\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(MAX_TEXTURES),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit\n      ]\n    });\n    const glProgram = compileHighShaderGlProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(MAX_TEXTURES),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBitGl\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: batchSamplersUniformGroup\n      }\n    });\n  }\n}\n\nexport { SdfShader };\n//# sourceMappingURL=SdfShader.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { batchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/batchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(MAX_TEXTURES),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(MAX_TEXTURES),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: batchSamplersUniformGroup,\n            }\n        });\n    }\n}\n","\"use strict\";\nconst localUniformMSDFBit = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n    )\n  }\n};\n\nexport { localUniformMSDFBit, localUniformMSDFBitGl };\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n\n    }\n};\n","\"use strict\";\nconst mSDFBit = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\n\nexport { mSDFBit, mSDFBitGl };\n//# sourceMappingURL=mSDFBit.mjs.map\n","export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { HTMLTextPipe } from './HTMLTextPipe.mjs';\nimport { HTMLTextSystem } from './HTMLTextSystem.mjs';\n\n\"use strict\";\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const newKey = htmlText._getKey();\n    if (gpuText.textureNeedsUploading) {\n      gpuText.textureNeedsUploading = false;\n      return true;\n    }\n    if (gpuText.currentKey !== newKey) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(htmlText) {\n    this._destroyRenderableById(htmlText.uid);\n  }\n  _destroyRenderableById(htmlTextUid) {\n    const gpuText = this._gpuText[htmlTextUid];\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    BigPool.return(gpuText.batchableSprite);\n    this._gpuText[htmlTextUid] = null;\n  }\n  _updateText(htmlText) {\n    const newKey = htmlText._getKey();\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(htmlText).catch((e) => {\n        console.error(e);\n      });\n    }\n    htmlText._didTextUpdate = false;\n    const padding = htmlText._style.padding;\n    updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const gpuText = this._getGpuText(htmlText);\n    if (gpuText.generatingTexture)\n      return;\n    const newKey = htmlText._getKey();\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    gpuText.generatingTexture = true;\n    gpuText.currentKey = newKey;\n    const resolution = htmlText.resolution ?? this._renderer.resolution;\n    const texture = await this._renderer.htmlText.getManagedTexture(\n      htmlText.text,\n      resolution,\n      htmlText._style,\n      htmlText._getKey()\n    );\n    const batchableSprite = gpuText.batchableSprite;\n    batchableSprite.texture = gpuText.texture = texture;\n    gpuText.generatingTexture = false;\n    gpuText.textureNeedsUploading = true;\n    htmlText.onViewUpdate();\n    const padding = htmlText._style.padding;\n    updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  _getGpuText(htmlText) {\n    return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const gpuTextData = {\n      texture: Texture.EMPTY,\n      currentKey: \"--\",\n      batchableSprite: BigPool.get(BatchableSprite),\n      textureNeedsUploading: false,\n      generatingTexture: false\n    };\n    const batchableSprite = gpuTextData.batchableSprite;\n    batchableSprite.renderable = htmlText;\n    batchableSprite.texture = Texture.EMPTY;\n    batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    this._gpuText[htmlText.uid] = gpuTextData;\n    htmlText.on(\"destroyed\", () => {\n      this.destroyRenderable(htmlText);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextPipe };\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HtmlTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        this._gpuText[htmlText.uid] = gpuTextData;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', () =>\n        {\n            this.destroyRenderable(htmlText);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { isSafari } from '../../utils/browser/isSafari.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource.mjs';\nimport { HTMLTextRenderData } from './HTMLTextRenderData.mjs';\nimport { HTMLTextStyle } from './HtmlTextStyle.mjs';\nimport { extractFontFamilies } from './utils/extractFontFamilies.mjs';\nimport { getFontCss } from './utils/getFontCss.mjs';\nimport { getSVGUrl } from './utils/getSVGUrl.mjs';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage.mjs';\nimport { loadSVGImage } from './utils/loadSVGImage.mjs';\nimport { measureHtmlText } from './utils/measureHtmlText.mjs';\n\n\"use strict\";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._activeTextures = {};\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === RendererType.WEBGPU;\n  }\n  getTexture(options) {\n    return this._buildTexturePromise(\n      options.text,\n      options.resolution,\n      options.style\n    );\n  }\n  getManagedTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].promise;\n    }\n    const promise = this._buildTexturePromise(text, resolution, style).then((texture) => {\n      this._activeTextures[textKey].texture = texture;\n      return texture;\n    });\n    this._activeTextures[textKey] = {\n      texture: null,\n      promise,\n      usageCount: 1\n    };\n    return promise;\n  }\n  async _buildTexturePromise(text, resolution, style) {\n    const htmlTextData = BigPool.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(\n      fontFamilies,\n      style,\n      HTMLTextStyle.defaultTextStyle\n    );\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    image.width = width | 0;\n    image.height = height | 0;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    let resource = image;\n    if (this._createCanvas) {\n      resource = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n    }\n    BigPool.return(htmlTextData);\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    if (!activeTexture)\n      return;\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      if (activeTexture.texture) {\n        this._cleanUp(activeTexture);\n      } else {\n        activeTexture.promise.then((texture) => {\n          activeTexture.texture = texture;\n          this._cleanUp(activeTexture);\n        }).catch(() => {\n          warn(\"HTMLTextSystem: Failed to clean texture\");\n        });\n      }\n      this._activeTextures[textKey] = null;\n    }\n  }\n  _cleanUp(activeTexture) {\n    TexturePool.returnTexture(activeTexture.texture);\n    activeTexture.texture.source.resource = null;\n    activeTexture.texture.source.uploadMethodId = \"unknown\";\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"htmlText\"\n};\nHTMLTextSystem.defaultFontOptions = {\n  fontFamily: \"Arial\",\n  fontStyle: \"normal\",\n  fontWeight: \"normal\"\n};\n\nexport { HTMLTextSystem };\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HtmlTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        image.width = width | 0;\n        image.height = height | 0;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        let resource: HTMLImageElement | HTMLCanvasElement = image;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            resource = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nfunction isSafari() {\n  const { userAgent } = DOMAdapter.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\nexport { isSafari };\n//# sourceMappingURL=isSafari.mjs.map\n","import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","\"use strict\";\nconst nssvg = \"http://www.w3.org/2000/svg\";\nconst nsxhtml = \"http://www.w3.org/1999/xhtml\";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, \"svg\");\n    this.foreignObject = document.createElementNS(nssvg, \"foreignObject\");\n    this.domElement = document.createElementNS(nsxhtml, \"div\");\n    this.styleElement = document.createElementNS(nsxhtml, \"style\");\n    this.image = new Image();\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute(\"width\", \"10000\");\n    foreignObject.setAttribute(\"height\", \"10000\");\n    foreignObject.style.overflow = \"hidden\";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n  }\n}\n\nexport { HTMLTextRenderData, nssvg, nsxhtml };\n//# sourceMappingURL=HTMLTextRenderData.mjs.map\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\nexport const nssvg = 'http://www.w3.org/2000/svg';\nexport const nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey.mjs';\nimport { textStyleToCSS } from './utils/textStyleToCSS.mjs';\n\n\"use strict\";\nclass HTMLTextStyle extends TextStyle {\n  constructor(options = {}) {\n    super(options);\n    this._cssOverrides = [];\n    this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);\n    this.tagStyles = options.tagStyles ?? {};\n  }\n  /** List of style overrides that will be applied to the HTML text. */\n  set cssOverrides(value) {\n    this._cssOverrides = value instanceof Array ? value : [value];\n    this.update();\n  }\n  get cssOverrides() {\n    return this._cssOverrides;\n  }\n  _generateKey() {\n    this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join(\"-\");\n    return this._styleKey;\n  }\n  update() {\n    this._cssStyle = null;\n    super.update();\n  }\n  /**\n   * Creates a new HTMLTextStyle object with the same values as this one.\n   * @returns New cloned HTMLTextStyle object\n   */\n  clone() {\n    return new HTMLTextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth,\n      cssOverrides: this.cssOverrides\n    });\n  }\n  get cssStyle() {\n    if (!this._cssStyle) {\n      this._cssStyle = textStyleToCSS(this);\n    }\n    return this._cssStyle;\n  }\n  /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride('background-color: red');\n   */\n  addOverride(...value) {\n    const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n    if (toAdd.length > 0) {\n      this.cssOverrides.push(...toAdd);\n      this.update();\n    }\n  }\n  /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride('background-color: red');\n   */\n  removeOverride(...value) {\n    const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n    if (toRemove.length > 0) {\n      this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n      this.update();\n    }\n  }\n  set fill(value) {\n    if (typeof value !== \"string\" && typeof value !== \"number\") {\n      warn(\"[HTMLTextStyle] only color fill is not supported by HTMLText\");\n    }\n    super.fill = value;\n  }\n  set stroke(value) {\n    if (value && typeof value !== \"string\" && typeof value !== \"number\") {\n      warn(\"[HTMLTextStyle] only color stroke is not supported by HTMLText\");\n    }\n    super.stroke = value;\n  }\n}\n\nexport { HTMLTextStyle };\n//# sourceMappingURL=HtmlTextStyle.mjs.map\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillStyleInputs } from '../graphics/shared/GraphicsContext';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends {@link TextStyle}.\n * @memberof text\n * @extends text.TextStyleOptions\n * @property {string[]} [cssOverrides] - CSS style(s) to add.\n * @property {Record<string, text.HTMLTextStyleOptions>} [tagStyles] - Tag styles.\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' >\n{\n    cssOverrides?: string[];\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @memberof text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * List of styles per tag.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides ??= options.cssOverrides;\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /** List of style overrides that will be applied to the HTML text. */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    protected override _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join('-');\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * @returns New cloned HTMLTextStyle object\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n        });\n    }\n\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    override set fill(value: FillStyleInputs)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    override set stroke(value: FillStyleInputs)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import { Color } from '../../../color/Color.mjs';\n\n\"use strict\";\nfunction textStyleToCSS(style) {\n  const stroke = style._stroke;\n  const fill = style._fill;\n  const cssStyleString = [\n    `color: ${Color.shared.setValue(fill.color).toHex()}`,\n    `font-size: ${style.fontSize}px`,\n    `font-family: ${style.fontFamily}`,\n    `font-weight: ${style.fontWeight}`,\n    `font-style: ${style.fontStyle}`,\n    `font-variant: ${style.fontVariant}`,\n    `letter-spacing: ${style.letterSpacing}px`,\n    `text-align: ${style.align}`,\n    `padding: ${style.padding}px`,\n    `white-space: ${style.whiteSpace === \"pre\" && style.wordWrap ? \"pre-wrap\" : style.whiteSpace}`,\n    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n    ...style.wordWrap ? [\n      `word-wrap: ${style.breakWords ? \"break-all\" : \"break-word\"}`,\n      `max-width: ${style.wordWrapWidth}px`\n    ] : [],\n    ...stroke ? [strokeToCSS(stroke)] : [],\n    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n    ...style.cssOverrides\n  ].join(\";\");\n  const cssStyles = [`div { ${cssStyleString} }`];\n  tagStyleToCSS(style.tagStyles, cssStyles);\n  return cssStyles.join(\" \");\n}\nfunction dropShadowToCSS(dropShadowStyle) {\n  const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n  const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const position = `${x}px ${y}px`;\n  if (dropShadowStyle.blur > 0) {\n    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n  }\n  return `text-shadow: ${position} ${color}`;\n}\nfunction strokeToCSS(stroke) {\n  return [\n    `-webkit-text-stroke-width: ${stroke.width}px`,\n    `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n    `text-stroke-width: ${stroke.width}px`,\n    `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n    \"paint-order: stroke\"\n  ].join(\";\");\n}\nconst templates = {\n  fontSize: `font-size: {{VALUE}}px`,\n  fontFamily: `font-family: {{VALUE}}`,\n  fontWeight: `font-weight: {{VALUE}}`,\n  fontStyle: `font-style: {{VALUE}}`,\n  fontVariant: `font-variant: {{VALUE}}`,\n  letterSpacing: `letter-spacing: {{VALUE}}px`,\n  align: `text-align: {{VALUE}}`,\n  padding: `padding: {{VALUE}}px`,\n  whiteSpace: `white-space: {{VALUE}}`,\n  lineHeight: `line-height: {{VALUE}}px`,\n  wordWrapWidth: `max-width: {{VALUE}}px`\n};\nconst transform = {\n  fill: (value) => `color: ${Color.shared.setValue(value).toHex()}`,\n  breakWords: (value) => `word-wrap: ${value ? \"break-all\" : \"break-word\"}`,\n  stroke: strokeToCSS,\n  dropShadow: dropShadowToCSS\n};\nfunction tagStyleToCSS(tagStyles, out) {\n  for (const i in tagStyles) {\n    const tagStyle = tagStyles[i];\n    const cssTagStyle = [];\n    for (const j in tagStyle) {\n      if (transform[j]) {\n        cssTagStyle.push(transform[j](tagStyle[j]));\n      } else if (templates[j]) {\n        cssTagStyle.push(templates[j].replace(\"{{VALUE}}\", tagStyle[j]));\n      }\n    }\n    out.push(`${i} { ${cssTagStyle.join(\";\")} }`);\n  }\n}\n\nexport { textStyleToCSS };\n//# sourceMappingURL=textStyleToCSS.mjs.map\n","import { Color } from '../../../color/Color';\n\nimport type { StrokeStyle } from '../../graphics/shared/GraphicsContext';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HtmlTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: StrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","\"use strict\";\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;\"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(\":\")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\nexport { extractFontFamilies };\n//# sourceMappingURL=extractFontFamilies.mjs.map\n","import type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import { Cache } from '../../../assets/cache/Cache.mjs';\nimport { loadFontCSS } from './loadFontCSS.mjs';\n\n\"use strict\";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies, style, defaultOptions) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily, i) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { url } = Cache.get(`${fontFamily}-and-url`);\n      if (i === 0) {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n      } else {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS({\n          fontWeight: defaultOptions.fontWeight,\n          fontStyle: defaultOptions.fontStyle,\n          fontFamily\n        }, url));\n      }\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join(\"\\n\");\n}\n\nexport { FontStylePromiseCache, getFontCss };\n//# sourceMappingURL=getFontCss.mjs.map\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64.mjs';\n\n\"use strict\";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\nexport { loadFontCSS };\n//# sourceMappingURL=loadFontCSS.mjs.map\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\n\n\"use strict\";\nasync function loadFontAsBase64(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\nexport { loadFontAsBase64 };\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","\"use strict\";\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute(\"style\", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute(\"width\", width.toString());\n  svgRoot.setAttribute(\"height\", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\nexport { getSVGUrl };\n//# sourceMappingURL=getSVGUrl.mjs.map\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\n\n\"use strict\";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  CanvasPool.returnCanvasAndContext(canvasAndContext);\n  return canvasAndContext.canvas;\n}\n\nexport { getTemporaryCanvasFromImage };\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * This canvas is immediately returned to the CanvasPool for reuse, so use the result straight away!\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): HTMLCanvasElement\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas and context to the CanvasPool.\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n    // Return the canvas.\n    return canvasAndContext.canvas as HTMLCanvasElement;\n}\n\n","\"use strict\";\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = \"anonymous\";\n  });\n}\n\nexport { loadSVGImage };\n//# sourceMappingURL=loadSVGImage.mjs.map\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics.mjs';\nimport { HTMLTextRenderData } from '../HTMLTextRenderData.mjs';\n\n\"use strict\";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n  return {\n    width: contentBounds.width,\n    height: contentBounds.height + descenderPadding\n  };\n}\n\nexport { measureHtmlText };\n//# sourceMappingURL=measureHtmlText.mjs.map\n","import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics';\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n\n    return {\n        width: contentBounds.width,\n        height: contentBounds.height + descenderPadding,\n    };\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { TilingSpritePipe } from './TilingSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { State } from '../../rendering/renderers/shared/state/State.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader.mjs';\nimport { QuadGeometry } from './utils/QuadGeometry.mjs';\nimport { setPositions } from './utils/setPositions.mjs';\nimport { setUvs } from './utils/setUvs.mjs';\n\n\"use strict\";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (batchableMesh.texture._source !== renderable.texture._source) {\n        return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n      }\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite._didTilingSpriteUpdate) {\n        tilingSprite._didTilingSpriteUpdate = false;\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.mesh = tilingSprite;\n        batchableMesh.texture = tilingSprite._texture;\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    color32BitToUniform(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: State.default2d\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite._didTilingSpriteUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh.batcher.updateElement(batchableMesh);\n    } else if (tilingSprite._didTilingSpriteUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n    tilingSprite._didTilingSpriteUpdate = false;\n  }\n  destroyRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    tilingSpriteData.batchableMesh = null;\n    tilingSpriteData.shader?.destroy();\n    this._tilingSpriteDataHash[tilingSprite.uid] = null;\n  }\n  _getTilingSpriteData(renderable) {\n    return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const geometry = new MeshGeometry({\n      indices: sharedQuad.indices,\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n    this._tilingSpriteDataHash[tilingSprite.uid] = {\n      canBatch: true,\n      renderable: tilingSprite,\n      geometry\n    };\n    tilingSprite.on(\"destroyed\", () => {\n      this.destroyRenderable(tilingSprite);\n    });\n    return this._tilingSpriteDataHash[tilingSprite.uid];\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== \"repeat\") {\n      style.addressMode = \"repeat\";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    for (const i in this._tilingSpriteDataHash) {\n      this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n    }\n    this._tilingSpriteDataHash = null;\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === RendererType.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"tilingSprite\"\n};\n\nexport { TilingSpritePipe };\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            // we are batching.. check a texture change!\n            if (batchableMesh.texture._source !== renderable.texture._source)\n\n            { return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture); }\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite._didTilingSpriteUpdate)\n            {\n                tilingSprite._didTilingSpriteUpdate = false;\n\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.mesh = tilingSprite;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: State.default2d,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite._didTilingSpriteUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh.batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite._didTilingSpriteUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n\n        tilingSprite._didTilingSpriteUpdate = false;\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(tilingSprite);\n        });\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { tilingBit, tilingBitGl } from './tilingBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader {\n  constructor() {\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBit,\n        tilingBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBitGl,\n        tilingBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    const tilingUniforms = new UniformGroup({\n      uMapCoord: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: \"vec4<f32>\" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: \"vec2<f32>\" },\n      uTextureTransform: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: \"vec4<f32>\" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup({\n          uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n          uRound: { value: 0, type: \"f32\" }\n        }),\n        tilingUniforms,\n        uTexture: Texture.EMPTY.source,\n        uSampler: Texture.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\nexport { TilingSpriteShader };\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","\"use strict\";\nconst tilingBit = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    )\n  }\n};\n\nexport { tilingBit, tilingBitGl };\n//# sourceMappingURL=tilingBit.mjs.map\n","export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nclass QuadGeometry extends MeshGeometry {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\nexport { QuadGeometry };\n//# sourceMappingURL=QuadGeometry.mjs.map\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","\"use strict\";\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\nexport { setPositions };\n//# sourceMappingURL=setPositions.mjs.map\n","import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { applyMatrix } from './applyMatrix.mjs';\n\n\"use strict\";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite._applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\nexport { setUvs };\n//# sourceMappingURL=setUvs.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite._applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","\"use strict\";\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\nexport { applyMatrix };\n//# sourceMappingURL=applyMatrix.mjs.map\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { NineSliceGeometry } from './NineSliceGeometry.mjs';\n\n\"use strict\";\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, _instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite.batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const texture = sprite._texture;\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (gpuSprite.texture._source !== texture._source) {\n      return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n    }\n    return false;\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    BigPool.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    sprite._didSpriteUpdate = false;\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableMesh = new BatchableMesh();\n    batchableMesh.geometry = new NineSliceGeometry();\n    batchableMesh.mesh = sprite;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableMesh;\n    sprite.on(\"destroyed\", () => {\n      this.destroyRenderable(sprite);\n    });\n    return batchableMesh;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      const batchableMesh = this._gpuSpriteHash[i];\n      batchableMesh.geometry.destroy();\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"nineSliceSprite\"\n};\n\nexport { NineSliceSpritePipe };\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, _instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite.batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (gpuSprite.texture._source !== texture._source)\n        {\n            return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n        }\n\n        return false;\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        sprite._didSpriteUpdate = false;\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = new BatchableMesh();\n\n        batchableMesh.geometry = new NineSliceGeometry();\n\n        batchableMesh.mesh = sprite;\n\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(sprite);\n        });\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { FilterPipe } from './FilterPipe.mjs';\nimport { FilterSystem } from './FilterSystem.mjs';\n\n\"use strict\";\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      canBundle: false,\n      action: \"pushFilter\",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === \"pushFilter\") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === \"popFilter\") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"filter\"\n};\n\nexport { FilterPipe };\n//# sourceMappingURL=FilterPipe.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n// eslint-disable-next-line max-len\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { Point } from '../maths/point/Point.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      location: 0,\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputPixel: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputClamp: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uGlobalFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputTexture: { value: new Float32Array(4), type: \"vec4<f32>\" }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    if (!this._filterStack[this._filterStackIndex]) {\n      this._filterStack[this._filterStackIndex] = this._getFilterData();\n    }\n    const filterData = this._filterStack[this._filterStackIndex];\n    this._filterStackIndex++;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      getFastGlobalBounds(instruction.container, bounds);\n    }\n    const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n    let resolution = colorTextureSource._resolution;\n    let padding = 0;\n    let antialias = colorTextureSource.antialias;\n    let blendRequired = false;\n    let enabled = false;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias !== \"inherit\") {\n        if (filter.antialias === \"on\") {\n          antialias = true;\n        } else {\n          antialias = false;\n        }\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired = blendRequired || filter.blendRequired;\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    const viewPort = renderer.renderTarget.rootViewPort;\n    bounds.scale(resolution).fitBounds(0, viewPort.width, 0, viewPort.height).scale(1 / resolution).pad(padding).ceil();\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.skip = false;\n    filterData.bounds = bounds;\n    filterData.blendRequired = blendRequired;\n    filterData.container = instruction.container;\n    filterData.filterEffect = instruction.filterEffect;\n    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n    filterData.inputTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      resolution,\n      antialias\n    );\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  pop() {\n    const renderer = this.renderer;\n    this._filterStackIndex--;\n    const filterData = this._filterStack[this._filterStackIndex];\n    if (filterData.skip) {\n      return;\n    }\n    this._activeFilterData = filterData;\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    let backTexture = Texture.EMPTY;\n    renderer.renderTarget.finishRenderPass();\n    if (filterData.blendRequired) {\n      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n    }\n    filterData.backTexture = backTexture;\n    const filters = filterData.filterEffect.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(backTexture.source, 3);\n    renderer.globalUniforms.pop();\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(inputTexture);\n    } else {\n      let flip = filterData.inputTexture;\n      let flop = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(flip);\n      TexturePool.returnTexture(flop);\n    }\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(backTexture);\n    }\n  }\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._filterStack[this._filterStackIndex];\n    const bounds = filterData.bounds;\n    const offset = Point.shared;\n    const previousRenderSurface = filterData.previousRenderSurface;\n    const isFinalTarget = previousRenderSurface === output;\n    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    if (currentIndex > 0) {\n      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n    }\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      let lastIndex = this._filterStackIndex;\n      while (lastIndex > 0) {\n        lastIndex--;\n        const filterData2 = this._filterStack[this._filterStackIndex - 1];\n        if (!filterData2.skip) {\n          offset.x = filterData2.bounds.minX;\n          offset.y = filterData2.bounds.minY;\n          break;\n        }\n      }\n      outputFrame[0] = bounds.minX - offset.x;\n      outputFrame[1] = bounds.minY - offset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offset.x * resolution;\n    globalFrame[1] = offset.y * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  _getFilterData() {\n    return {\n      skip: false,\n      inputTexture: null,\n      bounds: new Bounds(),\n      container: null,\n      filterEffect: null,\n      blendRequired: false,\n      previousRenderSurface: null\n    };\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.frame.width,\n      1 / sprite.texture.frame.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"filter\"\n};\n\nexport { FilterSystem };\n//# sourceMappingURL=FilterSystem.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            location: 0,\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = colorTextureSource._resolution;\n\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for any filter, it should be true\n        let antialias = colorTextureSource.antialias;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias !== 'inherit')\n            {\n                if (filter.antialias === 'on')\n                {\n                    antialias = true;\n                }\n                else\n                {\n                    antialias = false;\n                }\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const viewPort = renderer.renderTarget.rootViewPort;\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        // need to factor in resolutions also..\n        bounds.scale(resolution)\n            .fitBounds(0, viewPort.width, 0, viewPort.height)\n            .scale(1 / resolution)\n            .pad(padding)\n            .ceil();\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nfunction getFastGlobalBounds(target, bounds) {\n  bounds.clear();\n  _getGlobalBoundsRecursive(target, bounds);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  if (!target.isRenderGroupRoot) {\n    bounds.applyMatrix(target.renderGroup.worldTransform);\n  } else {\n    bounds.applyMatrix(target.renderGroup.localTransform);\n  }\n  return bounds;\n}\nfunction _getGlobalBoundsRecursive(target, bounds) {\n  if (target.localDisplayStatus !== 7 || !target.measurable) {\n    return;\n  }\n  const manageEffects = !!target.effects.length;\n  let localBounds = bounds;\n  if (target.isRenderGroupRoot || manageEffects) {\n    localBounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, target.worldTransform);\n  } else {\n    if (target.renderPipeId) {\n      const viewBounds = target.bounds;\n      localBounds.addFrame(\n        viewBounds.minX,\n        viewBounds.minY,\n        viewBounds.maxX,\n        viewBounds.maxY,\n        target.groupTransform\n      );\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getGlobalBoundsRecursive(children[i], localBounds);\n    }\n  }\n  if (manageEffects) {\n    let advanced = false;\n    for (let i = 0; i < target.effects.length; i++) {\n      if (target.effects[i].addBounds) {\n        if (!advanced) {\n          advanced = true;\n          localBounds.applyMatrix(target.renderGroup.worldTransform);\n        }\n        target.effects[i].addBounds(localBounds, true);\n      }\n    }\n    if (advanced) {\n      localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo(tempMatrix).invert());\n      bounds.addBounds(localBounds, target.relativeGroupTransform);\n    }\n    bounds.addBounds(localBounds);\n    boundsPool.return(localBounds);\n  } else if (target.isRenderGroupRoot) {\n    bounds.addBounds(localBounds, target.relativeGroupTransform);\n    boundsPool.return(localBounds);\n  }\n}\n\nexport { _getGlobalBoundsRecursive, getFastGlobalBounds };\n//# sourceMappingURL=getFastGlobalBounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n// TODO could we cache local bounds on the render groups?\n\nconst tempMatrix = new Matrix();\n\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    _getGlobalBoundsRecursive(target, bounds);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    if (!target.isRenderGroupRoot)\n    {\n        bounds.applyMatrix(target.renderGroup.worldTransform);\n    }\n    else\n    {\n        bounds.applyMatrix(target.renderGroup.localTransform);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBoundsRecursive(\n    target: Container,\n    bounds: Bounds,\n)\n{\n    if (target.localDisplayStatus !== 0b111 || !target.measurable)\n    {\n        return;\n    }\n\n    const manageEffects = !!target.effects.length;\n\n    let localBounds = bounds;\n\n    if (target.isRenderGroupRoot || manageEffects)\n    {\n        localBounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, target.worldTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            const viewBounds = (target as Renderable).bounds;\n\n            localBounds.addFrame(\n                viewBounds.minX,\n                viewBounds.minY,\n                viewBounds.maxX,\n                viewBounds.maxY,\n                target.groupTransform\n            );\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getGlobalBoundsRecursive(children[i], localBounds);\n        }\n    }\n\n    if (manageEffects)\n    {\n        let advanced = false;\n\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            if (target.effects[i].addBounds)\n            {\n                if (!advanced)\n                {\n                    advanced = true;\n                    localBounds.applyMatrix(target.renderGroup.worldTransform);\n                }\n\n                target.effects[i].addBounds(localBounds, true);\n            }\n        }\n\n        if (advanced)\n        {\n            localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo(tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n\n        bounds.addBounds(localBounds);\n        boundsPool.return(localBounds);\n    }\n    else if (target.isRenderGroupRoot)\n    {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        boundsPool.return(localBounds);\n    }\n}\n","\"use strict\";\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const tempMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    bounds.matrix = renderable.worldTransform;\n    renderable.addBounds(bounds);\n  }\n  bounds.matrix = tempMatrix;\n  return bounds;\n}\n\nexport { getGlobalRenderableBounds };\n//# sourceMappingURL=getRenderableBounds.mjs.map\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        renderable.addBounds(bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$i9BKe","$39o25","$8V0wO","extensions","add","ResizePlugin","TickerPlugin","$ea1a06b152e6d4d8$export$6453cd852defe94a","init","options","dom","removeEventListener","queueResize","_resizeTo","addEventListener","resize","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","width","height","window","innerWidth","innerHeight","clientWidth","clientHeight","renderer","render","resizeTo","destroy","extension","ExtensionType","Application","$63bd109872b60747$export$50c361ceb4e2f4f0","$cQMLP","$4J7WL","assign","autoStart","sharedTicker","ticker","_ticker","remove","UPDATE_PRIORITY","LOW","stop","start","Ticker","shared","oldTicker","$hFzkv","$3Ey0f","GraphicsPipe","GraphicsContextSystem","$41b59a27ea0e0c59$export$56171ef5563dc803","$2Aebl","$61KiY","$6B0gZ","$xZ5a3","constructor","adaptor","state","State","for2d","_graphicsBatchesHash","create","_adaptor","validateRenderable","graphics","context","wasBatched","uid","gpuContext","graphicsContext","updateGpuContext","isBatchable","addRenderable","instructionSet","_didGraphicsUpdate","_rebuild","_addToBatcher","renderPipes","batch","break","updateRenderable","batches","i","length","batcher","updateElement","destroyRenderable","_removeBatchForRenderable","execute","isRenderable","contextSystem","getGpuContext","shader","customShader","blendMode","groupBlendMode","localUniforms","resources","uniforms","uTransformMatrix","groupTransform","uRound","_roundPixels","color32BitToUniform","groupColorAlpha","uColor","_initBatchesForRenderable","batched","batchPipe","_getBatchesForRenderable","addToBatch","roundPixels","map","batchClone","BigPool","BatchableGraphics","copyTo","renderable","on","graphicsUid","forEach","return","type","WebGLPipes","WebGPUPipes","CanvasPipes","name","$6RHrb","MeshPipe","$b76d26320e7f1ae7$export$ec121977b4273ffd","$eY4rt","$awcfo","$cryyq","$72TA5","UniformGroup","value","Matrix","Float32Array","localUniformsBindGroup","BindGroup","_meshDataHash","_gpuBatchableMeshHash","mesh","meshData","_getMeshData","isBatched","geometry","_geometry","indices","indexSize","positions","vertexSize","batchableMesh","_getBatchableMesh","texture","_source","checkAndUpdateTexture","gpuBatchableMesh","_texture","renderPipeId","gpuMesh","update","_initMeshData","_initBatchableMesh","BatchableMesh","$67b85de4aa7ff7ce$export$2fa0f0ec877329e3","_uvUpdateId","_textureMatrixUpdateId","reset","packIndex","indexBuffer","index","indicesOffset","packAttributes","float32View","uint32View","textureId","wt","textureIdAndRound","b","c","d","tx","ty","uvBuffer","getBuffer","uvs","data","transformedUvs","textureMatrix","isSimple","_transformedUvs","_updateID","multiplyUvs","abgr","x","y","$5uDRx","$3O6SX","CanvasTextSystem","CanvasTextPipe","$c066d8737bdb07a6$export$ed0d779e44b53050","$f8J9J","$6qNFd","_gpuText","_renderer","text","gpuText","_getGpuText","newKey","_getKey","currentKey","resolution","canvasText","getTextureSize","_style","getReferenceCount","_instructionSet","batchableSprite","_didTextUpdate","_updateText","_destroyRenderableById","textUid","decreaseReferenceCount","_updateGpuText","padding","updateQuadBounds","bounds","_anchor","getTexture","initGpuText","gpuTextData","BatchableSprite","minX","maxX","minY","maxY","$78c42d114b108bc4$export$56e4907c2e518abc","$a2eTA","$NbSCN","$6RGCN","$3Xbp7","$ha93z","$l7b1V","$wLFHs","$fI0NC","$4JkiF","_activeTextures","style","measured","CanvasTextMetrics","measureText","Math","ceil","max","nextPow2","textKey","_increaseReferenceCount","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","canvas","renderTextToCanvas","getPo2TextureFromSource","trim","trimmed","getCanvasBoundingBox","frame","copyFrom","updateUvs","usageCount","activeTexture","returnCanvasAndContext","TexturePool","returnTexture","source","resource","uploadMethodId","alphaMode","linePositionX","linePositionY","font","fontStringFromTextStyle","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","resetTransform","scale","clearRect","_stroke","strokeStyle","lineWidth","miterLimit","lineJoin","join","lineCap","cap","passesCount","dropShadow","isShadowPass","dsOffsetText","dsOffsetShadow","fillStyle","shadowOptions","dropShadowColor","color","dropShadowAlpha","alpha","shadowColor","Color","setValue","setAlpha","toRgbaString","dropShadowBlur","blur","dropShadowDistance","distance","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","globalAlpha","_fill","getCanvasFillStyle","linePositionYShift","fontSize","strokeWidth","i2","ascent","align","_drawLetterSpacing","isStroke","letterSpacing","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","j","WebGLSystem","WebGPUSystem","CanvasSystem","$c7f22f786b0aa888$export$550eedf6c679837d","$fM4Mk","$c7f22f786b0aa888$var$checkRow","$c7f22f786b0aa888$var$checkColumn","top","bottom","stride","getContext","willReadFrequently","TypeError","imageData","getImageData","left","right","Rectangle","EMPTY","$eeb1e6506bb24c84$export$80c61c6b7fb407a3","$eeb1e6506bb24c84$var$tempBounds","$7wtv9","Bounds","image","getOptimalTexture","emit","$70d03c252755e3f8$export$c31af9427fa8602b","$bLlTJ","$hUCK4","$gwwtL","$ktCpi","Texture","WHITE","fill","toHex","FillPattern","fillPattern","pattern","createPattern","tempMatrix","transform","setTransform","FillGradient","fillGradient","gradient","createLinearGradient","x0","y0","x1","y1","gradientStops","addColorStop","offset","matrix","warn","$5ilA5","$5FVru","BitmapTextPipe","loadBitmapFont","bitmapFontCachePlugin","$67f0360d0045775d$export$778a313228f06f6c","$67f0360d0045775d$export$402edee29ac8bed4","$iEtN5","$5Oad7","$iCGeI","$lzfZe","$fl08K","$isMCe","$hsuiF","$67f0360d0045775d$var$validExtensions","CacheParser","test","asset","BitmapFont","getCacheableAssets","keys","out","key","fontFamily","LoadParser","priority","LoaderParserPriority","Normal","url","includes","path","extname","toLowerCase","testParse","bitmapFontTextParser","bitmapFontXMLStringParser","parse","loader","bitmapFontData","src","pages","textureUrls","pageFile","file","imagePath","dirname","copySearchParams","push","loadedTextures","load","textures","_options","response","DOMAdapter","fetch","unload","bitmapFont","_resolvedAsset","Promise","all","page","_sourceOrigin","$e203ca19ce7419c5$export$17957a09927cadc7","$hlNkG","$axl5b","AbstractBitmapFont","pageData","parseInt","id","chars","charData","textureSource","frameReal","codePointAt","xOffset","yOffset","xAdvance","kerning","baseRenderedFontSize","baseMeasurementFontSize","fontMetrics","descent","baseLineOffset","distanceField","range","install","BitmapFontManager","uninstall","$5d74af76d429a42b$export$70779aee6e4c1309","$3vRz3","$kXq8E","arguments","deprecation","v8_0_0","pageTextures","size","distanceFieldRange","distanceFieldType","destroyTextures","removeAllListeners","$906f35d9788bb217$export$d2ee57cdc0e1ed7f","$2IhKp","$eKNW7","$5Jnul","$hzhPt","$6ch13","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","defaultOptions","skipKerning","getFont","fontFamilyKey","overrideFill","Cache","has","fnt","DynamicBitmapFont","overrideSize","once","dynamicFont","ensureCharacters","getLayout","getBitmapTextLayout","split","args","Error","textStyle","TextStyle","flatChars","resolveCharacters","cacheKey","$8f5ec95844dc935f$export$bce21273d0a2e6c7","$aQPld","_padding","_measureCache","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","clone","requestedFontSize","measureFont","charList","filter","char","self","indexOf","_nextPage","currentX","currentY","fontScale","widthScale","fontStyle","maxCharHeight","skipTexture","metrics","paddedWidth","paddedHeight","pageData2","_drawGlyph","px","py","_applyKerning","newChars","measureCache","first","second","c1","c2","total","amount","textureResolution","_setupContext","ImageSource","textBaseline","stroke","strokeThickness","rgb","toArray","$6068e3267b929dcc$export$221291e5031b03d8","result","item","Array","isArray","startCode","charCodeAt","endCode","String","fromCharCode","from","$a05acbad40de1576$export$beeb37b3e20d3ee4","layoutData","offsetY","charPositions","spaceWidth","spacesIndex","currentLine","previousChar","firstWord","currentWord","spaceWord","nextWord","word","position","nextLine","lastChar","adjustedLetterSpacing","adjustedWordWrapWidth","wordWrapWidth","isEnd","isSpace","wordWrap","nextCharWidth","$a05acbad40de1576$var$alignCenter","measurementData","line","$a05acbad40de1576$var$alignRight","$a05acbad40de1576$var$alignJustify","indy","spaceIndex","totalSpaces","newSpaceWidth","$2e97ab653ff7bb1e$export$4c1815a0944ccac0","startsWith","txt","items","match","rawData","info","common","kernings","attributeList","itemData","strValue","replace","floatValue","parseFloat","isNaN","distanceRange","fieldType","face","base","charNode","letter","xoffset","yoffset","xadvance","$bc1a44b21cd9ad12$export$bfc0a19e2e2cc16","$KAE8q","bitmapFontXMLParser","parseXML","$e7c71a5aa13eb859$export$7a7adbcafc5cf8e3","xml","getElementsByTagName","getAttribute","$a13522d534d45eca$export$83d8b05a29a5f8ed","$3cebA","$kSjlm","_gpuBitmapText","bitmapText","graphicsRenderable","_getGpuBitmapText","_updateContext","$a13522d534d45eca$var$syncWithProxy","_updateDistanceField","_destroyRenderableByUid","renderableUid","proxyGraphics","clear","_sdfShader","SdfShader","bitmapTextLayout","translate","_x","_y","tint","round","proxyRenderable","Graphics","worldScale","abs","sqrt","uDistance","container","proxy","groupColor","globalDisplayStatus","localDisplayStatus","groupAlpha","$838fb3551287e62a$export$f19b070f8409d54d","$67Wkd","$3JBHn","$cNnNT","$ikSZA","$kSpdC","$5FRY8","$5iDyo","$h31yJ","$bSURu","Shader","glProgram","compileHighShaderGlProgram","bits","colorBitGl","generateTextureBatchBitGl","MAX_TEXTURES","localUniformMSDFBitGl","mSDFBitGl","roundPixelsBitGl","gpuProgram","compileHighShaderGpuProgram","colorBit","generateTextureBatchBit","localUniformMSDFBit","mSDFBit","roundPixelsBit","batchSamplers","batchSamplersUniformGroup","$93ced60a46db0c48$export$95191d1d81ffe694","$93ced60a46db0c48$export$7542046ad25e8068","vertex","header","main","end","fragment","$7144684246b95ecb$export$382a0eb192cd0a47","$7144684246b95ecb$export$52c5bf2a8ebe1f2a","$gTm15","$8fPaG","HTMLTextSystem","HTMLTextPipe","$d64c140cd435980d$export$ffcef6958193be1c","htmlText","textureNeedsUploading","htmlTextUid","catch","console","error","generatingTexture","getManagedTexture","onViewUpdate","$e561e497783631a4$export$f1b82676a746d8e9","$2bK9z","$2yYcV","$38D3N","$hbhnn","$4n9ps","$4He3o","$lT5va","$2ir1m","$1VDyN","$8z3uC","_createCanvas","RendererType","WEBGPU","_buildTexturePromise","promise","then","htmlTextData","HTMLTextRenderData","fontFamilies","extractFontFamilies","fontCSS","getFontCss","HTMLTextStyle","defaultTextStyle","measureHtmlText","svgURL","getSVGUrl","loadSVGImage","isSafari","getTemporaryCanvasFromImage","initSource","_cleanUp","defaultFontOptions","fontWeight","$bd3bd17de916f737$export$95df08bae54cb4df","userAgent","getNavigator","$60c804f97fa70757$export$47ab50939402e24e","$60c804f97fa70757$export$5211e83ad76beaeb","$60c804f97fa70757$export$ff15d493b5bfa767","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","Image","setAttribute","overflow","appendChild","$d10b94f8d29aac83$export$a2664b42ece43c6c","$6XitK","$9CzjF","_cssOverrides","cssOverrides","tagStyles","_generateKey","_styleKey","generateTextStyleKey","_cssStyle","breakWords","fontVariant","whiteSpace","cssStyle","textStyleToCSS","addOverride","toAdd","removeOverride","toRemove","$891e077217b1b85f$export$8daecfbc002513c1","cssStyleString","$891e077217b1b85f$var$strokeToCSS","$891e077217b1b85f$var$dropShadowToCSS","cssStyles","$891e077217b1b85f$var$tagStyleToCSS","tagStyle","cssTagStyle","$891e077217b1b85f$var$transform","$891e077217b1b85f$var$templates","dropShadowStyle","toHexa","$e590b2205fe17cfb$export$464e4dcbf779d16c","dedupe","matches","addFontFamily","fontFamily2","$e10fa454ed748556$export$634b39f5e6e8534d","$4gc1a","$e10fa454ed748556$export$9b6075a0351ad0f8","Map","fontPromises","loadFontCSS","$b2fd88ccbe9e838b$export$d5a8e182a5491db2","$e72s4","dataSrc","loadFontAsBase64","$212d11a0b2e57b9f$export$21404a5ba2126552","blob","reader","FileReader","resolve","reject","onloadend","onerror","readAsDataURL","$9b8d4f16b0cabdb3$export$98b744dca5b9429f","innerHTML","textContent","toString","XMLSerializer","serializeToString","$42569c927ab701bc$export$d871fed544c30b4e","drawImage","$eec64bea0a1a7a3b$export$31cf685397f1a12a","delay","resolve2","setTimeout","onload","encodeURIComponent","crossOrigin","$1346f45679b49b72$var$tempHTMLTextRenderData","$1346f45679b49b72$export$9df7f2a259800030","fontStyleCSS","htmlTextRenderData","body","contentBounds","getBoundingClientRect","descenderPadding","$boJto","TilingSpritePipe","$877b600b00add877$export$b56051ebf906ec5d","$8jdbq","$jWUuA","$gKZ05","$eomSC","$abfr9","$877b600b00add877$var$sharedQuad","QuadGeometry","_tilingSpriteDataHash","tilingSpriteData","_getTilingSpriteData","couldBatch","canBatch","_updateCanBatch","tilingSprite","_didTilingSpriteUpdate","_updateBatchableMesh","TilingSpriteShader","groups","globalUniforms","bindGroup","encoder","draw","default2d","updateUniforms","_tileTransform","anchor","_initTilingSpriteData","MeshGeometry","slice","addressMode","setUvs","setPositions","renderableData","_nonPowOf2wrapping","WEBGL","supports","nonPowOf2wrapping","isPowerOfTwo","$9e5ad752c25c114f$var$gpuProgram","$9e5ad752c25c114f$var$glProgram","$9e5ad752c25c114f$export$d1a26cc57b383809","$huPGn","$8CB2b","localUniformBit","tilingBit","localUniformBitGl","tilingBitGl","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","uTexture","uSampler","anchorX","anchorY","textureWidth","textureHeight","invert","mapCoord","$968261c072b57756$export$7551c6773b6af70d","$968261c072b57756$export$a104558c66046525","$8efbb87deaee95b8$export$d27e254c8c1b5a0e","Uint32Array","$91fe1eed38103067$export$7d390d1e3efa819a","$2b8cdf8bb9c2c4d7$export$f99a1f47283a6d20","$64pcG","_applyAnchorToTexture","applyMatrix","$7c4d06e5b7dad575$export$8e14504c3429ee65","array","$bGvgZ","NineSliceSpritePipe","$6a89a429372cfe88$export$69030e8b070eaa80","$hIpDK","_gpuSpriteHash","sprite","gpuSprite","_getGpuSprite","_didSpriteUpdate","_updateBatchableSprite","_initGPUSprite","NineSliceGeometry","$fVpPG","$6k8LM","FilterSystem","FilterPipe","$f5c2b3c7c7673802$export$26a654548ff780c7","filterEffect","canBundle","action","pop","_filterEffect","_container","instruction","$bad2f65b6eb67e91$export$e94225c0dfac29cf","$1HooC","$cOnev","$34O3h","$almkH","$bad2f65b6eb67e91$var$quadGeometry","Geometry","attributes","aPosition","buffer","location","format","_filterStackIndex","_filterStack","_filterGlobalUniforms","uInputSize","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","activeBackTexture","_activeFilterData","backTexture","filters","_getFilterData","filterData","skip","renderables","getGlobalRenderableBounds","filterArea","addRect","worldTransform","getFastGlobalBounds","colorTextureSource","renderTarget","rootRenderTarget","colorTexture","_resolution","antialias","blendRequired","enabled","min","compatibleRenderers","backBuffer","useBackBuffer","viewPort","rootViewPort","fitBounds","pad","isPositive","previousRenderSurface","renderSurface","inputTexture","bind","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","apply","flip","flop","t","lastRenderSurface","backgroundResolution","floor","copyToTexture","applyFilter","input","output","Point","isFinalTarget","currentIndex","filterUniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","pixelWidth","pixelHeight","rootTexture","isRoot","uniformBatch","batchUniforms","getUboResource","_state","topology","calculateSpriteMatrix","outputMatrix","mappedMatrix","prepend","$0b3ff78e821417cf$export$ec3cb2102fa5391a","$5tmC8","$0b3ff78e821417cf$var$tempMatrix","target","$0b3ff78e821417cf$export$b7169265e2c9b9ba","measurable","manageEffects","effects","localBounds","isRenderGroupRoot","boundsPool","boundsArea","viewBounds","addFrame","children","advanced","addBounds","renderGroup","relativeGroupTransform","isValid","localTransform","$1b7255a412b4bb69$export$11abb8ef28048394"],"version":3,"file":"browserAll.abfd9ec1.js.map"}